<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modload</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>modload</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"io/fs"
"os"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"internal/godebugs"
"internal/lazyregexp"
"io"
"os"
"path"
"path/filepath"
"slices"
"strconv"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/modfetch"
"cmd/go/internal/search"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"context"
"errors"
"fmt"
"go/build"
"internal/diff"
"io/fs"
"maps"
"os"
"path"
pathpkg "path"
"path/filepath"
"runtime"
"slices"
"sort"
"strings"
"sync"
"sync/atomic"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modfetch"
"cmd/go/internal/modindex"
"cmd/go/internal/mvs"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/internal/par"
"golang.org/x/mod/module"
"context"
"errors"
"fmt"
"os"
"path/filepath"
"strings"
"sync"
"unicode"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/modfetch"
"cmd/go/internal/trace"
"cmd/internal/par"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"bytes"
"context"
"errors"
"fmt"
"io/fs"
"os"
pathpkg "path"
"slices"
"sort"
"strings"
"sync"
"time"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modfetch"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/modinfo"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"io/fs"
"context"
"errors"
"fmt"
"maps"
"os"
"runtime"
"runtime/debug"
"slices"
"strings"
"sync"
"sync/atomic"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/mvs"
"cmd/internal/par"
"golang.org/x/mod/module"
"errors"
"fmt"
"io/fs"
"os"
"path/filepath"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/gover"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/mvs"
"cmd/internal/par"
"context"
"errors"
"fmt"
"maps"
"os"
"slices"
"golang.org/x/mod/module"
"cmd/go/internal/base"
"context"
"errors"
"fmt"
"go/build"
"io/fs"
"os"
pathpkg "path"
"path/filepath"
"sort"
"strings"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modindex"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/internal/par"
"golang.org/x/mod/module"
"context"
"errors"
"os"
"sort"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modfetch/codehost"
"golang.org/x/mod/module"
"context"
"encoding/hex"
"errors"
"fmt"
"io/fs"
"os"
"path/filepath"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/modindex"
"cmd/go/internal/modinfo"
"cmd/go/internal/search"
"golang.org/x/mod/module"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"os"
"runtime"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/modinfo"
"cmd/go/internal/search"
"cmd/internal/par"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
"io/fs"
"os"
"syscall"
"context"
"errors"
"fmt"
"io/fs"
"os"
"path"
"path/filepath"
"runtime"
"sort"
"strings"
"sync"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modindex"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/par"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="AutoRoot">
               <h3>
                  AutoRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>AutoRoot is the default for most commands. modload.Init will look for
a go.mod file in the current directory or any parent. If none is found,
modules may be disabled (GO111MODULE=auto) or commands may run in a
limited module mode.</p>
               
               <pre><code>const AutoRoot Root = iota</code></pre>
            </article>
            
            <article class="global" data-name="ErrDisallowed">
               <h3>
                  ErrDisallowed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrDisallowed is returned by version predicates passed to Query and similar
functions to indicate that a version should not be considered.</p>
               
               <pre><code>var ErrDisallowed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrNoModRoot">
               <h3>
                  ErrNoModRoot 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrNoModRoot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ExplicitWriteGoMod">
               <h3>
                  ExplicitWriteGoMod 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ExplicitWriteGoMod prevents LoadPackages, ListModules, and other functions
from updating go.mod and go.sum or reporting errors when updates are
needed. A package should set this if it would cause go.mod to be written
multiple times (for example, 'go get' calls LoadPackages multiple times) or
if it needs some other operation to be successful before go.mod and go.sum
can be written (for example, 'go mod download' must download modules before
adding sums to go.sum). Packages that set this are responsible for calling
WriteGoMod explicitly.</p>
               
               <pre><code>var ExplicitWriteGoMod bool</code></pre>
            </article>
            
            <article class="global" data-name="ForceUseModules">
               <h3>
                  ForceUseModules 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ForceUseModules may be set to force modules to be enabled when
GO111MODULE=auto or to report an error when GO111MODULE=off.</p>
               
               <pre><code>var ForceUseModules bool</code></pre>
            </article>
            
            <article class="global" data-name="HelpGoMod">
               <h3>
                  HelpGoMod 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var HelpGoMod = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="HelpModules">
               <h3>
                  HelpModules 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var HelpModules = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ListDeprecated">
               <h3>
                  ListDeprecated 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ListDeprecated</code></pre>
            </article>
            
            <article class="global" data-name="ListRetracted">
               <h3>
                  ListRetracted 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ListRetracted</code></pre>
            </article>
            
            <article class="global" data-name="ListRetractedVersions">
               <h3>
                  ListRetractedVersions 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ListRetractedVersions</code></pre>
            </article>
            
            <article class="global" data-name="ListU">
               <h3>
                  ListU 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ListU ListMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ListVersions">
               <h3>
                  ListVersions 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ListVersions</code></pre>
            </article>
            
            <article class="global" data-name="MainModules">
               <h3>
                  MainModules 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var MainModules *MainModuleSet</code></pre>
            </article>
            
            <article class="global" data-name="NeedRoot">
               <h3>
                  NeedRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NeedRoot is used for commands that must run in module mode and don't
make sense without a main module.</p>
               
               <pre><code>const NeedRoot</code></pre>
            </article>
            
            <article class="global" data-name="NoRoot">
               <h3>
                  NoRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NoRoot is used for commands that run in module mode and ignore any go.mod
file the current directory or in parent directories.</p>
               
               <pre><code>const NoRoot</code></pre>
            </article>
            
            <article class="global" data-name="RootMode">
               <h3>
                  RootMode 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>RootMode determines whether a module root is needed.</p>
               
               <pre><code>var RootMode Root</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ versionRepo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ versionRepo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ versionRepo = emptyRepo{...}</code></pre>
            </article>
            
            <article class="global" data-name="addBuildListZipSums">
               <h3>
                  addBuildListZipSums 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const addBuildListZipSums</code></pre>
            </article>
            
            <article class="global" data-name="allowMissingModuleImports">
               <h3>
                  allowMissingModuleImports 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Variables set by other packages.
TODO(#40775): See if these can be plumbed as explicit parameters.</p>
               
               <pre><code>var allowMissingModuleImports bool</code></pre>
            </article>
            
            <article class="global" data-name="altConfigs">
               <h3>
                  altConfigs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var altConfigs = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="errDirectoryNotFound">
               <h3>
                  errDirectoryNotFound 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errDirectoryNotFound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errExcluded">
               <h3>
                  errExcluded 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errExcluded = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errGoModDirty">
               <h3>
                  errGoModDirty 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errGoModDirty error = goModDirtyError{...}</code></pre>
            </article>
            
            <article class="global" data-name="errMissing">
               <h3>
                  errMissing 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errMissing = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoChange">
               <h3>
                  errNoChange 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoChange = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errPkgIsBuiltin">
               <h3>
                  errPkgIsBuiltin 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errPkgIsBuiltin = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errPkgIsGorootSrc">
               <h3>
                  errPkgIsGorootSrc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errPkgIsGorootSrc = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errQueryDisabled">
               <h3>
                  errQueryDisabled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errQueryDisabled error = queryDisabledError{...}</code></pre>
            </article>
            
            <article class="global" data-name="errRevQuery">
               <h3>
                  errRevQuery 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errRevQuery = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="gopath">
               <h3>
                  gopath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Variables set in Init.</p>
               
               <pre><code>var gopath string</code></pre>
            </article>
            
            <article class="global" data-name="haveGoFilesCache">
               <h3>
                  haveGoFilesCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var haveGoFilesCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="haveGoModCache">
               <h3>
                  haveGoModCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var haveGoModCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="importCommentRE">
               <h3>
                  importCommentRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var importCommentRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="includeStd">
               <h3>
                  includeStd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const includeStd</code></pre>
            </article>
            
            <article class="global" data-name="infoEnd">
               <h3>
                  infoEnd 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var infoEnd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="infoStart">
               <h3>
                  infoStart 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var infoStart = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="initialized">
               <h3>
                  initialized 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Variables set in Init.</p>
               
               <pre><code>var initialized bool</code></pre>
            </article>
            
            <article class="global" data-name="latestVersionIgnoringRetractionsCache">
               <h3>
                  latestVersionIgnoringRetractionsCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var latestVersionIgnoringRetractionsCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="loaded">
               <h3>
                  loaded 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>loaded is the most recently-used package loader.
It holds details about individual packages.
This variable should only be accessed directly in top-level exported
functions. All other functions that require or produce a *loader should pass
or return it as an explicit parameter.</p>
               
               <pre><code>var loaded *loader</code></pre>
            </article>
            
            <article class="global" data-name="loadedZipSumsOnly">
               <h3>
                  loadedZipSumsOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const loadedZipSumsOnly = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="modRoots">
               <h3>
                  modRoots 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>These are primarily used to initialize the MainModules, and should be
eventually superseded by them but are still used in cases where the module
roots are required but MainModules hasn't been initialized yet. Set to
the modRoots of the main modules.
modRoots != nil implies len(modRoots) > 0</p>
               
               <pre><code>var modRoots []string</code></pre>
            </article>
            
            <article class="global" data-name="omitStd">
               <h3>
                  omitStd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const omitStd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="omitToolchainRoot">
               <h3>
                  omitToolchainRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const omitToolchainRoot addToolchainRoot = false</code></pre>
            </article>
            
            <article class="global" data-name="pkgFromRoot">
               <h3>
                  pkgFromRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>pkgFromRoot indicates that the package is in the transitive closure of
imports starting at the roots. (Note that every package marked as pkgIsRoot
is also trivially marked pkgFromRoot.)</p>
               
               <pre><code>const pkgFromRoot</code></pre>
            </article>
            
            <article class="global" data-name="pkgImportsLoaded">
               <h3>
                  pkgImportsLoaded 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>pkgImportsLoaded indicates that the imports and testImports fields of a
loadPkg have been populated.</p>
               
               <pre><code>const pkgImportsLoaded</code></pre>
            </article>
            
            <article class="global" data-name="pkgInAll">
               <h3>
                  pkgInAll 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>pkgInAll indicates that the package is in the "all" package pattern,
regardless of whether we are loading the "all" package pattern.
When the pkgInAll flag and pkgImportsLoaded flags are both set, the caller
who set the last of those flags must propagate the pkgInAll marking to all
of the imports of the marked package.
A test is marked with pkgInAll if that test would promote the packages it
imports to be in "all" (such as when the test is itself within the main
module, or when ld.allClosesOverTests is true).</p>
               
               <pre><code>const pkgInAll loadPkgFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="pkgIsRoot">
               <h3>
                  pkgIsRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>pkgIsRoot indicates that the package matches one of the root package
patterns requested by the caller.
If LoadTests is set, then when pkgIsRoot and pkgImportsLoaded are both set,
the caller who set the last of those flags must populate a test for the
package (in the pkg.test field).
If the "all" pattern is included as a root, then non-test packages in "all"
are also roots (and must be marked pkgIsRoot).</p>
               
               <pre><code>const pkgIsRoot</code></pre>
            </article>
            
            <article class="global" data-name="pruned">
               <h3>
                  pruned 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const pruned modPruning = iota</code></pre>
            </article>
            
            <article class="global" data-name="rawGoModSummaryCache">
               <h3>
                  rawGoModSummaryCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rawGoModSummaryCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="rawGoVersion">
               <h3>
                  rawGoVersion 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>rawGoVersion records the Go version parsed from each module's go.mod file.
If a module is replaced, the version of the replacement is keyed by the
replacement module.Version, not the version being replaced.</p>
               
               <pre><code>var rawGoVersion sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="readModGraphDebugOnce">
               <h3>
                  readModGraphDebugOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var readModGraphDebugOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="requirements">
               <h3>
                  requirements 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>requirements is the requirement graph for the main module.
It is always non-nil if the main module's go.mod file has been loaded.
This variable should only be read from the loadModFile function, and should
only be written in the loadModFile and commitRequirements functions.
All other functions that need or produce a *Requirements should
accept and/or return an explicit parameter.</p>
               
               <pre><code>var requirements *Requirements</code></pre>
            </article>
            
            <article class="global" data-name="unpruned">
               <h3>
                  unpruned 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const unpruned</code></pre>
            </article>
            
            <article class="global" data-name="vendorList">
               <h3>
                  vendorList 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var vendorList []module.Version</code></pre>
            </article>
            
            <article class="global" data-name="vendorMeta">
               <h3>
                  vendorMeta 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var vendorMeta map[module.Version]vendorMetadata</code></pre>
            </article>
            
            <article class="global" data-name="vendorOnce">
               <h3>
                  vendorOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var vendorOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="vendorPkgModule">
               <h3>
                  vendorPkgModule 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var vendorPkgModule map[string]module.Version</code></pre>
            </article>
            
            <article class="global" data-name="vendorReplaced">
               <h3>
                  vendorReplaced 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var vendorReplaced []module.Version</code></pre>
            </article>
            
            <article class="global" data-name="vendorVersion">
               <h3>
                  vendorVersion 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var vendorVersion map[string]string</code></pre>
            </article>
            
            <article class="global" data-name="withToolchainRoot">
               <h3>
                  withToolchainRoot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const withToolchainRoot = true</code></pre>
            </article>
            
            <article class="global" data-name="workFilePath">
               <h3>
                  workFilePath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Set to the path to the go.work file, or "" if workspace mode is disabled.</p>
               
               <pre><code>var workFilePath string</code></pre>
            </article>
            
            <article class="global" data-name="workspace">
               <h3>
                  workspace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const workspace</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="AllowedFunc">
               <h3>
                  AllowedFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>AllowedFunc is used by Query and other functions to filter out unsuitable
versions, for example, those listed in exclude directives in the main
module's go.mod file.
An AllowedFunc returns an error equivalent to ErrDisallowed for an unsuitable
version. Any other error indicates the function was unable to determine
whether the version should be allowed, for example, the function was unable
to fetch or parse a go.mod file containing retractions. Typically, errors
other than ErrDisallowed may be ignored.</p>
               
               <pre><code>type AllowedFunc func(context.Context, module.Version) error</code></pre>
            </article>
            
            <article class="type" data-name="ListMode">
               <h3>
                  ListMode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type ListMode int</code></pre>
            </article>
            
            <article class="type" data-name="Root">
               <h3>
                  Root
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type Root int</code></pre>
            </article>
            
            <article class="type" data-name="addToolchainRoot">
               <h3>
                  addToolchainRoot
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type addToolchainRoot bool</code></pre>
            </article>
            
            <article class="type" data-name="loadPkgFlags">
               <h3>
                  loadPkgFlags
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>loadPkgFlags is a set of flags tracking metadata about a package.</p>
               
               <pre><code>type loadPkgFlags int8</code></pre>
            </article>
            
            <article class="type" data-name="modPruning">
               <h3>
                  modPruning
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A modPruning indicates whether transitive dependencies of Go 1.17 dependencies
are pruned out of the module subgraph rooted at a given module.
(See https://golang.org/ref/mod#graph-pruning.)</p>
               
               <pre><code>type modPruning uint8</code></pre>
            </article>
            
            <article class="type" data-name="stdFilter">
               <h3>
                  stdFilter
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type stdFilter int8</code></pre>
            </article>
            
            <article class="type" data-name="whichSums">
               <h3>
                  whichSums
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type whichSums int8</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="versionRepo">
               <h3>
                  versionRepo
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A versionRepo is a subset of modfetch.Repo that can report information about
available versions, but cannot fetch specific source files.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type versionRepo interface {
ModulePath() string
CheckReuse(context.Context, *codehost.Origin) error
Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)
Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)
Latest(context.Context) (*modfetch.RevInfo, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="AmbiguousImportError">
               <h3>
                  AmbiguousImportError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An AmbiguousImportError indicates an import of a package found in multiple
modules in the build list, or found in both the main module and its vendor
directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AmbiguousImportError struct {
importPath string
Dirs []string
Modules []module.Version
}</code></pre>
            </article>
            
            <article class="struct" data-name="Conflict">
               <h3>
                  Conflict
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Conflict is a path of requirements starting at a root or proposed root in
the requirement graph, explaining why that root either causes a module passed
in the mustSelect list to EditBuildList to be unattainable, or introduces an
unresolvable error in loading the requirement graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Conflict struct {
Path []module.Version
Constraint module.Version
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="ConstraintError">
               <h3>
                  ConstraintError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ConstraintError describes inconsistent constraints in EditBuildList</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ConstraintError struct {
Conflicts []Conflict
}</code></pre>
            </article>
            
            <article class="struct" data-name="DirectImportFromImplicitDependencyError">
               <h3>
                  DirectImportFromImplicitDependencyError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A DirectImportFromImplicitDependencyError indicates a package directly
imported by a package or test in the main module that is satisfied by a
dependency that is not explicit in the main module's go.mod file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DirectImportFromImplicitDependencyError struct {
ImporterPath string
ImportedPath string
Module module.Version
}</code></pre>
            </article>
            
            <article class="struct" data-name="ImportMissingError">
               <h3>
                  ImportMissingError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ImportMissingError struct {
Path string
Module module.Version
QueryErr error
ImportingMainModule module.Version
isStd bool
importerGoVersion string
replaced module.Version
newMissingVersion string
}</code></pre>
            </article>
            
            <article class="struct" data-name="ImportMissingSumError">
               <h3>
                  ImportMissingSumError
                  <span class="badge">struct</span>
               </h3>
               
               <p>ImportMissingSumError is reported in readonly mode when we need to check
if a module contains a package, but we don't have a sum for its .zip file.
We might need sums for multiple modules to verify the package is unique.
TODO(#43653): consolidate multiple errors of this type into a single error
that suggests a 'go get' command for root packages that transitively import
packages from modules with missing sums. load.CheckPackageErrors would be
a good place to consolidate errors, but we'll need to attach the import
stack here.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ImportMissingSumError struct {
importPath string
found bool
mods []module.Version
importer string
importerVersion string
importerIsTest bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="MainModuleSet">
               <h3>
                  MainModuleSet
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MainModuleSet struct {
versions []module.Version
modRoot map[module.Version]string
pathPrefix map[module.Version]string
inGorootSrc map[module.Version]bool
modFiles map[module.Version]*modfile.File
tools map[string]bool
modContainingCWD module.Version
workFile *modfile.WorkFile
workFileReplaceMap map[module.Version]module.Version
highestReplaced map[string]string
indexMu sync.Mutex
indices map[module.Version]*modFileIndex
}</code></pre>
            </article>
            
            <article class="struct" data-name="ModuleGraph">
               <h3>
                  ModuleGraph
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ModuleGraph represents the complete graph of module dependencies
of a main module.
If the main module supports module graph pruning, the graph does not include
transitive dependencies of non-root (implicit) dependencies.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ModuleGraph struct {
g *mvs.Graph
loadCache *ast.IndexListExpr
buildListOnce sync.Once
buildList []module.Version
}</code></pre>
            </article>
            
            <article class="struct" data-name="ModuleRetractedError">
               <h3>
                  ModuleRetractedError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ModuleRetractedError struct {
Rationale []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="NoMatchingVersionError">
               <h3>
                  NoMatchingVersionError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A NoMatchingVersionError indicates that Query found a module at the requested
path, but not at any versions satisfying the query string and allow-function.
NOTE: NoMatchingVersionError MUST NOT implement Is(fs.ErrNotExist).
If the module came from a proxy, that proxy had to return a successful status
code for the versions it knows about, and thus did not have the opportunity
to return a non-400 status code to suppress fallback.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NoMatchingVersionError struct {
query string
current string
}</code></pre>
            </article>
            
            <article class="struct" data-name="NoPatchBaseError">
               <h3>
                  NoPatchBaseError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A NoPatchBaseError indicates that Query was called with the query "patch"
but with a current version of "" or "none".</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NoPatchBaseError struct {
path string
}</code></pre>
            </article>
            
            <article class="struct" data-name="PackageNotInModuleError">
               <h3>
                  PackageNotInModuleError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A PackageNotInModuleError indicates that QueryPattern found a candidate
module at the requested version, but that module did not contain any packages
matching the requested pattern.
NOTE: PackageNotInModuleError MUST NOT implement Is(fs.ErrNotExist).
If the module came from a proxy, that proxy had to return a successful status
code for the versions it knows about, and thus did not have the opportunity
to return a non-400 status code to suppress fallback.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PackageNotInModuleError struct {
MainModules []module.Version
Mod module.Version
Replacement module.Version
Query string
Pattern string
}</code></pre>
            </article>
            
            <article class="struct" data-name="PackageOpts">
               <h3>
                  PackageOpts
                  <span class="badge">struct</span>
               </h3>
               
               <p>PackageOpts control the behavior of the LoadPackages function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PackageOpts struct {
TidyGoVersion string
Tags map[string]bool
Tidy bool
TidyDiff bool
TidyCompatibleVersion string
VendorModulesInGOROOTSrc bool
ResolveMissingImports bool
AssumeRootsImported bool
AllowPackage func(ctx context.Context, path string, mod module.Version) error
LoadTests bool
UseVendorAll bool
AllowErrors bool
SilencePackageErrors bool
SilenceMissingStdImports bool
SilenceNoGoErrors bool
SilenceUnmatchedWarnings bool
MainModule module.Version
Switcher gover.Switcher
}</code></pre>
            </article>
            
            <article class="struct" data-name="QueryMatchesMainModulesError">
               <h3>
                  QueryMatchesMainModulesError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A QueryMatchesMainModulesError indicates that a query requests
a version of the main module that cannot be satisfied.
(The main module's version cannot be changed.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type QueryMatchesMainModulesError struct {
MainModules []module.Version
Pattern string
Query string
}</code></pre>
            </article>
            
            <article class="struct" data-name="QueryMatchesPackagesInMainModuleError">
               <h3>
                  QueryMatchesPackagesInMainModuleError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A QueryMatchesPackagesInMainModuleError indicates that a query cannot be
satisfied because it matches one or more packages found in the main module.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type QueryMatchesPackagesInMainModuleError struct {
Pattern string
Query string
Packages []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="QueryResult">
               <h3>
                  QueryResult
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type QueryResult struct {
Mod module.Version
Rev *modfetch.RevInfo
Packages []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="QueryUpgradesAllError">
               <h3>
                  QueryUpgradesAllError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A QueryUpgradesAllError indicates that a query requests
an upgrade on the all pattern.
(The main module's version cannot be changed.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type QueryUpgradesAllError struct {
MainModules []module.Version
Query string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Requirements">
               <h3>
                  Requirements
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Requirements represents a logically-immutable set of root module requirements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Requirements struct {
pruning modPruning
rootModules []module.Version
maxRootVersion map[string]string
direct map[string]bool
graphOnce sync.Once
graph *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="WildcardInFirstElementError">
               <h3>
                  WildcardInFirstElementError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A WildcardInFirstElementError indicates that a pattern passed to QueryPattern
had a wildcard in its first path element, and therefore had no pattern-prefix
modules to search in.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WildcardInFirstElementError struct {
Pattern string
Query string
}</code></pre>
            </article>
            
            <article class="struct" data-name="WriteOpts">
               <h3>
                  WriteOpts
                  <span class="badge">struct</span>
               </h3>
               
               <p>WriteOpts control the behavior of WriteGoMod.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WriteOpts struct {
DropToolchain bool
ExplicitToolchain bool
AddTools []string
DropTools []string
TidyWroteGo bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="atomicLoadPkgFlags">
               <h3>
                  atomicLoadPkgFlags
                  <span class="badge">struct</span>
               </h3>
               
               <p>An atomicLoadPkgFlags stores a loadPkgFlags for which individual flags can be
added atomically.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type atomicLoadPkgFlags struct {
bits atomic.Int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="cachedGraph">
               <h3>
                  cachedGraph
                  <span class="badge">struct</span>
               </h3>
               
               <p>A cachedGraph is a non-nil *ModuleGraph, together with any error discovered
while loading that graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cachedGraph struct {
mg *ModuleGraph
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="dqState">
               <h3>
                  dqState
                  <span class="badge">struct</span>
               </h3>
               
               <p>A dqState indicates whether and why a module version is “disqualified” from
being used in a way that would incorporate its requirements.
The zero dqState indicates that the module version is not known to be
disqualified, either because it is ok or because we are currently traversing
a cycle that includes it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dqState struct {
err error
dep module.Version
}</code></pre>
            </article>
            
            <article class="struct" data-name="dqTracker">
               <h3>
                  dqTracker
                  <span class="badge">struct</span>
               </h3>
               
               <p>A dqTracker tracks and propagates the reason that each module version
cannot be included in the module graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dqTracker struct {
extendedRootPruning map[module.Version]modPruning
dqReason map[module.Version]*ast.IndexExpr
requiring map[module.Version][]module.Version
}</code></pre>
            </article>
            
            <article class="struct" data-name="emptyRepo">
               <h3>
                  emptyRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>An emptyRepo is a versionRepo that contains no versions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type emptyRepo struct {
path string
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="excludedError">
               <h3>
                  excludedError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type excludedError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="goModDirtyError">
               <h3>
                  goModDirtyError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type goModDirtyError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="invalidImportError">
               <h3>
                  invalidImportError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type invalidImportError struct {
importPath string
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="loadPkg">
               <h3>
                  loadPkg
                  <span class="badge">struct</span>
               </h3>
               
               <p>A loadPkg records information about a single loaded package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type loadPkg struct {
path string
testOf *loadPkg
flags atomicLoadPkgFlags
mod module.Version
dir string
err error
imports []*loadPkg
testImports []string
inStd bool
altMods []module.Version
testOnce sync.Once
test *loadPkg
stack *loadPkg
}</code></pre>
            </article>
            
            <article class="struct" data-name="loader">
               <h3>
                  loader
                  <span class="badge">struct</span>
               </h3>
               
               <p>A loader manages the process of loading information about
the required packages for a particular build,
checking that the packages are available in the module set,
and updating the module set if needed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type loader struct {
loaderParams
allClosesOverTests bool
skipImportModFiles bool
work *par.Queue
roots []*loadPkg
pkgCache **ast.IndexListExpr
pkgs []*loadPkg
}</code></pre>
            </article>
            
            <article class="struct" data-name="loaderParams">
               <h3>
                  loaderParams
                  <span class="badge">struct</span>
               </h3>
               
               <p>loaderParams configure the packages loaded by, and the properties reported
by, a loader instance.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type loaderParams struct {
PackageOpts
requirements *Requirements
allPatternIsRoot bool
listRoots func(rs *Requirements) []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="modFileIndex">
               <h3>
                  modFileIndex
                  <span class="badge">struct</span>
               </h3>
               
               <p>A modFileIndex is an index of data corresponding to a modFile
at a specific point in time.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type modFileIndex struct {
data []byte
dataNeedsFix bool
module module.Version
goVersion string
toolchain string
require map[module.Version]requireMeta
replace map[module.Version]module.Version
exclude map[module.Version]bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="modFileSummary">
               <h3>
                  modFileSummary
                  <span class="badge">struct</span>
               </h3>
               
               <p>A modFileSummary is a summary of a go.mod file for which we do not need to
retain complete information — for example, the go.mod file of a dependency
module.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type modFileSummary struct {
module module.Version
goVersion string
toolchain string
pruning modPruning
require []module.Version
retract []retraction
deprecated string
}</code></pre>
            </article>
            
            <article class="struct" data-name="mvsReqs">
               <h3>
                  mvsReqs
                  <span class="badge">struct</span>
               </h3>
               
               <p>mvsReqs implements mvs.Reqs for module semantic versions,
with any exclusions or replacements applied internally.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mvsReqs struct {
roots []module.Version
}</code></pre>
            </article>
            
            <article class="struct" data-name="perPruning">
               <h3>
                  perPruning
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type perPruning struct {
pruned T
unpruned T
}</code></pre>
            </article>
            
            <article class="struct" data-name="queryDisabledError">
               <h3>
                  queryDisabledError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type queryDisabledError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="queryMatcher">
               <h3>
                  queryMatcher
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type queryMatcher struct {
path string
prefix string
filter func(version string) bool
allowed AllowedFunc
canStat bool
preferLower bool
mayUseLatest bool
preferIncompatible bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="replacementRepo">
               <h3>
                  replacementRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A replacementRepo augments a versionRepo to include the replacement versions
(if any) found in the main module's go.mod file.
A replacementRepo suppresses "not found" errors for otherwise-nonexistent
modules, so a replacementRepo should only be constructed for a module that
actually has one or more valid replacements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type replacementRepo struct {
repo versionRepo
}</code></pre>
            </article>
            
            <article class="struct" data-name="requireMeta">
               <h3>
                  requireMeta
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type requireMeta struct {
indirect bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="retraction">
               <h3>
                  retraction
                  <span class="badge">struct</span>
               </h3>
               
               <p>A retraction consists of a retracted version interval and rationale.
retraction is like modfile.Retract, but it doesn't point to the syntax tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type retraction struct {
modfile.VersionInterval
Rationale string
}</code></pre>
            </article>
            
            <article class="struct" data-name="retractionLoadingError">
               <h3>
                  retractionLoadingError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type retractionLoadingError struct {
m module.Version
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="sumMissingError">
               <h3>
                  sumMissingError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sumMissingError struct {
suggestion string
}</code></pre>
            </article>
            
            <article class="struct" data-name="vendorMetadata">
               <h3>
                  vendorMetadata
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type vendorMetadata struct {
Explicit bool
Replacement module.Version
GoVersion string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AllowMissingModuleImports">
               <h3>
                  AllowMissingModuleImports 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AllowMissingModuleImports allows import paths to be resolved to modules
when there is no module root. Normally, this is forbidden because it's slow
and there's no way to make the result reproducible, but some commands
like 'go get' are expected to do this.
This function affects the default cfg.BuildMod when outside of a module,
so it can only be called prior to Init.</p>
               
               <pre><code>func AllowMissingModuleImports()</code></pre>
            </article>
            
            <article class="function" data-name="BinDir">
               <h3>
                  BinDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func BinDir() string</code></pre>
            </article>
            
            <article class="function" data-name="BuildList">
               <h3>
                  BuildList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BuildList returns the selected versions of all modules present in the graph,
beginning with the main modules.
The order of the remaining elements in the list is deterministic
but arbitrary.
The caller must not modify the returned list, but may safely append to it
and may rely on it not to be modified.</p>
               
               <pre><code>func (mg *ModuleGraph) BuildList() []module.Version</code></pre>
            </article>
            
            <article class="function" data-name="CheckAllowed">
               <h3>
                  CheckAllowed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckAllowed returns an error equivalent to ErrDisallowed if m is excluded by
the main module's go.mod or retracted by its author. Most version queries use
this to filter out versions that should not be used.</p>
               
               <pre><code>func CheckAllowed(ctx context.Context, m module.Version) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckDeprecation">
               <h3>
                  CheckDeprecation 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckDeprecation returns a deprecation message from the go.mod file of the
latest version of the given module. Deprecation messages are comments
before or on the same line as the module directives that start with
"Deprecated:" and run until the end of the paragraph.
CheckDeprecation returns an error if the message can't be loaded.
CheckDeprecation returns "", nil if there is no deprecation message.</p>
               
               <pre><code>func CheckDeprecation(ctx context.Context, m module.Version) (deprecation string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckExclusions">
               <h3>
                  CheckExclusions 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckExclusions returns an error equivalent to ErrDisallowed if module m is
excluded by the main module's go.mod file.</p>
               
               <pre><code>func CheckExclusions(ctx context.Context, m module.Version) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckGodebug">
               <h3>
                  CheckGodebug 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func CheckGodebug(verb string, k string, v string) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckRetractions">
               <h3>
                  CheckRetractions 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckRetractions returns an error if module m has been retracted by
its author.</p>
               
               <pre><code>func CheckRetractions(ctx context.Context, m module.Version) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (er emptyRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rr *replacementRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) Contains(path string) bool</code></pre>
            </article>
            
            <article class="function" data-name="CreateModFile">
               <h3>
                  CreateModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CreateModFile initializes a new module by creating a go.mod file.
If modPath is empty, CreateModFile will attempt to infer the path from the
directory location within GOPATH.
If a vendoring configuration file is present, CreateModFile will attempt to
translate it to go.mod directives. The resulting build list may not be
exactly the same as in the legacy configuration (for example, we can't get
packages at multiple versions from the same module).</p>
               
               <pre><code>func CreateModFile(ctx context.Context, modPath string)</code></pre>
            </article>
            
            <article class="function" data-name="DirImportPath">
               <h3>
                  DirImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DirImportPath returns the effective import path for dir,
provided it is within a main module, or else returns ".".</p>
               
               <pre><code>func (mms *MainModuleSet) DirImportPath(ctx context.Context, dir string) (path string, m module.Version)</code></pre>
            </article>
            
            <article class="function" data-name="EditBuildList">
               <h3>
                  EditBuildList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EditBuildList edits the global build list by first adding every module in add
to the existing build list, then adjusting versions (and adding or removing
requirements as needed) until every module in mustSelect is selected at the
given version.
(Note that the newly-added modules might not be selected in the resulting
build list: they could be lower than existing requirements or conflict with
versions in mustSelect.)
If the versions listed in mustSelect are mutually incompatible (due to one of
the listed modules requiring a higher version of another), EditBuildList
returns a *ConstraintError and leaves the build list in its previous state.
On success, EditBuildList reports whether the selected version of any module
in the build list may have been changed (possibly to or from "none") as a
result.</p>
               
               <pre><code>func EditBuildList(ctx context.Context, add []module.Version, mustSelect []module.Version) (changed bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Enabled reports whether modules are (or must be) enabled.
If modules are enabled but there is no main module, Enabled returns true
and then the first use of module information will call die
(usually through MustModRoot).</p>
               
               <pre><code>func Enabled() bool</code></pre>
            </article>
            
            <article class="function" data-name="EnterModule">
               <h3>
                  EnterModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EnterModule resets MainModules and requirements to refer to just this one module.</p>
               
               <pre><code>func EnterModule(ctx context.Context, enterModroot string)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ModuleRetractedError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *NoPatchBaseError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *sumMissingError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *excludedError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ImportMissingError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *NoMatchingVersionError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *invalidImportError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ImportMissingSumError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DirectImportFromImplicitDependencyError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ConstraintError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *WildcardInFirstElementError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *AmbiguousImportError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *PackageNotInModuleError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *QueryMatchesPackagesInMainModuleError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *retractionLoadingError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *QueryUpgradesAllError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (queryDisabledError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (goModDirtyError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *QueryMatchesMainModulesError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="FindGoMod">
               <h3>
                  FindGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FindGoMod returns the name of the go.mod file for this command,
or the empty string if there isn't one.
Most code should use Init and Enabled rather than use this directly.
It is exported mainly for Go toolchain switching, which must process
the go.mod very early at startup.</p>
               
               <pre><code>func FindGoMod(wd string) string</code></pre>
            </article>
            
            <article class="function" data-name="FindGoWork">
               <h3>
                  FindGoWork 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FindGoWork returns the name of the go.work file for this command,
or the empty string if there isn't one.
Most code should use Init and Enabled rather than use this directly.
It is exported mainly for Go toolchain switching, which must process
the go.work very early at startup.</p>
               
               <pre><code>func FindGoWork(wd string) string</code></pre>
            </article>
            
            <article class="function" data-name="GetSingleIndexOrNil">
               <h3>
                  GetSingleIndexOrNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) GetSingleIndexOrNil() *modFileIndex</code></pre>
            </article>
            
            <article class="function" data-name="GoVersion">
               <h3>
                  GoVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GoVersion returns the go version set on the single module, in module mode,
or the go.work file in workspace mode.</p>
               
               <pre><code>func (mms *MainModuleSet) GoVersion() string</code></pre>
            </article>
            
            <article class="function" data-name="GoVersion">
               <h3>
                  GoVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GoVersion returns the Go language version for the Requirements.</p>
               
               <pre><code>func (rs *Requirements) GoVersion() string</code></pre>
            </article>
            
            <article class="function" data-name="Godebugs">
               <h3>
                  Godebugs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Godebugs returns the godebug lines set on the single module, in module mode,
or on the go.work file in workspace mode.
The caller must not modify the result.</p>
               
               <pre><code>func (mms *MainModuleSet) Godebugs() []*modfile.Godebug</code></pre>
            </article>
            
            <article class="function" data-name="Graph">
               <h3>
                  Graph 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Graph returns the graph of module requirements loaded from the current
root modules (as reported by RootModules).
Graph always makes a best effort to load the requirement graph despite any
errors, and always returns a non-nil *ModuleGraph.
If the requirements of any relevant module fail to load, Graph also
returns a non-nil error of type *mvs.BuildListError.</p>
               
               <pre><code>func (rs *Requirements) Graph(ctx context.Context) (*ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function" data-name="HasModRoot">
               <h3>
                  HasModRoot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HasModRoot reports whether a main module is present.
HasModRoot may return false even if Enabled returns true: for example, 'get'
does not require a main module.</p>
               
               <pre><code>func HasModRoot() bool</code></pre>
            </article>
            
            <article class="function" data-name="HighestReplaced">
               <h3>
                  HighestReplaced 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) HighestReplaced() map[string]string</code></pre>
            </article>
            
            <article class="function" data-name="ImportFromFiles">
               <h3>
                  ImportFromFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ImportFromFiles adds modules to the build list as needed
to satisfy the imports in the named Go source files.
Errors in missing dependencies are silenced.
TODO(bcmills): Silencing errors seems off. Take a closer look at this and
figure out what the error-reporting actually ought to be.</p>
               
               <pre><code>func ImportFromFiles(ctx context.Context, gofiles []string)</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DirectImportFromImplicitDependencyError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *invalidImportError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ImportMissingSumError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ImportMissingError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *PackageNotInModuleError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *AmbiguousImportError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="InGorootSrc">
               <h3>
                  InGorootSrc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) InGorootSrc(m module.Version) bool</code></pre>
            </article>
            
            <article class="function" data-name="Index">
               <h3>
                  Index 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) Index(m module.Version) *modFileIndex</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Init determines whether module mode is enabled, locates the root of the
current module (if any), sets environment variables for Git subprocesses, and
configures the cfg, codehost, load, modfetch, and search packages for use
with modules.</p>
               
               <pre><code>func Init()</code></pre>
            </article>
            
            <article class="function" data-name="InitWorkfile">
               <h3>
                  InitWorkfile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InitWorkfile initializes the workFilePath variable for commands that
operate in workspace mode. It should not be called by other commands,
for example 'go mod tidy', that don't operate in workspace mode.</p>
               
               <pre><code>func InitWorkfile()</code></pre>
            </article>
            
            <article class="function" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *excludedError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ModuleRetractedError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDirect">
               <h3>
                  IsDirect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsDirect returns whether the given module provides a package directly
imported by a package or test in the main module.</p>
               
               <pre><code>func (rs *Requirements) IsDirect(path string) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsRevisionQuery">
               <h3>
                  IsRevisionQuery 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsRevisionQuery returns true if vers is a version query that may refer to
a particular version or revision in a repository like "v1.0.0", "master",
or "0123abcd". IsRevisionQuery returns false if vers is a query that
chooses from among available versions like "latest" or ">v1.0.0".</p>
               
               <pre><code>func IsRevisionQuery(path string, vers string) bool</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rr *replacementRepo) Latest(ctx context.Context) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (er emptyRepo) Latest(ctx context.Context) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="ListModules">
               <h3>
                  ListModules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListModules returns a description of the modules matching args, if known,
along with any error preventing additional matches from being identified.
The returned slice can be nonempty even if the error is non-nil.</p>
               
               <pre><code>func ListModules(ctx context.Context, args []string, mode ListMode, reuseFile string) ([]*modinfo.ModulePublic, error)</code></pre>
            </article>
            
            <article class="function" data-name="LoadModFile">
               <h3>
                  LoadModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LoadModFile sets Target and, if there is a main module, parses the initial
build list from its go.mod file.
LoadModFile may make changes in memory, like adding a go directive and
ensuring requirements are consistent. The caller is responsible for ensuring
those changes are written to disk by calling LoadPackages or ListModules
(unless ExplicitWriteGoMod is set) or by calling WriteGoMod directly.
As a side-effect, LoadModFile may change cfg.BuildMod to "vendor" if
-mod wasn't set explicitly and automatic vendoring should be enabled.
If LoadModFile or CreateModFile has already been called, LoadModFile returns
the existing in-memory requirements (rather than re-reading them from disk).
LoadModFile checks the roots of the module graph for consistency with each
other, but unlike LoadModGraph does not load the full module graph or check
it for global consistency. Most callers outside of the modload package should
use LoadModGraph instead.</p>
               
               <pre><code>func LoadModFile(ctx context.Context) *Requirements</code></pre>
            </article>
            
            <article class="function" data-name="LoadModGraph">
               <h3>
                  LoadModGraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LoadModGraph loads and returns the graph of module dependencies of the main module,
without loading any packages.
If the goVersion string is non-empty, the returned graph is the graph
as interpreted by the given Go version (instead of the version indicated
in the go.mod file).
Modules are loaded automatically (and lazily) in LoadPackages:
LoadModGraph need only be called if LoadPackages is not,
typically in commands that care about modules but no particular package.</p>
               
               <pre><code>func LoadModGraph(ctx context.Context, goVersion string) (*ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function" data-name="LoadPackages">
               <h3>
                  LoadPackages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LoadPackages identifies the set of packages matching the given patterns and
loads the packages in the import graph rooted at that set.</p>
               
               <pre><code>func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (matches []*search.Match, loadedPackages []string)</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Lookup returns the source directory, import path, and any loading error for
the package at path as imported from the package in parentDir.
Lookup requires that one of the Load functions in this package has already
been called.</p>
               
               <pre><code>func Lookup(parentPath string, parentIsStd bool, path string) (dir string, realPath string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="MatchInModule">
               <h3>
                  MatchInModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MatchInModule identifies the packages matching the given pattern within the
given module version, which does not need to be in the build list or module
requirement graph.
If m is the zero module.Version, MatchInModule matches the pattern
against the standard library (std and cmd) in GOROOT/src.</p>
               
               <pre><code>func MatchInModule(ctx context.Context, pattern string, m module.Version, tags map[string]bool) *search.Match</code></pre>
            </article>
            
            <article class="function" data-name="Max">
               <h3>
                  Max 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Max returns the maximum of v1 and v2 according to gover.ModCompare.
As a special case, the version "" is considered higher than all other
versions. The main module (also known as the target) has no version and must
be chosen over other versions of the same module in the module dependency
graph.</p>
               
               <pre><code>func (*mvsReqs) Max(p string, v1 string, v2 string) string</code></pre>
            </article>
            
            <article class="function" data-name="ModContainingCWD">
               <h3>
                  ModContainingCWD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ModContainingCWD returns the main module containing the working directory,
or module.Version{} if none of the main modules contain the working
directory.</p>
               
               <pre><code>func (mms *MainModuleSet) ModContainingCWD() module.Version</code></pre>
            </article>
            
            <article class="function" data-name="ModFile">
               <h3>
                  ModFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) ModFile(m module.Version) *modfile.File</code></pre>
            </article>
            
            <article class="function" data-name="ModFile">
               <h3>
                  ModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ModFile returns the parsed go.mod file.
Note that after calling LoadPackages or LoadModGraph,
the require statements in the modfile.File are no longer
the source of truth and will be ignored: edits made directly
will be lost at the next call to WriteGoMod.
To make permanent changes to the require statements
in go.mod, edit it before loading.</p>
               
               <pre><code>func ModFile() *modfile.File</code></pre>
            </article>
            
            <article class="function" data-name="ModFilePath">
               <h3>
                  ModFilePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ModFilePath returns the path that would be used for the go.mod
file, if in module mode. ModFilePath calls base.Fatalf if there is no main
module, even if -modfile is set.</p>
               
               <pre><code>func ModFilePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModInfoData">
               <h3>
                  ModInfoData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ModInfoData(info string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="ModInfoProg">
               <h3>
                  ModInfoProg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ModInfoProg(info string, isgccgo bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="ModRoot">
               <h3>
                  ModRoot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) ModRoot(m module.Version) string</code></pre>
            </article>
            
            <article class="function" data-name="ModuleInfo">
               <h3>
                  ModuleInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ModuleInfo(ctx context.Context, path string) *modinfo.ModulePublic</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rr *replacementRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (er emptyRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="MustHaveModRoot">
               <h3>
                  MustHaveModRoot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustHaveModRoot checks that a main module or main modules are present,
and calls base.Fatalf if there are no main modules.</p>
               
               <pre><code>func MustHaveModRoot()</code></pre>
            </article>
            
            <article class="function" data-name="OverrideRoots">
               <h3>
                  OverrideRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>OverrideRoots edits the global requirement roots by replacing the specific module versions.</p>
               
               <pre><code>func OverrideRoots(ctx context.Context, replace []module.Version)</code></pre>
            </article>
            
            <article class="function" data-name="PackageModRoot">
               <h3>
                  PackageModRoot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PackageModRoot returns the module root directory for the module that provides
a given package. If modules are not enabled or if the package is in the
standard library or if the package was not successfully loaded with
LoadPackages or ImportFromFiles, the empty string is returned.</p>
               
               <pre><code>func PackageModRoot(ctx context.Context, pkgpath string) string</code></pre>
            </article>
            
            <article class="function" data-name="PackageModule">
               <h3>
                  PackageModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PackageModule returns the module providing the package named by the import path.</p>
               
               <pre><code>func PackageModule(path string) module.Version</code></pre>
            </article>
            
            <article class="function" data-name="PackageModuleInfo">
               <h3>
                  PackageModuleInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PackageModuleInfo returns information about the module that provides
a given package. If modules are not enabled or if the package is in the
standard library or if the package was not successfully loaded with
LoadPackages or ImportFromFiles, nil is returned.</p>
               
               <pre><code>func PackageModuleInfo(ctx context.Context, pkgpath string) *modinfo.ModulePublic</code></pre>
            </article>
            
            <article class="function" data-name="PathPrefix">
               <h3>
                  PathPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) PathPrefix(m module.Version) string</code></pre>
            </article>
            
            <article class="function" data-name="Previous">
               <h3>
                  Previous 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*mvsReqs) Previous(m module.Version) (module.Version, error)</code></pre>
            </article>
            
            <article class="function" data-name="Query">
               <h3>
                  Query 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Query looks up a revision of a given module given a version query string.
The module must be a complete module path.
The version must take one of the following forms:
- the literal string "latest", denoting the latest available, allowed
tagged version, with non-prereleases preferred over prereleases.
If there are no tagged versions in the repo, latest returns the most
recent commit.
- the literal string "upgrade", equivalent to "latest" except that if
current is a newer version, current will be returned (see below).
- the literal string "patch", denoting the latest available tagged version
with the same major and minor number as current (see below).
- v1, denoting the latest available tagged version v1.x.x.
- v1.2, denoting the latest available tagged version v1.2.x.
- v1.2.3, a semantic version string denoting that tagged version.
- <v1.2.3, <=v1.2.3, >v1.2.3, >=v1.2.3,
denoting the version closest to the target and satisfying the given operator,
with non-prereleases preferred over prereleases.
- a repository commit identifier or tag, denoting that commit.
current denotes the currently-selected version of the module; it may be
"none" if no version is currently selected, or "" if the currently-selected
version is unknown or should not be considered. If query is
"upgrade" or "patch", current will be returned if it is a newer
semantic version or a chronologically later pseudo-version than the
version that would otherwise be chosen. This prevents accidental downgrades
from newer pre-release or development versions.
The allowed function (which may be nil) is used to filter out unsuitable
versions (see AllowedFunc documentation for details). If the query refers to
a specific revision (for example, "master"; see IsRevisionQuery), and the
revision is disallowed by allowed, Query returns the error. If the query
does not refer to a specific revision (for example, "latest"), Query
acts as if versions disallowed by allowed do not exist.
If path is the path of the main module and the query is "latest",
Query returns Target.Version as the version.
Query often returns a non-nil *RevInfo with a non-nil error,
to provide an info.Origin that can allow the error to be cached.</p>
               
               <pre><code>func Query(ctx context.Context, path string, query string, current string, allowed AllowedFunc) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryPackages">
               <h3>
                  QueryPackages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>QueryPackages is like QueryPattern, but requires that the pattern match at
least one package and omits the non-package result (if any).</p>
               
               <pre><code>func QueryPackages(ctx context.Context, pattern string, query string, current func(string) string, allowed AllowedFunc) ([]QueryResult, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryPattern">
               <h3>
                  QueryPattern 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>QueryPattern looks up the module(s) containing at least one package matching
the given pattern at the given version. The results are sorted by module path
length in descending order. If any proxy provides a non-empty set of candidate
modules, no further proxies are tried.
For wildcard patterns, QueryPattern looks in modules with package paths up to
the first "..." in the pattern. For the pattern "example.com/a/b.../c",
QueryPattern would consider prefixes of "example.com/a".
If any matching package is in the main module, QueryPattern considers only
the main module and only the version "latest", without checking for other
possible modules.
QueryPattern always returns at least one QueryResult (which may be only
modOnly) or a non-nil error.</p>
               
               <pre><code>func QueryPattern(ctx context.Context, pattern string, query string, current func(string) string, allowed AllowedFunc) (pkgMods []QueryResult, modOnly *QueryResult, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadModFile">
               <h3>
                  ReadModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReadModFile reads and parses the mod file at gomod. ReadModFile properly applies the
overlay, locks the file while reading, and applies fix, if applicable.</p>
               
               <pre><code>func ReadModFile(gomod string, fix modfile.VersionFixer) (data []byte, f *modfile.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadWorkFile">
               <h3>
                  ReadWorkFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReadWorkFile reads and parses the go.work file at the given path.</p>
               
               <pre><code>func ReadWorkFile(path string) (*modfile.WorkFile, error)</code></pre>
            </article>
            
            <article class="function" data-name="Replacement">
               <h3>
                  Replacement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Replacement returns the replacement for mod, if any. If the path in the
module.Version is relative it's relative to the single main module outside
workspace mode, or the workspace's directory in workspace mode.</p>
               
               <pre><code>func Replacement(mod module.Version) module.Version</code></pre>
            </article>
            
            <article class="function" data-name="Required">
               <h3>
                  Required 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error)</code></pre>
            </article>
            
            <article class="function" data-name="RequiredBy">
               <h3>
                  RequiredBy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RequiredBy returns the dependencies required by module m in the graph,
or ok=false if module m's dependencies are pruned out.
The caller must not modify the returned slice, but may safely append to it
and may rely on it not to be modified.</p>
               
               <pre><code>func (mg *ModuleGraph) RequiredBy(m module.Version) (reqs []module.Version, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Reset clears all the initialized, cached state about the use of modules,
so that we can start over.</p>
               
               <pre><code>func Reset()</code></pre>
            </article>
            
            <article class="function" data-name="Selected">
               <h3>
                  Selected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Selected returns the selected version of the module with the given path.
If no version is selected, Selected returns version "none".</p>
               
               <pre><code>func (mg *ModuleGraph) Selected(path string) (version string)</code></pre>
            </article>
            
            <article class="function" data-name="SetIndex">
               <h3>
                  SetIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) SetIndex(m module.Version, index *modFileIndex)</code></pre>
            </article>
            
            <article class="function" data-name="ShortMessage">
               <h3>
                  ShortMessage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ShortMessage returns a string from go.mod (for example, a retraction
rationale or deprecation message) that is safe to print in a terminal.
If the given string is empty, ShortMessage returns the given default. If the
given string is too long or contains non-printable characters, ShortMessage
returns a hard-coded string.</p>
               
               <pre><code>func ShortMessage(message string, emptyDefault string) string</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rr *replacementRepo) Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (er emptyRepo) Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a string that describes the full conflict path.</p>
               
               <pre><code>func (c Conflict) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p modPruning) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a string describing the Requirements for debugging.</p>
               
               <pre><code>func (rs *Requirements) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dq dqState) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Summary">
               <h3>
                  Summary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Summary returns a string that describes only the first and last modules in
the conflict path.</p>
               
               <pre><code>func (c Conflict) Summary() string</code></pre>
            </article>
            
            <article class="function" data-name="ToDirectoryPath">
               <h3>
                  ToDirectoryPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToDirectoryPath adds a prefix if necessary so that path in unambiguously
an absolute path or a relative path starting with a '.' or '..'
path component.</p>
               
               <pre><code>func ToDirectoryPath(path string) string</code></pre>
            </article>
            
            <article class="function" data-name="Toolchain">
               <h3>
                  Toolchain 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Toolchain returns the toolchain set on the single module, in module mode,
or the go.work file in workspace mode.</p>
               
               <pre><code>func (mms *MainModuleSet) Toolchain() string</code></pre>
            </article>
            
            <article class="function" data-name="Tools">
               <h3>
                  Tools 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Tools returns the tools defined by all the main modules.
The key is the absolute package path of the tool.</p>
               
               <pre><code>func (mms *MainModuleSet) Tools() map[string]bool</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *invalidImportError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *retractionLoadingError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ImportMissingError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="UnwrapModuleError">
               <h3>
                  UnwrapModuleError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnwrapModuleError returns c.Err, but unwraps it if it is a module.ModuleError
with a version and path matching the last entry in the Path slice.</p>
               
               <pre><code>func (c Conflict) UnwrapModuleError() error</code></pre>
            </article>
            
            <article class="function" data-name="UpdateGoModFromReqs">
               <h3>
                  UpdateGoModFromReqs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UpdateGoModFromReqs returns a modified go.mod file using the current
requirements. It does not commit these changes to disk.</p>
               
               <pre><code>func UpdateGoModFromReqs(ctx context.Context, opts WriteOpts) (before []byte, after []byte, modFile *modfile.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="UpdateWorkFile">
               <h3>
                  UpdateWorkFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UpdateWorkFile updates comments on directory directives in the go.work
file to include the associated module path.</p>
               
               <pre><code>func UpdateWorkFile(wf *modfile.WorkFile)</code></pre>
            </article>
            
            <article class="function" data-name="UpdateWorkGoVersion">
               <h3>
                  UpdateWorkGoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UpdateWorkGoVersion updates the go line in wf to be at least goVers,
reporting whether it changed the file.</p>
               
               <pre><code>func UpdateWorkGoVersion(wf *modfile.WorkFile, goVers string) (changed bool)</code></pre>
            </article>
            
            <article class="function" data-name="Upgrade">
               <h3>
                  Upgrade 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Upgrade is a no-op, here to implement mvs.Reqs.
The upgrade logic for go get -u is in ../modget/get.go.</p>
               
               <pre><code>func (*mvsReqs) Upgrade(m module.Version) (module.Version, error)</code></pre>
            </article>
            
            <article class="function" data-name="VendorDir">
               <h3>
                  VendorDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func VendorDir() string</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Versions returns the versions from rr.repo augmented with any matching
replacement versions.</p>
               
               <pre><code>func (rr *replacementRepo) Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (er emptyRepo) Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Versions returns the module.Version values of each of the main modules.
For each of them, the Path fields are ordinary module paths and the Version
fields are empty strings.
Callers should not modify the returned slice.</p>
               
               <pre><code>func (mms *MainModuleSet) Versions() []module.Version</code></pre>
            </article>
            
            <article class="function" data-name="WalkBreadthFirst">
               <h3>
                  WalkBreadthFirst 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WalkBreadthFirst invokes f once, in breadth-first order, for each module
version other than "none" that appears in the graph, regardless of whether
that version is selected.</p>
               
               <pre><code>func (mg *ModuleGraph) WalkBreadthFirst(f func(m module.Version))</code></pre>
            </article>
            
            <article class="function" data-name="Why">
               <h3>
                  Why 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Why returns the "go mod why" output stanza for the given package,
without the leading # comment.
The package graph must have been loaded already, usually by LoadPackages.
If there is no reason for the package to be in the current build,
Why returns an empty string.</p>
               
               <pre><code>func Why(path string) string</code></pre>
            </article>
            
            <article class="function" data-name="WhyDepth">
               <h3>
                  WhyDepth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WhyDepth returns the number of steps in the Why listing.
If there is no reason for the package to be in the current build,
WhyDepth returns 0.</p>
               
               <pre><code>func WhyDepth(path string) int</code></pre>
            </article>
            
            <article class="function" data-name="WillBeEnabled">
               <h3>
                  WillBeEnabled 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WillBeEnabled checks whether modules should be enabled but does not
initialize modules by installing hooks. If Init has already been called,
WillBeEnabled returns the same result as Enabled.
This function is needed to break a cycle. The main package needs to know
whether modules are enabled in order to install the module or GOPATH version
of 'go get', but Init reads the -modfile flag in 'go get', so it shouldn't
be called until the command is installed and flags are parsed. Instead of
calling Init and Enabled, the main package can call this function.</p>
               
               <pre><code>func WillBeEnabled() bool</code></pre>
            </article>
            
            <article class="function" data-name="WorkFile">
               <h3>
                  WorkFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) WorkFile() *modfile.WorkFile</code></pre>
            </article>
            
            <article class="function" data-name="WorkFilePath">
               <h3>
                  WorkFilePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WorkFilePath returns the absolute path of the go.work file, or "" if not in
workspace mode. WorkFilePath must be called after InitWorkfile.</p>
               
               <pre><code>func WorkFilePath() string</code></pre>
            </article>
            
            <article class="function" data-name="WorkFileReplaceMap">
               <h3>
                  WorkFileReplaceMap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) WorkFileReplaceMap() map[module.Version]module.Version</code></pre>
            </article>
            
            <article class="function" data-name="WriteGoMod">
               <h3>
                  WriteGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteGoMod writes the current build list back to go.mod.</p>
               
               <pre><code>func WriteGoMod(ctx context.Context, opts WriteOpts) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteWorkFile">
               <h3>
                  WriteWorkFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteWorkFile cleans and writes out the go.work file to the given path.</p>
               
               <pre><code>func WriteWorkFile(path string, wf *modfile.WorkFile) error</code></pre>
            </article>
            
            <article class="function" data-name="addDeprecation">
               <h3>
                  addDeprecation 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addDeprecation fills in m.Deprecated if the module was deprecated by its
author. m.Error is set if there's an error loading deprecation information.</p>
               
               <pre><code>func addDeprecation(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
            </article>
            
            <article class="function" data-name="addGoStmt">
               <h3>
                  addGoStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addGoStmt adds a go directive to the go.mod file if it does not already
include one. The 'go' version added, if any, is the latest version supported
by this toolchain.</p>
               
               <pre><code>func addGoStmt(modFile *modfile.File, mod module.Version, v string)</code></pre>
            </article>
            
            <article class="function" data-name="addRetraction">
               <h3>
                  addRetraction 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addRetraction fills in m.Retracted if the module was retracted by its author.
m.Error is set if there's an error loading retraction information.</p>
               
               <pre><code>func addRetraction(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
            </article>
            
            <article class="function" data-name="addUpdate">
               <h3>
                  addUpdate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addUpdate fills in m.Update if an updated version is available.</p>
               
               <pre><code>func addUpdate(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
            </article>
            
            <article class="function" data-name="addVersions">
               <h3>
                  addVersions 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addVersions fills in m.Versions with the list of known versions.
Excluded versions will be omitted. If listRetracted is false, retracted
versions will also be omitted.</p>
               
               <pre><code>func addVersions(ctx context.Context, m *modinfo.ModulePublic, listRetracted bool)</code></pre>
            </article>
            
            <article class="function" data-name="allRootsSelected">
               <h3>
                  allRootsSelected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mg *ModuleGraph) allRootsSelected() bool</code></pre>
            </article>
            
            <article class="function" data-name="allowsVersion">
               <h3>
                  allowsVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allowsVersion reports whether version v is allowed by the prefix, filter, and
AllowedFunc of qm.</p>
               
               <pre><code>func (qm *queryMatcher) allowsVersion(ctx context.Context, v string) bool</code></pre>
            </article>
            
            <article class="function" data-name="appendGoAndToolchainRoots">
               <h3>
                  appendGoAndToolchainRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendGoAndToolchainRoots(roots []module.Version, goVersion string, toolchain string, direct map[string]bool) []module.Version</code></pre>
            </article>
            
            <article class="function" data-name="applyPkgFlags">
               <h3>
                  applyPkgFlags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>applyPkgFlags updates pkg.flags to set the given flags and propagate the
(transitive) effects of those flags, possibly loading or enqueueing further
packages as a result.</p>
               
               <pre><code>func (ld *loader) applyPkgFlags(ctx context.Context, pkg *loadPkg, flags loadPkgFlags)</code></pre>
            </article>
            
            <article class="function" data-name="buildStacks">
               <h3>
                  buildStacks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>buildStacks computes minimal import stacks for each package,
for use in error messages. When it completes, packages that
are part of the original root set have pkg.stack == nil,
and other packages have pkg.stack pointing at the next
package up the import stack in their minimal chain.
As a side effect, buildStacks also constructs ld.pkgs,
the list of all packages loaded.</p>
               
               <pre><code>func (ld *loader) buildStacks()</code></pre>
            </article>
            
            <article class="function" data-name="canonicalizeReplacePath">
               <h3>
                  canonicalizeReplacePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canonicalizeReplacePath ensures that relative, on-disk, replaced module paths
are relative to the workspace directory (in workspace mode) or to the module's
directory (in module mode, as they already are).</p>
               
               <pre><code>func canonicalizeReplacePath(r module.Version, modRoot string) module.Version</code></pre>
            </article>
            
            <article class="function" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>check reports whether m is disqualified in the given pruning context.</p>
               
               <pre><code>func (t *dqTracker) check(m module.Version, pruning modPruning) dqState</code></pre>
            </article>
            
            <article class="function" data-name="checkMultiplePaths">
               <h3>
                  checkMultiplePaths 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkMultiplePaths verifies that a given module path is used as itself
or as a replacement for another module, but not both at the same time.
(See https://golang.org/issue/26607 and https://golang.org/issue/34650.)</p>
               
               <pre><code>func (ld *loader) checkMultiplePaths()</code></pre>
            </article>
            
            <article class="function" data-name="checkReuse">
               <h3>
                  checkReuse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkReuse checks whether a revision of a given module
for a given module may be reused, according to the information in origin.</p>
               
               <pre><code>func checkReuse(ctx context.Context, m module.Version, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="checkReuseRepo">
               <h3>
                  checkReuseRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkReuseRepo(ctx context.Context, repo versionRepo, path string, query string, origin *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="checkTidyCompatibility">
               <h3>
                  checkTidyCompatibility 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkTidyCompatibility emits an error if any package would be loaded from a
different module under rs than under ld.requirements.</p>
               
               <pre><code>func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements, compatVersion string)</code></pre>
            </article>
            
            <article class="function" data-name="checkVendorConsistency">
               <h3>
                  checkVendorConsistency 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkVendorConsistency verifies that the vendor/modules.txt file matches (if
go 1.14) or at least does not contradict (go 1.13 or earlier) the
requirements and replacements listed in the main module's go.mod file.</p>
               
               <pre><code>func checkVendorConsistency(indexes []*modFileIndex, modFiles []*modfile.File, modRoots []string)</code></pre>
            </article>
            
            <article class="function" data-name="cmpVersion">
               <h3>
                  cmpVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cmpVersion implements the comparison for versions in the module loader.
It is consistent with gover.ModCompare except that as a special case,
the version "" is considered higher than all other versions.
The main module (also known as the target) has no version and must be chosen
over other versions of the same module in the module dependency graph.</p>
               
               <pre><code>func cmpVersion(p string, v1 string, v2 string) int</code></pre>
            </article>
            
            <article class="function" data-name="commitRequirements">
               <h3>
                  commitRequirements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>commitRequirements ensures go.mod and go.sum are up to date with the current
requirements.
In "mod" mode, commitRequirements writes changes to go.mod and go.sum.
In "readonly" and "vendor" modes, commitRequirements returns an error if
go.mod or go.sum are out of date in a semantically significant way.
In workspace mode, commitRequirements only writes changes to go.work.sum.</p>
               
               <pre><code>func commitRequirements(ctx context.Context, opts WriteOpts) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="computePatternAll">
               <h3>
                  computePatternAll 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>computePatternAll returns the list of packages matching pattern "all",
starting with a list of the import paths for the packages in the main module.</p>
               
               <pre><code>func (ld *loader) computePatternAll() (all []string)</code></pre>
            </article>
            
            <article class="function" data-name="convertPruning">
               <h3>
                  convertPruning 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertPruning returns a version of rs with the given pruning behavior.
If rs already has the given pruning, convertPruning returns rs unmodified.</p>
               
               <pre><code>func convertPruning(ctx context.Context, rs *Requirements, pruning modPruning) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="die">
               <h3>
                  die 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func die()</code></pre>
            </article>
            
            <article class="function" data-name="dirInModule">
               <h3>
                  dirInModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dirInModule locates the directory that would hold the package named by the given path,
if it were in the module with module path mpath and root mdir.
If path is syntactically not within mpath,
or if mdir is a local file tree (isLocal == true) and the directory
that would hold path is in a sub-module (covered by a go.mod below mdir),
dirInModule returns "", false, nil.
Otherwise, dirInModule returns the name of the directory where
Go source files would be expected, along with a boolean indicating
whether there are in fact Go source files in that directory.
A non-nil error indicates that the existence of the directory and/or
source files could not be determined, for example due to a permission error.</p>
               
               <pre><code>func dirInModule(path string, mpath string, mdir string, isLocal bool) (dir string, haveGoFiles bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="directRequirements">
               <h3>
                  directRequirements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func directRequirements(modFiles []*modfile.File) map[string]bool</code></pre>
            </article>
            
            <article class="function" data-name="disqualify">
               <h3>
                  disqualify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>disqualify records why the dependencies of m cannot be included in the module
graph if reached from a part of the graph with the given pruning.
Since the pruned graph is a subgraph of the unpruned graph, disqualifying a
module from a pruned part of the graph also disqualifies it in the unpruned
parts.</p>
               
               <pre><code>func (t *dqTracker) disqualify(m module.Version, fromPruning modPruning, reason dqState)</code></pre>
            </article>
            
            <article class="function" data-name="editRequirements">
               <h3>
                  editRequirements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>editRequirements returns an edited version of rs such that:
1. Each module version in mustSelect is selected.
2. Each module version in tryUpgrade is upgraded toward the indicated
version as far as can be done without violating (1).
(Other upgrades are also allowed if they are caused by
transitive requirements of versions in mustSelect or
tryUpgrade.)
3. Each module version in rs.rootModules (or rs.graph, if rs is unpruned)
is downgraded or upgraded from its original version only to the extent
needed to satisfy (1) and (2).
Generally, the module versions in mustSelect are due to the module or a
package within the module matching an explicit command line argument to 'go
get', and the versions in tryUpgrade are transitive dependencies that are
either being upgraded by 'go get -u' or being added to satisfy some
otherwise-missing package import.
If pruning is enabled, the roots of the edited requirements include an
explicit entry for each module path in tryUpgrade, mustSelect, and the roots
of rs, unless the selected version for the module path is "none".</p>
               
               <pre><code>func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade []module.Version, mustSelect []module.Version) (edited *Requirements, changed bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="errWorkTooOld">
               <h3>
                  errWorkTooOld 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func errWorkTooOld(gomod string, wf *modfile.WorkFile, goVers string) error</code></pre>
            </article>
            
            <article class="function" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>error reports an error via either os.Stderr or base.Error,
according to whether ld.AllowErrors is set.</p>
               
               <pre><code>func (ld *loader) error(err error)</code></pre>
            </article>
            
            <article class="function" data-name="exitIfErrors">
               <h3>
                  exitIfErrors 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>exitIfErrors switches toolchains if a switch is needed
or else exits if any errors have been reported.</p>
               
               <pre><code>func (ld *loader) exitIfErrors(ctx context.Context)</code></pre>
            </article>
            
            <article class="function" data-name="expandGraph">
               <h3>
                  expandGraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>expandGraph loads the complete module graph from rs.
If the complete graph reveals that some root of rs is not actually the
selected version of its path, expandGraph computes a new set of roots that
are consistent. (With a pruned module graph, this may result in upgrades to
other modules due to requirements that were previously pruned out.)
expandGraph returns the updated roots, along with the module graph loaded
from those roots and any error encountered while loading that graph.
expandGraph returns non-nil requirements and a non-nil graph regardless of
errors. On error, the roots might not be updated to be consistent.</p>
               
               <pre><code>func expandGraph(ctx context.Context, rs *Requirements) (*Requirements, *ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function" data-name="extendGraph">
               <h3>
                  extendGraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>extendGraph loads the module graph from roots, and iteratively extends it by
unpruning the selected version of each module path that is a root in rs or in
the roots slice until the graph reaches a fixed point.
The graph is guaranteed to converge to a fixed point because unpruning a
module version can only increase (never decrease) the selected versions,
and the set of versions for each module is finite.
The extended graph is useful for diagnosing version conflicts: for each
selected module version, it can provide a complete path of requirements from
some root to that version.</p>
               
               <pre><code>func extendGraph(ctx context.Context, rootPruning modPruning, roots []module.Version, selectedRoot map[string]string) (mg *ModuleGraph, upgradedRoot map[module.Version]bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="fetch">
               <h3>
                  fetch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fetch downloads the given module (or its replacement)
and returns its location.
The isLocal return value reports whether the replacement,
if any, is local to the filesystem.</p>
               
               <pre><code>func fetch(ctx context.Context, mod module.Version) (dir string, isLocal bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="filterVersions">
               <h3>
                  filterVersions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>filterVersions classifies versions into releases and pre-releases, filtering
out:
1. versions that do not satisfy the 'allowed' predicate, and
2. "+incompatible" versions, if a compatible one satisfies the predicate
and the incompatible version is not preferred.
If the allowed predicate returns an error not equivalent to ErrDisallowed,
filterVersions returns that error.</p>
               
               <pre><code>func (qm *queryMatcher) filterVersions(ctx context.Context, versions []string) (releases []string, prereleases []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="findAltConfig">
               <h3>
                  findAltConfig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findAltConfig(dir string) (root string, name string)</code></pre>
            </article>
            
            <article class="function" data-name="findError">
               <h3>
                  findError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mg *ModuleGraph) findError() error</code></pre>
            </article>
            
            <article class="function" data-name="findImportComment">
               <h3>
                  findImportComment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findImportComment(file string) string</code></pre>
            </article>
            
            <article class="function" data-name="findModule">
               <h3>
                  findModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>findModule searches for the module that contains the package at path.
If the package was loaded, its containing module and true are returned.
Otherwise, module.Version{} and false are returned.</p>
               
               <pre><code>func findModule(ld *loader, path string) (module.Version, bool)</code></pre>
            </article>
            
            <article class="function" data-name="findModulePath">
               <h3>
                  findModulePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findModulePath(dir string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="findModuleRoot">
               <h3>
                  findModuleRoot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findModuleRoot(dir string) (roots string)</code></pre>
            </article>
            
            <article class="function" data-name="findStandardImportPath">
               <h3>
                  findStandardImportPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findStandardImportPath(path string) string</code></pre>
            </article>
            
            <article class="function" data-name="findWorkspaceFile">
               <h3>
                  findWorkspaceFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findWorkspaceFile(dir string) (root string)</code></pre>
            </article>
            
            <article class="function" data-name="fixVersion">
               <h3>
                  fixVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fixVersion returns a modfile.VersionFixer implemented using the Query function.
It resolves commit hashes and branch names to versions,
canonicalizes versions that appeared in early vgo drafts,
and does nothing for versions that already appear to be canonical.
The VersionFixer sets 'fixed' if it ever returns a non-canonical version.</p>
               
               <pre><code>func fixVersion(ctx context.Context, fixed *bool) modfile.VersionFixer</code></pre>
            </article>
            
            <article class="function" data-name="forceGoStmt">
               <h3>
                  forceGoStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func forceGoStmt(modFile *modfile.File, mod module.Version, v string)</code></pre>
            </article>
            
            <article class="function" data-name="from">
               <h3>
                  from 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pp *ast.IndexExpr) from(p modPruning) T</code></pre>
            </article>
            
            <article class="function" data-name="fromExternalModule">
               <h3>
                  fromExternalModule 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fromExternalModule reports whether pkg was loaded from a module other than
the main module.</p>
               
               <pre><code>func (pkg *loadPkg) fromExternalModule() bool</code></pre>
            </article>
            
            <article class="function" data-name="goModSummary">
               <h3>
                  goModSummary 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goModSummary returns a summary of the go.mod file for module m,
taking into account any replacements for m, exclusions of its dependencies,
and/or vendoring.
m must be a version in the module graph, reachable from the Target module.
In readonly mode, the go.sum file must contain an entry for m's go.mod file
(or its replacement). goModSummary must not be called for the Target module
itself, as its requirements may change. Use rawGoModSummary for other
module versions.
The caller must not modify the returned summary.</p>
               
               <pre><code>func goModSummary(m module.Version) (*modFileSummary, error)</code></pre>
            </article>
            
            <article class="function" data-name="goVersion">
               <h3>
                  goVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goVersion reports the Go version that should be used for the loader's
requirements: ld.TidyGoVersion if set, or ld.requirements.GoVersion()
otherwise.</p>
               
               <pre><code>func (ld *loader) goVersion() string</code></pre>
            </article>
            
            <article class="function" data-name="has">
               <h3>
                  has 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>has reports whether all of the flags in cond are set in af.</p>
               
               <pre><code>func (af *atomicLoadPkgFlags) has(cond loadPkgFlags) bool</code></pre>
            </article>
            
            <article class="function" data-name="has">
               <h3>
                  has 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>has reports whether all of the flags in cond are set in f.</p>
               
               <pre><code>func (f loadPkgFlags) has(cond loadPkgFlags) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasRedundantRoot">
               <h3>
                  hasRedundantRoot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hasRedundantRoot returns true if the root list contains multiple requirements
of the same module or a requirement on any version of the main module.
Redundant requirements should be pruned, but they may influence version
selection.</p>
               
               <pre><code>func (rs *Requirements) hasRedundantRoot() bool</code></pre>
            </article>
            
            <article class="function" data-name="hasWritePerm">
               <h3>
                  hasWritePerm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.</p>
               
               <pre><code>func hasWritePerm(_ string, fi fs.FileInfo) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasWritePerm">
               <h3>
                  hasWritePerm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.
Although the root user on most Unix systems can write to files even without
permission, hasWritePerm reports false if no appropriate permission bit is
set even if the current user is root.</p>
               
               <pre><code>func hasWritePerm(path string, fi fs.FileInfo) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasWritePerm">
               <h3>
                  hasWritePerm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.</p>
               
               <pre><code>func hasWritePerm(path string, _ fs.FileInfo) bool</code></pre>
            </article>
            
            <article class="function" data-name="importFromModules">
               <h3>
                  importFromModules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>importFromModules finds the module and directory in the dependency graph of
rs containing the package with the given import path. If mg is nil,
importFromModules attempts to locate the module using only the main module
and the roots of rs before it loads the full graph.
The answer must be unique: importFromModules returns an error if multiple
modules are observed to provide the same package.
importFromModules can return a module with an empty m.Path, for packages in
the standard library.
importFromModules can return an empty directory string, for fake packages
like "C" and "unsafe".
If the package is not present in any module selected from the requirement
graph, importFromModules returns an *ImportMissingError.
If the package is present in exactly one module, importFromModules will
return the module, its root directory, and a list of other modules that
lexically could have provided the package but did not.
If skipModFile is true, the go.mod file for the package is not loaded. This
allows 'go mod tidy' to preserve a minor checksum-preservation bug
(https://go.dev/issue/56222) for modules with 'go' versions between 1.17 and
1.20, preventing unnecessary go.sum churn and network access in those
modules.</p>
               
               <pre><code>func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph, skipModFile bool) (m module.Version, modroot string, dir string, altMods []module.Version, err error)</code></pre>
            </article>
            
            <article class="function" data-name="inWorkspaceMode">
               <h3>
                  inWorkspaceMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func inWorkspaceMode() bool</code></pre>
            </article>
            
            <article class="function" data-name="indexModFile">
               <h3>
                  indexModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indexModFile rebuilds the index of modFile.
If modFile has been changed since it was first read,
modFile.Cleanup must be called before indexModFile.</p>
               
               <pre><code>func indexModFile(data []byte, modFile *modfile.File, mod module.Version, needsFix bool) *modFileIndex</code></pre>
            </article>
            
            <article class="function" data-name="initVendor">
               <h3>
                  initVendor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>initVendor initializes rs.graph from the given list of vendored module
dependencies, overriding the graph that would normally be loaded from module
requirements.</p>
               
               <pre><code>func (rs *Requirements) initVendor(vendorList []module.Version)</code></pre>
            </article>
            
            <article class="function" data-name="isDisqualified">
               <h3>
                  isDisqualified 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dq dqState) isDisqualified() bool</code></pre>
            </article>
            
            <article class="function" data-name="isStandardImportPath">
               <h3>
                  isStandardImportPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isStandardImportPath(path string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isTest">
               <h3>
                  isTest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isTest reports whether pkg is a test of another package.</p>
               
               <pre><code>func (pkg *loadPkg) isTest() bool</code></pre>
            </article>
            
            <article class="function" data-name="keepSums">
               <h3>
                  keepSums 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>keepSums returns the set of modules (and go.mod file entries) for which
checksums would be needed in order to reload the same set of packages
loaded by the most recent call to LoadPackages or ImportFromFiles,
including any go.mod files needed to reconstruct the MVS result
or identify go versions,
in addition to the checksums for every module in keepMods.</p>
               
               <pre><code>func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums) map[module.Version]bool</code></pre>
            </article>
            
            <article class="function" data-name="listModules">
               <h3>
                  listModules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func listModules(ctx context.Context, rs *Requirements, args []string, mode ListMode, reuse map[module.Version]*modinfo.ModulePublic) (_ *Requirements, mods []*modinfo.ModulePublic, mgErr error)</code></pre>
            </article>
            
            <article class="function" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>load loads an individual package.</p>
               
               <pre><code>func (ld *loader) load(ctx context.Context, pkg *loadPkg)</code></pre>
            </article>
            
            <article class="function" data-name="loadFromRoots">
               <h3>
                  loadFromRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadFromRoots attempts to load the build graph needed to process a set of
root packages and their dependencies.
The set of root packages is returned by the params.listRoots function, and
expanded to the full set of packages by tracing imports (and possibly tests)
as needed.</p>
               
               <pre><code>func loadFromRoots(ctx context.Context, params loaderParams) *loader</code></pre>
            </article>
            
            <article class="function" data-name="loadModFile">
               <h3>
                  loadModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadModFile(ctx context.Context, opts *PackageOpts) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="loadWorkFile">
               <h3>
                  loadWorkFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadWorkFile(path string) (workFile *modfile.WorkFile, modRoots []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupRepo">
               <h3>
                  lookupRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupRepo(ctx context.Context, proxy string, path string) (repo versionRepo, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeMainModules">
               <h3>
                  makeMainModules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeMainModules creates a MainModuleSet and associated variables according to
the given main modules.</p>
               
               <pre><code>func makeMainModules(ms []module.Version, rootDirs []string, modFiles []*modfile.File, indices []*modFileIndex, workFile *modfile.WorkFile) *MainModuleSet</code></pre>
            </article>
            
            <article class="function" data-name="matchLocalDirs">
               <h3>
                  matchLocalDirs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories
outside of the standard library and active modules.</p>
               
               <pre><code>func matchLocalDirs(ctx context.Context, modRoots []string, m *search.Match, rs *Requirements)</code></pre>
            </article>
            
            <article class="function" data-name="matchPackages">
               <h3>
                  matchPackages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>matchPackages is like m.MatchPackages, but uses a local variable (rather than
a global) for tags, can include or exclude packages in the standard library,
and is restricted to the given list of modules.</p>
               
               <pre><code>func matchPackages(ctx context.Context, m *search.Match, tags map[string]bool, filter stdFilter, modules []module.Version)</code></pre>
            </article>
            
            <article class="function" data-name="maybeInModule">
               <h3>
                  maybeInModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>maybeInModule reports whether, syntactically,
a package with the given import path could be supplied
by a module with the given module path (mpath).</p>
               
               <pre><code>func maybeInModule(path string, mpath string) bool</code></pre>
            </article>
            
            <article class="function" data-name="mergeOrigin">
               <h3>
                  mergeOrigin 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mergeOrigin returns the union of data from two origins,
returning either a new origin or one of its unmodified arguments.
If the two origins conflict including if either is nil,
mergeOrigin returns nil.</p>
               
               <pre><code>func mergeOrigin(m1 *codehost.Origin, m2 *codehost.Origin) *codehost.Origin</code></pre>
            </article>
            
            <article class="function" data-name="modFileIsDirty">
               <h3>
                  modFileIsDirty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>modFileIsDirty reports whether the go.mod file differs meaningfully
from what was indexed.
If modFile has been changed (even cosmetically) since it was first read,
modFile.Cleanup must be called before modFileIsDirty.</p>
               
               <pre><code>func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool</code></pre>
            </article>
            
            <article class="function" data-name="modFilePath">
               <h3>
                  modFilePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func modFilePath(modRoot string) string</code></pre>
            </article>
            
            <article class="function" data-name="modinfoError">
               <h3>
                  modinfoError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>modinfoError wraps an error to create an error message in
modinfo.ModuleError with minimal redundancy.</p>
               
               <pre><code>func modinfoError(path string, vers string, err error) *modinfo.ModuleError</code></pre>
            </article>
            
            <article class="function" data-name="modkey">
               <h3>
                  modkey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>modkey returns the module.Version under which the checksum for m's go.mod
file is stored in the go.sum file.</p>
               
               <pre><code>func modkey(m module.Version) module.Version</code></pre>
            </article>
            
            <article class="function" data-name="moduleInfo">
               <h3>
                  moduleInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>moduleInfo returns information about module m, loaded from the requirements
in rs (which may be nil to indicate that m was not loaded from a requirement
graph).</p>
               
               <pre><code>func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode ListMode, reuse map[module.Version]*modinfo.ModulePublic) *modinfo.ModulePublic</code></pre>
            </article>
            
            <article class="function" data-name="modulePrefixesExcludingTarget">
               <h3>
                  modulePrefixesExcludingTarget 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>modulePrefixesExcludingTarget returns all prefixes of path that may plausibly
exist as a module, excluding targetPrefix but otherwise including path
itself, sorted by descending length. Prefixes that are not valid module paths
but are valid package paths (like "m" or "example.com/.gen") are included,
since they might be replaced.</p>
               
               <pre><code>func modulePrefixesExcludingTarget(path string) []string</code></pre>
            </article>
            
            <article class="function" data-name="modulesTextIsForWorkspace">
               <h3>
                  modulesTextIsForWorkspace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func modulesTextIsForWorkspace(vendorDir string) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="mustGetSingleMainModule">
               <h3>
                  mustGetSingleMainModule 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mms *MainModuleSet) mustGetSingleMainModule() module.Version</code></pre>
            </article>
            
            <article class="function" data-name="mustHaveCompleteRequirements">
               <h3>
                  mustHaveCompleteRequirements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mustHaveCompleteRequirements() bool</code></pre>
            </article>
            
            <article class="function" data-name="mustHaveGoRoot">
               <h3>
                  mustHaveGoRoot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mustHaveGoRoot(roots []module.Version)</code></pre>
            </article>
            
            <article class="function" data-name="mustHaveSums">
               <h3>
                  mustHaveSums 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mustHaveSums reports whether we require that all checksums
needed to load or build packages are already present in the go.sum file.</p>
               
               <pre><code>func mustHaveSums() bool</code></pre>
            </article>
            
            <article class="function" data-name="newQueryMatcher">
               <h3>
                  newQueryMatcher 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newQueryMatcher returns a new queryMatcher that matches the versions
specified by the given query on the module with the given path.
If the query can only be resolved by statting a non-SemVer revision,
newQueryMatcher returns errRevQuery.</p>
               
               <pre><code>func newQueryMatcher(path string, query string, current string, allowed AllowedFunc) (*queryMatcher, error)</code></pre>
            </article>
            
            <article class="function" data-name="newRequirements">
               <h3>
                  newRequirements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newRequirements returns a new requirement set with the given root modules.
The dependencies of the roots will be loaded lazily at the first call to the
Graph method.
The rootModules slice must be sorted according to gover.ModSort.
The caller must not modify the rootModules slice or direct map after passing
them to newRequirements.
If vendoring is in effect, the caller must invoke initVendor on the returned
*Requirements before any other method.</p>
               
               <pre><code>func newRequirements(pruning modPruning, rootModules []module.Version, direct map[string]bool) *Requirements</code></pre>
            </article>
            
            <article class="function" data-name="overrideRoots">
               <h3>
                  overrideRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func overrideRoots(ctx context.Context, rs *Requirements, replace []module.Version) *Requirements</code></pre>
            </article>
            
            <article class="function" data-name="path">
               <h3>
                  path 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>path returns the path from m to the reason it is disqualified, which may be
either a module that violates constraints or an error in loading
requirements.
If m is not disqualified, path returns (nil, nil).</p>
               
               <pre><code>func (t *dqTracker) path(m module.Version, pruning modPruning) (path []module.Version, err error)</code></pre>
            </article>
            
            <article class="function" data-name="pathInModuleCache">
               <h3>
                  pathInModuleCache 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pathInModuleCache returns the import path of the directory dir,
if dir is in the module cache copy of a module in our build list.</p>
               
               <pre><code>func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string</code></pre>
            </article>
            
            <article class="function" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pkg locates the *loadPkg for path, creating and queuing it for loading if
needed, and updates its state to reflect the given flags.
The imports of the returned *loadPkg will be loaded asynchronously in the
ld.work queue, and its test (if requested) will also be populated once
imports have been resolved. When ld.work goes idle, all transitive imports of
the requested package (and its test, if requested) will have been loaded.</p>
               
               <pre><code>func (ld *loader) pkg(ctx context.Context, path string, flags loadPkgFlags) *loadPkg</code></pre>
            </article>
            
            <article class="function" data-name="pkgTest">
               <h3>
                  pkgTest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pkgTest locates the test of pkg, creating it if needed, and updates its state
to reflect the given flags.
pkgTest requires that the imports of pkg have already been loaded (flagged
with pkgImportsLoaded).</p>
               
               <pre><code>func (ld *loader) pkgTest(ctx context.Context, pkg *loadPkg, testFlags loadPkgFlags) *loadPkg</code></pre>
            </article>
            
            <article class="function" data-name="preloadRootModules">
               <h3>
                  preloadRootModules 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>preloadRootModules loads the module requirements needed to identify the
selected version of each module providing a package in rootPkgs,
adding new root modules to the module graph if needed.</p>
               
               <pre><code>func (ld *loader) preloadRootModules(ctx context.Context, rootPkgs []string) (changedBuildList bool)</code></pre>
            </article>
            
            <article class="function" data-name="previousVersion">
               <h3>
                  previousVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>previousVersion returns the tagged version of m.Path immediately prior to
m.Version, or version "none" if no prior version is tagged.
Since the version of a main module is not found in the version list,
it has no previous version.</p>
               
               <pre><code>func previousVersion(ctx context.Context, m module.Version) (module.Version, error)</code></pre>
            </article>
            
            <article class="function" data-name="pruningForGoVersion">
               <h3>
                  pruningForGoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pruningForGoVersion(goVersion string) modPruning</code></pre>
            </article>
            
            <article class="function" data-name="queryImport">
               <h3>
                  queryImport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>queryImport attempts to locate a module that can be added to the current
build list to provide the package with the given import path.
Unlike QueryPattern, queryImport prefers to add a replaced version of a
module *before* checking the proxies for a version to add.</p>
               
               <pre><code>func queryImport(ctx context.Context, path string, rs *Requirements) (module.Version, error)</code></pre>
            </article>
            
            <article class="function" data-name="queryLatestVersionIgnoringRetractions">
               <h3>
                  queryLatestVersionIgnoringRetractions 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>queryLatestVersionIgnoringRetractions looks up the latest version of the
module with the given path without considering retracted or excluded
versions.
If all versions of the module are replaced,
queryLatestVersionIgnoringRetractions returns the replacement without making
a query.
If the queried latest version is replaced,
queryLatestVersionIgnoringRetractions returns the replacement.</p>
               
               <pre><code>func queryLatestVersionIgnoringRetractions(ctx context.Context, path string) (latest module.Version, err error)</code></pre>
            </article>
            
            <article class="function" data-name="queryPrefixModules">
               <h3>
                  queryPrefixModules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func queryPrefixModules(ctx context.Context, candidateModules []string, queryModule func(ctx context.Context, path string) (QueryResult, error)) (found []QueryResult, err error)</code></pre>
            </article>
            
            <article class="function" data-name="queryProxy">
               <h3>
                  queryProxy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func queryProxy(ctx context.Context, proxy string, path string, query string, current string, allowed AllowedFunc, reuse map[module.Version]*modinfo.ModulePublic) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="queryReuse">
               <h3>
                  queryReuse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>queryReuse is like Query but also takes a map of module info that can be reused
if the validation criteria in Origin are met.</p>
               
               <pre><code>func queryReuse(ctx context.Context, path string, query string, current string, allowed AllowedFunc, reuse map[module.Version]*modinfo.ModulePublic) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="rawGoModData">
               <h3>
                  rawGoModData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rawGoModData returns the content of the go.mod file for module m, ignoring
all replacements that may apply to m.
rawGoModData cannot be used on the main module outside of workspace mode.
Unlike rawGoModSummary, rawGoModData does not cache its results in memory.
Use rawGoModSummary instead unless you specifically need these bytes.</p>
               
               <pre><code>func rawGoModData(m module.Version) (name string, data []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="rawGoModSummary">
               <h3>
                  rawGoModSummary 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rawGoModSummary returns a new summary of the go.mod file for module m,
ignoring all replacements that may apply to m and excludes that may apply to
its dependencies.
rawGoModSummary cannot be used on the main module outside of workspace mode.
The modFileSummary can still be used for retractions and deprecations
even if a TooNewError is returned.</p>
               
               <pre><code>func rawGoModSummary(m module.Version) (*modFileSummary, error)</code></pre>
            </article>
            
            <article class="function" data-name="readModGraph">
               <h3>
                  readModGraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readModGraph reads and returns the module dependency graph starting at the
given roots.
The requirements of the module versions found in the unprune map are included
in the graph even if they would normally be pruned out.
Unlike LoadModGraph, readModGraph does not attempt to diagnose or update
inconsistent roots.</p>
               
               <pre><code>func readModGraph(ctx context.Context, pruning modPruning, roots []module.Version, unprune map[module.Version]bool) (*ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function" data-name="readVendorList">
               <h3>
                  readVendorList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readVendorList reads the list of vendored modules from vendor/modules.txt.</p>
               
               <pre><code>func readVendorList(vendorDir string)</code></pre>
            </article>
            
            <article class="function" data-name="replaceRelativeTo">
               <h3>
                  replaceRelativeTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func replaceRelativeTo() string</code></pre>
            </article>
            
            <article class="function" data-name="replacement">
               <h3>
                  replacement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func replacement(mod module.Version, replace map[module.Version]module.Version) (fromVersion string, to module.Version, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="replacementFrom">
               <h3>
                  replacementFrom 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>replacementFrom returns the replacement for mod, if any, the modroot of the replacement if it appeared in a go.mod,
and the source of the replacement. The replacement is relative to the go.work or go.mod file it appears in.</p>
               
               <pre><code>func replacementFrom(mod module.Version) (r module.Version, modroot string, fromFile string)</code></pre>
            </article>
            
            <article class="function" data-name="replacementStat">
               <h3>
                  replacementStat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rr *replacementRepo) replacementStat(v string) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="require">
               <h3>
                  require 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>require records that m directly requires r, in case r becomes disqualified.
(These edges are in the opposite direction from the edges in an mvs.Graph.)
If r is already disqualified, require propagates the disqualification to m
and returns the reason for the disqualification.</p>
               
               <pre><code>func (t *dqTracker) require(m module.Version, r module.Version) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="requirementsFromModFiles">
               <h3>
                  requirementsFromModFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>requirementsFromModFiles returns the set of non-excluded requirements from
the global modFile.</p>
               
               <pre><code>func requirementsFromModFiles(ctx context.Context, workFile *modfile.WorkFile, modFiles []*modfile.File, opts *PackageOpts) *Requirements</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ld *loader) reset()</code></pre>
            </article>
            
            <article class="function" data-name="resolveLocalPackage">
               <h3>
                  resolveLocalPackage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveLocalPackage resolves a filesystem path to a package path.</p>
               
               <pre><code>func resolveLocalPackage(ctx context.Context, dir string, rs *Requirements) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="resolveMissingImports">
               <h3>
                  resolveMissingImports 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resolveMissingImports returns a set of modules that could be added as
dependencies in order to resolve missing packages from pkgs.
The newly-resolved packages are added to the addedModuleFor map, and
resolveMissingImports returns a map from each new module version to
the first missing package that module would resolve.</p>
               
               <pre><code>func (ld *loader) resolveMissingImports(ctx context.Context) (modAddedBy map[module.Version]*loadPkg, err error)</code></pre>
            </article>
            
            <article class="function" data-name="resolveReplacement">
               <h3>
                  resolveReplacement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveReplacement returns the module actually used to load the source code
for m: either m itself, or the replacement for m (iff m is replaced).
It also returns the modroot of the module providing the replacement if
one was found.</p>
               
               <pre><code>func resolveReplacement(m module.Version) module.Version</code></pre>
            </article>
            
            <article class="function" data-name="rootSelected">
               <h3>
                  rootSelected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rootSelected returns the version of the root dependency with the given module
path, or the zero module.Version and ok=false if the module is not a root
dependency.</p>
               
               <pre><code>func (rs *Requirements) rootSelected(path string) (version string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="rootsFromModFile">
               <h3>
                  rootsFromModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rootsFromModFile(m module.Version, modFile *modfile.File, addToolchainRoot addToolchainRoot) (roots []module.Version, direct map[string]bool)</code></pre>
            </article>
            
            <article class="function" data-name="scanDir">
               <h3>
                  scanDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>scanDir is like imports.ScanDir but elides known magic imports from the list,
so that we do not go looking for packages that don't really exist.
The standard magic import is "C", for cgo.
The only other known magic imports are appengine and appengine/*.
These are so old that they predate "go get" and did not use URL-like paths.
Most code today now uses google.golang.org/appengine instead,
but not all code has been so updated. When we mostly ignore build tags
during "go vendor", we look into "// +build appengine" files and
may see these legacy imports. We drop them so that the module
search does not look for modules to try to satisfy them.</p>
               
               <pre><code>func scanDir(modroot string, dir string, tags map[string]bool) (imports_ []string, testImports []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultBuildMod">
               <h3>
                  setDefaultBuildMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setDefaultBuildMod sets a default value for cfg.BuildMod if the -mod flag
wasn't provided. setDefaultBuildMod may be called multiple times.</p>
               
               <pre><code>func setDefaultBuildMod()</code></pre>
            </article>
            
            <article class="function" data-name="shortPathErrorList">
               <h3>
                  shortPathErrorList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func shortPathErrorList(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="spotCheckRoots">
               <h3>
                  spotCheckRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>spotCheckRoots reports whether the versions of the roots in rs satisfy the
explicit requirements of the modules in mods.</p>
               
               <pre><code>func spotCheckRoots(ctx context.Context, rs *Requirements, mods map[module.Version]bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="stackText">
               <h3>
                  stackText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stackText builds the import stack text to use when
reporting an error in pkg. It has the general form
root imports
other imports
other2 tested by
other2.test imports
pkg</p>
               
               <pre><code>func (pkg *loadPkg) stackText() string</code></pre>
            </article>
            
            <article class="function" data-name="stdVendor">
               <h3>
                  stdVendor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stdVendor returns the canonical import path for the package with the given
path when imported from the standard-library package at parentPath.</p>
               
               <pre><code>func (ld *loader) stdVendor(parentPath string, path string) string</code></pre>
            </article>
            
            <article class="function" data-name="suggestGopkgIn">
               <h3>
                  suggestGopkgIn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func suggestGopkgIn(path string) string</code></pre>
            </article>
            
            <article class="function" data-name="suggestModulePath">
               <h3>
                  suggestModulePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func suggestModulePath(path string) string</code></pre>
            </article>
            
            <article class="function" data-name="switchIfErrors">
               <h3>
                  switchIfErrors 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>switchIfErrors switches toolchains if a switch is needed.</p>
               
               <pre><code>func (ld *loader) switchIfErrors(ctx context.Context)</code></pre>
            </article>
            
            <article class="function" data-name="tidyPrunedRoots">
               <h3>
                  tidyPrunedRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tidyPrunedRoots returns a minimal set of root requirements that maintains the
invariants of the go.mod file needed to support graph pruning for the given
packages:
1. For each package marked with pkgInAll, the module path that provided that
package is included as a root.
2. For all packages, the module that provided that package either remains
selected at the same version or is upgraded by the dependencies of a
root.
If any module that provided a package has been upgraded above its previous
version, the caller may need to reload and recompute the package graph.
To ensure that the loading process eventually converges, the caller should
add any needed roots from the tidy root set (without removing existing untidy
roots) until the set of roots has converged.</p>
               
               <pre><code>func tidyPrunedRoots(ctx context.Context, mainModule module.Version, old *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="tidyRoots">
               <h3>
                  tidyRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tidyRoots trims the root dependencies to the minimal requirements needed to
both retain the same versions of all packages in pkgs and satisfy the
graph-pruning invariants (if applicable).</p>
               
               <pre><code>func tidyRoots(ctx context.Context, rs *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="tidyUnprunedRoots">
               <h3>
                  tidyUnprunedRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tidyUnprunedRoots returns a minimal set of root requirements that maintains
the selected version of every module that provided or lexically could have
provided a package in pkgs, and includes the selected version of every such
module in direct as a root.</p>
               
               <pre><code>func tidyUnprunedRoots(ctx context.Context, mainModule module.Version, old *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="toReplaceMap">
               <h3>
                  toReplaceMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func toReplaceMap(replacements []*modfile.Replace) map[module.Version]module.Version</code></pre>
            </article>
            
            <article class="function" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>update sets the given flags in af (in addition to any flags already set).
update returns the previous flag state so that the caller may determine which
flags were newly-set.</p>
               
               <pre><code>func (af *atomicLoadPkgFlags) update(flags loadPkgFlags) (old loadPkgFlags)</code></pre>
            </article>
            
            <article class="function" data-name="updatePrunedRoots">
               <h3>
                  updatePrunedRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>updatePrunedRoots returns a set of root requirements that maintains the
invariants of the go.mod file needed to support graph pruning:
1. The selected version of the module providing each package marked with
either pkgInAll or pkgIsRoot is included as a root.
Note that certain root patterns (such as '...') may explode the root set
to contain every module that provides any package imported (or merely
required) by any other module.
2. Each root appears only once, at the selected version of its path
(if rs.graph is non-nil) or at the highest version otherwise present as a
root (otherwise).
3. Every module path that appears as a root in rs remains a root.
4. Every version in add is selected at its given version unless upgraded by
(the dependencies of) an existing root or another module in add.
The packages in pkgs are assumed to have been loaded from either the roots of
rs or the modules selected in the graph of rs.
The above invariants together imply the graph-pruning invariants for the
go.mod file:
1. (The import invariant.) Every module that provides a package transitively
imported by any package or test in the main module is included as a root.
This follows by induction from (1) and (3) above. Transitively-imported
packages loaded during this invocation are marked with pkgInAll (1),
and by hypothesis any transitively-imported packages loaded in previous
invocations were already roots in rs (3).
2. (The argument invariant.) Every module that provides a package matching
an explicit package pattern is included as a root. This follows directly
from (1): packages matching explicit package patterns are marked with
pkgIsRoot.
3. (The completeness invariant.) Every module that contributed any package
to the build is required by either the main module or one of the modules
it requires explicitly. This invariant is left up to the caller, who must
not load packages from outside the module graph but may add roots to the
graph, but is facilitated by (3). If the caller adds roots to the graph in
order to resolve missing packages, then updatePrunedRoots will retain them,
the selected versions of those roots cannot regress, and they will
eventually be written back to the main module's go.mod file.
(See https://golang.org/design/36460-lazy-module-loading#invariants for more
detail.)</p>
               
               <pre><code>func updatePrunedRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="updateRequirements">
               <h3>
                  updateRequirements 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>updateRequirements ensures that ld.requirements is consistent with the
information gained from ld.pkgs.
In particular:
- Modules that provide packages directly imported from the main module are
marked as direct, and are promoted to explicit roots. If a needed root
cannot be promoted due to -mod=readonly or -mod=vendor, the importing
package is marked with an error.
- If ld scanned the "all" pattern independent of build constraints, it is
guaranteed to have seen every direct import. Module dependencies that did
not provide any directly-imported package are then marked as indirect.
- Root dependencies are updated to their selected versions.
The "changed" return value reports whether the update changed the selected
version of any module that either provided a loaded package or may now
provide a package that was previously unresolved.</p>
               
               <pre><code>func (ld *loader) updateRequirements(ctx context.Context) (changed bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="updateRoots">
               <h3>
                  updateRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func updateRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="updateUnprunedRoots">
               <h3>
                  updateUnprunedRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>updateUnprunedRoots returns a set of root requirements that includes the selected
version of every module path in direct as a root, and maintains the selected
version of every module selected in the graph of rs.
The roots are updated such that:
1. The selected version of every module path in direct is included as a root
(if it is not "none").
2. Each root is the selected version of its path. (We say that such a root
set is “consistent”.)
3. Every version selected in the graph of rs remains selected unless upgraded
by a dependency in add.
4. Every version in add is selected at its given version unless upgraded by
(the dependencies of) an existing root or another module in add.</p>
               
               <pre><code>func updateUnprunedRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="updateWorkspaceRoots">
               <h3>
                  updateWorkspaceRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func updateWorkspaceRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function" data-name="versionHasGoMod">
               <h3>
                  versionHasGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>versionHasGoMod returns whether a version has a go.mod file.
versionHasGoMod fetches the go.mod file (possibly a fake) and true if it
contains anything other than a module directive with the same path. When a
module does not have a real go.mod file, the go command acts as if it had one
that only contained a module directive. Normal go.mod files created after
1.12 at least have a go directive.
This function is a heuristic, since it's possible to commit a file that would
pass this test. However, we only need a heuristic for determining whether
+incompatible versions may be "latest", which is what this function is used
for.
This heuristic is useful for two reasons: first, when using a proxy,
this lets us fetch from the .mod endpoint which is much faster than the .zip
endpoint. The .mod file is used anyway, even if the .zip file contains a
go.mod with different content. Second, if we don't fetch the .zip, then
we don't need to verify it in go.sum. This makes 'go list -m -u' faster
and simpler.</p>
               
               <pre><code>func versionHasGoMod(_ context.Context, m module.Version) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="versions">
               <h3>
                  versions 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func versions(ctx context.Context, path string, allowed AllowedFunc) (versions []string, origin *codehost.Origin, err error)</code></pre>
            </article>
            
            <article class="function" data-name="walkFromIndex">
               <h3>
                  walkFromIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>walkFromIndex matches packages in a module using the module index. modroot
is the module's root directory on disk, index is the modindex.Module for the
module, and importPathRoot is the module's path prefix.</p>
               
               <pre><code>func walkFromIndex(index *modindex.Module, importPathRoot string, isMatch func(string) bool, treeCanMatch func(string) bool, tags map[string]bool, have map[string]bool, addPkg func(string))</code></pre>
            </article>
            
            <article class="function" data-name="why">
               <h3>
                  why 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>why returns the text to use in "go mod why" output about the given package.
It is less ornate than the stackText but contains the same information.</p>
               
               <pre><code>func (pkg *loadPkg) why() string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
