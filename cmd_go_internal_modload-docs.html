<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>modload - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>modload</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"context"
"errors"
"fmt"
"go/build"
"io/fs"
"os"
pathpkg "path"
"path/filepath"
"sort"
"strings"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modindex"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/internal/par"
"golang.org/x/mod/module"
"context"
"errors"
"fmt"
"os"
"path/filepath"
"strings"
"sync"
"unicode"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/modfetch"
"cmd/go/internal/trace"
"cmd/internal/par"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"errors"
"fmt"
"io/fs"
"os"
"path/filepath"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/gover"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"context"
"errors"
"fmt"
"maps"
"os"
"runtime"
"runtime/debug"
"slices"
"strings"
"sync"
"sync/atomic"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/mvs"
"cmd/internal/par"
"golang.org/x/mod/module"
"cmd/go/internal/base"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"internal/godebugs"
"internal/lazyregexp"
"io"
"os"
"path"
"path/filepath"
"slices"
"strconv"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/modfetch"
"cmd/go/internal/search"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"os"
"runtime"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/modinfo"
"cmd/go/internal/search"
"cmd/internal/par"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/mvs"
"cmd/internal/par"
"context"
"errors"
"fmt"
"maps"
"os"
"slices"
"golang.org/x/mod/module"
"context"
"errors"
"os"
"sort"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modfetch/codehost"
"golang.org/x/mod/module"
"context"
"errors"
"fmt"
"io/fs"
"os"
"path"
"path/filepath"
"runtime"
"sort"
"strings"
"sync"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modindex"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/par"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
"io/fs"
"os"
"io/fs"
"os"
"syscall"
"io/fs"
"context"
"encoding/hex"
"errors"
"fmt"
"io/fs"
"os"
"path/filepath"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/modindex"
"cmd/go/internal/modinfo"
"cmd/go/internal/search"
"golang.org/x/mod/module"
"context"
"errors"
"fmt"
"go/build"
"internal/diff"
"io/fs"
"maps"
"os"
"path"
pathpkg "path"
"path/filepath"
"runtime"
"slices"
"sort"
"strings"
"sync"
"sync/atomic"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modfetch"
"cmd/go/internal/modindex"
"cmd/go/internal/mvs"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/internal/par"
"golang.org/x/mod/module"
"bytes"
"context"
"errors"
"fmt"
"io/fs"
"os"
pathpkg "path"
"slices"
"sort"
"strings"
"sync"
"time"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modfetch"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/modinfo"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AutoRoot" data-name="AutoRoot">
               <h3>
                  AutoRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AutoRoot" class="anchor" title="Link to AutoRoot">#</a>
               </h3>
               
                  <p class="doc-comment">AutoRoot is the default for most commands. modload.Init will look for
a go.mod file in the current directory or any parent. If none is found,
modules may be disabled (GO111MODULE=auto) or commands may run in a
limited module mode.</p>
               
               <pre><code class="language-go">const AutoRoot Root = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrDisallowed" data-name="ErrDisallowed">
               <h3>
                  ErrDisallowed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrDisallowed" class="anchor" title="Link to ErrDisallowed">#</a>
               </h3>
               
                  <p class="doc-comment">ErrDisallowed is returned by version predicates passed to Query and similar
functions to indicate that a version should not be considered.</p>
               
               <pre><code class="language-go">var ErrDisallowed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNoModRoot" data-name="ErrNoModRoot">
               <h3>
                  ErrNoModRoot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNoModRoot" class="anchor" title="Link to ErrNoModRoot">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrNoModRoot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ExplicitWriteGoMod" data-name="ExplicitWriteGoMod">
               <h3>
                  ExplicitWriteGoMod 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ExplicitWriteGoMod" class="anchor" title="Link to ExplicitWriteGoMod">#</a>
               </h3>
               
                  <p class="doc-comment">ExplicitWriteGoMod prevents LoadPackages, ListModules, and other functions
from updating go.mod and go.sum or reporting errors when updates are
needed. A package should set this if it would cause go.mod to be written
multiple times (for example, 'go get' calls LoadPackages multiple times) or
if it needs some other operation to be successful before go.mod and go.sum
can be written (for example, 'go mod download' must download modules before
adding sums to go.sum). Packages that set this are responsible for calling
WriteGoMod explicitly.</p>
               
               <pre><code class="language-go">var ExplicitWriteGoMod bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ForceUseModules" data-name="ForceUseModules">
               <h3>
                  ForceUseModules 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ForceUseModules" class="anchor" title="Link to ForceUseModules">#</a>
               </h3>
               
                  <p class="doc-comment">ForceUseModules may be set to force modules to be enabled when
GO111MODULE=auto or to report an error when GO111MODULE=off.</p>
               
               <pre><code class="language-go">var ForceUseModules bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HelpGoMod" data-name="HelpGoMod">
               <h3>
                  HelpGoMod 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HelpGoMod" class="anchor" title="Link to HelpGoMod">#</a>
               </h3>
               
               <pre><code class="language-go">var HelpGoMod = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HelpModules" data-name="HelpModules">
               <h3>
                  HelpModules 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HelpModules" class="anchor" title="Link to HelpModules">#</a>
               </h3>
               
               <pre><code class="language-go">var HelpModules = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ListDeprecated" data-name="ListDeprecated">
               <h3>
                  ListDeprecated 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ListDeprecated" class="anchor" title="Link to ListDeprecated">#</a>
               </h3>
               
               <pre><code class="language-go">const ListDeprecated</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ListRetracted" data-name="ListRetracted">
               <h3>
                  ListRetracted 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ListRetracted" class="anchor" title="Link to ListRetracted">#</a>
               </h3>
               
               <pre><code class="language-go">const ListRetracted</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ListRetractedVersions" data-name="ListRetractedVersions">
               <h3>
                  ListRetractedVersions 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ListRetractedVersions" class="anchor" title="Link to ListRetractedVersions">#</a>
               </h3>
               
               <pre><code class="language-go">const ListRetractedVersions</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ListU" data-name="ListU">
               <h3>
                  ListU 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ListU" class="anchor" title="Link to ListU">#</a>
               </h3>
               
               <pre><code class="language-go">const ListU ListMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ListVersions" data-name="ListVersions">
               <h3>
                  ListVersions 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ListVersions" class="anchor" title="Link to ListVersions">#</a>
               </h3>
               
               <pre><code class="language-go">const ListVersions</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MainModules" data-name="MainModules">
               <h3>
                  MainModules 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#MainModules" class="anchor" title="Link to MainModules">#</a>
               </h3>
               
               <pre><code class="language-go">var MainModules *MainModuleSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NeedRoot" data-name="NeedRoot">
               <h3>
                  NeedRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NeedRoot" class="anchor" title="Link to NeedRoot">#</a>
               </h3>
               
                  <p class="doc-comment">NeedRoot is used for commands that must run in module mode and don't
make sense without a main module.</p>
               
               <pre><code class="language-go">const NeedRoot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoRoot" data-name="NoRoot">
               <h3>
                  NoRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NoRoot" class="anchor" title="Link to NoRoot">#</a>
               </h3>
               
                  <p class="doc-comment">NoRoot is used for commands that run in module mode and ignore any go.mod
file the current directory or in parent directories.</p>
               
               <pre><code class="language-go">const NoRoot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RootMode" data-name="RootMode">
               <h3>
                  RootMode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#RootMode" class="anchor" title="Link to RootMode">#</a>
               </h3>
               
                  <p class="doc-comment">RootMode determines whether a module root is needed.</p>
               
               <pre><code class="language-go">var RootMode Root</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ versionRepo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ versionRepo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ versionRepo = emptyRepo{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="addBuildListZipSums" data-name="addBuildListZipSums">
               <h3>
                  addBuildListZipSums 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#addBuildListZipSums" class="anchor" title="Link to addBuildListZipSums">#</a>
               </h3>
               
               <pre><code class="language-go">const addBuildListZipSums</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allowMissingModuleImports" data-name="allowMissingModuleImports">
               <h3>
                  allowMissingModuleImports 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allowMissingModuleImports" class="anchor" title="Link to allowMissingModuleImports">#</a>
               </h3>
               
                  <p class="doc-comment">Variables set by other packages.
TODO(#40775): See if these can be plumbed as explicit parameters.</p>
               
               <pre><code class="language-go">var allowMissingModuleImports bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="altConfigs" data-name="altConfigs">
               <h3>
                  altConfigs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#altConfigs" class="anchor" title="Link to altConfigs">#</a>
               </h3>
               
               <pre><code class="language-go">var altConfigs = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errDirectoryNotFound" data-name="errDirectoryNotFound">
               <h3>
                  errDirectoryNotFound 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errDirectoryNotFound" class="anchor" title="Link to errDirectoryNotFound">#</a>
               </h3>
               
               <pre><code class="language-go">var errDirectoryNotFound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errExcluded" data-name="errExcluded">
               <h3>
                  errExcluded 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errExcluded" class="anchor" title="Link to errExcluded">#</a>
               </h3>
               
               <pre><code class="language-go">var errExcluded = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errGoModDirty" data-name="errGoModDirty">
               <h3>
                  errGoModDirty 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errGoModDirty" class="anchor" title="Link to errGoModDirty">#</a>
               </h3>
               
               <pre><code class="language-go">var errGoModDirty error = goModDirtyError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMissing" data-name="errMissing">
               <h3>
                  errMissing 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMissing" class="anchor" title="Link to errMissing">#</a>
               </h3>
               
               <pre><code class="language-go">var errMissing = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoChange" data-name="errNoChange">
               <h3>
                  errNoChange 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoChange" class="anchor" title="Link to errNoChange">#</a>
               </h3>
               
               <pre><code class="language-go">var errNoChange = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errPkgIsBuiltin" data-name="errPkgIsBuiltin">
               <h3>
                  errPkgIsBuiltin 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errPkgIsBuiltin" class="anchor" title="Link to errPkgIsBuiltin">#</a>
               </h3>
               
               <pre><code class="language-go">var errPkgIsBuiltin = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errPkgIsGorootSrc" data-name="errPkgIsGorootSrc">
               <h3>
                  errPkgIsGorootSrc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errPkgIsGorootSrc" class="anchor" title="Link to errPkgIsGorootSrc">#</a>
               </h3>
               
               <pre><code class="language-go">var errPkgIsGorootSrc = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errQueryDisabled" data-name="errQueryDisabled">
               <h3>
                  errQueryDisabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errQueryDisabled" class="anchor" title="Link to errQueryDisabled">#</a>
               </h3>
               
               <pre><code class="language-go">var errQueryDisabled error = queryDisabledError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errRevQuery" data-name="errRevQuery">
               <h3>
                  errRevQuery 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errRevQuery" class="anchor" title="Link to errRevQuery">#</a>
               </h3>
               
               <pre><code class="language-go">var errRevQuery = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gopath" data-name="gopath">
               <h3>
                  gopath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gopath" class="anchor" title="Link to gopath">#</a>
               </h3>
               
                  <p class="doc-comment">Variables set in Init.</p>
               
               <pre><code class="language-go">var gopath string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="haveGoFilesCache" data-name="haveGoFilesCache">
               <h3>
                  haveGoFilesCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#haveGoFilesCache" class="anchor" title="Link to haveGoFilesCache">#</a>
               </h3>
               
               <pre><code class="language-go">var haveGoFilesCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="haveGoModCache" data-name="haveGoModCache">
               <h3>
                  haveGoModCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#haveGoModCache" class="anchor" title="Link to haveGoModCache">#</a>
               </h3>
               
               <pre><code class="language-go">var haveGoModCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="importCommentRE" data-name="importCommentRE">
               <h3>
                  importCommentRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#importCommentRE" class="anchor" title="Link to importCommentRE">#</a>
               </h3>
               
               <pre><code class="language-go">var importCommentRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="includeStd" data-name="includeStd">
               <h3>
                  includeStd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#includeStd" class="anchor" title="Link to includeStd">#</a>
               </h3>
               
               <pre><code class="language-go">const includeStd</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="infoEnd" data-name="infoEnd">
               <h3>
                  infoEnd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#infoEnd" class="anchor" title="Link to infoEnd">#</a>
               </h3>
               
               <pre><code class="language-go">var infoEnd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="infoStart" data-name="infoStart">
               <h3>
                  infoStart 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#infoStart" class="anchor" title="Link to infoStart">#</a>
               </h3>
               
               <pre><code class="language-go">var infoStart = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initialized" data-name="initialized">
               <h3>
                  initialized 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initialized" class="anchor" title="Link to initialized">#</a>
               </h3>
               
                  <p class="doc-comment">Variables set in Init.</p>
               
               <pre><code class="language-go">var initialized bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="latestVersionIgnoringRetractionsCache" data-name="latestVersionIgnoringRetractionsCache">
               <h3>
                  latestVersionIgnoringRetractionsCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#latestVersionIgnoringRetractionsCache" class="anchor" title="Link to latestVersionIgnoringRetractionsCache">#</a>
               </h3>
               
               <pre><code class="language-go">var latestVersionIgnoringRetractionsCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="loaded" data-name="loaded">
               <h3>
                  loaded 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#loaded" class="anchor" title="Link to loaded">#</a>
               </h3>
               
                  <p class="doc-comment">loaded is the most recently-used package loader.
It holds details about individual packages.
This variable should only be accessed directly in top-level exported
functions. All other functions that require or produce a *loader should pass
or return it as an explicit parameter.</p>
               
               <pre><code class="language-go">var loaded *loader</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="loadedZipSumsOnly" data-name="loadedZipSumsOnly">
               <h3>
                  loadedZipSumsOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#loadedZipSumsOnly" class="anchor" title="Link to loadedZipSumsOnly">#</a>
               </h3>
               
               <pre><code class="language-go">const loadedZipSumsOnly = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modRoots" data-name="modRoots">
               <h3>
                  modRoots 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#modRoots" class="anchor" title="Link to modRoots">#</a>
               </h3>
               
                  <p class="doc-comment">These are primarily used to initialize the MainModules, and should be
eventually superseded by them but are still used in cases where the module
roots are required but MainModules hasn't been initialized yet. Set to
the modRoots of the main modules.
modRoots != nil implies len(modRoots) > 0</p>
               
               <pre><code class="language-go">var modRoots []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="omitStd" data-name="omitStd">
               <h3>
                  omitStd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#omitStd" class="anchor" title="Link to omitStd">#</a>
               </h3>
               
               <pre><code class="language-go">const omitStd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="omitToolchainRoot" data-name="omitToolchainRoot">
               <h3>
                  omitToolchainRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#omitToolchainRoot" class="anchor" title="Link to omitToolchainRoot">#</a>
               </h3>
               
               <pre><code class="language-go">const omitToolchainRoot addToolchainRoot = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pkgFromRoot" data-name="pkgFromRoot">
               <h3>
                  pkgFromRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pkgFromRoot" class="anchor" title="Link to pkgFromRoot">#</a>
               </h3>
               
                  <p class="doc-comment">pkgFromRoot indicates that the package is in the transitive closure of
imports starting at the roots. (Note that every package marked as pkgIsRoot
is also trivially marked pkgFromRoot.)</p>
               
               <pre><code class="language-go">const pkgFromRoot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pkgImportsLoaded" data-name="pkgImportsLoaded">
               <h3>
                  pkgImportsLoaded 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pkgImportsLoaded" class="anchor" title="Link to pkgImportsLoaded">#</a>
               </h3>
               
                  <p class="doc-comment">pkgImportsLoaded indicates that the imports and testImports fields of a
loadPkg have been populated.</p>
               
               <pre><code class="language-go">const pkgImportsLoaded</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pkgInAll" data-name="pkgInAll">
               <h3>
                  pkgInAll 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pkgInAll" class="anchor" title="Link to pkgInAll">#</a>
               </h3>
               
                  <p class="doc-comment">pkgInAll indicates that the package is in the "all" package pattern,
regardless of whether we are loading the "all" package pattern.
When the pkgInAll flag and pkgImportsLoaded flags are both set, the caller
who set the last of those flags must propagate the pkgInAll marking to all
of the imports of the marked package.
A test is marked with pkgInAll if that test would promote the packages it
imports to be in "all" (such as when the test is itself within the main
module, or when ld.allClosesOverTests is true).</p>
               
               <pre><code class="language-go">const pkgInAll loadPkgFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pkgIsRoot" data-name="pkgIsRoot">
               <h3>
                  pkgIsRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pkgIsRoot" class="anchor" title="Link to pkgIsRoot">#</a>
               </h3>
               
                  <p class="doc-comment">pkgIsRoot indicates that the package matches one of the root package
patterns requested by the caller.
If LoadTests is set, then when pkgIsRoot and pkgImportsLoaded are both set,
the caller who set the last of those flags must populate a test for the
package (in the pkg.test field).
If the "all" pattern is included as a root, then non-test packages in "all"
are also roots (and must be marked pkgIsRoot).</p>
               
               <pre><code class="language-go">const pkgIsRoot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pruned" data-name="pruned">
               <h3>
                  pruned 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pruned" class="anchor" title="Link to pruned">#</a>
               </h3>
               
               <pre><code class="language-go">const pruned modPruning = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rawGoModSummaryCache" data-name="rawGoModSummaryCache">
               <h3>
                  rawGoModSummaryCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#rawGoModSummaryCache" class="anchor" title="Link to rawGoModSummaryCache">#</a>
               </h3>
               
               <pre><code class="language-go">var rawGoModSummaryCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rawGoVersion" data-name="rawGoVersion">
               <h3>
                  rawGoVersion 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#rawGoVersion" class="anchor" title="Link to rawGoVersion">#</a>
               </h3>
               
                  <p class="doc-comment">rawGoVersion records the Go version parsed from each module's go.mod file.
If a module is replaced, the version of the replacement is keyed by the
replacement module.Version, not the version being replaced.</p>
               
               <pre><code class="language-go">var rawGoVersion sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="readModGraphDebugOnce" data-name="readModGraphDebugOnce">
               <h3>
                  readModGraphDebugOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#readModGraphDebugOnce" class="anchor" title="Link to readModGraphDebugOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var readModGraphDebugOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="requirements" data-name="requirements">
               <h3>
                  requirements 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#requirements" class="anchor" title="Link to requirements">#</a>
               </h3>
               
                  <p class="doc-comment">requirements is the requirement graph for the main module.
It is always non-nil if the main module's go.mod file has been loaded.
This variable should only be read from the loadModFile function, and should
only be written in the loadModFile and commitRequirements functions.
All other functions that need or produce a *Requirements should
accept and/or return an explicit parameter.</p>
               
               <pre><code class="language-go">var requirements *Requirements</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unpruned" data-name="unpruned">
               <h3>
                  unpruned 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unpruned" class="anchor" title="Link to unpruned">#</a>
               </h3>
               
               <pre><code class="language-go">const unpruned</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vendorList" data-name="vendorList">
               <h3>
                  vendorList 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vendorList" class="anchor" title="Link to vendorList">#</a>
               </h3>
               
               <pre><code class="language-go">var vendorList []module.Version</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vendorMeta" data-name="vendorMeta">
               <h3>
                  vendorMeta 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vendorMeta" class="anchor" title="Link to vendorMeta">#</a>
               </h3>
               
               <pre><code class="language-go">var vendorMeta map[module.Version]vendorMetadata</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vendorOnce" data-name="vendorOnce">
               <h3>
                  vendorOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vendorOnce" class="anchor" title="Link to vendorOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var vendorOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vendorPkgModule" data-name="vendorPkgModule">
               <h3>
                  vendorPkgModule 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vendorPkgModule" class="anchor" title="Link to vendorPkgModule">#</a>
               </h3>
               
               <pre><code class="language-go">var vendorPkgModule map[string]module.Version</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vendorReplaced" data-name="vendorReplaced">
               <h3>
                  vendorReplaced 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vendorReplaced" class="anchor" title="Link to vendorReplaced">#</a>
               </h3>
               
               <pre><code class="language-go">var vendorReplaced []module.Version</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vendorVersion" data-name="vendorVersion">
               <h3>
                  vendorVersion 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vendorVersion" class="anchor" title="Link to vendorVersion">#</a>
               </h3>
               
               <pre><code class="language-go">var vendorVersion map[string]string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="withToolchainRoot" data-name="withToolchainRoot">
               <h3>
                  withToolchainRoot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#withToolchainRoot" class="anchor" title="Link to withToolchainRoot">#</a>
               </h3>
               
               <pre><code class="language-go">const withToolchainRoot = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="workFilePath" data-name="workFilePath">
               <h3>
                  workFilePath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#workFilePath" class="anchor" title="Link to workFilePath">#</a>
               </h3>
               
                  <p class="doc-comment">Set to the path to the go.work file, or "" if workspace mode is disabled.</p>
               
               <pre><code class="language-go">var workFilePath string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="workspace" data-name="workspace">
               <h3>
                  workspace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#workspace" class="anchor" title="Link to workspace">#</a>
               </h3>
               
               <pre><code class="language-go">const workspace</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="AllowedFunc" data-name="AllowedFunc">
               <h3>
                  AllowedFunc
                  <span class="badge type-badge">type</span>
                  <a href="#AllowedFunc" class="anchor" title="Link to AllowedFunc">#</a>
               </h3>
               
               <p>AllowedFunc is used by Query and other functions to filter out unsuitable
versions, for example, those listed in exclude directives in the main
module's go.mod file.
An AllowedFunc returns an error equivalent to ErrDisallowed for an unsuitable
version. Any other error indicates the function was unable to determine
whether the version should be allowed, for example, the function was unable
to fetch or parse a go.mod file containing retractions. Typically, errors
other than ErrDisallowed may be ignored.</p>
               
               <pre><code class="language-go">type AllowedFunc func(context.Context, module.Version) error</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ListMode" data-name="ListMode">
               <h3>
                  ListMode
                  <span class="badge type-badge">type</span>
                  <a href="#ListMode" class="anchor" title="Link to ListMode">#</a>
               </h3>
               
               <pre><code class="language-go">type ListMode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Root" data-name="Root">
               <h3>
                  Root
                  <span class="badge type-badge">type</span>
                  <a href="#Root" class="anchor" title="Link to Root">#</a>
               </h3>
               
               <pre><code class="language-go">type Root int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="addToolchainRoot" data-name="addToolchainRoot">
               <h3>
                  addToolchainRoot
                  <span class="badge type-badge">type</span>
                  <a href="#addToolchainRoot" class="anchor" title="Link to addToolchainRoot">#</a>
               </h3>
               
               <pre><code class="language-go">type addToolchainRoot bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="loadPkgFlags" data-name="loadPkgFlags">
               <h3>
                  loadPkgFlags
                  <span class="badge type-badge">type</span>
                  <a href="#loadPkgFlags" class="anchor" title="Link to loadPkgFlags">#</a>
               </h3>
               
               <p>loadPkgFlags is a set of flags tracking metadata about a package.</p>
               
               <pre><code class="language-go">type loadPkgFlags int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="modPruning" data-name="modPruning">
               <h3>
                  modPruning
                  <span class="badge type-badge">type</span>
                  <a href="#modPruning" class="anchor" title="Link to modPruning">#</a>
               </h3>
               
               <p>A modPruning indicates whether transitive dependencies of Go 1.17 dependencies
are pruned out of the module subgraph rooted at a given module.
(See https://golang.org/ref/mod#graph-pruning.)</p>
               
               <pre><code class="language-go">type modPruning uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="stdFilter" data-name="stdFilter">
               <h3>
                  stdFilter
                  <span class="badge type-badge">type</span>
                  <a href="#stdFilter" class="anchor" title="Link to stdFilter">#</a>
               </h3>
               
               <pre><code class="language-go">type stdFilter int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="whichSums" data-name="whichSums">
               <h3>
                  whichSums
                  <span class="badge type-badge">type</span>
                  <a href="#whichSums" class="anchor" title="Link to whichSums">#</a>
               </h3>
               
               <pre><code class="language-go">type whichSums int8</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="versionRepo" data-name="versionRepo">
               <h3>
                  versionRepo
                  <span class="badge interface-badge">interface</span>
                  <a href="#versionRepo" class="anchor" title="Link to versionRepo">#</a>
               </h3>
               
               <p>A versionRepo is a subset of modfetch.Repo that can report information about
available versions, but cannot fetch specific source files.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type versionRepo interface {
ModulePath() string
CheckReuse(context.Context, *codehost.Origin) error
Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)
Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)
Latest(context.Context) (*modfetch.RevInfo, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="AmbiguousImportError" data-name="AmbiguousImportError">
               <h3>
                  AmbiguousImportError
                  <span class="badge">struct</span>
                  <a href="#AmbiguousImportError" class="anchor" title="Link to AmbiguousImportError">#</a>
               </h3>
               
               <p>An AmbiguousImportError indicates an import of a package found in multiple
modules in the build list, or found in both the main module and its vendor
directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type AmbiguousImportError struct {
importPath string
Dirs []string
Modules []module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Conflict" data-name="Conflict">
               <h3>
                  Conflict
                  <span class="badge">struct</span>
                  <a href="#Conflict" class="anchor" title="Link to Conflict">#</a>
               </h3>
               
               <p>A Conflict is a path of requirements starting at a root or proposed root in
the requirement graph, explaining why that root either causes a module passed
in the mustSelect list to EditBuildList to be unattainable, or introduces an
unresolvable error in loading the requirement graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Conflict struct {
Path []module.Version
Constraint module.Version
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ConstraintError" data-name="ConstraintError">
               <h3>
                  ConstraintError
                  <span class="badge">struct</span>
                  <a href="#ConstraintError" class="anchor" title="Link to ConstraintError">#</a>
               </h3>
               
               <p>A ConstraintError describes inconsistent constraints in EditBuildList</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ConstraintError struct {
Conflicts []Conflict
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DirectImportFromImplicitDependencyError" data-name="DirectImportFromImplicitDependencyError">
               <h3>
                  DirectImportFromImplicitDependencyError
                  <span class="badge">struct</span>
                  <a href="#DirectImportFromImplicitDependencyError" class="anchor" title="Link to DirectImportFromImplicitDependencyError">#</a>
               </h3>
               
               <p>A DirectImportFromImplicitDependencyError indicates a package directly
imported by a package or test in the main module that is satisfied by a
dependency that is not explicit in the main module's go.mod file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DirectImportFromImplicitDependencyError struct {
ImporterPath string
ImportedPath string
Module module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ImportMissingError" data-name="ImportMissingError">
               <h3>
                  ImportMissingError
                  <span class="badge">struct</span>
                  <a href="#ImportMissingError" class="anchor" title="Link to ImportMissingError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ImportMissingError struct {
Path string
Module module.Version
QueryErr error
ImportingMainModule module.Version
isStd bool
importerGoVersion string
replaced module.Version
newMissingVersion string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ImportMissingSumError" data-name="ImportMissingSumError">
               <h3>
                  ImportMissingSumError
                  <span class="badge">struct</span>
                  <a href="#ImportMissingSumError" class="anchor" title="Link to ImportMissingSumError">#</a>
               </h3>
               
               <p>ImportMissingSumError is reported in readonly mode when we need to check
if a module contains a package, but we don't have a sum for its .zip file.
We might need sums for multiple modules to verify the package is unique.
TODO(#43653): consolidate multiple errors of this type into a single error
that suggests a 'go get' command for root packages that transitively import
packages from modules with missing sums. load.CheckPackageErrors would be
a good place to consolidate errors, but we'll need to attach the import
stack here.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ImportMissingSumError struct {
importPath string
found bool
mods []module.Version
importer string
importerVersion string
importerIsTest bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MainModuleSet" data-name="MainModuleSet">
               <h3>
                  MainModuleSet
                  <span class="badge">struct</span>
                  <a href="#MainModuleSet" class="anchor" title="Link to MainModuleSet">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type MainModuleSet struct {
versions []module.Version
modRoot map[module.Version]string
pathPrefix map[module.Version]string
inGorootSrc map[module.Version]bool
modFiles map[module.Version]*modfile.File
tools map[string]bool
modContainingCWD module.Version
workFile *modfile.WorkFile
workFileReplaceMap map[module.Version]module.Version
highestReplaced map[string]string
indexMu sync.Mutex
indices map[module.Version]*modFileIndex
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ModuleGraph" data-name="ModuleGraph">
               <h3>
                  ModuleGraph
                  <span class="badge">struct</span>
                  <a href="#ModuleGraph" class="anchor" title="Link to ModuleGraph">#</a>
               </h3>
               
               <p>A ModuleGraph represents the complete graph of module dependencies
of a main module.
If the main module supports module graph pruning, the graph does not include
transitive dependencies of non-root (implicit) dependencies.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ModuleGraph struct {
g *mvs.Graph
loadCache *ast.IndexListExpr
buildListOnce sync.Once
buildList []module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ModuleRetractedError" data-name="ModuleRetractedError">
               <h3>
                  ModuleRetractedError
                  <span class="badge">struct</span>
                  <a href="#ModuleRetractedError" class="anchor" title="Link to ModuleRetractedError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ModuleRetractedError struct {
Rationale []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NoMatchingVersionError" data-name="NoMatchingVersionError">
               <h3>
                  NoMatchingVersionError
                  <span class="badge">struct</span>
                  <a href="#NoMatchingVersionError" class="anchor" title="Link to NoMatchingVersionError">#</a>
               </h3>
               
               <p>A NoMatchingVersionError indicates that Query found a module at the requested
path, but not at any versions satisfying the query string and allow-function.
NOTE: NoMatchingVersionError MUST NOT implement Is(fs.ErrNotExist).
If the module came from a proxy, that proxy had to return a successful status
code for the versions it knows about, and thus did not have the opportunity
to return a non-400 status code to suppress fallback.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type NoMatchingVersionError struct {
query string
current string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NoPatchBaseError" data-name="NoPatchBaseError">
               <h3>
                  NoPatchBaseError
                  <span class="badge">struct</span>
                  <a href="#NoPatchBaseError" class="anchor" title="Link to NoPatchBaseError">#</a>
               </h3>
               
               <p>A NoPatchBaseError indicates that Query was called with the query "patch"
but with a current version of "" or "none".</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type NoPatchBaseError struct {
path string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageNotInModuleError" data-name="PackageNotInModuleError">
               <h3>
                  PackageNotInModuleError
                  <span class="badge">struct</span>
                  <a href="#PackageNotInModuleError" class="anchor" title="Link to PackageNotInModuleError">#</a>
               </h3>
               
               <p>A PackageNotInModuleError indicates that QueryPattern found a candidate
module at the requested version, but that module did not contain any packages
matching the requested pattern.
NOTE: PackageNotInModuleError MUST NOT implement Is(fs.ErrNotExist).
If the module came from a proxy, that proxy had to return a successful status
code for the versions it knows about, and thus did not have the opportunity
to return a non-400 status code to suppress fallback.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackageNotInModuleError struct {
MainModules []module.Version
Mod module.Version
Replacement module.Version
Query string
Pattern string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageOpts" data-name="PackageOpts">
               <h3>
                  PackageOpts
                  <span class="badge">struct</span>
                  <a href="#PackageOpts" class="anchor" title="Link to PackageOpts">#</a>
               </h3>
               
               <p>PackageOpts control the behavior of the LoadPackages function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackageOpts struct {
TidyGoVersion string
Tags map[string]bool
Tidy bool
TidyDiff bool
TidyCompatibleVersion string
VendorModulesInGOROOTSrc bool
ResolveMissingImports bool
AssumeRootsImported bool
AllowPackage func(ctx context.Context, path string, mod module.Version) error
LoadTests bool
UseVendorAll bool
AllowErrors bool
SilencePackageErrors bool
SilenceMissingStdImports bool
SilenceNoGoErrors bool
SilenceUnmatchedWarnings bool
MainModule module.Version
Switcher gover.Switcher
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="QueryMatchesMainModulesError" data-name="QueryMatchesMainModulesError">
               <h3>
                  QueryMatchesMainModulesError
                  <span class="badge">struct</span>
                  <a href="#QueryMatchesMainModulesError" class="anchor" title="Link to QueryMatchesMainModulesError">#</a>
               </h3>
               
               <p>A QueryMatchesMainModulesError indicates that a query requests
a version of the main module that cannot be satisfied.
(The main module's version cannot be changed.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type QueryMatchesMainModulesError struct {
MainModules []module.Version
Pattern string
Query string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="QueryMatchesPackagesInMainModuleError" data-name="QueryMatchesPackagesInMainModuleError">
               <h3>
                  QueryMatchesPackagesInMainModuleError
                  <span class="badge">struct</span>
                  <a href="#QueryMatchesPackagesInMainModuleError" class="anchor" title="Link to QueryMatchesPackagesInMainModuleError">#</a>
               </h3>
               
               <p>A QueryMatchesPackagesInMainModuleError indicates that a query cannot be
satisfied because it matches one or more packages found in the main module.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type QueryMatchesPackagesInMainModuleError struct {
Pattern string
Query string
Packages []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="QueryResult" data-name="QueryResult">
               <h3>
                  QueryResult
                  <span class="badge">struct</span>
                  <a href="#QueryResult" class="anchor" title="Link to QueryResult">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type QueryResult struct {
Mod module.Version
Rev *modfetch.RevInfo
Packages []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="QueryUpgradesAllError" data-name="QueryUpgradesAllError">
               <h3>
                  QueryUpgradesAllError
                  <span class="badge">struct</span>
                  <a href="#QueryUpgradesAllError" class="anchor" title="Link to QueryUpgradesAllError">#</a>
               </h3>
               
               <p>A QueryUpgradesAllError indicates that a query requests
an upgrade on the all pattern.
(The main module's version cannot be changed.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type QueryUpgradesAllError struct {
MainModules []module.Version
Query string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Requirements" data-name="Requirements">
               <h3>
                  Requirements
                  <span class="badge">struct</span>
                  <a href="#Requirements" class="anchor" title="Link to Requirements">#</a>
               </h3>
               
               <p>A Requirements represents a logically-immutable set of root module requirements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Requirements struct {
pruning modPruning
rootModules []module.Version
maxRootVersion map[string]string
direct map[string]bool
graphOnce sync.Once
graph *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WildcardInFirstElementError" data-name="WildcardInFirstElementError">
               <h3>
                  WildcardInFirstElementError
                  <span class="badge">struct</span>
                  <a href="#WildcardInFirstElementError" class="anchor" title="Link to WildcardInFirstElementError">#</a>
               </h3>
               
               <p>A WildcardInFirstElementError indicates that a pattern passed to QueryPattern
had a wildcard in its first path element, and therefore had no pattern-prefix
modules to search in.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WildcardInFirstElementError struct {
Pattern string
Query string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WriteOpts" data-name="WriteOpts">
               <h3>
                  WriteOpts
                  <span class="badge">struct</span>
                  <a href="#WriteOpts" class="anchor" title="Link to WriteOpts">#</a>
               </h3>
               
               <p>WriteOpts control the behavior of WriteGoMod.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WriteOpts struct {
DropToolchain bool
ExplicitToolchain bool
AddTools []string
DropTools []string
TidyWroteGo bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="atomicLoadPkgFlags" data-name="atomicLoadPkgFlags">
               <h3>
                  atomicLoadPkgFlags
                  <span class="badge">struct</span>
                  <a href="#atomicLoadPkgFlags" class="anchor" title="Link to atomicLoadPkgFlags">#</a>
               </h3>
               
               <p>An atomicLoadPkgFlags stores a loadPkgFlags for which individual flags can be
added atomically.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type atomicLoadPkgFlags struct {
bits atomic.Int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cachedGraph" data-name="cachedGraph">
               <h3>
                  cachedGraph
                  <span class="badge">struct</span>
                  <a href="#cachedGraph" class="anchor" title="Link to cachedGraph">#</a>
               </h3>
               
               <p>A cachedGraph is a non-nil *ModuleGraph, together with any error discovered
while loading that graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cachedGraph struct {
mg *ModuleGraph
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dqState" data-name="dqState">
               <h3>
                  dqState
                  <span class="badge">struct</span>
                  <a href="#dqState" class="anchor" title="Link to dqState">#</a>
               </h3>
               
               <p>A dqState indicates whether and why a module version is “disqualified” from
being used in a way that would incorporate its requirements.
The zero dqState indicates that the module version is not known to be
disqualified, either because it is ok or because we are currently traversing
a cycle that includes it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dqState struct {
err error
dep module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dqTracker" data-name="dqTracker">
               <h3>
                  dqTracker
                  <span class="badge">struct</span>
                  <a href="#dqTracker" class="anchor" title="Link to dqTracker">#</a>
               </h3>
               
               <p>A dqTracker tracks and propagates the reason that each module version
cannot be included in the module graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dqTracker struct {
extendedRootPruning map[module.Version]modPruning
dqReason map[module.Version]*ast.IndexExpr
requiring map[module.Version][]module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="emptyRepo" data-name="emptyRepo">
               <h3>
                  emptyRepo
                  <span class="badge">struct</span>
                  <a href="#emptyRepo" class="anchor" title="Link to emptyRepo">#</a>
               </h3>
               
               <p>An emptyRepo is a versionRepo that contains no versions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type emptyRepo struct {
path string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="excludedError" data-name="excludedError">
               <h3>
                  excludedError
                  <span class="badge">struct</span>
                  <a href="#excludedError" class="anchor" title="Link to excludedError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type excludedError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="goModDirtyError" data-name="goModDirtyError">
               <h3>
                  goModDirtyError
                  <span class="badge">struct</span>
                  <a href="#goModDirtyError" class="anchor" title="Link to goModDirtyError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type goModDirtyError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="invalidImportError" data-name="invalidImportError">
               <h3>
                  invalidImportError
                  <span class="badge">struct</span>
                  <a href="#invalidImportError" class="anchor" title="Link to invalidImportError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type invalidImportError struct {
importPath string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="loadPkg" data-name="loadPkg">
               <h3>
                  loadPkg
                  <span class="badge">struct</span>
                  <a href="#loadPkg" class="anchor" title="Link to loadPkg">#</a>
               </h3>
               
               <p>A loadPkg records information about a single loaded package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type loadPkg struct {
path string
testOf *loadPkg
flags atomicLoadPkgFlags
mod module.Version
dir string
err error
imports []*loadPkg
testImports []string
inStd bool
altMods []module.Version
testOnce sync.Once
test *loadPkg
stack *loadPkg
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="loader" data-name="loader">
               <h3>
                  loader
                  <span class="badge">struct</span>
                  <a href="#loader" class="anchor" title="Link to loader">#</a>
               </h3>
               
               <p>A loader manages the process of loading information about
the required packages for a particular build,
checking that the packages are available in the module set,
and updating the module set if needed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type loader struct {
loaderParams
allClosesOverTests bool
skipImportModFiles bool
work *par.Queue
roots []*loadPkg
pkgCache **ast.IndexListExpr
pkgs []*loadPkg
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="loaderParams" data-name="loaderParams">
               <h3>
                  loaderParams
                  <span class="badge">struct</span>
                  <a href="#loaderParams" class="anchor" title="Link to loaderParams">#</a>
               </h3>
               
               <p>loaderParams configure the packages loaded by, and the properties reported
by, a loader instance.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type loaderParams struct {
PackageOpts
requirements *Requirements
allPatternIsRoot bool
listRoots func(rs *Requirements) []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="modFileIndex" data-name="modFileIndex">
               <h3>
                  modFileIndex
                  <span class="badge">struct</span>
                  <a href="#modFileIndex" class="anchor" title="Link to modFileIndex">#</a>
               </h3>
               
               <p>A modFileIndex is an index of data corresponding to a modFile
at a specific point in time.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type modFileIndex struct {
data []byte
dataNeedsFix bool
module module.Version
goVersion string
toolchain string
require map[module.Version]requireMeta
replace map[module.Version]module.Version
exclude map[module.Version]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="modFileSummary" data-name="modFileSummary">
               <h3>
                  modFileSummary
                  <span class="badge">struct</span>
                  <a href="#modFileSummary" class="anchor" title="Link to modFileSummary">#</a>
               </h3>
               
               <p>A modFileSummary is a summary of a go.mod file for which we do not need to
retain complete information — for example, the go.mod file of a dependency
module.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type modFileSummary struct {
module module.Version
goVersion string
toolchain string
pruning modPruning
require []module.Version
retract []retraction
deprecated string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mvsReqs" data-name="mvsReqs">
               <h3>
                  mvsReqs
                  <span class="badge">struct</span>
                  <a href="#mvsReqs" class="anchor" title="Link to mvsReqs">#</a>
               </h3>
               
               <p>mvsReqs implements mvs.Reqs for module semantic versions,
with any exclusions or replacements applied internally.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type mvsReqs struct {
roots []module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="perPruning" data-name="perPruning">
               <h3>
                  perPruning
                  <span class="badge">struct</span>
                  <a href="#perPruning" class="anchor" title="Link to perPruning">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type perPruning struct {
pruned T
unpruned T
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="queryDisabledError" data-name="queryDisabledError">
               <h3>
                  queryDisabledError
                  <span class="badge">struct</span>
                  <a href="#queryDisabledError" class="anchor" title="Link to queryDisabledError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type queryDisabledError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="queryMatcher" data-name="queryMatcher">
               <h3>
                  queryMatcher
                  <span class="badge">struct</span>
                  <a href="#queryMatcher" class="anchor" title="Link to queryMatcher">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type queryMatcher struct {
path string
prefix string
filter func(version string) bool
allowed AllowedFunc
canStat bool
preferLower bool
mayUseLatest bool
preferIncompatible bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="replacementRepo" data-name="replacementRepo">
               <h3>
                  replacementRepo
                  <span class="badge">struct</span>
                  <a href="#replacementRepo" class="anchor" title="Link to replacementRepo">#</a>
               </h3>
               
               <p>A replacementRepo augments a versionRepo to include the replacement versions
(if any) found in the main module's go.mod file.
A replacementRepo suppresses "not found" errors for otherwise-nonexistent
modules, so a replacementRepo should only be constructed for a module that
actually has one or more valid replacements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type replacementRepo struct {
repo versionRepo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="requireMeta" data-name="requireMeta">
               <h3>
                  requireMeta
                  <span class="badge">struct</span>
                  <a href="#requireMeta" class="anchor" title="Link to requireMeta">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type requireMeta struct {
indirect bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="retraction" data-name="retraction">
               <h3>
                  retraction
                  <span class="badge">struct</span>
                  <a href="#retraction" class="anchor" title="Link to retraction">#</a>
               </h3>
               
               <p>A retraction consists of a retracted version interval and rationale.
retraction is like modfile.Retract, but it doesn't point to the syntax tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type retraction struct {
modfile.VersionInterval
Rationale string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="retractionLoadingError" data-name="retractionLoadingError">
               <h3>
                  retractionLoadingError
                  <span class="badge">struct</span>
                  <a href="#retractionLoadingError" class="anchor" title="Link to retractionLoadingError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type retractionLoadingError struct {
m module.Version
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sumMissingError" data-name="sumMissingError">
               <h3>
                  sumMissingError
                  <span class="badge">struct</span>
                  <a href="#sumMissingError" class="anchor" title="Link to sumMissingError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sumMissingError struct {
suggestion string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="vendorMetadata" data-name="vendorMetadata">
               <h3>
                  vendorMetadata
                  <span class="badge">struct</span>
                  <a href="#vendorMetadata" class="anchor" title="Link to vendorMetadata">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type vendorMetadata struct {
Explicit bool
Replacement module.Version
GoVersion string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AllowMissingModuleImports" data-name="AllowMissingModuleImports">
               <h3>
                  AllowMissingModuleImports 
                  <span class="badge">function</span>
                  
                  <a href="#AllowMissingModuleImports" class="anchor" title="Link to AllowMissingModuleImports">#</a>
               </h3>
               
               <p>AllowMissingModuleImports allows import paths to be resolved to modules
when there is no module root. Normally, this is forbidden because it's slow
and there's no way to make the result reproducible, but some commands
like 'go get' are expected to do this.
This function affects the default cfg.BuildMod when outside of a module,
so it can only be called prior to Init.</p>
               
               <pre><code class="language-go">func AllowMissingModuleImports()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BinDir" data-name="BinDir">
               <h3>
                  BinDir 
                  <span class="badge">function</span>
                  
                  <a href="#BinDir" class="anchor" title="Link to BinDir">#</a>
               </h3>
               
               <pre><code class="language-go">func BinDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildList" data-name="BuildList">
               <h3>
                  BuildList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BuildList" class="anchor" title="Link to BuildList">#</a>
               </h3>
               
               <p>BuildList returns the selected versions of all modules present in the graph,
beginning with the main modules.
The order of the remaining elements in the list is deterministic
but arbitrary.
The caller must not modify the returned list, but may safely append to it
and may rely on it not to be modified.</p>
               
               <pre><code class="language-go">func (mg *ModuleGraph) BuildList() []module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckAllowed" data-name="CheckAllowed">
               <h3>
                  CheckAllowed 
                  <span class="badge">function</span>
                  
                  <a href="#CheckAllowed" class="anchor" title="Link to CheckAllowed">#</a>
               </h3>
               
               <p>CheckAllowed returns an error equivalent to ErrDisallowed if m is excluded by
the main module's go.mod or retracted by its author. Most version queries use
this to filter out versions that should not be used.</p>
               
               <pre><code class="language-go">func CheckAllowed(ctx context.Context, m module.Version) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckDeprecation" data-name="CheckDeprecation">
               <h3>
                  CheckDeprecation 
                  <span class="badge">function</span>
                  
                  <a href="#CheckDeprecation" class="anchor" title="Link to CheckDeprecation">#</a>
               </h3>
               
               <p>CheckDeprecation returns a deprecation message from the go.mod file of the
latest version of the given module. Deprecation messages are comments
before or on the same line as the module directives that start with
"Deprecated:" and run until the end of the paragraph.
CheckDeprecation returns an error if the message can't be loaded.
CheckDeprecation returns "", nil if there is no deprecation message.</p>
               
               <pre><code class="language-go">func CheckDeprecation(ctx context.Context, m module.Version) (deprecation string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckExclusions" data-name="CheckExclusions">
               <h3>
                  CheckExclusions 
                  <span class="badge">function</span>
                  
                  <a href="#CheckExclusions" class="anchor" title="Link to CheckExclusions">#</a>
               </h3>
               
               <p>CheckExclusions returns an error equivalent to ErrDisallowed if module m is
excluded by the main module's go.mod file.</p>
               
               <pre><code class="language-go">func CheckExclusions(ctx context.Context, m module.Version) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckGodebug" data-name="CheckGodebug">
               <h3>
                  CheckGodebug 
                  <span class="badge">function</span>
                  
                  <a href="#CheckGodebug" class="anchor" title="Link to CheckGodebug">#</a>
               </h3>
               
               <pre><code class="language-go">func CheckGodebug(verb string, k string, v string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckRetractions" data-name="CheckRetractions">
               <h3>
                  CheckRetractions 
                  <span class="badge">function</span>
                  
                  <a href="#CheckRetractions" class="anchor" title="Link to CheckRetractions">#</a>
               </h3>
               
               <p>CheckRetractions returns an error if module m has been retracted by
its author.</p>
               
               <pre><code class="language-go">func CheckRetractions(ctx context.Context, m module.Version) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (rr *replacementRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (er emptyRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Contains" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Contains" class="anchor" title="Link to Contains">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Contains(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateModFile" data-name="CreateModFile">
               <h3>
                  CreateModFile 
                  <span class="badge">function</span>
                  
                  <a href="#CreateModFile" class="anchor" title="Link to CreateModFile">#</a>
               </h3>
               
               <p>CreateModFile initializes a new module by creating a go.mod file.
If modPath is empty, CreateModFile will attempt to infer the path from the
directory location within GOPATH.
If a vendoring configuration file is present, CreateModFile will attempt to
translate it to go.mod directives. The resulting build list may not be
exactly the same as in the legacy configuration (for example, we can't get
packages at multiple versions from the same module).</p>
               
               <pre><code class="language-go">func CreateModFile(ctx context.Context, modPath string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DirImportPath" data-name="DirImportPath">
               <h3>
                  DirImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DirImportPath" class="anchor" title="Link to DirImportPath">#</a>
               </h3>
               
               <p>DirImportPath returns the effective import path for dir,
provided it is within a main module, or else returns ".".</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) DirImportPath(ctx context.Context, dir string) (path string, m module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EditBuildList" data-name="EditBuildList">
               <h3>
                  EditBuildList 
                  <span class="badge">function</span>
                  
                  <a href="#EditBuildList" class="anchor" title="Link to EditBuildList">#</a>
               </h3>
               
               <p>EditBuildList edits the global build list by first adding every module in add
to the existing build list, then adjusting versions (and adding or removing
requirements as needed) until every module in mustSelect is selected at the
given version.
(Note that the newly-added modules might not be selected in the resulting
build list: they could be lower than existing requirements or conflict with
versions in mustSelect.)
If the versions listed in mustSelect are mutually incompatible (due to one of
the listed modules requiring a higher version of another), EditBuildList
returns a *ConstraintError and leaves the build list in its previous state.
On success, EditBuildList reports whether the selected version of any module
in the build list may have been changed (possibly to or from "none") as a
result.</p>
               
               <pre><code class="language-go">func EditBuildList(ctx context.Context, add []module.Version, mustSelect []module.Version) (changed bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Enabled" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge">function</span>
                  
                  <a href="#Enabled" class="anchor" title="Link to Enabled">#</a>
               </h3>
               
               <p>Enabled reports whether modules are (or must be) enabled.
If modules are enabled but there is no main module, Enabled returns true
and then the first use of module information will call die
(usually through MustModRoot).</p>
               
               <pre><code class="language-go">func Enabled() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnterModule" data-name="EnterModule">
               <h3>
                  EnterModule 
                  <span class="badge">function</span>
                  
                  <a href="#EnterModule" class="anchor" title="Link to EnterModule">#</a>
               </h3>
               
               <p>EnterModule resets MainModules and requirements to refer to just this one module.</p>
               
               <pre><code class="language-go">func EnterModule(ctx context.Context, enterModroot string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ModuleRetractedError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *DirectImportFromImplicitDependencyError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *sumMissingError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *WildcardInFirstElementError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *PackageNotInModuleError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *QueryUpgradesAllError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (queryDisabledError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *invalidImportError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ConstraintError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *excludedError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *NoPatchBaseError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ImportMissingError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *QueryMatchesMainModulesError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *AmbiguousImportError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *QueryMatchesPackagesInMainModuleError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *NoMatchingVersionError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *retractionLoadingError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ImportMissingSumError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (goModDirtyError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FindGoMod" data-name="FindGoMod">
               <h3>
                  FindGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#FindGoMod" class="anchor" title="Link to FindGoMod">#</a>
               </h3>
               
               <p>FindGoMod returns the name of the go.mod file for this command,
or the empty string if there isn't one.
Most code should use Init and Enabled rather than use this directly.
It is exported mainly for Go toolchain switching, which must process
the go.mod very early at startup.</p>
               
               <pre><code class="language-go">func FindGoMod(wd string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FindGoWork" data-name="FindGoWork">
               <h3>
                  FindGoWork 
                  <span class="badge">function</span>
                  
                  <a href="#FindGoWork" class="anchor" title="Link to FindGoWork">#</a>
               </h3>
               
               <p>FindGoWork returns the name of the go.work file for this command,
or the empty string if there isn't one.
Most code should use Init and Enabled rather than use this directly.
It is exported mainly for Go toolchain switching, which must process
the go.work very early at startup.</p>
               
               <pre><code class="language-go">func FindGoWork(wd string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetSingleIndexOrNil" data-name="GetSingleIndexOrNil">
               <h3>
                  GetSingleIndexOrNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetSingleIndexOrNil" class="anchor" title="Link to GetSingleIndexOrNil">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) GetSingleIndexOrNil() *modFileIndex</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoVersion" data-name="GoVersion">
               <h3>
                  GoVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoVersion" class="anchor" title="Link to GoVersion">#</a>
               </h3>
               
               <p>GoVersion returns the Go language version for the Requirements.</p>
               
               <pre><code class="language-go">func (rs *Requirements) GoVersion() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoVersion" data-name="GoVersion">
               <h3>
                  GoVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoVersion" class="anchor" title="Link to GoVersion">#</a>
               </h3>
               
               <p>GoVersion returns the go version set on the single module, in module mode,
or the go.work file in workspace mode.</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) GoVersion() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Godebugs" data-name="Godebugs">
               <h3>
                  Godebugs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Godebugs" class="anchor" title="Link to Godebugs">#</a>
               </h3>
               
               <p>Godebugs returns the godebug lines set on the single module, in module mode,
or on the go.work file in workspace mode.
The caller must not modify the result.</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Godebugs() []*modfile.Godebug</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Graph" data-name="Graph">
               <h3>
                  Graph 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Graph" class="anchor" title="Link to Graph">#</a>
               </h3>
               
               <p>Graph returns the graph of module requirements loaded from the current
root modules (as reported by RootModules).
Graph always makes a best effort to load the requirement graph despite any
errors, and always returns a non-nil *ModuleGraph.
If the requirements of any relevant module fail to load, Graph also
returns a non-nil error of type *mvs.BuildListError.</p>
               
               <pre><code class="language-go">func (rs *Requirements) Graph(ctx context.Context) (*ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasModRoot" data-name="HasModRoot">
               <h3>
                  HasModRoot 
                  <span class="badge">function</span>
                  
                  <a href="#HasModRoot" class="anchor" title="Link to HasModRoot">#</a>
               </h3>
               
               <p>HasModRoot reports whether a main module is present.
HasModRoot may return false even if Enabled returns true: for example, 'get'
does not require a main module.</p>
               
               <pre><code class="language-go">func HasModRoot() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HighestReplaced" data-name="HighestReplaced">
               <h3>
                  HighestReplaced 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HighestReplaced" class="anchor" title="Link to HighestReplaced">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) HighestReplaced() map[string]string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportFromFiles" data-name="ImportFromFiles">
               <h3>
                  ImportFromFiles 
                  <span class="badge">function</span>
                  
                  <a href="#ImportFromFiles" class="anchor" title="Link to ImportFromFiles">#</a>
               </h3>
               
               <p>ImportFromFiles adds modules to the build list as needed
to satisfy the imports in the named Go source files.
Errors in missing dependencies are silenced.
TODO(bcmills): Silencing errors seems off. Take a closer look at this and
figure out what the error-reporting actually ought to be.</p>
               
               <pre><code class="language-go">func ImportFromFiles(ctx context.Context, gofiles []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *PackageNotInModuleError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ImportMissingError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *AmbiguousImportError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *DirectImportFromImplicitDependencyError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ImportMissingSumError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *invalidImportError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InGorootSrc" data-name="InGorootSrc">
               <h3>
                  InGorootSrc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InGorootSrc" class="anchor" title="Link to InGorootSrc">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) InGorootSrc(m module.Version) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Index" data-name="Index">
               <h3>
                  Index 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Index" class="anchor" title="Link to Index">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Index(m module.Version) *modFileIndex</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge">function</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>Init determines whether module mode is enabled, locates the root of the
current module (if any), sets environment variables for Git subprocesses, and
configures the cfg, codehost, load, modfetch, and search packages for use
with modules.</p>
               
               <pre><code class="language-go">func Init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitWorkfile" data-name="InitWorkfile">
               <h3>
                  InitWorkfile 
                  <span class="badge">function</span>
                  
                  <a href="#InitWorkfile" class="anchor" title="Link to InitWorkfile">#</a>
               </h3>
               
               <p>InitWorkfile initializes the workFilePath variable for commands that
operate in workspace mode. It should not be called by other commands,
for example 'go mod tidy', that don't operate in workspace mode.</p>
               
               <pre><code class="language-go">func InitWorkfile()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ModuleRetractedError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *excludedError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDirect" data-name="IsDirect">
               <h3>
                  IsDirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDirect" class="anchor" title="Link to IsDirect">#</a>
               </h3>
               
               <p>IsDirect returns whether the given module provides a package directly
imported by a package or test in the main module.</p>
               
               <pre><code class="language-go">func (rs *Requirements) IsDirect(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsRevisionQuery" data-name="IsRevisionQuery">
               <h3>
                  IsRevisionQuery 
                  <span class="badge">function</span>
                  
                  <a href="#IsRevisionQuery" class="anchor" title="Link to IsRevisionQuery">#</a>
               </h3>
               
               <p>IsRevisionQuery returns true if vers is a version query that may refer to
a particular version or revision in a repository like "v1.0.0", "master",
or "0123abcd". IsRevisionQuery returns false if vers is a query that
chooses from among available versions like "latest" or ">v1.0.0".</p>
               
               <pre><code class="language-go">func IsRevisionQuery(path string, vers string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (er emptyRepo) Latest(ctx context.Context) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (rr *replacementRepo) Latest(ctx context.Context) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ListModules" data-name="ListModules">
               <h3>
                  ListModules 
                  <span class="badge">function</span>
                  
                  <a href="#ListModules" class="anchor" title="Link to ListModules">#</a>
               </h3>
               
               <p>ListModules returns a description of the modules matching args, if known,
along with any error preventing additional matches from being identified.
The returned slice can be nonempty even if the error is non-nil.</p>
               
               <pre><code class="language-go">func ListModules(ctx context.Context, args []string, mode ListMode, reuseFile string) ([]*modinfo.ModulePublic, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadModFile" data-name="LoadModFile">
               <h3>
                  LoadModFile 
                  <span class="badge">function</span>
                  
                  <a href="#LoadModFile" class="anchor" title="Link to LoadModFile">#</a>
               </h3>
               
               <p>LoadModFile sets Target and, if there is a main module, parses the initial
build list from its go.mod file.
LoadModFile may make changes in memory, like adding a go directive and
ensuring requirements are consistent. The caller is responsible for ensuring
those changes are written to disk by calling LoadPackages or ListModules
(unless ExplicitWriteGoMod is set) or by calling WriteGoMod directly.
As a side-effect, LoadModFile may change cfg.BuildMod to "vendor" if
-mod wasn't set explicitly and automatic vendoring should be enabled.
If LoadModFile or CreateModFile has already been called, LoadModFile returns
the existing in-memory requirements (rather than re-reading them from disk).
LoadModFile checks the roots of the module graph for consistency with each
other, but unlike LoadModGraph does not load the full module graph or check
it for global consistency. Most callers outside of the modload package should
use LoadModGraph instead.</p>
               
               <pre><code class="language-go">func LoadModFile(ctx context.Context) *Requirements</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadModGraph" data-name="LoadModGraph">
               <h3>
                  LoadModGraph 
                  <span class="badge">function</span>
                  
                  <a href="#LoadModGraph" class="anchor" title="Link to LoadModGraph">#</a>
               </h3>
               
               <p>LoadModGraph loads and returns the graph of module dependencies of the main module,
without loading any packages.
If the goVersion string is non-empty, the returned graph is the graph
as interpreted by the given Go version (instead of the version indicated
in the go.mod file).
Modules are loaded automatically (and lazily) in LoadPackages:
LoadModGraph need only be called if LoadPackages is not,
typically in commands that care about modules but no particular package.</p>
               
               <pre><code class="language-go">func LoadModGraph(ctx context.Context, goVersion string) (*ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadPackages" data-name="LoadPackages">
               <h3>
                  LoadPackages 
                  <span class="badge">function</span>
                  
                  <a href="#LoadPackages" class="anchor" title="Link to LoadPackages">#</a>
               </h3>
               
               <p>LoadPackages identifies the set of packages matching the given patterns and
loads the packages in the import graph rooted at that set.</p>
               
               <pre><code class="language-go">func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (matches []*search.Match, loadedPackages []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup returns the source directory, import path, and any loading error for
the package at path as imported from the package in parentDir.
Lookup requires that one of the Load functions in this package has already
been called.</p>
               
               <pre><code class="language-go">func Lookup(parentPath string, parentIsStd bool, path string) (dir string, realPath string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchInModule" data-name="MatchInModule">
               <h3>
                  MatchInModule 
                  <span class="badge">function</span>
                  
                  <a href="#MatchInModule" class="anchor" title="Link to MatchInModule">#</a>
               </h3>
               
               <p>MatchInModule identifies the packages matching the given pattern within the
given module version, which does not need to be in the build list or module
requirement graph.
If m is the zero module.Version, MatchInModule matches the pattern
against the standard library (std and cmd) in GOROOT/src.</p>
               
               <pre><code class="language-go">func MatchInModule(ctx context.Context, pattern string, m module.Version, tags map[string]bool) *search.Match</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Max" data-name="Max">
               <h3>
                  Max 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Max" class="anchor" title="Link to Max">#</a>
               </h3>
               
               <p>Max returns the maximum of v1 and v2 according to gover.ModCompare.
As a special case, the version "" is considered higher than all other
versions. The main module (also known as the target) has no version and must
be chosen over other versions of the same module in the module dependency
graph.</p>
               
               <pre><code class="language-go">func (*mvsReqs) Max(p string, v1 string, v2 string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModContainingCWD" data-name="ModContainingCWD">
               <h3>
                  ModContainingCWD 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModContainingCWD" class="anchor" title="Link to ModContainingCWD">#</a>
               </h3>
               
               <p>ModContainingCWD returns the main module containing the working directory,
or module.Version{} if none of the main modules contain the working
directory.</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) ModContainingCWD() module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModFile" data-name="ModFile">
               <h3>
                  ModFile 
                  <span class="badge">function</span>
                  
                  <a href="#ModFile" class="anchor" title="Link to ModFile">#</a>
               </h3>
               
               <p>ModFile returns the parsed go.mod file.
Note that after calling LoadPackages or LoadModGraph,
the require statements in the modfile.File are no longer
the source of truth and will be ignored: edits made directly
will be lost at the next call to WriteGoMod.
To make permanent changes to the require statements
in go.mod, edit it before loading.</p>
               
               <pre><code class="language-go">func ModFile() *modfile.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModFile" data-name="ModFile">
               <h3>
                  ModFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModFile" class="anchor" title="Link to ModFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) ModFile(m module.Version) *modfile.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModFilePath" data-name="ModFilePath">
               <h3>
                  ModFilePath 
                  <span class="badge">function</span>
                  
                  <a href="#ModFilePath" class="anchor" title="Link to ModFilePath">#</a>
               </h3>
               
               <p>ModFilePath returns the path that would be used for the go.mod
file, if in module mode. ModFilePath calls base.Fatalf if there is no main
module, even if -modfile is set.</p>
               
               <pre><code class="language-go">func ModFilePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModInfoData" data-name="ModInfoData">
               <h3>
                  ModInfoData 
                  <span class="badge">function</span>
                  
                  <a href="#ModInfoData" class="anchor" title="Link to ModInfoData">#</a>
               </h3>
               
               <pre><code class="language-go">func ModInfoData(info string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModInfoProg" data-name="ModInfoProg">
               <h3>
                  ModInfoProg 
                  <span class="badge">function</span>
                  
                  <a href="#ModInfoProg" class="anchor" title="Link to ModInfoProg">#</a>
               </h3>
               
               <pre><code class="language-go">func ModInfoProg(info string, isgccgo bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModRoot" data-name="ModRoot">
               <h3>
                  ModRoot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModRoot" class="anchor" title="Link to ModRoot">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) ModRoot(m module.Version) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModuleInfo" data-name="ModuleInfo">
               <h3>
                  ModuleInfo 
                  <span class="badge">function</span>
                  
                  <a href="#ModuleInfo" class="anchor" title="Link to ModuleInfo">#</a>
               </h3>
               
               <pre><code class="language-go">func ModuleInfo(ctx context.Context, path string) *modinfo.ModulePublic</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (rr *replacementRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (er emptyRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MustHaveModRoot" data-name="MustHaveModRoot">
               <h3>
                  MustHaveModRoot 
                  <span class="badge">function</span>
                  
                  <a href="#MustHaveModRoot" class="anchor" title="Link to MustHaveModRoot">#</a>
               </h3>
               
               <p>MustHaveModRoot checks that a main module or main modules are present,
and calls base.Fatalf if there are no main modules.</p>
               
               <pre><code class="language-go">func MustHaveModRoot()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverrideRoots" data-name="OverrideRoots">
               <h3>
                  OverrideRoots 
                  <span class="badge">function</span>
                  
                  <a href="#OverrideRoots" class="anchor" title="Link to OverrideRoots">#</a>
               </h3>
               
               <p>OverrideRoots edits the global requirement roots by replacing the specific module versions.</p>
               
               <pre><code class="language-go">func OverrideRoots(ctx context.Context, replace []module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackageModRoot" data-name="PackageModRoot">
               <h3>
                  PackageModRoot 
                  <span class="badge">function</span>
                  
                  <a href="#PackageModRoot" class="anchor" title="Link to PackageModRoot">#</a>
               </h3>
               
               <p>PackageModRoot returns the module root directory for the module that provides
a given package. If modules are not enabled or if the package is in the
standard library or if the package was not successfully loaded with
LoadPackages or ImportFromFiles, the empty string is returned.</p>
               
               <pre><code class="language-go">func PackageModRoot(ctx context.Context, pkgpath string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackageModule" data-name="PackageModule">
               <h3>
                  PackageModule 
                  <span class="badge">function</span>
                  
                  <a href="#PackageModule" class="anchor" title="Link to PackageModule">#</a>
               </h3>
               
               <p>PackageModule returns the module providing the package named by the import path.</p>
               
               <pre><code class="language-go">func PackageModule(path string) module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackageModuleInfo" data-name="PackageModuleInfo">
               <h3>
                  PackageModuleInfo 
                  <span class="badge">function</span>
                  
                  <a href="#PackageModuleInfo" class="anchor" title="Link to PackageModuleInfo">#</a>
               </h3>
               
               <p>PackageModuleInfo returns information about the module that provides
a given package. If modules are not enabled or if the package is in the
standard library or if the package was not successfully loaded with
LoadPackages or ImportFromFiles, nil is returned.</p>
               
               <pre><code class="language-go">func PackageModuleInfo(ctx context.Context, pkgpath string) *modinfo.ModulePublic</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PathPrefix" data-name="PathPrefix">
               <h3>
                  PathPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PathPrefix" class="anchor" title="Link to PathPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) PathPrefix(m module.Version) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Previous" data-name="Previous">
               <h3>
                  Previous 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Previous" class="anchor" title="Link to Previous">#</a>
               </h3>
               
               <pre><code class="language-go">func (*mvsReqs) Previous(m module.Version) (module.Version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Query" data-name="Query">
               <h3>
                  Query 
                  <span class="badge">function</span>
                  
                  <a href="#Query" class="anchor" title="Link to Query">#</a>
               </h3>
               
               <p>Query looks up a revision of a given module given a version query string.
The module must be a complete module path.
The version must take one of the following forms:
- the literal string "latest", denoting the latest available, allowed
tagged version, with non-prereleases preferred over prereleases.
If there are no tagged versions in the repo, latest returns the most
recent commit.
- the literal string "upgrade", equivalent to "latest" except that if
current is a newer version, current will be returned (see below).
- the literal string "patch", denoting the latest available tagged version
with the same major and minor number as current (see below).
- v1, denoting the latest available tagged version v1.x.x.
- v1.2, denoting the latest available tagged version v1.2.x.
- v1.2.3, a semantic version string denoting that tagged version.
- <v1.2.3, <=v1.2.3, >v1.2.3, >=v1.2.3,
denoting the version closest to the target and satisfying the given operator,
with non-prereleases preferred over prereleases.
- a repository commit identifier or tag, denoting that commit.
current denotes the currently-selected version of the module; it may be
"none" if no version is currently selected, or "" if the currently-selected
version is unknown or should not be considered. If query is
"upgrade" or "patch", current will be returned if it is a newer
semantic version or a chronologically later pseudo-version than the
version that would otherwise be chosen. This prevents accidental downgrades
from newer pre-release or development versions.
The allowed function (which may be nil) is used to filter out unsuitable
versions (see AllowedFunc documentation for details). If the query refers to
a specific revision (for example, "master"; see IsRevisionQuery), and the
revision is disallowed by allowed, Query returns the error. If the query
does not refer to a specific revision (for example, "latest"), Query
acts as if versions disallowed by allowed do not exist.
If path is the path of the main module and the query is "latest",
Query returns Target.Version as the version.
Query often returns a non-nil *RevInfo with a non-nil error,
to provide an info.Origin that can allow the error to be cached.</p>
               
               <pre><code class="language-go">func Query(ctx context.Context, path string, query string, current string, allowed AllowedFunc) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="QueryPackages" data-name="QueryPackages">
               <h3>
                  QueryPackages 
                  <span class="badge">function</span>
                  
                  <a href="#QueryPackages" class="anchor" title="Link to QueryPackages">#</a>
               </h3>
               
               <p>QueryPackages is like QueryPattern, but requires that the pattern match at
least one package and omits the non-package result (if any).</p>
               
               <pre><code class="language-go">func QueryPackages(ctx context.Context, pattern string, query string, current func(string) string, allowed AllowedFunc) ([]QueryResult, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="QueryPattern" data-name="QueryPattern">
               <h3>
                  QueryPattern 
                  <span class="badge">function</span>
                  
                  <a href="#QueryPattern" class="anchor" title="Link to QueryPattern">#</a>
               </h3>
               
               <p>QueryPattern looks up the module(s) containing at least one package matching
the given pattern at the given version. The results are sorted by module path
length in descending order. If any proxy provides a non-empty set of candidate
modules, no further proxies are tried.
For wildcard patterns, QueryPattern looks in modules with package paths up to
the first "..." in the pattern. For the pattern "example.com/a/b.../c",
QueryPattern would consider prefixes of "example.com/a".
If any matching package is in the main module, QueryPattern considers only
the main module and only the version "latest", without checking for other
possible modules.
QueryPattern always returns at least one QueryResult (which may be only
modOnly) or a non-nil error.</p>
               
               <pre><code class="language-go">func QueryPattern(ctx context.Context, pattern string, query string, current func(string) string, allowed AllowedFunc) (pkgMods []QueryResult, modOnly *QueryResult, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadModFile" data-name="ReadModFile">
               <h3>
                  ReadModFile 
                  <span class="badge">function</span>
                  
                  <a href="#ReadModFile" class="anchor" title="Link to ReadModFile">#</a>
               </h3>
               
               <p>ReadModFile reads and parses the mod file at gomod. ReadModFile properly applies the
overlay, locks the file while reading, and applies fix, if applicable.</p>
               
               <pre><code class="language-go">func ReadModFile(gomod string, fix modfile.VersionFixer) (data []byte, f *modfile.File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadWorkFile" data-name="ReadWorkFile">
               <h3>
                  ReadWorkFile 
                  <span class="badge">function</span>
                  
                  <a href="#ReadWorkFile" class="anchor" title="Link to ReadWorkFile">#</a>
               </h3>
               
               <p>ReadWorkFile reads and parses the go.work file at the given path.</p>
               
               <pre><code class="language-go">func ReadWorkFile(path string) (*modfile.WorkFile, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Replacement" data-name="Replacement">
               <h3>
                  Replacement 
                  <span class="badge">function</span>
                  
                  <a href="#Replacement" class="anchor" title="Link to Replacement">#</a>
               </h3>
               
               <p>Replacement returns the replacement for mod, if any. If the path in the
module.Version is relative it's relative to the single main module outside
workspace mode, or the workspace's directory in workspace mode.</p>
               
               <pre><code class="language-go">func Replacement(mod module.Version) module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Required" data-name="Required">
               <h3>
                  Required 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Required" class="anchor" title="Link to Required">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RequiredBy" data-name="RequiredBy">
               <h3>
                  RequiredBy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RequiredBy" class="anchor" title="Link to RequiredBy">#</a>
               </h3>
               
               <p>RequiredBy returns the dependencies required by module m in the graph,
or ok=false if module m's dependencies are pruned out.
The caller must not modify the returned slice, but may safely append to it
and may rely on it not to be modified.</p>
               
               <pre><code class="language-go">func (mg *ModuleGraph) RequiredBy(m module.Version) (reqs []module.Version, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge">function</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset clears all the initialized, cached state about the use of modules,
so that we can start over.</p>
               
               <pre><code class="language-go">func Reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Selected" data-name="Selected">
               <h3>
                  Selected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Selected" class="anchor" title="Link to Selected">#</a>
               </h3>
               
               <p>Selected returns the selected version of the module with the given path.
If no version is selected, Selected returns version "none".</p>
               
               <pre><code class="language-go">func (mg *ModuleGraph) Selected(path string) (version string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIndex" data-name="SetIndex">
               <h3>
                  SetIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIndex" class="anchor" title="Link to SetIndex">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) SetIndex(m module.Version, index *modFileIndex)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ShortMessage" data-name="ShortMessage">
               <h3>
                  ShortMessage 
                  <span class="badge">function</span>
                  
                  <a href="#ShortMessage" class="anchor" title="Link to ShortMessage">#</a>
               </h3>
               
               <p>ShortMessage returns a string from go.mod (for example, a retraction
rationale or deprecation message) that is safe to print in a terminal.
If the given string is empty, ShortMessage returns the given default. If the
given string is too long or contains non-printable characters, ShortMessage
returns a hard-coded string.</p>
               
               <pre><code class="language-go">func ShortMessage(message string, emptyDefault string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (er emptyRepo) Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (rr *replacementRepo) Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string that describes the full conflict path.</p>
               
               <pre><code class="language-go">func (c Conflict) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string describing the Requirements for debugging.</p>
               
               <pre><code class="language-go">func (rs *Requirements) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (p modPruning) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (dq dqState) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Summary" data-name="Summary">
               <h3>
                  Summary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Summary" class="anchor" title="Link to Summary">#</a>
               </h3>
               
               <p>Summary returns a string that describes only the first and last modules in
the conflict path.</p>
               
               <pre><code class="language-go">func (c Conflict) Summary() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToDirectoryPath" data-name="ToDirectoryPath">
               <h3>
                  ToDirectoryPath 
                  <span class="badge">function</span>
                  
                  <a href="#ToDirectoryPath" class="anchor" title="Link to ToDirectoryPath">#</a>
               </h3>
               
               <p>ToDirectoryPath adds a prefix if necessary so that path in unambiguously
an absolute path or a relative path starting with a '.' or '..'
path component.</p>
               
               <pre><code class="language-go">func ToDirectoryPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Toolchain" data-name="Toolchain">
               <h3>
                  Toolchain 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Toolchain" class="anchor" title="Link to Toolchain">#</a>
               </h3>
               
               <p>Toolchain returns the toolchain set on the single module, in module mode,
or the go.work file in workspace mode.</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Toolchain() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Tools" data-name="Tools">
               <h3>
                  Tools 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Tools" class="anchor" title="Link to Tools">#</a>
               </h3>
               
               <p>Tools returns the tools defined by all the main modules.
The key is the absolute package path of the tool.</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Tools() map[string]bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *retractionLoadingError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *invalidImportError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ImportMissingError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnwrapModuleError" data-name="UnwrapModuleError">
               <h3>
                  UnwrapModuleError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnwrapModuleError" class="anchor" title="Link to UnwrapModuleError">#</a>
               </h3>
               
               <p>UnwrapModuleError returns c.Err, but unwraps it if it is a module.ModuleError
with a version and path matching the last entry in the Path slice.</p>
               
               <pre><code class="language-go">func (c Conflict) UnwrapModuleError() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UpdateGoModFromReqs" data-name="UpdateGoModFromReqs">
               <h3>
                  UpdateGoModFromReqs 
                  <span class="badge">function</span>
                  
                  <a href="#UpdateGoModFromReqs" class="anchor" title="Link to UpdateGoModFromReqs">#</a>
               </h3>
               
               <p>UpdateGoModFromReqs returns a modified go.mod file using the current
requirements. It does not commit these changes to disk.</p>
               
               <pre><code class="language-go">func UpdateGoModFromReqs(ctx context.Context, opts WriteOpts) (before []byte, after []byte, modFile *modfile.File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UpdateWorkFile" data-name="UpdateWorkFile">
               <h3>
                  UpdateWorkFile 
                  <span class="badge">function</span>
                  
                  <a href="#UpdateWorkFile" class="anchor" title="Link to UpdateWorkFile">#</a>
               </h3>
               
               <p>UpdateWorkFile updates comments on directory directives in the go.work
file to include the associated module path.</p>
               
               <pre><code class="language-go">func UpdateWorkFile(wf *modfile.WorkFile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UpdateWorkGoVersion" data-name="UpdateWorkGoVersion">
               <h3>
                  UpdateWorkGoVersion 
                  <span class="badge">function</span>
                  
                  <a href="#UpdateWorkGoVersion" class="anchor" title="Link to UpdateWorkGoVersion">#</a>
               </h3>
               
               <p>UpdateWorkGoVersion updates the go line in wf to be at least goVers,
reporting whether it changed the file.</p>
               
               <pre><code class="language-go">func UpdateWorkGoVersion(wf *modfile.WorkFile, goVers string) (changed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Upgrade" data-name="Upgrade">
               <h3>
                  Upgrade 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Upgrade" class="anchor" title="Link to Upgrade">#</a>
               </h3>
               
               <p>Upgrade is a no-op, here to implement mvs.Reqs.
The upgrade logic for go get -u is in ../modget/get.go.</p>
               
               <pre><code class="language-go">func (*mvsReqs) Upgrade(m module.Version) (module.Version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VendorDir" data-name="VendorDir">
               <h3>
                  VendorDir 
                  <span class="badge">function</span>
                  
                  <a href="#VendorDir" class="anchor" title="Link to VendorDir">#</a>
               </h3>
               
               <pre><code class="language-go">func VendorDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <p>Versions returns the versions from rr.repo augmented with any matching
replacement versions.</p>
               
               <pre><code class="language-go">func (rr *replacementRepo) Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (er emptyRepo) Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <p>Versions returns the module.Version values of each of the main modules.
For each of them, the Path fields are ordinary module paths and the Version
fields are empty strings.
Callers should not modify the returned slice.</p>
               
               <pre><code class="language-go">func (mms *MainModuleSet) Versions() []module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WalkBreadthFirst" data-name="WalkBreadthFirst">
               <h3>
                  WalkBreadthFirst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WalkBreadthFirst" class="anchor" title="Link to WalkBreadthFirst">#</a>
               </h3>
               
               <p>WalkBreadthFirst invokes f once, in breadth-first order, for each module
version other than "none" that appears in the graph, regardless of whether
that version is selected.</p>
               
               <pre><code class="language-go">func (mg *ModuleGraph) WalkBreadthFirst(f func(m module.Version))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Why" data-name="Why">
               <h3>
                  Why 
                  <span class="badge">function</span>
                  
                  <a href="#Why" class="anchor" title="Link to Why">#</a>
               </h3>
               
               <p>Why returns the "go mod why" output stanza for the given package,
without the leading # comment.
The package graph must have been loaded already, usually by LoadPackages.
If there is no reason for the package to be in the current build,
Why returns an empty string.</p>
               
               <pre><code class="language-go">func Why(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WhyDepth" data-name="WhyDepth">
               <h3>
                  WhyDepth 
                  <span class="badge">function</span>
                  
                  <a href="#WhyDepth" class="anchor" title="Link to WhyDepth">#</a>
               </h3>
               
               <p>WhyDepth returns the number of steps in the Why listing.
If there is no reason for the package to be in the current build,
WhyDepth returns 0.</p>
               
               <pre><code class="language-go">func WhyDepth(path string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WillBeEnabled" data-name="WillBeEnabled">
               <h3>
                  WillBeEnabled 
                  <span class="badge">function</span>
                  
                  <a href="#WillBeEnabled" class="anchor" title="Link to WillBeEnabled">#</a>
               </h3>
               
               <p>WillBeEnabled checks whether modules should be enabled but does not
initialize modules by installing hooks. If Init has already been called,
WillBeEnabled returns the same result as Enabled.
This function is needed to break a cycle. The main package needs to know
whether modules are enabled in order to install the module or GOPATH version
of 'go get', but Init reads the -modfile flag in 'go get', so it shouldn't
be called until the command is installed and flags are parsed. Instead of
calling Init and Enabled, the main package can call this function.</p>
               
               <pre><code class="language-go">func WillBeEnabled() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WorkFile" data-name="WorkFile">
               <h3>
                  WorkFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WorkFile" class="anchor" title="Link to WorkFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) WorkFile() *modfile.WorkFile</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WorkFilePath" data-name="WorkFilePath">
               <h3>
                  WorkFilePath 
                  <span class="badge">function</span>
                  
                  <a href="#WorkFilePath" class="anchor" title="Link to WorkFilePath">#</a>
               </h3>
               
               <p>WorkFilePath returns the absolute path of the go.work file, or "" if not in
workspace mode. WorkFilePath must be called after InitWorkfile.</p>
               
               <pre><code class="language-go">func WorkFilePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WorkFileReplaceMap" data-name="WorkFileReplaceMap">
               <h3>
                  WorkFileReplaceMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WorkFileReplaceMap" class="anchor" title="Link to WorkFileReplaceMap">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) WorkFileReplaceMap() map[module.Version]module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteGoMod" data-name="WriteGoMod">
               <h3>
                  WriteGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#WriteGoMod" class="anchor" title="Link to WriteGoMod">#</a>
               </h3>
               
               <p>WriteGoMod writes the current build list back to go.mod.</p>
               
               <pre><code class="language-go">func WriteGoMod(ctx context.Context, opts WriteOpts) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteWorkFile" data-name="WriteWorkFile">
               <h3>
                  WriteWorkFile 
                  <span class="badge">function</span>
                  
                  <a href="#WriteWorkFile" class="anchor" title="Link to WriteWorkFile">#</a>
               </h3>
               
               <p>WriteWorkFile cleans and writes out the go.work file to the given path.</p>
               
               <pre><code class="language-go">func WriteWorkFile(path string, wf *modfile.WorkFile) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addDeprecation" data-name="addDeprecation">
               <h3>
                  addDeprecation 
                  <span class="badge">function</span>
                  
                  <a href="#addDeprecation" class="anchor" title="Link to addDeprecation">#</a>
               </h3>
               
               <p>addDeprecation fills in m.Deprecated if the module was deprecated by its
author. m.Error is set if there's an error loading deprecation information.</p>
               
               <pre><code class="language-go">func addDeprecation(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addGoStmt" data-name="addGoStmt">
               <h3>
                  addGoStmt 
                  <span class="badge">function</span>
                  
                  <a href="#addGoStmt" class="anchor" title="Link to addGoStmt">#</a>
               </h3>
               
               <p>addGoStmt adds a go directive to the go.mod file if it does not already
include one. The 'go' version added, if any, is the latest version supported
by this toolchain.</p>
               
               <pre><code class="language-go">func addGoStmt(modFile *modfile.File, mod module.Version, v string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addRetraction" data-name="addRetraction">
               <h3>
                  addRetraction 
                  <span class="badge">function</span>
                  
                  <a href="#addRetraction" class="anchor" title="Link to addRetraction">#</a>
               </h3>
               
               <p>addRetraction fills in m.Retracted if the module was retracted by its author.
m.Error is set if there's an error loading retraction information.</p>
               
               <pre><code class="language-go">func addRetraction(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addUpdate" data-name="addUpdate">
               <h3>
                  addUpdate 
                  <span class="badge">function</span>
                  
                  <a href="#addUpdate" class="anchor" title="Link to addUpdate">#</a>
               </h3>
               
               <p>addUpdate fills in m.Update if an updated version is available.</p>
               
               <pre><code class="language-go">func addUpdate(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVersions" data-name="addVersions">
               <h3>
                  addVersions 
                  <span class="badge">function</span>
                  
                  <a href="#addVersions" class="anchor" title="Link to addVersions">#</a>
               </h3>
               
               <p>addVersions fills in m.Versions with the list of known versions.
Excluded versions will be omitted. If listRetracted is false, retracted
versions will also be omitted.</p>
               
               <pre><code class="language-go">func addVersions(ctx context.Context, m *modinfo.ModulePublic, listRetracted bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allRootsSelected" data-name="allRootsSelected">
               <h3>
                  allRootsSelected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#allRootsSelected" class="anchor" title="Link to allRootsSelected">#</a>
               </h3>
               
               <pre><code class="language-go">func (mg *ModuleGraph) allRootsSelected() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allowsVersion" data-name="allowsVersion">
               <h3>
                  allowsVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#allowsVersion" class="anchor" title="Link to allowsVersion">#</a>
               </h3>
               
               <p>allowsVersion reports whether version v is allowed by the prefix, filter, and
AllowedFunc of qm.</p>
               
               <pre><code class="language-go">func (qm *queryMatcher) allowsVersion(ctx context.Context, v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendGoAndToolchainRoots" data-name="appendGoAndToolchainRoots">
               <h3>
                  appendGoAndToolchainRoots 
                  <span class="badge">function</span>
                  
                  <a href="#appendGoAndToolchainRoots" class="anchor" title="Link to appendGoAndToolchainRoots">#</a>
               </h3>
               
               <pre><code class="language-go">func appendGoAndToolchainRoots(roots []module.Version, goVersion string, toolchain string, direct map[string]bool) []module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="applyPkgFlags" data-name="applyPkgFlags">
               <h3>
                  applyPkgFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#applyPkgFlags" class="anchor" title="Link to applyPkgFlags">#</a>
               </h3>
               
               <p>applyPkgFlags updates pkg.flags to set the given flags and propagate the
(transitive) effects of those flags, possibly loading or enqueueing further
packages as a result.</p>
               
               <pre><code class="language-go">func (ld *loader) applyPkgFlags(ctx context.Context, pkg *loadPkg, flags loadPkgFlags)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildStacks" data-name="buildStacks">
               <h3>
                  buildStacks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#buildStacks" class="anchor" title="Link to buildStacks">#</a>
               </h3>
               
               <p>buildStacks computes minimal import stacks for each package,
for use in error messages. When it completes, packages that
are part of the original root set have pkg.stack == nil,
and other packages have pkg.stack pointing at the next
package up the import stack in their minimal chain.
As a side effect, buildStacks also constructs ld.pkgs,
the list of all packages loaded.</p>
               
               <pre><code class="language-go">func (ld *loader) buildStacks()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canonicalizeReplacePath" data-name="canonicalizeReplacePath">
               <h3>
                  canonicalizeReplacePath 
                  <span class="badge">function</span>
                  
                  <a href="#canonicalizeReplacePath" class="anchor" title="Link to canonicalizeReplacePath">#</a>
               </h3>
               
               <p>canonicalizeReplacePath ensures that relative, on-disk, replaced module paths
are relative to the workspace directory (in workspace mode) or to the module's
directory (in module mode, as they already are).</p>
               
               <pre><code class="language-go">func canonicalizeReplacePath(r module.Version, modRoot string) module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <p>check reports whether m is disqualified in the given pruning context.</p>
               
               <pre><code class="language-go">func (t *dqTracker) check(m module.Version, pruning modPruning) dqState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkMultiplePaths" data-name="checkMultiplePaths">
               <h3>
                  checkMultiplePaths 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkMultiplePaths" class="anchor" title="Link to checkMultiplePaths">#</a>
               </h3>
               
               <p>checkMultiplePaths verifies that a given module path is used as itself
or as a replacement for another module, but not both at the same time.
(See https://golang.org/issue/26607 and https://golang.org/issue/34650.)</p>
               
               <pre><code class="language-go">func (ld *loader) checkMultiplePaths()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkReuse" data-name="checkReuse">
               <h3>
                  checkReuse 
                  <span class="badge">function</span>
                  
                  <a href="#checkReuse" class="anchor" title="Link to checkReuse">#</a>
               </h3>
               
               <p>checkReuse checks whether a revision of a given module
for a given module may be reused, according to the information in origin.</p>
               
               <pre><code class="language-go">func checkReuse(ctx context.Context, m module.Version, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkReuseRepo" data-name="checkReuseRepo">
               <h3>
                  checkReuseRepo 
                  <span class="badge">function</span>
                  
                  <a href="#checkReuseRepo" class="anchor" title="Link to checkReuseRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func checkReuseRepo(ctx context.Context, repo versionRepo, path string, query string, origin *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkTidyCompatibility" data-name="checkTidyCompatibility">
               <h3>
                  checkTidyCompatibility 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkTidyCompatibility" class="anchor" title="Link to checkTidyCompatibility">#</a>
               </h3>
               
               <p>checkTidyCompatibility emits an error if any package would be loaded from a
different module under rs than under ld.requirements.</p>
               
               <pre><code class="language-go">func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements, compatVersion string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkVendorConsistency" data-name="checkVendorConsistency">
               <h3>
                  checkVendorConsistency 
                  <span class="badge">function</span>
                  
                  <a href="#checkVendorConsistency" class="anchor" title="Link to checkVendorConsistency">#</a>
               </h3>
               
               <p>checkVendorConsistency verifies that the vendor/modules.txt file matches (if
go 1.14) or at least does not contradict (go 1.13 or earlier) the
requirements and replacements listed in the main module's go.mod file.</p>
               
               <pre><code class="language-go">func checkVendorConsistency(indexes []*modFileIndex, modFiles []*modfile.File, modRoots []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmpVersion" data-name="cmpVersion">
               <h3>
                  cmpVersion 
                  <span class="badge">function</span>
                  
                  <a href="#cmpVersion" class="anchor" title="Link to cmpVersion">#</a>
               </h3>
               
               <p>cmpVersion implements the comparison for versions in the module loader.
It is consistent with gover.ModCompare except that as a special case,
the version "" is considered higher than all other versions.
The main module (also known as the target) has no version and must be chosen
over other versions of the same module in the module dependency graph.</p>
               
               <pre><code class="language-go">func cmpVersion(p string, v1 string, v2 string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commitRequirements" data-name="commitRequirements">
               <h3>
                  commitRequirements 
                  <span class="badge">function</span>
                  
                  <a href="#commitRequirements" class="anchor" title="Link to commitRequirements">#</a>
               </h3>
               
               <p>commitRequirements ensures go.mod and go.sum are up to date with the current
requirements.
In "mod" mode, commitRequirements writes changes to go.mod and go.sum.
In "readonly" and "vendor" modes, commitRequirements returns an error if
go.mod or go.sum are out of date in a semantically significant way.
In workspace mode, commitRequirements only writes changes to go.work.sum.</p>
               
               <pre><code class="language-go">func commitRequirements(ctx context.Context, opts WriteOpts) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computePatternAll" data-name="computePatternAll">
               <h3>
                  computePatternAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#computePatternAll" class="anchor" title="Link to computePatternAll">#</a>
               </h3>
               
               <p>computePatternAll returns the list of packages matching pattern "all",
starting with a list of the import paths for the packages in the main module.</p>
               
               <pre><code class="language-go">func (ld *loader) computePatternAll() (all []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertPruning" data-name="convertPruning">
               <h3>
                  convertPruning 
                  <span class="badge">function</span>
                  
                  <a href="#convertPruning" class="anchor" title="Link to convertPruning">#</a>
               </h3>
               
               <p>convertPruning returns a version of rs with the given pruning behavior.
If rs already has the given pruning, convertPruning returns rs unmodified.</p>
               
               <pre><code class="language-go">func convertPruning(ctx context.Context, rs *Requirements, pruning modPruning) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="die" data-name="die">
               <h3>
                  die 
                  <span class="badge">function</span>
                  
                  <a href="#die" class="anchor" title="Link to die">#</a>
               </h3>
               
               <pre><code class="language-go">func die()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirInModule" data-name="dirInModule">
               <h3>
                  dirInModule 
                  <span class="badge">function</span>
                  
                  <a href="#dirInModule" class="anchor" title="Link to dirInModule">#</a>
               </h3>
               
               <p>dirInModule locates the directory that would hold the package named by the given path,
if it were in the module with module path mpath and root mdir.
If path is syntactically not within mpath,
or if mdir is a local file tree (isLocal == true) and the directory
that would hold path is in a sub-module (covered by a go.mod below mdir),
dirInModule returns "", false, nil.
Otherwise, dirInModule returns the name of the directory where
Go source files would be expected, along with a boolean indicating
whether there are in fact Go source files in that directory.
A non-nil error indicates that the existence of the directory and/or
source files could not be determined, for example due to a permission error.</p>
               
               <pre><code class="language-go">func dirInModule(path string, mpath string, mdir string, isLocal bool) (dir string, haveGoFiles bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directRequirements" data-name="directRequirements">
               <h3>
                  directRequirements 
                  <span class="badge">function</span>
                  
                  <a href="#directRequirements" class="anchor" title="Link to directRequirements">#</a>
               </h3>
               
               <pre><code class="language-go">func directRequirements(modFiles []*modfile.File) map[string]bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disqualify" data-name="disqualify">
               <h3>
                  disqualify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disqualify" class="anchor" title="Link to disqualify">#</a>
               </h3>
               
               <p>disqualify records why the dependencies of m cannot be included in the module
graph if reached from a part of the graph with the given pruning.
Since the pruned graph is a subgraph of the unpruned graph, disqualifying a
module from a pruned part of the graph also disqualifies it in the unpruned
parts.</p>
               
               <pre><code class="language-go">func (t *dqTracker) disqualify(m module.Version, fromPruning modPruning, reason dqState)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="editRequirements" data-name="editRequirements">
               <h3>
                  editRequirements 
                  <span class="badge">function</span>
                  
                  <a href="#editRequirements" class="anchor" title="Link to editRequirements">#</a>
               </h3>
               
               <p>editRequirements returns an edited version of rs such that:
1. Each module version in mustSelect is selected.
2. Each module version in tryUpgrade is upgraded toward the indicated
version as far as can be done without violating (1).
(Other upgrades are also allowed if they are caused by
transitive requirements of versions in mustSelect or
tryUpgrade.)
3. Each module version in rs.rootModules (or rs.graph, if rs is unpruned)
is downgraded or upgraded from its original version only to the extent
needed to satisfy (1) and (2).
Generally, the module versions in mustSelect are due to the module or a
package within the module matching an explicit command line argument to 'go
get', and the versions in tryUpgrade are transitive dependencies that are
either being upgraded by 'go get -u' or being added to satisfy some
otherwise-missing package import.
If pruning is enabled, the roots of the edited requirements include an
explicit entry for each module path in tryUpgrade, mustSelect, and the roots
of rs, unless the selected version for the module path is "none".</p>
               
               <pre><code class="language-go">func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade []module.Version, mustSelect []module.Version) (edited *Requirements, changed bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errWorkTooOld" data-name="errWorkTooOld">
               <h3>
                  errWorkTooOld 
                  <span class="badge">function</span>
                  
                  <a href="#errWorkTooOld" class="anchor" title="Link to errWorkTooOld">#</a>
               </h3>
               
               <pre><code class="language-go">func errWorkTooOld(gomod string, wf *modfile.WorkFile, goVers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <p>error reports an error via either os.Stderr or base.Error,
according to whether ld.AllowErrors is set.</p>
               
               <pre><code class="language-go">func (ld *loader) error(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exitIfErrors" data-name="exitIfErrors">
               <h3>
                  exitIfErrors 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exitIfErrors" class="anchor" title="Link to exitIfErrors">#</a>
               </h3>
               
               <p>exitIfErrors switches toolchains if a switch is needed
or else exits if any errors have been reported.</p>
               
               <pre><code class="language-go">func (ld *loader) exitIfErrors(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandGraph" data-name="expandGraph">
               <h3>
                  expandGraph 
                  <span class="badge">function</span>
                  
                  <a href="#expandGraph" class="anchor" title="Link to expandGraph">#</a>
               </h3>
               
               <p>expandGraph loads the complete module graph from rs.
If the complete graph reveals that some root of rs is not actually the
selected version of its path, expandGraph computes a new set of roots that
are consistent. (With a pruned module graph, this may result in upgrades to
other modules due to requirements that were previously pruned out.)
expandGraph returns the updated roots, along with the module graph loaded
from those roots and any error encountered while loading that graph.
expandGraph returns non-nil requirements and a non-nil graph regardless of
errors. On error, the roots might not be updated to be consistent.</p>
               
               <pre><code class="language-go">func expandGraph(ctx context.Context, rs *Requirements) (*Requirements, *ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extendGraph" data-name="extendGraph">
               <h3>
                  extendGraph 
                  <span class="badge">function</span>
                  
                  <a href="#extendGraph" class="anchor" title="Link to extendGraph">#</a>
               </h3>
               
               <p>extendGraph loads the module graph from roots, and iteratively extends it by
unpruning the selected version of each module path that is a root in rs or in
the roots slice until the graph reaches a fixed point.
The graph is guaranteed to converge to a fixed point because unpruning a
module version can only increase (never decrease) the selected versions,
and the set of versions for each module is finite.
The extended graph is useful for diagnosing version conflicts: for each
selected module version, it can provide a complete path of requirements from
some root to that version.</p>
               
               <pre><code class="language-go">func extendGraph(ctx context.Context, rootPruning modPruning, roots []module.Version, selectedRoot map[string]string) (mg *ModuleGraph, upgradedRoot map[module.Version]bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fetch" data-name="fetch">
               <h3>
                  fetch 
                  <span class="badge">function</span>
                  
                  <a href="#fetch" class="anchor" title="Link to fetch">#</a>
               </h3>
               
               <p>fetch downloads the given module (or its replacement)
and returns its location.
The isLocal return value reports whether the replacement,
if any, is local to the filesystem.</p>
               
               <pre><code class="language-go">func fetch(ctx context.Context, mod module.Version) (dir string, isLocal bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterVersions" data-name="filterVersions">
               <h3>
                  filterVersions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterVersions" class="anchor" title="Link to filterVersions">#</a>
               </h3>
               
               <p>filterVersions classifies versions into releases and pre-releases, filtering
out:
1. versions that do not satisfy the 'allowed' predicate, and
2. "+incompatible" versions, if a compatible one satisfies the predicate
and the incompatible version is not preferred.
If the allowed predicate returns an error not equivalent to ErrDisallowed,
filterVersions returns that error.</p>
               
               <pre><code class="language-go">func (qm *queryMatcher) filterVersions(ctx context.Context, versions []string) (releases []string, prereleases []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findAltConfig" data-name="findAltConfig">
               <h3>
                  findAltConfig 
                  <span class="badge">function</span>
                  
                  <a href="#findAltConfig" class="anchor" title="Link to findAltConfig">#</a>
               </h3>
               
               <pre><code class="language-go">func findAltConfig(dir string) (root string, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findError" data-name="findError">
               <h3>
                  findError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findError" class="anchor" title="Link to findError">#</a>
               </h3>
               
               <pre><code class="language-go">func (mg *ModuleGraph) findError() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findImportComment" data-name="findImportComment">
               <h3>
                  findImportComment 
                  <span class="badge">function</span>
                  
                  <a href="#findImportComment" class="anchor" title="Link to findImportComment">#</a>
               </h3>
               
               <pre><code class="language-go">func findImportComment(file string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findModule" data-name="findModule">
               <h3>
                  findModule 
                  <span class="badge">function</span>
                  
                  <a href="#findModule" class="anchor" title="Link to findModule">#</a>
               </h3>
               
               <p>findModule searches for the module that contains the package at path.
If the package was loaded, its containing module and true are returned.
Otherwise, module.Version{} and false are returned.</p>
               
               <pre><code class="language-go">func findModule(ld *loader, path string) (module.Version, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findModulePath" data-name="findModulePath">
               <h3>
                  findModulePath 
                  <span class="badge">function</span>
                  
                  <a href="#findModulePath" class="anchor" title="Link to findModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func findModulePath(dir string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findModuleRoot" data-name="findModuleRoot">
               <h3>
                  findModuleRoot 
                  <span class="badge">function</span>
                  
                  <a href="#findModuleRoot" class="anchor" title="Link to findModuleRoot">#</a>
               </h3>
               
               <pre><code class="language-go">func findModuleRoot(dir string) (roots string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findStandardImportPath" data-name="findStandardImportPath">
               <h3>
                  findStandardImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#findStandardImportPath" class="anchor" title="Link to findStandardImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func findStandardImportPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findWorkspaceFile" data-name="findWorkspaceFile">
               <h3>
                  findWorkspaceFile 
                  <span class="badge">function</span>
                  
                  <a href="#findWorkspaceFile" class="anchor" title="Link to findWorkspaceFile">#</a>
               </h3>
               
               <pre><code class="language-go">func findWorkspaceFile(dir string) (root string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixVersion" data-name="fixVersion">
               <h3>
                  fixVersion 
                  <span class="badge">function</span>
                  
                  <a href="#fixVersion" class="anchor" title="Link to fixVersion">#</a>
               </h3>
               
               <p>fixVersion returns a modfile.VersionFixer implemented using the Query function.
It resolves commit hashes and branch names to versions,
canonicalizes versions that appeared in early vgo drafts,
and does nothing for versions that already appear to be canonical.
The VersionFixer sets 'fixed' if it ever returns a non-canonical version.</p>
               
               <pre><code class="language-go">func fixVersion(ctx context.Context, fixed *bool) modfile.VersionFixer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forceGoStmt" data-name="forceGoStmt">
               <h3>
                  forceGoStmt 
                  <span class="badge">function</span>
                  
                  <a href="#forceGoStmt" class="anchor" title="Link to forceGoStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func forceGoStmt(modFile *modfile.File, mod module.Version, v string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="from" data-name="from">
               <h3>
                  from 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#from" class="anchor" title="Link to from">#</a>
               </h3>
               
               <pre><code class="language-go">func (pp *ast.IndexExpr) from(p modPruning) T</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fromExternalModule" data-name="fromExternalModule">
               <h3>
                  fromExternalModule 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fromExternalModule" class="anchor" title="Link to fromExternalModule">#</a>
               </h3>
               
               <p>fromExternalModule reports whether pkg was loaded from a module other than
the main module.</p>
               
               <pre><code class="language-go">func (pkg *loadPkg) fromExternalModule() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goModSummary" data-name="goModSummary">
               <h3>
                  goModSummary 
                  <span class="badge">function</span>
                  
                  <a href="#goModSummary" class="anchor" title="Link to goModSummary">#</a>
               </h3>
               
               <p>goModSummary returns a summary of the go.mod file for module m,
taking into account any replacements for m, exclusions of its dependencies,
and/or vendoring.
m must be a version in the module graph, reachable from the Target module.
In readonly mode, the go.sum file must contain an entry for m's go.mod file
(or its replacement). goModSummary must not be called for the Target module
itself, as its requirements may change. Use rawGoModSummary for other
module versions.
The caller must not modify the returned summary.</p>
               
               <pre><code class="language-go">func goModSummary(m module.Version) (*modFileSummary, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goVersion" data-name="goVersion">
               <h3>
                  goVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#goVersion" class="anchor" title="Link to goVersion">#</a>
               </h3>
               
               <p>goVersion reports the Go version that should be used for the loader's
requirements: ld.TidyGoVersion if set, or ld.requirements.GoVersion()
otherwise.</p>
               
               <pre><code class="language-go">func (ld *loader) goVersion() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="has" data-name="has">
               <h3>
                  has 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#has" class="anchor" title="Link to has">#</a>
               </h3>
               
               <p>has reports whether all of the flags in cond are set in f.</p>
               
               <pre><code class="language-go">func (f loadPkgFlags) has(cond loadPkgFlags) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="has" data-name="has">
               <h3>
                  has 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#has" class="anchor" title="Link to has">#</a>
               </h3>
               
               <p>has reports whether all of the flags in cond are set in af.</p>
               
               <pre><code class="language-go">func (af *atomicLoadPkgFlags) has(cond loadPkgFlags) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasRedundantRoot" data-name="hasRedundantRoot">
               <h3>
                  hasRedundantRoot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasRedundantRoot" class="anchor" title="Link to hasRedundantRoot">#</a>
               </h3>
               
               <p>hasRedundantRoot returns true if the root list contains multiple requirements
of the same module or a requirement on any version of the main module.
Redundant requirements should be pruned, but they may influence version
selection.</p>
               
               <pre><code class="language-go">func (rs *Requirements) hasRedundantRoot() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasWritePerm" data-name="hasWritePerm">
               <h3>
                  hasWritePerm 
                  <span class="badge">function</span>
                  
                  <a href="#hasWritePerm" class="anchor" title="Link to hasWritePerm">#</a>
               </h3>
               
               <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.</p>
               
               <pre><code class="language-go">func hasWritePerm(path string, _ fs.FileInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasWritePerm" data-name="hasWritePerm">
               <h3>
                  hasWritePerm 
                  <span class="badge">function</span>
                  
                  <a href="#hasWritePerm" class="anchor" title="Link to hasWritePerm">#</a>
               </h3>
               
               <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.
Although the root user on most Unix systems can write to files even without
permission, hasWritePerm reports false if no appropriate permission bit is
set even if the current user is root.</p>
               
               <pre><code class="language-go">func hasWritePerm(path string, fi fs.FileInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasWritePerm" data-name="hasWritePerm">
               <h3>
                  hasWritePerm 
                  <span class="badge">function</span>
                  
                  <a href="#hasWritePerm" class="anchor" title="Link to hasWritePerm">#</a>
               </h3>
               
               <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.</p>
               
               <pre><code class="language-go">func hasWritePerm(_ string, fi fs.FileInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importFromModules" data-name="importFromModules">
               <h3>
                  importFromModules 
                  <span class="badge">function</span>
                  
                  <a href="#importFromModules" class="anchor" title="Link to importFromModules">#</a>
               </h3>
               
               <p>importFromModules finds the module and directory in the dependency graph of
rs containing the package with the given import path. If mg is nil,
importFromModules attempts to locate the module using only the main module
and the roots of rs before it loads the full graph.
The answer must be unique: importFromModules returns an error if multiple
modules are observed to provide the same package.
importFromModules can return a module with an empty m.Path, for packages in
the standard library.
importFromModules can return an empty directory string, for fake packages
like "C" and "unsafe".
If the package is not present in any module selected from the requirement
graph, importFromModules returns an *ImportMissingError.
If the package is present in exactly one module, importFromModules will
return the module, its root directory, and a list of other modules that
lexically could have provided the package but did not.
If skipModFile is true, the go.mod file for the package is not loaded. This
allows 'go mod tidy' to preserve a minor checksum-preservation bug
(https://go.dev/issue/56222) for modules with 'go' versions between 1.17 and
1.20, preventing unnecessary go.sum churn and network access in those
modules.</p>
               
               <pre><code class="language-go">func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph, skipModFile bool) (m module.Version, modroot string, dir string, altMods []module.Version, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inWorkspaceMode" data-name="inWorkspaceMode">
               <h3>
                  inWorkspaceMode 
                  <span class="badge">function</span>
                  
                  <a href="#inWorkspaceMode" class="anchor" title="Link to inWorkspaceMode">#</a>
               </h3>
               
               <pre><code class="language-go">func inWorkspaceMode() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexModFile" data-name="indexModFile">
               <h3>
                  indexModFile 
                  <span class="badge">function</span>
                  
                  <a href="#indexModFile" class="anchor" title="Link to indexModFile">#</a>
               </h3>
               
               <p>indexModFile rebuilds the index of modFile.
If modFile has been changed since it was first read,
modFile.Cleanup must be called before indexModFile.</p>
               
               <pre><code class="language-go">func indexModFile(data []byte, modFile *modfile.File, mod module.Version, needsFix bool) *modFileIndex</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initVendor" data-name="initVendor">
               <h3>
                  initVendor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initVendor" class="anchor" title="Link to initVendor">#</a>
               </h3>
               
               <p>initVendor initializes rs.graph from the given list of vendored module
dependencies, overriding the graph that would normally be loaded from module
requirements.</p>
               
               <pre><code class="language-go">func (rs *Requirements) initVendor(vendorList []module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDisqualified" data-name="isDisqualified">
               <h3>
                  isDisqualified 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDisqualified" class="anchor" title="Link to isDisqualified">#</a>
               </h3>
               
               <pre><code class="language-go">func (dq dqState) isDisqualified() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isStandardImportPath" data-name="isStandardImportPath">
               <h3>
                  isStandardImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#isStandardImportPath" class="anchor" title="Link to isStandardImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func isStandardImportPath(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTest" data-name="isTest">
               <h3>
                  isTest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isTest" class="anchor" title="Link to isTest">#</a>
               </h3>
               
               <p>isTest reports whether pkg is a test of another package.</p>
               
               <pre><code class="language-go">func (pkg *loadPkg) isTest() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="keepSums" data-name="keepSums">
               <h3>
                  keepSums 
                  <span class="badge">function</span>
                  
                  <a href="#keepSums" class="anchor" title="Link to keepSums">#</a>
               </h3>
               
               <p>keepSums returns the set of modules (and go.mod file entries) for which
checksums would be needed in order to reload the same set of packages
loaded by the most recent call to LoadPackages or ImportFromFiles,
including any go.mod files needed to reconstruct the MVS result
or identify go versions,
in addition to the checksums for every module in keepMods.</p>
               
               <pre><code class="language-go">func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums) map[module.Version]bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="listModules" data-name="listModules">
               <h3>
                  listModules 
                  <span class="badge">function</span>
                  
                  <a href="#listModules" class="anchor" title="Link to listModules">#</a>
               </h3>
               
               <pre><code class="language-go">func listModules(ctx context.Context, rs *Requirements, args []string, mode ListMode, reuse map[module.Version]*modinfo.ModulePublic) (_ *Requirements, mods []*modinfo.ModulePublic, mgErr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <p>load loads an individual package.</p>
               
               <pre><code class="language-go">func (ld *loader) load(ctx context.Context, pkg *loadPkg)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadFromRoots" data-name="loadFromRoots">
               <h3>
                  loadFromRoots 
                  <span class="badge">function</span>
                  
                  <a href="#loadFromRoots" class="anchor" title="Link to loadFromRoots">#</a>
               </h3>
               
               <p>loadFromRoots attempts to load the build graph needed to process a set of
root packages and their dependencies.
The set of root packages is returned by the params.listRoots function, and
expanded to the full set of packages by tracing imports (and possibly tests)
as needed.</p>
               
               <pre><code class="language-go">func loadFromRoots(ctx context.Context, params loaderParams) *loader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadModFile" data-name="loadModFile">
               <h3>
                  loadModFile 
                  <span class="badge">function</span>
                  
                  <a href="#loadModFile" class="anchor" title="Link to loadModFile">#</a>
               </h3>
               
               <pre><code class="language-go">func loadModFile(ctx context.Context, opts *PackageOpts) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadWorkFile" data-name="loadWorkFile">
               <h3>
                  loadWorkFile 
                  <span class="badge">function</span>
                  
                  <a href="#loadWorkFile" class="anchor" title="Link to loadWorkFile">#</a>
               </h3>
               
               <pre><code class="language-go">func loadWorkFile(path string) (workFile *modfile.WorkFile, modRoots []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupRepo" data-name="lookupRepo">
               <h3>
                  lookupRepo 
                  <span class="badge">function</span>
                  
                  <a href="#lookupRepo" class="anchor" title="Link to lookupRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func lookupRepo(ctx context.Context, proxy string, path string) (repo versionRepo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeMainModules" data-name="makeMainModules">
               <h3>
                  makeMainModules 
                  <span class="badge">function</span>
                  
                  <a href="#makeMainModules" class="anchor" title="Link to makeMainModules">#</a>
               </h3>
               
               <p>makeMainModules creates a MainModuleSet and associated variables according to
the given main modules.</p>
               
               <pre><code class="language-go">func makeMainModules(ms []module.Version, rootDirs []string, modFiles []*modfile.File, indices []*modFileIndex, workFile *modfile.WorkFile) *MainModuleSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchLocalDirs" data-name="matchLocalDirs">
               <h3>
                  matchLocalDirs 
                  <span class="badge">function</span>
                  
                  <a href="#matchLocalDirs" class="anchor" title="Link to matchLocalDirs">#</a>
               </h3>
               
               <p>matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories
outside of the standard library and active modules.</p>
               
               <pre><code class="language-go">func matchLocalDirs(ctx context.Context, modRoots []string, m *search.Match, rs *Requirements)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchPackages" data-name="matchPackages">
               <h3>
                  matchPackages 
                  <span class="badge">function</span>
                  
                  <a href="#matchPackages" class="anchor" title="Link to matchPackages">#</a>
               </h3>
               
               <p>matchPackages is like m.MatchPackages, but uses a local variable (rather than
a global) for tags, can include or exclude packages in the standard library,
and is restricted to the given list of modules.</p>
               
               <pre><code class="language-go">func matchPackages(ctx context.Context, m *search.Match, tags map[string]bool, filter stdFilter, modules []module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeInModule" data-name="maybeInModule">
               <h3>
                  maybeInModule 
                  <span class="badge">function</span>
                  
                  <a href="#maybeInModule" class="anchor" title="Link to maybeInModule">#</a>
               </h3>
               
               <p>maybeInModule reports whether, syntactically,
a package with the given import path could be supplied
by a module with the given module path (mpath).</p>
               
               <pre><code class="language-go">func maybeInModule(path string, mpath string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeOrigin" data-name="mergeOrigin">
               <h3>
                  mergeOrigin 
                  <span class="badge">function</span>
                  
                  <a href="#mergeOrigin" class="anchor" title="Link to mergeOrigin">#</a>
               </h3>
               
               <p>mergeOrigin returns the union of data from two origins,
returning either a new origin or one of its unmodified arguments.
If the two origins conflict including if either is nil,
mergeOrigin returns nil.</p>
               
               <pre><code class="language-go">func mergeOrigin(m1 *codehost.Origin, m2 *codehost.Origin) *codehost.Origin</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modFileIsDirty" data-name="modFileIsDirty">
               <h3>
                  modFileIsDirty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modFileIsDirty" class="anchor" title="Link to modFileIsDirty">#</a>
               </h3>
               
               <p>modFileIsDirty reports whether the go.mod file differs meaningfully
from what was indexed.
If modFile has been changed (even cosmetically) since it was first read,
modFile.Cleanup must be called before modFileIsDirty.</p>
               
               <pre><code class="language-go">func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modFilePath" data-name="modFilePath">
               <h3>
                  modFilePath 
                  <span class="badge">function</span>
                  
                  <a href="#modFilePath" class="anchor" title="Link to modFilePath">#</a>
               </h3>
               
               <pre><code class="language-go">func modFilePath(modRoot string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modinfoError" data-name="modinfoError">
               <h3>
                  modinfoError 
                  <span class="badge">function</span>
                  
                  <a href="#modinfoError" class="anchor" title="Link to modinfoError">#</a>
               </h3>
               
               <p>modinfoError wraps an error to create an error message in
modinfo.ModuleError with minimal redundancy.</p>
               
               <pre><code class="language-go">func modinfoError(path string, vers string, err error) *modinfo.ModuleError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modkey" data-name="modkey">
               <h3>
                  modkey 
                  <span class="badge">function</span>
                  
                  <a href="#modkey" class="anchor" title="Link to modkey">#</a>
               </h3>
               
               <p>modkey returns the module.Version under which the checksum for m's go.mod
file is stored in the go.sum file.</p>
               
               <pre><code class="language-go">func modkey(m module.Version) module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moduleInfo" data-name="moduleInfo">
               <h3>
                  moduleInfo 
                  <span class="badge">function</span>
                  
                  <a href="#moduleInfo" class="anchor" title="Link to moduleInfo">#</a>
               </h3>
               
               <p>moduleInfo returns information about module m, loaded from the requirements
in rs (which may be nil to indicate that m was not loaded from a requirement
graph).</p>
               
               <pre><code class="language-go">func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode ListMode, reuse map[module.Version]*modinfo.ModulePublic) *modinfo.ModulePublic</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modulePrefixesExcludingTarget" data-name="modulePrefixesExcludingTarget">
               <h3>
                  modulePrefixesExcludingTarget 
                  <span class="badge">function</span>
                  
                  <a href="#modulePrefixesExcludingTarget" class="anchor" title="Link to modulePrefixesExcludingTarget">#</a>
               </h3>
               
               <p>modulePrefixesExcludingTarget returns all prefixes of path that may plausibly
exist as a module, excluding targetPrefix but otherwise including path
itself, sorted by descending length. Prefixes that are not valid module paths
but are valid package paths (like "m" or "example.com/.gen") are included,
since they might be replaced.</p>
               
               <pre><code class="language-go">func modulePrefixesExcludingTarget(path string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modulesTextIsForWorkspace" data-name="modulesTextIsForWorkspace">
               <h3>
                  modulesTextIsForWorkspace 
                  <span class="badge">function</span>
                  
                  <a href="#modulesTextIsForWorkspace" class="anchor" title="Link to modulesTextIsForWorkspace">#</a>
               </h3>
               
               <pre><code class="language-go">func modulesTextIsForWorkspace(vendorDir string) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustGetSingleMainModule" data-name="mustGetSingleMainModule">
               <h3>
                  mustGetSingleMainModule 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustGetSingleMainModule" class="anchor" title="Link to mustGetSingleMainModule">#</a>
               </h3>
               
               <pre><code class="language-go">func (mms *MainModuleSet) mustGetSingleMainModule() module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustHaveCompleteRequirements" data-name="mustHaveCompleteRequirements">
               <h3>
                  mustHaveCompleteRequirements 
                  <span class="badge">function</span>
                  
                  <a href="#mustHaveCompleteRequirements" class="anchor" title="Link to mustHaveCompleteRequirements">#</a>
               </h3>
               
               <pre><code class="language-go">func mustHaveCompleteRequirements() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustHaveGoRoot" data-name="mustHaveGoRoot">
               <h3>
                  mustHaveGoRoot 
                  <span class="badge">function</span>
                  
                  <a href="#mustHaveGoRoot" class="anchor" title="Link to mustHaveGoRoot">#</a>
               </h3>
               
               <pre><code class="language-go">func mustHaveGoRoot(roots []module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustHaveSums" data-name="mustHaveSums">
               <h3>
                  mustHaveSums 
                  <span class="badge">function</span>
                  
                  <a href="#mustHaveSums" class="anchor" title="Link to mustHaveSums">#</a>
               </h3>
               
               <p>mustHaveSums reports whether we require that all checksums
needed to load or build packages are already present in the go.sum file.</p>
               
               <pre><code class="language-go">func mustHaveSums() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newQueryMatcher" data-name="newQueryMatcher">
               <h3>
                  newQueryMatcher 
                  <span class="badge">function</span>
                  
                  <a href="#newQueryMatcher" class="anchor" title="Link to newQueryMatcher">#</a>
               </h3>
               
               <p>newQueryMatcher returns a new queryMatcher that matches the versions
specified by the given query on the module with the given path.
If the query can only be resolved by statting a non-SemVer revision,
newQueryMatcher returns errRevQuery.</p>
               
               <pre><code class="language-go">func newQueryMatcher(path string, query string, current string, allowed AllowedFunc) (*queryMatcher, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRequirements" data-name="newRequirements">
               <h3>
                  newRequirements 
                  <span class="badge">function</span>
                  
                  <a href="#newRequirements" class="anchor" title="Link to newRequirements">#</a>
               </h3>
               
               <p>newRequirements returns a new requirement set with the given root modules.
The dependencies of the roots will be loaded lazily at the first call to the
Graph method.
The rootModules slice must be sorted according to gover.ModSort.
The caller must not modify the rootModules slice or direct map after passing
them to newRequirements.
If vendoring is in effect, the caller must invoke initVendor on the returned
*Requirements before any other method.</p>
               
               <pre><code class="language-go">func newRequirements(pruning modPruning, rootModules []module.Version, direct map[string]bool) *Requirements</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="overrideRoots" data-name="overrideRoots">
               <h3>
                  overrideRoots 
                  <span class="badge">function</span>
                  
                  <a href="#overrideRoots" class="anchor" title="Link to overrideRoots">#</a>
               </h3>
               
               <pre><code class="language-go">func overrideRoots(ctx context.Context, rs *Requirements, replace []module.Version) *Requirements</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="path" data-name="path">
               <h3>
                  path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#path" class="anchor" title="Link to path">#</a>
               </h3>
               
               <p>path returns the path from m to the reason it is disqualified, which may be
either a module that violates constraints or an error in loading
requirements.
If m is not disqualified, path returns (nil, nil).</p>
               
               <pre><code class="language-go">func (t *dqTracker) path(m module.Version, pruning modPruning) (path []module.Version, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathInModuleCache" data-name="pathInModuleCache">
               <h3>
                  pathInModuleCache 
                  <span class="badge">function</span>
                  
                  <a href="#pathInModuleCache" class="anchor" title="Link to pathInModuleCache">#</a>
               </h3>
               
               <p>pathInModuleCache returns the import path of the directory dir,
if dir is in the module cache copy of a module in our build list.</p>
               
               <pre><code class="language-go">func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkg" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkg" class="anchor" title="Link to pkg">#</a>
               </h3>
               
               <p>pkg locates the *loadPkg for path, creating and queuing it for loading if
needed, and updates its state to reflect the given flags.
The imports of the returned *loadPkg will be loaded asynchronously in the
ld.work queue, and its test (if requested) will also be populated once
imports have been resolved. When ld.work goes idle, all transitive imports of
the requested package (and its test, if requested) will have been loaded.</p>
               
               <pre><code class="language-go">func (ld *loader) pkg(ctx context.Context, path string, flags loadPkgFlags) *loadPkg</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgTest" data-name="pkgTest">
               <h3>
                  pkgTest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgTest" class="anchor" title="Link to pkgTest">#</a>
               </h3>
               
               <p>pkgTest locates the test of pkg, creating it if needed, and updates its state
to reflect the given flags.
pkgTest requires that the imports of pkg have already been loaded (flagged
with pkgImportsLoaded).</p>
               
               <pre><code class="language-go">func (ld *loader) pkgTest(ctx context.Context, pkg *loadPkg, testFlags loadPkgFlags) *loadPkg</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="preloadRootModules" data-name="preloadRootModules">
               <h3>
                  preloadRootModules 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#preloadRootModules" class="anchor" title="Link to preloadRootModules">#</a>
               </h3>
               
               <p>preloadRootModules loads the module requirements needed to identify the
selected version of each module providing a package in rootPkgs,
adding new root modules to the module graph if needed.</p>
               
               <pre><code class="language-go">func (ld *loader) preloadRootModules(ctx context.Context, rootPkgs []string) (changedBuildList bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="previousVersion" data-name="previousVersion">
               <h3>
                  previousVersion 
                  <span class="badge">function</span>
                  
                  <a href="#previousVersion" class="anchor" title="Link to previousVersion">#</a>
               </h3>
               
               <p>previousVersion returns the tagged version of m.Path immediately prior to
m.Version, or version "none" if no prior version is tagged.
Since the version of a main module is not found in the version list,
it has no previous version.</p>
               
               <pre><code class="language-go">func previousVersion(ctx context.Context, m module.Version) (module.Version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pruningForGoVersion" data-name="pruningForGoVersion">
               <h3>
                  pruningForGoVersion 
                  <span class="badge">function</span>
                  
                  <a href="#pruningForGoVersion" class="anchor" title="Link to pruningForGoVersion">#</a>
               </h3>
               
               <pre><code class="language-go">func pruningForGoVersion(goVersion string) modPruning</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryImport" data-name="queryImport">
               <h3>
                  queryImport 
                  <span class="badge">function</span>
                  
                  <a href="#queryImport" class="anchor" title="Link to queryImport">#</a>
               </h3>
               
               <p>queryImport attempts to locate a module that can be added to the current
build list to provide the package with the given import path.
Unlike QueryPattern, queryImport prefers to add a replaced version of a
module *before* checking the proxies for a version to add.</p>
               
               <pre><code class="language-go">func queryImport(ctx context.Context, path string, rs *Requirements) (module.Version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryLatestVersionIgnoringRetractions" data-name="queryLatestVersionIgnoringRetractions">
               <h3>
                  queryLatestVersionIgnoringRetractions 
                  <span class="badge">function</span>
                  
                  <a href="#queryLatestVersionIgnoringRetractions" class="anchor" title="Link to queryLatestVersionIgnoringRetractions">#</a>
               </h3>
               
               <p>queryLatestVersionIgnoringRetractions looks up the latest version of the
module with the given path without considering retracted or excluded
versions.
If all versions of the module are replaced,
queryLatestVersionIgnoringRetractions returns the replacement without making
a query.
If the queried latest version is replaced,
queryLatestVersionIgnoringRetractions returns the replacement.</p>
               
               <pre><code class="language-go">func queryLatestVersionIgnoringRetractions(ctx context.Context, path string) (latest module.Version, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryPrefixModules" data-name="queryPrefixModules">
               <h3>
                  queryPrefixModules 
                  <span class="badge">function</span>
                  
                  <a href="#queryPrefixModules" class="anchor" title="Link to queryPrefixModules">#</a>
               </h3>
               
               <pre><code class="language-go">func queryPrefixModules(ctx context.Context, candidateModules []string, queryModule func(ctx context.Context, path string) (QueryResult, error)) (found []QueryResult, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryProxy" data-name="queryProxy">
               <h3>
                  queryProxy 
                  <span class="badge">function</span>
                  
                  <a href="#queryProxy" class="anchor" title="Link to queryProxy">#</a>
               </h3>
               
               <pre><code class="language-go">func queryProxy(ctx context.Context, proxy string, path string, query string, current string, allowed AllowedFunc, reuse map[module.Version]*modinfo.ModulePublic) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryReuse" data-name="queryReuse">
               <h3>
                  queryReuse 
                  <span class="badge">function</span>
                  
                  <a href="#queryReuse" class="anchor" title="Link to queryReuse">#</a>
               </h3>
               
               <p>queryReuse is like Query but also takes a map of module info that can be reused
if the validation criteria in Origin are met.</p>
               
               <pre><code class="language-go">func queryReuse(ctx context.Context, path string, query string, current string, allowed AllowedFunc, reuse map[module.Version]*modinfo.ModulePublic) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rawGoModData" data-name="rawGoModData">
               <h3>
                  rawGoModData 
                  <span class="badge">function</span>
                  
                  <a href="#rawGoModData" class="anchor" title="Link to rawGoModData">#</a>
               </h3>
               
               <p>rawGoModData returns the content of the go.mod file for module m, ignoring
all replacements that may apply to m.
rawGoModData cannot be used on the main module outside of workspace mode.
Unlike rawGoModSummary, rawGoModData does not cache its results in memory.
Use rawGoModSummary instead unless you specifically need these bytes.</p>
               
               <pre><code class="language-go">func rawGoModData(m module.Version) (name string, data []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rawGoModSummary" data-name="rawGoModSummary">
               <h3>
                  rawGoModSummary 
                  <span class="badge">function</span>
                  
                  <a href="#rawGoModSummary" class="anchor" title="Link to rawGoModSummary">#</a>
               </h3>
               
               <p>rawGoModSummary returns a new summary of the go.mod file for module m,
ignoring all replacements that may apply to m and excludes that may apply to
its dependencies.
rawGoModSummary cannot be used on the main module outside of workspace mode.
The modFileSummary can still be used for retractions and deprecations
even if a TooNewError is returned.</p>
               
               <pre><code class="language-go">func rawGoModSummary(m module.Version) (*modFileSummary, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readModGraph" data-name="readModGraph">
               <h3>
                  readModGraph 
                  <span class="badge">function</span>
                  
                  <a href="#readModGraph" class="anchor" title="Link to readModGraph">#</a>
               </h3>
               
               <p>readModGraph reads and returns the module dependency graph starting at the
given roots.
The requirements of the module versions found in the unprune map are included
in the graph even if they would normally be pruned out.
Unlike LoadModGraph, readModGraph does not attempt to diagnose or update
inconsistent roots.</p>
               
               <pre><code class="language-go">func readModGraph(ctx context.Context, pruning modPruning, roots []module.Version, unprune map[module.Version]bool) (*ModuleGraph, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readVendorList" data-name="readVendorList">
               <h3>
                  readVendorList 
                  <span class="badge">function</span>
                  
                  <a href="#readVendorList" class="anchor" title="Link to readVendorList">#</a>
               </h3>
               
               <p>readVendorList reads the list of vendored modules from vendor/modules.txt.</p>
               
               <pre><code class="language-go">func readVendorList(vendorDir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replaceRelativeTo" data-name="replaceRelativeTo">
               <h3>
                  replaceRelativeTo 
                  <span class="badge">function</span>
                  
                  <a href="#replaceRelativeTo" class="anchor" title="Link to replaceRelativeTo">#</a>
               </h3>
               
               <pre><code class="language-go">func replaceRelativeTo() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replacement" data-name="replacement">
               <h3>
                  replacement 
                  <span class="badge">function</span>
                  
                  <a href="#replacement" class="anchor" title="Link to replacement">#</a>
               </h3>
               
               <pre><code class="language-go">func replacement(mod module.Version, replace map[module.Version]module.Version) (fromVersion string, to module.Version, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replacementFrom" data-name="replacementFrom">
               <h3>
                  replacementFrom 
                  <span class="badge">function</span>
                  
                  <a href="#replacementFrom" class="anchor" title="Link to replacementFrom">#</a>
               </h3>
               
               <p>replacementFrom returns the replacement for mod, if any, the modroot of the replacement if it appeared in a go.mod,
and the source of the replacement. The replacement is relative to the go.work or go.mod file it appears in.</p>
               
               <pre><code class="language-go">func replacementFrom(mod module.Version) (r module.Version, modroot string, fromFile string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replacementStat" data-name="replacementStat">
               <h3>
                  replacementStat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#replacementStat" class="anchor" title="Link to replacementStat">#</a>
               </h3>
               
               <pre><code class="language-go">func (rr *replacementRepo) replacementStat(v string) (*modfetch.RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="require" data-name="require">
               <h3>
                  require 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#require" class="anchor" title="Link to require">#</a>
               </h3>
               
               <p>require records that m directly requires r, in case r becomes disqualified.
(These edges are in the opposite direction from the edges in an mvs.Graph.)
If r is already disqualified, require propagates the disqualification to m
and returns the reason for the disqualification.</p>
               
               <pre><code class="language-go">func (t *dqTracker) require(m module.Version, r module.Version) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="requirementsFromModFiles" data-name="requirementsFromModFiles">
               <h3>
                  requirementsFromModFiles 
                  <span class="badge">function</span>
                  
                  <a href="#requirementsFromModFiles" class="anchor" title="Link to requirementsFromModFiles">#</a>
               </h3>
               
               <p>requirementsFromModFiles returns the set of non-excluded requirements from
the global modFile.</p>
               
               <pre><code class="language-go">func requirementsFromModFiles(ctx context.Context, workFile *modfile.WorkFile, modFiles []*modfile.File, opts *PackageOpts) *Requirements</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <pre><code class="language-go">func (ld *loader) reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveLocalPackage" data-name="resolveLocalPackage">
               <h3>
                  resolveLocalPackage 
                  <span class="badge">function</span>
                  
                  <a href="#resolveLocalPackage" class="anchor" title="Link to resolveLocalPackage">#</a>
               </h3>
               
               <p>resolveLocalPackage resolves a filesystem path to a package path.</p>
               
               <pre><code class="language-go">func resolveLocalPackage(ctx context.Context, dir string, rs *Requirements) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveMissingImports" data-name="resolveMissingImports">
               <h3>
                  resolveMissingImports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resolveMissingImports" class="anchor" title="Link to resolveMissingImports">#</a>
               </h3>
               
               <p>resolveMissingImports returns a set of modules that could be added as
dependencies in order to resolve missing packages from pkgs.
The newly-resolved packages are added to the addedModuleFor map, and
resolveMissingImports returns a map from each new module version to
the first missing package that module would resolve.</p>
               
               <pre><code class="language-go">func (ld *loader) resolveMissingImports(ctx context.Context) (modAddedBy map[module.Version]*loadPkg, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveReplacement" data-name="resolveReplacement">
               <h3>
                  resolveReplacement 
                  <span class="badge">function</span>
                  
                  <a href="#resolveReplacement" class="anchor" title="Link to resolveReplacement">#</a>
               </h3>
               
               <p>resolveReplacement returns the module actually used to load the source code
for m: either m itself, or the replacement for m (iff m is replaced).
It also returns the modroot of the module providing the replacement if
one was found.</p>
               
               <pre><code class="language-go">func resolveReplacement(m module.Version) module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootSelected" data-name="rootSelected">
               <h3>
                  rootSelected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rootSelected" class="anchor" title="Link to rootSelected">#</a>
               </h3>
               
               <p>rootSelected returns the version of the root dependency with the given module
path, or the zero module.Version and ok=false if the module is not a root
dependency.</p>
               
               <pre><code class="language-go">func (rs *Requirements) rootSelected(path string) (version string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootsFromModFile" data-name="rootsFromModFile">
               <h3>
                  rootsFromModFile 
                  <span class="badge">function</span>
                  
                  <a href="#rootsFromModFile" class="anchor" title="Link to rootsFromModFile">#</a>
               </h3>
               
               <pre><code class="language-go">func rootsFromModFile(m module.Version, modFile *modfile.File, addToolchainRoot addToolchainRoot) (roots []module.Version, direct map[string]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanDir" data-name="scanDir">
               <h3>
                  scanDir 
                  <span class="badge">function</span>
                  
                  <a href="#scanDir" class="anchor" title="Link to scanDir">#</a>
               </h3>
               
               <p>scanDir is like imports.ScanDir but elides known magic imports from the list,
so that we do not go looking for packages that don't really exist.
The standard magic import is "C", for cgo.
The only other known magic imports are appengine and appengine/*.
These are so old that they predate "go get" and did not use URL-like paths.
Most code today now uses google.golang.org/appengine instead,
but not all code has been so updated. When we mostly ignore build tags
during "go vendor", we look into "// +build appengine" files and
may see these legacy imports. We drop them so that the module
search does not look for modules to try to satisfy them.</p>
               
               <pre><code class="language-go">func scanDir(modroot string, dir string, tags map[string]bool) (imports_ []string, testImports []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setDefaultBuildMod" data-name="setDefaultBuildMod">
               <h3>
                  setDefaultBuildMod 
                  <span class="badge">function</span>
                  
                  <a href="#setDefaultBuildMod" class="anchor" title="Link to setDefaultBuildMod">#</a>
               </h3>
               
               <p>setDefaultBuildMod sets a default value for cfg.BuildMod if the -mod flag
wasn't provided. setDefaultBuildMod may be called multiple times.</p>
               
               <pre><code class="language-go">func setDefaultBuildMod()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shortPathErrorList" data-name="shortPathErrorList">
               <h3>
                  shortPathErrorList 
                  <span class="badge">function</span>
                  
                  <a href="#shortPathErrorList" class="anchor" title="Link to shortPathErrorList">#</a>
               </h3>
               
               <pre><code class="language-go">func shortPathErrorList(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="spotCheckRoots" data-name="spotCheckRoots">
               <h3>
                  spotCheckRoots 
                  <span class="badge">function</span>
                  
                  <a href="#spotCheckRoots" class="anchor" title="Link to spotCheckRoots">#</a>
               </h3>
               
               <p>spotCheckRoots reports whether the versions of the roots in rs satisfy the
explicit requirements of the modules in mods.</p>
               
               <pre><code class="language-go">func spotCheckRoots(ctx context.Context, rs *Requirements, mods map[module.Version]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stackText" data-name="stackText">
               <h3>
                  stackText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stackText" class="anchor" title="Link to stackText">#</a>
               </h3>
               
               <p>stackText builds the import stack text to use when
reporting an error in pkg. It has the general form
root imports
other imports
other2 tested by
other2.test imports
pkg</p>
               
               <pre><code class="language-go">func (pkg *loadPkg) stackText() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stdVendor" data-name="stdVendor">
               <h3>
                  stdVendor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stdVendor" class="anchor" title="Link to stdVendor">#</a>
               </h3>
               
               <p>stdVendor returns the canonical import path for the package with the given
path when imported from the standard-library package at parentPath.</p>
               
               <pre><code class="language-go">func (ld *loader) stdVendor(parentPath string, path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="suggestGopkgIn" data-name="suggestGopkgIn">
               <h3>
                  suggestGopkgIn 
                  <span class="badge">function</span>
                  
                  <a href="#suggestGopkgIn" class="anchor" title="Link to suggestGopkgIn">#</a>
               </h3>
               
               <pre><code class="language-go">func suggestGopkgIn(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="suggestModulePath" data-name="suggestModulePath">
               <h3>
                  suggestModulePath 
                  <span class="badge">function</span>
                  
                  <a href="#suggestModulePath" class="anchor" title="Link to suggestModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func suggestModulePath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switchIfErrors" data-name="switchIfErrors">
               <h3>
                  switchIfErrors 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switchIfErrors" class="anchor" title="Link to switchIfErrors">#</a>
               </h3>
               
               <p>switchIfErrors switches toolchains if a switch is needed.</p>
               
               <pre><code class="language-go">func (ld *loader) switchIfErrors(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tidyPrunedRoots" data-name="tidyPrunedRoots">
               <h3>
                  tidyPrunedRoots 
                  <span class="badge">function</span>
                  
                  <a href="#tidyPrunedRoots" class="anchor" title="Link to tidyPrunedRoots">#</a>
               </h3>
               
               <p>tidyPrunedRoots returns a minimal set of root requirements that maintains the
invariants of the go.mod file needed to support graph pruning for the given
packages:
1. For each package marked with pkgInAll, the module path that provided that
package is included as a root.
2. For all packages, the module that provided that package either remains
selected at the same version or is upgraded by the dependencies of a
root.
If any module that provided a package has been upgraded above its previous
version, the caller may need to reload and recompute the package graph.
To ensure that the loading process eventually converges, the caller should
add any needed roots from the tidy root set (without removing existing untidy
roots) until the set of roots has converged.</p>
               
               <pre><code class="language-go">func tidyPrunedRoots(ctx context.Context, mainModule module.Version, old *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tidyRoots" data-name="tidyRoots">
               <h3>
                  tidyRoots 
                  <span class="badge">function</span>
                  
                  <a href="#tidyRoots" class="anchor" title="Link to tidyRoots">#</a>
               </h3>
               
               <p>tidyRoots trims the root dependencies to the minimal requirements needed to
both retain the same versions of all packages in pkgs and satisfy the
graph-pruning invariants (if applicable).</p>
               
               <pre><code class="language-go">func tidyRoots(ctx context.Context, rs *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tidyUnprunedRoots" data-name="tidyUnprunedRoots">
               <h3>
                  tidyUnprunedRoots 
                  <span class="badge">function</span>
                  
                  <a href="#tidyUnprunedRoots" class="anchor" title="Link to tidyUnprunedRoots">#</a>
               </h3>
               
               <p>tidyUnprunedRoots returns a minimal set of root requirements that maintains
the selected version of every module that provided or lexically could have
provided a package in pkgs, and includes the selected version of every such
module in direct as a root.</p>
               
               <pre><code class="language-go">func tidyUnprunedRoots(ctx context.Context, mainModule module.Version, old *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toReplaceMap" data-name="toReplaceMap">
               <h3>
                  toReplaceMap 
                  <span class="badge">function</span>
                  
                  <a href="#toReplaceMap" class="anchor" title="Link to toReplaceMap">#</a>
               </h3>
               
               <pre><code class="language-go">func toReplaceMap(replacements []*modfile.Replace) map[module.Version]module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <p>update sets the given flags in af (in addition to any flags already set).
update returns the previous flag state so that the caller may determine which
flags were newly-set.</p>
               
               <pre><code class="language-go">func (af *atomicLoadPkgFlags) update(flags loadPkgFlags) (old loadPkgFlags)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updatePrunedRoots" data-name="updatePrunedRoots">
               <h3>
                  updatePrunedRoots 
                  <span class="badge">function</span>
                  
                  <a href="#updatePrunedRoots" class="anchor" title="Link to updatePrunedRoots">#</a>
               </h3>
               
               <p>updatePrunedRoots returns a set of root requirements that maintains the
invariants of the go.mod file needed to support graph pruning:
1. The selected version of the module providing each package marked with
either pkgInAll or pkgIsRoot is included as a root.
Note that certain root patterns (such as '...') may explode the root set
to contain every module that provides any package imported (or merely
required) by any other module.
2. Each root appears only once, at the selected version of its path
(if rs.graph is non-nil) or at the highest version otherwise present as a
root (otherwise).
3. Every module path that appears as a root in rs remains a root.
4. Every version in add is selected at its given version unless upgraded by
(the dependencies of) an existing root or another module in add.
The packages in pkgs are assumed to have been loaded from either the roots of
rs or the modules selected in the graph of rs.
The above invariants together imply the graph-pruning invariants for the
go.mod file:
1. (The import invariant.) Every module that provides a package transitively
imported by any package or test in the main module is included as a root.
This follows by induction from (1) and (3) above. Transitively-imported
packages loaded during this invocation are marked with pkgInAll (1),
and by hypothesis any transitively-imported packages loaded in previous
invocations were already roots in rs (3).
2. (The argument invariant.) Every module that provides a package matching
an explicit package pattern is included as a root. This follows directly
from (1): packages matching explicit package patterns are marked with
pkgIsRoot.
3. (The completeness invariant.) Every module that contributed any package
to the build is required by either the main module or one of the modules
it requires explicitly. This invariant is left up to the caller, who must
not load packages from outside the module graph but may add roots to the
graph, but is facilitated by (3). If the caller adds roots to the graph in
order to resolve missing packages, then updatePrunedRoots will retain them,
the selected versions of those roots cannot regress, and they will
eventually be written back to the main module's go.mod file.
(See https://golang.org/design/36460-lazy-module-loading#invariants for more
detail.)</p>
               
               <pre><code class="language-go">func updatePrunedRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateRequirements" data-name="updateRequirements">
               <h3>
                  updateRequirements 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateRequirements" class="anchor" title="Link to updateRequirements">#</a>
               </h3>
               
               <p>updateRequirements ensures that ld.requirements is consistent with the
information gained from ld.pkgs.
In particular:
- Modules that provide packages directly imported from the main module are
marked as direct, and are promoted to explicit roots. If a needed root
cannot be promoted due to -mod=readonly or -mod=vendor, the importing
package is marked with an error.
- If ld scanned the "all" pattern independent of build constraints, it is
guaranteed to have seen every direct import. Module dependencies that did
not provide any directly-imported package are then marked as indirect.
- Root dependencies are updated to their selected versions.
The "changed" return value reports whether the update changed the selected
version of any module that either provided a loaded package or may now
provide a package that was previously unresolved.</p>
               
               <pre><code class="language-go">func (ld *loader) updateRequirements(ctx context.Context) (changed bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateRoots" data-name="updateRoots">
               <h3>
                  updateRoots 
                  <span class="badge">function</span>
                  
                  <a href="#updateRoots" class="anchor" title="Link to updateRoots">#</a>
               </h3>
               
               <pre><code class="language-go">func updateRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateUnprunedRoots" data-name="updateUnprunedRoots">
               <h3>
                  updateUnprunedRoots 
                  <span class="badge">function</span>
                  
                  <a href="#updateUnprunedRoots" class="anchor" title="Link to updateUnprunedRoots">#</a>
               </h3>
               
               <p>updateUnprunedRoots returns a set of root requirements that includes the selected
version of every module path in direct as a root, and maintains the selected
version of every module selected in the graph of rs.
The roots are updated such that:
1. The selected version of every module path in direct is included as a root
(if it is not "none").
2. Each root is the selected version of its path. (We say that such a root
set is “consistent”.)
3. Every version selected in the graph of rs remains selected unless upgraded
by a dependency in add.
4. Every version in add is selected at its given version unless upgraded by
(the dependencies of) an existing root or another module in add.</p>
               
               <pre><code class="language-go">func updateUnprunedRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateWorkspaceRoots" data-name="updateWorkspaceRoots">
               <h3>
                  updateWorkspaceRoots 
                  <span class="badge">function</span>
                  
                  <a href="#updateWorkspaceRoots" class="anchor" title="Link to updateWorkspaceRoots">#</a>
               </h3>
               
               <pre><code class="language-go">func updateWorkspaceRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versionHasGoMod" data-name="versionHasGoMod">
               <h3>
                  versionHasGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#versionHasGoMod" class="anchor" title="Link to versionHasGoMod">#</a>
               </h3>
               
               <p>versionHasGoMod returns whether a version has a go.mod file.
versionHasGoMod fetches the go.mod file (possibly a fake) and true if it
contains anything other than a module directive with the same path. When a
module does not have a real go.mod file, the go command acts as if it had one
that only contained a module directive. Normal go.mod files created after
1.12 at least have a go directive.
This function is a heuristic, since it's possible to commit a file that would
pass this test. However, we only need a heuristic for determining whether
+incompatible versions may be "latest", which is what this function is used
for.
This heuristic is useful for two reasons: first, when using a proxy,
this lets us fetch from the .mod endpoint which is much faster than the .zip
endpoint. The .mod file is used anyway, even if the .zip file contains a
go.mod with different content. Second, if we don't fetch the .zip, then
we don't need to verify it in go.sum. This makes 'go list -m -u' faster
and simpler.</p>
               
               <pre><code class="language-go">func versionHasGoMod(_ context.Context, m module.Version) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versions" data-name="versions">
               <h3>
                  versions 
                  <span class="badge">function</span>
                  
                  <a href="#versions" class="anchor" title="Link to versions">#</a>
               </h3>
               
               <pre><code class="language-go">func versions(ctx context.Context, path string, allowed AllowedFunc) (versions []string, origin *codehost.Origin, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkFromIndex" data-name="walkFromIndex">
               <h3>
                  walkFromIndex 
                  <span class="badge">function</span>
                  
                  <a href="#walkFromIndex" class="anchor" title="Link to walkFromIndex">#</a>
               </h3>
               
               <p>walkFromIndex matches packages in a module using the module index. modroot
is the module's root directory on disk, index is the modindex.Module for the
module, and importPathRoot is the module's path prefix.</p>
               
               <pre><code class="language-go">func walkFromIndex(index *modindex.Module, importPathRoot string, isMatch func(string) bool, treeCanMatch func(string) bool, tags map[string]bool, have map[string]bool, addPkg func(string))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="why" data-name="why">
               <h3>
                  why 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#why" class="anchor" title="Link to why">#</a>
               </h3>
               
               <p>why returns the text to use in "go mod why" output about the given package.
It is less ornate than the stackText but contains the same information.</p>
               
               <pre><code class="language-go">func (pkg *loadPkg) why() string</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>