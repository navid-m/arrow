<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modload</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>modload</code>
         </h1>
         <hr />
         
         <article class="global" data-name="infoStart">
            <h2>infoStart</h2>
            <hr />
            
            <pre><code>infoStart</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="infoEnd">
            <h2>infoEnd</h2>
            <hr />
            
            <pre><code>infoEnd</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="requirements">
            <h2>requirements</h2>
            <hr />
            
            <p>requirements is the requirement graph for the main module.

It is always non-nil if the main module's go.mod file has been loaded.

This variable should only be read from the loadModFile function, and should
only be written in the loadModFile and commitRequirements functions.
All other functions that need or produce a *Requirements should
accept and/or return an explicit parameter.</p>
            
            <pre><code>requirements *Requirements</code></pre>
         </article>
         
         <article class="global" data-name="readModGraphDebugOnce">
            <h2>readModGraphDebugOnce</h2>
            <hr />
            
            <pre><code>readModGraphDebugOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="importTests">
            <h2>importTests</h2>
            <hr />
            
            <pre><code>importTests</code></pre>
         </article>
         
         <article class="global" data-name="loaded">
            <h2>loaded</h2>
            <hr />
            
            <p>loaded is the most recently-used package loader.
It holds details about individual packages.

This variable should only be accessed directly in top-level exported
functions. All other functions that require or produce a *loader should pass
or return it as an explicit parameter.</p>
            
            <pre><code>loaded *loader</code></pre>
         </article>
         
         <article class="global" data-name="errDirectoryNotFound">
            <h2>errDirectoryNotFound</h2>
            <hr />
            
            <pre><code>errDirectoryNotFound</code></pre>
         </article>
         
         <article class="global" data-name="errPkgIsGorootSrc">
            <h2>errPkgIsGorootSrc</h2>
            <hr />
            
            <pre><code>errPkgIsGorootSrc</code></pre>
         </article>
         
         <article class="global" data-name="errPkgIsBuiltin">
            <h2>errPkgIsBuiltin</h2>
            <hr />
            
            <pre><code>errPkgIsBuiltin</code></pre>
         </article>
         
         <article class="global" data-name="pkgInAll">
            <h2>pkgInAll</h2>
            <hr />
            
            <p>pkgInAll indicates that the package is in the "all" package pattern,
regardless of whether we are loading the "all" package pattern.

When the pkgInAll flag and pkgImportsLoaded flags are both set, the caller
who set the last of those flags must propagate the pkgInAll marking to all
of the imports of the marked package.

A test is marked with pkgInAll if that test would promote the packages it
imports to be in "all" (such as when the test is itself within the main
module, or when ld.allClosesOverTests is true).</p>
            
            <pre><code>pkgInAll loadPkgFlags</code></pre>
         </article>
         
         <article class="global" data-name="pkgIsRoot">
            <h2>pkgIsRoot</h2>
            <hr />
            
            <p>pkgIsRoot indicates that the package matches one of the root package
patterns requested by the caller.

If LoadTests is set, then when pkgIsRoot and pkgImportsLoaded are both set,
the caller who set the last of those flags must populate a test for the
package (in the pkg.test field).

If the "all" pattern is included as a root, then non-test packages in "all"
are also roots (and must be marked pkgIsRoot).</p>
            
            <pre><code>pkgIsRoot</code></pre>
         </article>
         
         <article class="global" data-name="pkgFromRoot">
            <h2>pkgFromRoot</h2>
            <hr />
            
            <p>pkgFromRoot indicates that the package is in the transitive closure of
imports starting at the roots. (Note that every package marked as pkgIsRoot
is also trivially marked pkgFromRoot.)</p>
            
            <pre><code>pkgFromRoot</code></pre>
         </article>
         
         <article class="global" data-name="pkgImportsLoaded">
            <h2>pkgImportsLoaded</h2>
            <hr />
            
            <p>pkgImportsLoaded indicates that the imports and testImports fields of a
loadPkg have been populated.</p>
            
            <pre><code>pkgImportsLoaded</code></pre>
         </article>
         
         <article class="global" data-name="errMissing">
            <h2>errMissing</h2>
            <hr />
            
            <pre><code>errMissing</code></pre>
         </article>
         
         <article class="global" data-name="errQueryDisabled">
            <h2>errQueryDisabled</h2>
            <hr />
            
            <pre><code>errQueryDisabled error</code></pre>
         </article>
         
         <article class="global" data-name="errRevQuery">
            <h2>errRevQuery</h2>
            <hr />
            
            <pre><code>errRevQuery</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ versionRepo</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ versionRepo</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ versionRepo</code></pre>
         </article>
         
         <article class="global" data-name="queryRepo">
            <h2>queryRepo</h2>
            <hr />
            
            <pre><code>queryRepo</code></pre>
         </article>
         
         <article class="global" data-name="queryRepoV2">
            <h2>queryRepoV2</h2>
            <hr />
            
            <pre><code>queryRepoV2</code></pre>
         </article>
         
         <article class="global" data-name="queryRepoV3">
            <h2>queryRepoV3</h2>
            <hr />
            
            <pre><code>queryRepoV3</code></pre>
         </article>
         
         <article class="global" data-name="emptyRepoPath">
            <h2>emptyRepoPath</h2>
            <hr />
            
            <p>Empty version list (no semver tags), not actually empty.</p>
            
            <pre><code>emptyRepoPath</code></pre>
         </article>
         
         <article class="global" data-name="queryTests">
            <h2>queryTests</h2>
            <hr />
            
            <pre><code>queryTests</code></pre>
         </article>
         
         <article class="global" data-name="omitStd">
            <h2>omitStd</h2>
            <hr />
            
            <pre><code>omitStd</code></pre>
         </article>
         
         <article class="global" data-name="includeStd">
            <h2>includeStd</h2>
            <hr />
            
            <pre><code>includeStd</code></pre>
         </article>
         
         <article class="global" data-name="HelpModules">
            <h2>HelpModules</h2>
            <hr />
            
            <pre><code>HelpModules</code></pre>
         </article>
         
         <article class="global" data-name="HelpGoMod">
            <h2>HelpGoMod</h2>
            <hr />
            
            <pre><code>HelpGoMod</code></pre>
         </article>
         
         <article class="global" data-name="RootMode">
            <h2>RootMode</h2>
            <hr />
            
            <p>RootMode determines whether a module root is needed.</p>
            
            <pre><code>RootMode Root</code></pre>
         </article>
         
         <article class="global" data-name="ForceUseModules">
            <h2>ForceUseModules</h2>
            <hr />
            
            <p>ForceUseModules may be set to force modules to be enabled when
GO111MODULE=auto or to report an error when GO111MODULE=off.</p>
            
            <pre><code>ForceUseModules bool</code></pre>
         </article>
         
         <article class="global" data-name="allowMissingModuleImports">
            <h2>allowMissingModuleImports</h2>
            <hr />
            
            <p>Variables set by other packages.

TODO(#40775): See if these can be plumbed as explicit parameters.</p>
            
            <pre><code>allowMissingModuleImports bool</code></pre>
         </article>
         
         <article class="global" data-name="ExplicitWriteGoMod">
            <h2>ExplicitWriteGoMod</h2>
            <hr />
            
            <p>ExplicitWriteGoMod prevents LoadPackages, ListModules, and other functions
from updating go.mod and go.sum or reporting errors when updates are
needed. A package should set this if it would cause go.mod to be written
multiple times (for example, 'go get' calls LoadPackages multiple times) or
if it needs some other operation to be successful before go.mod and go.sum
can be written (for example, 'go mod download' must download modules before
adding sums to go.sum). Packages that set this are responsible for calling
WriteGoMod explicitly.</p>
            
            <pre><code>ExplicitWriteGoMod bool</code></pre>
         </article>
         
         <article class="global" data-name="initialized">
            <h2>initialized</h2>
            <hr />
            
            <p>Variables set in Init.</p>
            
            <pre><code>initialized bool</code></pre>
         </article>
         
         <article class="global" data-name="modRoots">
            <h2>modRoots</h2>
            <hr />
            
            <p>These are primarily used to initialize the MainModules, and should be
eventually superseded by them but are still used in cases where the module
roots are required but MainModules hasn't been initialized yet. Set to
the modRoots of the main modules.
modRoots != nil implies len(modRoots) > 0</p>
            
            <pre><code>modRoots []string</code></pre>
         </article>
         
         <article class="global" data-name="gopath">
            <h2>gopath</h2>
            <hr />
            
            <p>Variables set in Init.</p>
            
            <pre><code>gopath string</code></pre>
         </article>
         
         <article class="global" data-name="workFilePath">
            <h2>workFilePath</h2>
            <hr />
            
            <p>Set to the path to the go.work file, or "" if workspace mode is disabled.</p>
            
            <pre><code>workFilePath string</code></pre>
         </article>
         
         <article class="global" data-name="MainModules">
            <h2>MainModules</h2>
            <hr />
            
            <pre><code>MainModules *MainModuleSet</code></pre>
         </article>
         
         <article class="global" data-name="AutoRoot">
            <h2>AutoRoot</h2>
            <hr />
            
            <p>AutoRoot is the default for most commands. modload.Init will look for
a go.mod file in the current directory or any parent. If none is found,
modules may be disabled (GO111MODULE=auto) or commands may run in a
limited module mode.</p>
            
            <pre><code>AutoRoot Root</code></pre>
         </article>
         
         <article class="global" data-name="NoRoot">
            <h2>NoRoot</h2>
            <hr />
            
            <p>NoRoot is used for commands that run in module mode and ignore any go.mod
file the current directory or in parent directories.</p>
            
            <pre><code>NoRoot</code></pre>
         </article>
         
         <article class="global" data-name="NeedRoot">
            <h2>NeedRoot</h2>
            <hr />
            
            <p>NeedRoot is used for commands that must run in module mode and don't
make sense without a main module.</p>
            
            <pre><code>NeedRoot</code></pre>
         </article>
         
         <article class="global" data-name="ErrNoModRoot">
            <h2>ErrNoModRoot</h2>
            <hr />
            
            <pre><code>ErrNoModRoot</code></pre>
         </article>
         
         <article class="global" data-name="errGoModDirty">
            <h2>errGoModDirty</h2>
            <hr />
            
            <pre><code>errGoModDirty error</code></pre>
         </article>
         
         <article class="global" data-name="omitToolchainRoot">
            <h2>omitToolchainRoot</h2>
            <hr />
            
            <pre><code>omitToolchainRoot addToolchainRoot</code></pre>
         </article>
         
         <article class="global" data-name="withToolchainRoot">
            <h2>withToolchainRoot</h2>
            <hr />
            
            <pre><code>withToolchainRoot</code></pre>
         </article>
         
         <article class="global" data-name="altConfigs">
            <h2>altConfigs</h2>
            <hr />
            
            <pre><code>altConfigs</code></pre>
         </article>
         
         <article class="global" data-name="importCommentRE">
            <h2>importCommentRE</h2>
            <hr />
            
            <pre><code>importCommentRE</code></pre>
         </article>
         
         <article class="global" data-name="errNoChange">
            <h2>errNoChange</h2>
            <hr />
            
            <pre><code>errNoChange</code></pre>
         </article>
         
         <article class="global" data-name="loadedZipSumsOnly">
            <h2>loadedZipSumsOnly</h2>
            <hr />
            
            <pre><code>loadedZipSumsOnly</code></pre>
         </article>
         
         <article class="global" data-name="addBuildListZipSums">
            <h2>addBuildListZipSums</h2>
            <hr />
            
            <pre><code>addBuildListZipSums</code></pre>
         </article>
         
         <article class="global" data-name="ListU">
            <h2>ListU</h2>
            <hr />
            
            <pre><code>ListU ListMode</code></pre>
         </article>
         
         <article class="global" data-name="ListRetracted">
            <h2>ListRetracted</h2>
            <hr />
            
            <pre><code>ListRetracted</code></pre>
         </article>
         
         <article class="global" data-name="ListDeprecated">
            <h2>ListDeprecated</h2>
            <hr />
            
            <pre><code>ListDeprecated</code></pre>
         </article>
         
         <article class="global" data-name="ListVersions">
            <h2>ListVersions</h2>
            <hr />
            
            <pre><code>ListVersions</code></pre>
         </article>
         
         <article class="global" data-name="ListRetractedVersions">
            <h2>ListRetractedVersions</h2>
            <hr />
            
            <pre><code>ListRetractedVersions</code></pre>
         </article>
         
         <article class="global" data-name="pruned">
            <h2>pruned</h2>
            <hr />
            
            <pre><code>pruned modPruning</code></pre>
         </article>
         
         <article class="global" data-name="unpruned">
            <h2>unpruned</h2>
            <hr />
            
            <pre><code>unpruned</code></pre>
         </article>
         
         <article class="global" data-name="workspace">
            <h2>workspace</h2>
            <hr />
            
            <pre><code>workspace</code></pre>
         </article>
         
         <article class="global" data-name="ErrDisallowed">
            <h2>ErrDisallowed</h2>
            <hr />
            
            <p>ErrDisallowed is returned by version predicates passed to Query and similar
functions to indicate that a version should not be considered.</p>
            
            <pre><code>ErrDisallowed</code></pre>
         </article>
         
         <article class="global" data-name="errExcluded">
            <h2>errExcluded</h2>
            <hr />
            
            <pre><code>errExcluded</code></pre>
         </article>
         
         <article class="global" data-name="rawGoVersion">
            <h2>rawGoVersion</h2>
            <hr />
            
            <p>rawGoVersion records the Go version parsed from each module's go.mod file.

If a module is replaced, the version of the replacement is keyed by the
replacement module.Version, not the version being replaced.</p>
            
            <pre><code>rawGoVersion sync.Map</code></pre>
         </article>
         
         <article class="global" data-name="rawGoModSummaryCache">
            <h2>rawGoModSummaryCache</h2>
            <hr />
            
            <pre><code>rawGoModSummaryCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="latestVersionIgnoringRetractionsCache">
            <h2>latestVersionIgnoringRetractionsCache</h2>
            <hr />
            
            <pre><code>latestVersionIgnoringRetractionsCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="haveGoModCache">
            <h2>haveGoModCache</h2>
            <hr />
            
            <pre><code>haveGoModCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="haveGoFilesCache">
            <h2>haveGoFilesCache</h2>
            <hr />
            
            <pre><code>haveGoFilesCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="vendorOnce">
            <h2>vendorOnce</h2>
            <hr />
            
            <pre><code>vendorOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="vendorList">
            <h2>vendorList</h2>
            <hr />
            
            <pre><code>vendorList []module.Version</code></pre>
         </article>
         
         <article class="global" data-name="vendorReplaced">
            <h2>vendorReplaced</h2>
            <hr />
            
            <pre><code>vendorReplaced []module.Version</code></pre>
         </article>
         
         <article class="global" data-name="vendorVersion">
            <h2>vendorVersion</h2>
            <hr />
            
            <pre><code>vendorVersion *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="vendorPkgModule">
            <h2>vendorPkgModule</h2>
            <hr />
            
            <pre><code>vendorPkgModule *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="vendorMeta">
            <h2>vendorMeta</h2>
            <hr />
            
            <pre><code>vendorMeta *ast.MapType</code></pre>
         </article>
          
         <article class="struct" data-name="Requirements">
            <h2>type Requirements struct</h2>
            <hr />
            
            <p>A Requirements represents a logically-immutable set of root module requirements.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pruning modPruning
rootModules []module.Version
maxRootVersion *ast.MapType
direct *ast.MapType
graphOnce sync.Once
graph *ast.IndexExpr</code></pre>
         </article>
         
         <article class="struct" data-name="cachedGraph">
            <h2>type cachedGraph struct</h2>
            <hr />
            
            <p>A cachedGraph is a non-nil *ModuleGraph, together with any error discovered
while loading that graph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mg *ModuleGraph
err error</code></pre>
         </article>
         
         <article class="struct" data-name="ModuleGraph">
            <h2>type ModuleGraph struct</h2>
            <hr />
            
            <p>A ModuleGraph represents the complete graph of module dependencies
of a main module.

If the main module supports module graph pruning, the graph does not include
transitive dependencies of non-root (implicit) dependencies.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">g *mvs.Graph
loadCache *ast.IndexListExpr
buildListOnce sync.Once
buildList []module.Version</code></pre>
         </article>
         
         <article class="struct" data-name="ConstraintError">
            <h2>type ConstraintError struct</h2>
            <hr />
            
            <p>A ConstraintError describes inconsistent constraints in EditBuildList</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Conflicts []Conflict</code></pre>
         </article>
         
         <article class="struct" data-name="Conflict">
            <h2>type Conflict struct</h2>
            <hr />
            
            <p>A Conflict is a path of requirements starting at a root or proposed root in
the requirement graph, explaining why that root either causes a module passed
in the mustSelect list to EditBuildList to be unattainable, or introduces an
unresolvable error in loading the requirement graph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path []module.Version
Constraint module.Version
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="PackageOpts">
            <h2>type PackageOpts struct</h2>
            <hr />
            
            <p>PackageOpts control the behavior of the LoadPackages function.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">TidyGoVersion string
Tags *ast.MapType
Tidy bool
TidyDiff bool
TidyCompatibleVersion string
VendorModulesInGOROOTSrc bool
ResolveMissingImports bool
AssumeRootsImported bool
AllowPackage func
LoadTests bool
UseVendorAll bool
AllowErrors bool
SilencePackageErrors bool
SilenceMissingStdImports bool
SilenceNoGoErrors bool
SilenceUnmatchedWarnings bool
MainModule module.Version
Switcher gover.Switcher</code></pre>
         </article>
         
         <article class="struct" data-name="loader">
            <h2>type loader struct</h2>
            <hr />
            
            <p>A loader manages the process of loading information about
the required packages for a particular build,
checking that the packages are available in the module set,
and updating the module set if needed.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">loaderParams
allClosesOverTests bool
skipImportModFiles bool
work *par.Queue
roots []*loadPkg
pkgCache **ast.IndexListExpr
pkgs []*loadPkg</code></pre>
         </article>
         
         <article class="struct" data-name="loaderParams">
            <h2>type loaderParams struct</h2>
            <hr />
            
            <p>loaderParams configure the packages loaded by, and the properties reported
by, a loader instance.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">PackageOpts
requirements *Requirements
allPatternIsRoot bool
listRoots func</code></pre>
         </article>
         
         <article class="struct" data-name="loadPkg">
            <h2>type loadPkg struct</h2>
            <hr />
            
            <p>A loadPkg records information about a single loaded package.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
testOf *loadPkg
flags atomicLoadPkgFlags
mod module.Version
dir string
err error
imports []*loadPkg
testImports []string
inStd bool
altMods []module.Version
testOnce sync.Once
test *loadPkg
stack *loadPkg</code></pre>
         </article>
         
         <article class="struct" data-name="atomicLoadPkgFlags">
            <h2>type atomicLoadPkgFlags struct</h2>
            <hr />
            
            <p>An atomicLoadPkgFlags stores a loadPkgFlags for which individual flags can be
added atomically.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">bits atomic.Int32</code></pre>
         </article>
         
         <article class="struct" data-name="queryDisabledError">
            <h2>type queryDisabledError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="queryMatcher">
            <h2>type queryMatcher struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
prefix string
filter func
allowed AllowedFunc
canStat bool
preferLower bool
mayUseLatest bool
preferIncompatible bool</code></pre>
         </article>
         
         <article class="struct" data-name="QueryResult">
            <h2>type QueryResult struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mod module.Version
Rev *modfetch.RevInfo
Packages []string</code></pre>
         </article>
         
         <article class="struct" data-name="NoMatchingVersionError">
            <h2>type NoMatchingVersionError struct</h2>
            <hr />
            
            <p>A NoMatchingVersionError indicates that Query found a module at the requested
path, but not at any versions satisfying the query string and allow-function.

NOTE: NoMatchingVersionError MUST NOT implement Is(fs.ErrNotExist).

If the module came from a proxy, that proxy had to return a successful status
code for the versions it knows about, and thus did not have the opportunity
to return a non-400 status code to suppress fallback.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">query string
current string</code></pre>
         </article>
         
         <article class="struct" data-name="NoPatchBaseError">
            <h2>type NoPatchBaseError struct</h2>
            <hr />
            
            <p>A NoPatchBaseError indicates that Query was called with the query "patch"
but with a current version of "" or "none".</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string</code></pre>
         </article>
         
         <article class="struct" data-name="WildcardInFirstElementError">
            <h2>type WildcardInFirstElementError struct</h2>
            <hr />
            
            <p>A WildcardInFirstElementError indicates that a pattern passed to QueryPattern
had a wildcard in its first path element, and therefore had no pattern-prefix
modules to search in.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pattern string
Query string</code></pre>
         </article>
         
         <article class="struct" data-name="PackageNotInModuleError">
            <h2>type PackageNotInModuleError struct</h2>
            <hr />
            
            <p>A PackageNotInModuleError indicates that QueryPattern found a candidate
module at the requested version, but that module did not contain any packages
matching the requested pattern.

NOTE: PackageNotInModuleError MUST NOT implement Is(fs.ErrNotExist).

If the module came from a proxy, that proxy had to return a successful status
code for the versions it knows about, and thus did not have the opportunity
to return a non-400 status code to suppress fallback.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">MainModules []module.Version
Mod module.Version
Replacement module.Version
Query string
Pattern string</code></pre>
         </article>
         
         <article class="struct" data-name="emptyRepo">
            <h2>type emptyRepo struct</h2>
            <hr />
            
            <p>An emptyRepo is a versionRepo that contains no versions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
err error</code></pre>
         </article>
         
         <article class="struct" data-name="replacementRepo">
            <h2>type replacementRepo struct</h2>
            <hr />
            
            <p>A replacementRepo augments a versionRepo to include the replacement versions
(if any) found in the main module's go.mod file.

A replacementRepo suppresses "not found" errors for otherwise-nonexistent
modules, so a replacementRepo should only be constructed for a module that
actually has one or more valid replacements.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">repo versionRepo</code></pre>
         </article>
         
         <article class="struct" data-name="QueryMatchesMainModulesError">
            <h2>type QueryMatchesMainModulesError struct</h2>
            <hr />
            
            <p>A QueryMatchesMainModulesError indicates that a query requests
a version of the main module that cannot be satisfied.
(The main module's version cannot be changed.)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">MainModules []module.Version
Pattern string
Query string</code></pre>
         </article>
         
         <article class="struct" data-name="QueryUpgradesAllError">
            <h2>type QueryUpgradesAllError struct</h2>
            <hr />
            
            <p>A QueryUpgradesAllError indicates that a query requests
an upgrade on the all pattern.
(The main module's version cannot be changed.)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">MainModules []module.Version
Query string</code></pre>
         </article>
         
         <article class="struct" data-name="QueryMatchesPackagesInMainModuleError">
            <h2>type QueryMatchesPackagesInMainModuleError struct</h2>
            <hr />
            
            <p>A QueryMatchesPackagesInMainModuleError indicates that a query cannot be
satisfied because it matches one or more packages found in the main module.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pattern string
Query string
Packages []string</code></pre>
         </article>
         
         <article class="struct" data-name="MainModuleSet">
            <h2>type MainModuleSet struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">versions []module.Version
modRoot *ast.MapType
pathPrefix *ast.MapType
inGorootSrc *ast.MapType
modFiles *ast.MapType
tools *ast.MapType
modContainingCWD module.Version
workFile *modfile.WorkFile
workFileReplaceMap *ast.MapType
highestReplaced *ast.MapType
indexMu sync.Mutex
indices *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="goModDirtyError">
            <h2>type goModDirtyError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="WriteOpts">
            <h2>type WriteOpts struct</h2>
            <hr />
            
            <p>WriteOpts control the behavior of WriteGoMod.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">DropToolchain bool
ExplicitToolchain bool
AddTools []string
DropTools []string
TidyWroteGo bool</code></pre>
         </article>
         
         <article class="struct" data-name="modFileIndex">
            <h2>type modFileIndex struct</h2>
            <hr />
            
            <p>A modFileIndex is an index of data corresponding to a modFile
at a specific point in time.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
dataNeedsFix bool
module module.Version
goVersion string
toolchain string
require *ast.MapType
replace *ast.MapType
exclude *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="requireMeta">
            <h2>type requireMeta struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">indirect bool</code></pre>
         </article>
         
         <article class="struct" data-name="excludedError">
            <h2>type excludedError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="ModuleRetractedError">
            <h2>type ModuleRetractedError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Rationale []string</code></pre>
         </article>
         
         <article class="struct" data-name="retractionLoadingError">
            <h2>type retractionLoadingError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">m module.Version
err error</code></pre>
         </article>
         
         <article class="struct" data-name="modFileSummary">
            <h2>type modFileSummary struct</h2>
            <hr />
            
            <p>A modFileSummary is a summary of a go.mod file for which we do not need to
retain complete information — for example, the go.mod file of a dependency
module.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">module module.Version
goVersion string
toolchain string
pruning modPruning
require []module.Version
retract []retraction
deprecated string</code></pre>
         </article>
         
         <article class="struct" data-name="retraction">
            <h2>type retraction struct</h2>
            <hr />
            
            <p>A retraction consists of a retracted version interval and rationale.
retraction is like modfile.Retract, but it doesn't point to the syntax tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">modfile.VersionInterval
Rationale string</code></pre>
         </article>
         
         <article class="struct" data-name="mvsReqs">
            <h2>type mvsReqs struct</h2>
            <hr />
            
            <p>mvsReqs implements mvs.Reqs for module semantic versions,
with any exclusions or replacements applied internally.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">roots []module.Version</code></pre>
         </article>
         
         <article class="struct" data-name="perPruning">
            <h2>type perPruning struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pruned T
unpruned T</code></pre>
         </article>
         
         <article class="struct" data-name="dqTracker">
            <h2>type dqTracker struct</h2>
            <hr />
            
            <p>A dqTracker tracks and propagates the reason that each module version
cannot be included in the module graph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">extendedRootPruning *ast.MapType
dqReason *ast.MapType
requiring *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="dqState">
            <h2>type dqState struct</h2>
            <hr />
            
            <p>A dqState indicates whether and why a module version is “disqualified” from
being used in a way that would incorporate its requirements.

The zero dqState indicates that the module version is not known to be
disqualified, either because it is ok or because we are currently traversing
a cycle that includes it.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">err error
dep module.Version</code></pre>
         </article>
         
         <article class="struct" data-name="ImportMissingError">
            <h2>type ImportMissingError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Module module.Version
QueryErr error
ImportingMainModule module.Version
isStd bool
importerGoVersion string
replaced module.Version
newMissingVersion string</code></pre>
         </article>
         
         <article class="struct" data-name="AmbiguousImportError">
            <h2>type AmbiguousImportError struct</h2>
            <hr />
            
            <p>An AmbiguousImportError indicates an import of a package found in multiple
modules in the build list, or found in both the main module and its vendor
directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">importPath string
Dirs []string
Modules []module.Version</code></pre>
         </article>
         
         <article class="struct" data-name="DirectImportFromImplicitDependencyError">
            <h2>type DirectImportFromImplicitDependencyError struct</h2>
            <hr />
            
            <p>A DirectImportFromImplicitDependencyError indicates a package directly
imported by a package or test in the main module that is satisfied by a
dependency that is not explicit in the main module's go.mod file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ImporterPath string
ImportedPath string
Module module.Version</code></pre>
         </article>
         
         <article class="struct" data-name="ImportMissingSumError">
            <h2>type ImportMissingSumError struct</h2>
            <hr />
            
            <p>ImportMissingSumError is reported in readonly mode when we need to check
if a module contains a package, but we don't have a sum for its .zip file.
We might need sums for multiple modules to verify the package is unique.

TODO(#43653): consolidate multiple errors of this type into a single error
that suggests a 'go get' command for root packages that transitively import
packages from modules with missing sums. load.CheckPackageErrors would be
a good place to consolidate errors, but we'll need to attach the import
stack here.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">importPath string
found bool
mods []module.Version
importer string
importerVersion string
importerIsTest bool</code></pre>
         </article>
         
         <article class="struct" data-name="invalidImportError">
            <h2>type invalidImportError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">importPath string
err error</code></pre>
         </article>
         
         <article class="struct" data-name="sumMissingError">
            <h2>type sumMissingError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">suggestion string</code></pre>
         </article>
         
         <article class="struct" data-name="vendorMetadata">
            <h2>type vendorMetadata struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Explicit bool
Replacement module.Version
GoVersion string</code></pre>
         </article>
          
         <article class="function" data-name="isStandardImportPath">
            <h2>isStandardImportPath</h2>
            <hr />
            
            <pre><code>func isStandardImportPath(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="findStandardImportPath">
            <h2>findStandardImportPath</h2>
            <hr />
            
            <pre><code>func findStandardImportPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="PackageModuleInfo">
            <h2>PackageModuleInfo</h2>
            <hr />
            
            <p>PackageModuleInfo returns information about the module that provides
a given package. If modules are not enabled or if the package is in the
standard library or if the package was not successfully loaded with
LoadPackages or ImportFromFiles, nil is returned.</p>
            
            <pre><code>func PackageModuleInfo(ctx context.Context, pkgpath string) *modinfo.ModulePublic</code></pre>
         </article>
         
         <article class="function" data-name="PackageModRoot">
            <h2>PackageModRoot</h2>
            <hr />
            
            <p>PackageModRoot returns the module root directory for the module that provides
a given package. If modules are not enabled or if the package is in the
standard library or if the package was not successfully loaded with
LoadPackages or ImportFromFiles, the empty string is returned.</p>
            
            <pre><code>func PackageModRoot(ctx context.Context, pkgpath string) string</code></pre>
         </article>
         
         <article class="function" data-name="ModuleInfo">
            <h2>ModuleInfo</h2>
            <hr />
            
            <pre><code>func ModuleInfo(ctx context.Context, path string) *modinfo.ModulePublic</code></pre>
         </article>
         
         <article class="function" data-name="addUpdate">
            <h2>addUpdate</h2>
            <hr />
            
            <p>addUpdate fills in m.Update if an updated version is available.</p>
            
            <pre><code>func addUpdate(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
         </article>
         
         <article class="function" data-name="mergeOrigin">
            <h2>mergeOrigin</h2>
            <hr />
            
            <p>mergeOrigin returns the union of data from two origins,
returning either a new origin or one of its unmodified arguments.
If the two origins conflict including if either is nil,
mergeOrigin returns nil.</p>
            
            <pre><code>func mergeOrigin(m1 *codehost.Origin, m2 *codehost.Origin) *codehost.Origin</code></pre>
         </article>
         
         <article class="function" data-name="addVersions">
            <h2>addVersions</h2>
            <hr />
            
            <p>addVersions fills in m.Versions with the list of known versions.
Excluded versions will be omitted. If listRetracted is false, retracted
versions will also be omitted.</p>
            
            <pre><code>func addVersions(ctx context.Context, m *modinfo.ModulePublic, listRetracted bool)</code></pre>
         </article>
         
         <article class="function" data-name="addRetraction">
            <h2>addRetraction</h2>
            <hr />
            
            <p>addRetraction fills in m.Retracted if the module was retracted by its author.
m.Error is set if there's an error loading retraction information.</p>
            
            <pre><code>func addRetraction(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
         </article>
         
         <article class="function" data-name="addDeprecation">
            <h2>addDeprecation</h2>
            <hr />
            
            <p>addDeprecation fills in m.Deprecated if the module was deprecated by its
author. m.Error is set if there's an error loading deprecation information.</p>
            
            <pre><code>func addDeprecation(ctx context.Context, m *modinfo.ModulePublic)</code></pre>
         </article>
         
         <article class="function" data-name="moduleInfo">
            <h2>moduleInfo</h2>
            <hr />
            
            <p>moduleInfo returns information about module m, loaded from the requirements
in rs (which may be nil to indicate that m was not loaded from a requirement
graph).</p>
            
            <pre><code>func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode ListMode, reuse *ast.MapType) *modinfo.ModulePublic</code></pre>
         </article>
         
         <article class="function" data-name="findModule">
            <h2>findModule</h2>
            <hr />
            
            <p>findModule searches for the module that contains the package at path.
If the package was loaded, its containing module and true are returned.
Otherwise, module.Version{} and false are returned.</p>
            
            <pre><code>func findModule(ld *loader, path string) (module.Version, bool)</code></pre>
         </article>
         
         <article class="function" data-name="ModInfoProg">
            <h2>ModInfoProg</h2>
            <hr />
            
            <pre><code>func ModInfoProg(info string, isgccgo bool) []byte</code></pre>
         </article>
         
         <article class="function" data-name="ModInfoData">
            <h2>ModInfoData</h2>
            <hr />
            
            <pre><code>func ModInfoData(info string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="mustHaveGoRoot">
            <h2>mustHaveGoRoot</h2>
            <hr />
            
            <pre><code>func mustHaveGoRoot(roots []module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="newRequirements">
            <h2>newRequirements</h2>
            <hr />
            
            <p>newRequirements returns a new requirement set with the given root modules.
The dependencies of the roots will be loaded lazily at the first call to the
Graph method.

The rootModules slice must be sorted according to gover.ModSort.
The caller must not modify the rootModules slice or direct map after passing
them to newRequirements.

If vendoring is in effect, the caller must invoke initVendor on the returned
*Requirements before any other method.</p>
            
            <pre><code>func newRequirements(pruning modPruning, rootModules []module.Version, direct *ast.MapType) *Requirements</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a string describing the Requirements for debugging.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="initVendor">
            <h2>initVendor</h2>
            <hr />
            
            <p>initVendor initializes rs.graph from the given list of vendored module
dependencies, overriding the graph that would normally be loaded from module
requirements.</p>
            
            <pre><code>func initVendor(vendorList []module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="GoVersion">
            <h2>GoVersion</h2>
            <hr />
            
            <p>GoVersion returns the Go language version for the Requirements.</p>
            
            <pre><code>func GoVersion() string</code></pre>
         </article>
         
         <article class="function" data-name="rootSelected">
            <h2>rootSelected</h2>
            <hr />
            
            <p>rootSelected returns the version of the root dependency with the given module
path, or the zero module.Version and ok=false if the module is not a root
dependency.</p>
            
            <pre><code>func rootSelected(path string) (version string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="hasRedundantRoot">
            <h2>hasRedundantRoot</h2>
            <hr />
            
            <p>hasRedundantRoot returns true if the root list contains multiple requirements
of the same module or a requirement on any version of the main module.
Redundant requirements should be pruned, but they may influence version
selection.</p>
            
            <pre><code>func hasRedundantRoot() bool</code></pre>
         </article>
         
         <article class="function" data-name="Graph">
            <h2>Graph</h2>
            <hr />
            
            <p>Graph returns the graph of module requirements loaded from the current
root modules (as reported by RootModules).

Graph always makes a best effort to load the requirement graph despite any
errors, and always returns a non-nil *ModuleGraph.

If the requirements of any relevant module fail to load, Graph also
returns a non-nil error of type *mvs.BuildListError.</p>
            
            <pre><code>func Graph(ctx context.Context) (*ModuleGraph, error)</code></pre>
         </article>
         
         <article class="function" data-name="IsDirect">
            <h2>IsDirect</h2>
            <hr />
            
            <p>IsDirect returns whether the given module provides a package directly
imported by a package or test in the main module.</p>
            
            <pre><code>func IsDirect(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="readModGraph">
            <h2>readModGraph</h2>
            <hr />
            
            <p>readModGraph reads and returns the module dependency graph starting at the
given roots.

The requirements of the module versions found in the unprune map are included
in the graph even if they would normally be pruned out.

Unlike LoadModGraph, readModGraph does not attempt to diagnose or update
inconsistent roots.</p>
            
            <pre><code>func readModGraph(ctx context.Context, pruning modPruning, roots []module.Version, unprune *ast.MapType) (*ModuleGraph, error)</code></pre>
         </article>
         
         <article class="function" data-name="RequiredBy">
            <h2>RequiredBy</h2>
            <hr />
            
            <p>RequiredBy returns the dependencies required by module m in the graph,
or ok=false if module m's dependencies are pruned out.

The caller must not modify the returned slice, but may safely append to it
and may rely on it not to be modified.</p>
            
            <pre><code>func RequiredBy(m module.Version) (reqs []module.Version, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="Selected">
            <h2>Selected</h2>
            <hr />
            
            <p>Selected returns the selected version of the module with the given path.

If no version is selected, Selected returns version "none".</p>
            
            <pre><code>func Selected(path string) version string</code></pre>
         </article>
         
         <article class="function" data-name="WalkBreadthFirst">
            <h2>WalkBreadthFirst</h2>
            <hr />
            
            <p>WalkBreadthFirst invokes f once, in breadth-first order, for each module
version other than "none" that appears in the graph, regardless of whether
that version is selected.</p>
            
            <pre><code>func WalkBreadthFirst(f func)</code></pre>
         </article>
         
         <article class="function" data-name="BuildList">
            <h2>BuildList</h2>
            <hr />
            
            <p>BuildList returns the selected versions of all modules present in the graph,
beginning with the main modules.

The order of the remaining elements in the list is deterministic
but arbitrary.

The caller must not modify the returned list, but may safely append to it
and may rely on it not to be modified.</p>
            
            <pre><code>func BuildList() []module.Version</code></pre>
         </article>
         
         <article class="function" data-name="findError">
            <h2>findError</h2>
            <hr />
            
            <pre><code>func findError() error</code></pre>
         </article>
         
         <article class="function" data-name="allRootsSelected">
            <h2>allRootsSelected</h2>
            <hr />
            
            <pre><code>func allRootsSelected() bool</code></pre>
         </article>
         
         <article class="function" data-name="LoadModGraph">
            <h2>LoadModGraph</h2>
            <hr />
            
            <p>LoadModGraph loads and returns the graph of module dependencies of the main module,
without loading any packages.

If the goVersion string is non-empty, the returned graph is the graph
as interpreted by the given Go version (instead of the version indicated
in the go.mod file).

Modules are loaded automatically (and lazily) in LoadPackages:
LoadModGraph need only be called if LoadPackages is not,
typically in commands that care about modules but no particular package.</p>
            
            <pre><code>func LoadModGraph(ctx context.Context, goVersion string) (*ModuleGraph, error)</code></pre>
         </article>
         
         <article class="function" data-name="expandGraph">
            <h2>expandGraph</h2>
            <hr />
            
            <p>expandGraph loads the complete module graph from rs.

If the complete graph reveals that some root of rs is not actually the
selected version of its path, expandGraph computes a new set of roots that
are consistent. (With a pruned module graph, this may result in upgrades to
other modules due to requirements that were previously pruned out.)

expandGraph returns the updated roots, along with the module graph loaded
from those roots and any error encountered while loading that graph.
expandGraph returns non-nil requirements and a non-nil graph regardless of
errors. On error, the roots might not be updated to be consistent.</p>
            
            <pre><code>func expandGraph(ctx context.Context, rs *Requirements) (*Requirements, *ModuleGraph, error)</code></pre>
         </article>
         
         <article class="function" data-name="EditBuildList">
            <h2>EditBuildList</h2>
            <hr />
            
            <p>EditBuildList edits the global build list by first adding every module in add
to the existing build list, then adjusting versions (and adding or removing
requirements as needed) until every module in mustSelect is selected at the
given version.

(Note that the newly-added modules might not be selected in the resulting
build list: they could be lower than existing requirements or conflict with
versions in mustSelect.)

If the versions listed in mustSelect are mutually incompatible (due to one of
the listed modules requiring a higher version of another), EditBuildList
returns a *ConstraintError and leaves the build list in its previous state.

On success, EditBuildList reports whether the selected version of any module
in the build list may have been changed (possibly to or from "none") as a
result.</p>
            
            <pre><code>func EditBuildList(ctx context.Context, add []module.Version, mustSelect []module.Version) (changed bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="OverrideRoots">
            <h2>OverrideRoots</h2>
            <hr />
            
            <p>OverrideRoots edits the global requirement roots by replacing the specific module versions.</p>
            
            <pre><code>func OverrideRoots(ctx context.Context, replace []module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="overrideRoots">
            <h2>overrideRoots</h2>
            <hr />
            
            <pre><code>func overrideRoots(ctx context.Context, rs *Requirements, replace []module.Version) *Requirements</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="UnwrapModuleError">
            <h2>UnwrapModuleError</h2>
            <hr />
            
            <p>UnwrapModuleError returns c.Err, but unwraps it if it is a module.ModuleError
with a version and path matching the last entry in the Path slice.</p>
            
            <pre><code>func UnwrapModuleError() error</code></pre>
         </article>
         
         <article class="function" data-name="Summary">
            <h2>Summary</h2>
            <hr />
            
            <p>Summary returns a string that describes only the first and last modules in
the conflict path.</p>
            
            <pre><code>func Summary() string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a string that describes the full conflict path.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="tidyRoots">
            <h2>tidyRoots</h2>
            <hr />
            
            <p>tidyRoots trims the root dependencies to the minimal requirements needed to
both retain the same versions of all packages in pkgs and satisfy the
graph-pruning invariants (if applicable).</p>
            
            <pre><code>func tidyRoots(ctx context.Context, rs *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="updateRoots">
            <h2>updateRoots</h2>
            <hr />
            
            <pre><code>func updateRoots(ctx context.Context, direct *ast.MapType, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="updateWorkspaceRoots">
            <h2>updateWorkspaceRoots</h2>
            <hr />
            
            <pre><code>func updateWorkspaceRoots(ctx context.Context, direct *ast.MapType, rs *Requirements, add []module.Version) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="tidyPrunedRoots">
            <h2>tidyPrunedRoots</h2>
            <hr />
            
            <p>tidyPrunedRoots returns a minimal set of root requirements that maintains the
invariants of the go.mod file needed to support graph pruning for the given
packages:

 1. For each package marked with pkgInAll, the module path that provided that
    package is included as a root.
 2. For all packages, the module that provided that package either remains
    selected at the same version or is upgraded by the dependencies of a
    root.

If any module that provided a package has been upgraded above its previous
version, the caller may need to reload and recompute the package graph.

To ensure that the loading process eventually converges, the caller should
add any needed roots from the tidy root set (without removing existing untidy
roots) until the set of roots has converged.</p>
            
            <pre><code>func tidyPrunedRoots(ctx context.Context, mainModule module.Version, old *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="updatePrunedRoots">
            <h2>updatePrunedRoots</h2>
            <hr />
            
            <p>updatePrunedRoots returns a set of root requirements that maintains the
invariants of the go.mod file needed to support graph pruning:

 1. The selected version of the module providing each package marked with
    either pkgInAll or pkgIsRoot is included as a root.
    Note that certain root patterns (such as '...') may explode the root set
    to contain every module that provides any package imported (or merely
    required) by any other module.
 2. Each root appears only once, at the selected version of its path
    (if rs.graph is non-nil) or at the highest version otherwise present as a
    root (otherwise).
 3. Every module path that appears as a root in rs remains a root.
 4. Every version in add is selected at its given version unless upgraded by
    (the dependencies of) an existing root or another module in add.

The packages in pkgs are assumed to have been loaded from either the roots of
rs or the modules selected in the graph of rs.

The above invariants together imply the graph-pruning invariants for the
go.mod file:

 1. (The import invariant.) Every module that provides a package transitively
    imported by any package or test in the main module is included as a root.
    This follows by induction from (1) and (3) above. Transitively-imported
    packages loaded during this invocation are marked with pkgInAll (1),
    and by hypothesis any transitively-imported packages loaded in previous
    invocations were already roots in rs (3).

 2. (The argument invariant.) Every module that provides a package matching
    an explicit package pattern is included as a root. This follows directly
    from (1): packages matching explicit package patterns are marked with
    pkgIsRoot.

 3. (The completeness invariant.) Every module that contributed any package
    to the build is required by either the main module or one of the modules
    it requires explicitly. This invariant is left up to the caller, who must
    not load packages from outside the module graph but may add roots to the
    graph, but is facilitated by (3). If the caller adds roots to the graph in
    order to resolve missing packages, then updatePrunedRoots will retain them,
    the selected versions of those roots cannot regress, and they will
    eventually be written back to the main module's go.mod file.

(See https://golang.org/design/36460-lazy-module-loading#invariants for more
detail.)</p>
            
            <pre><code>func updatePrunedRoots(ctx context.Context, direct *ast.MapType, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="spotCheckRoots">
            <h2>spotCheckRoots</h2>
            <hr />
            
            <p>spotCheckRoots reports whether the versions of the roots in rs satisfy the
explicit requirements of the modules in mods.</p>
            
            <pre><code>func spotCheckRoots(ctx context.Context, rs *Requirements, mods *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="tidyUnprunedRoots">
            <h2>tidyUnprunedRoots</h2>
            <hr />
            
            <p>tidyUnprunedRoots returns a minimal set of root requirements that maintains
the selected version of every module that provided or lexically could have
provided a package in pkgs, and includes the selected version of every such
module in direct as a root.</p>
            
            <pre><code>func tidyUnprunedRoots(ctx context.Context, mainModule module.Version, old *Requirements, pkgs []*loadPkg) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="updateUnprunedRoots">
            <h2>updateUnprunedRoots</h2>
            <hr />
            
            <p>updateUnprunedRoots returns a set of root requirements that includes the selected
version of every module path in direct as a root, and maintains the selected
version of every module selected in the graph of rs.

The roots are updated such that:

 1. The selected version of every module path in direct is included as a root
    (if it is not "none").
 2. Each root is the selected version of its path. (We say that such a root
    set is “consistent”.)
 3. Every version selected in the graph of rs remains selected unless upgraded
    by a dependency in add.
 4. Every version in add is selected at its given version unless upgraded by
    (the dependencies of) an existing root or another module in add.</p>
            
            <pre><code>func updateUnprunedRoots(ctx context.Context, direct *ast.MapType, rs *Requirements, add []module.Version) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="convertPruning">
            <h2>convertPruning</h2>
            <hr />
            
            <p>convertPruning returns a version of rs with the given pruning behavior.
If rs already has the given pruning, convertPruning returns rs unmodified.</p>
            
            <pre><code>func convertPruning(ctx context.Context, rs *Requirements, pruning modPruning) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestQueryImport">
            <h2>TestQueryImport</h2>
            <hr />
            
            <pre><code>func TestQueryImport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="LoadPackages">
            <h2>LoadPackages</h2>
            <hr />
            
            <p>LoadPackages identifies the set of packages matching the given patterns and
loads the packages in the import graph rooted at that set.</p>
            
            <pre><code>func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (matches []*search.Match, loadedPackages []string)</code></pre>
         </article>
         
         <article class="function" data-name="matchLocalDirs">
            <h2>matchLocalDirs</h2>
            <hr />
            
            <p>matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories
outside of the standard library and active modules.</p>
            
            <pre><code>func matchLocalDirs(ctx context.Context, modRoots []string, m *search.Match, rs *Requirements)</code></pre>
         </article>
         
         <article class="function" data-name="resolveLocalPackage">
            <h2>resolveLocalPackage</h2>
            <hr />
            
            <p>resolveLocalPackage resolves a filesystem path to a package path.</p>
            
            <pre><code>func resolveLocalPackage(ctx context.Context, dir string, rs *Requirements) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="pathInModuleCache">
            <h2>pathInModuleCache</h2>
            <hr />
            
            <p>pathInModuleCache returns the import path of the directory dir,
if dir is in the module cache copy of a module in our build list.</p>
            
            <pre><code>func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string</code></pre>
         </article>
         
         <article class="function" data-name="ImportFromFiles">
            <h2>ImportFromFiles</h2>
            <hr />
            
            <p>ImportFromFiles adds modules to the build list as needed
to satisfy the imports in the named Go source files.

Errors in missing dependencies are silenced.

TODO(bcmills): Silencing errors seems off. Take a closer look at this and
figure out what the error-reporting actually ought to be.</p>
            
            <pre><code>func ImportFromFiles(ctx context.Context, gofiles []string)</code></pre>
         </article>
         
         <article class="function" data-name="DirImportPath">
            <h2>DirImportPath</h2>
            <hr />
            
            <p>DirImportPath returns the effective import path for dir,
provided it is within a main module, or else returns ".".</p>
            
            <pre><code>func DirImportPath(ctx context.Context, dir string) (path string, m module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="PackageModule">
            <h2>PackageModule</h2>
            <hr />
            
            <p>PackageModule returns the module providing the package named by the import path.</p>
            
            <pre><code>func PackageModule(path string) module.Version</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Lookup returns the source directory, import path, and any loading error for
the package at path as imported from the package in parentDir.
Lookup requires that one of the Load functions in this package has already
been called.</p>
            
            <pre><code>func Lookup(parentPath string, parentIsStd bool, path string) (dir string, realPath string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <pre><code>func reset()</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <p>error reports an error via either os.Stderr or base.Error,
according to whether ld.AllowErrors is set.</p>
            
            <pre><code>func error(err error)</code></pre>
         </article>
         
         <article class="function" data-name="switchIfErrors">
            <h2>switchIfErrors</h2>
            <hr />
            
            <p>switchIfErrors switches toolchains if a switch is needed.</p>
            
            <pre><code>func switchIfErrors(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="exitIfErrors">
            <h2>exitIfErrors</h2>
            <hr />
            
            <p>exitIfErrors switches toolchains if a switch is needed
or else exits if any errors have been reported.</p>
            
            <pre><code>func exitIfErrors(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="goVersion">
            <h2>goVersion</h2>
            <hr />
            
            <p>goVersion reports the Go version that should be used for the loader's
requirements: ld.TidyGoVersion if set, or ld.requirements.GoVersion()
otherwise.</p>
            
            <pre><code>func goVersion() string</code></pre>
         </article>
         
         <article class="function" data-name="has">
            <h2>has</h2>
            <hr />
            
            <p>has reports whether all of the flags in cond are set in f.</p>
            
            <pre><code>func has(cond loadPkgFlags) bool</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <p>update sets the given flags in af (in addition to any flags already set).

update returns the previous flag state so that the caller may determine which
flags were newly-set.</p>
            
            <pre><code>func update(flags loadPkgFlags) old loadPkgFlags</code></pre>
         </article>
         
         <article class="function" data-name="has">
            <h2>has</h2>
            <hr />
            
            <p>has reports whether all of the flags in cond are set in af.</p>
            
            <pre><code>func has(cond loadPkgFlags) bool</code></pre>
         </article>
         
         <article class="function" data-name="isTest">
            <h2>isTest</h2>
            <hr />
            
            <p>isTest reports whether pkg is a test of another package.</p>
            
            <pre><code>func isTest() bool</code></pre>
         </article>
         
         <article class="function" data-name="fromExternalModule">
            <h2>fromExternalModule</h2>
            <hr />
            
            <p>fromExternalModule reports whether pkg was loaded from a module other than
the main module.</p>
            
            <pre><code>func fromExternalModule() bool</code></pre>
         </article>
         
         <article class="function" data-name="loadFromRoots">
            <h2>loadFromRoots</h2>
            <hr />
            
            <p>loadFromRoots attempts to load the build graph needed to process a set of
root packages and their dependencies.

The set of root packages is returned by the params.listRoots function, and
expanded to the full set of packages by tracing imports (and possibly tests)
as needed.</p>
            
            <pre><code>func loadFromRoots(ctx context.Context, params loaderParams) *loader</code></pre>
         </article>
         
         <article class="function" data-name="updateRequirements">
            <h2>updateRequirements</h2>
            <hr />
            
            <p>updateRequirements ensures that ld.requirements is consistent with the
information gained from ld.pkgs.

In particular:

  - Modules that provide packages directly imported from the main module are
    marked as direct, and are promoted to explicit roots. If a needed root
    cannot be promoted due to -mod=readonly or -mod=vendor, the importing
    package is marked with an error.

  - If ld scanned the "all" pattern independent of build constraints, it is
    guaranteed to have seen every direct import. Module dependencies that did
    not provide any directly-imported package are then marked as indirect.

  - Root dependencies are updated to their selected versions.

The "changed" return value reports whether the update changed the selected
version of any module that either provided a loaded package or may now
provide a package that was previously unresolved.</p>
            
            <pre><code>func updateRequirements(ctx context.Context) (changed bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="resolveMissingImports">
            <h2>resolveMissingImports</h2>
            <hr />
            
            <p>resolveMissingImports returns a set of modules that could be added as
dependencies in order to resolve missing packages from pkgs.

The newly-resolved packages are added to the addedModuleFor map, and
resolveMissingImports returns a map from each new module version to
the first missing package that module would resolve.</p>
            
            <pre><code>func resolveMissingImports(ctx context.Context) (modAddedBy *ast.MapType, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pkg">
            <h2>pkg</h2>
            <hr />
            
            <p>pkg locates the *loadPkg for path, creating and queuing it for loading if
needed, and updates its state to reflect the given flags.

The imports of the returned *loadPkg will be loaded asynchronously in the
ld.work queue, and its test (if requested) will also be populated once
imports have been resolved. When ld.work goes idle, all transitive imports of
the requested package (and its test, if requested) will have been loaded.</p>
            
            <pre><code>func pkg(ctx context.Context, path string, flags loadPkgFlags) *loadPkg</code></pre>
         </article>
         
         <article class="function" data-name="applyPkgFlags">
            <h2>applyPkgFlags</h2>
            <hr />
            
            <p>applyPkgFlags updates pkg.flags to set the given flags and propagate the
(transitive) effects of those flags, possibly loading or enqueueing further
packages as a result.</p>
            
            <pre><code>func applyPkgFlags(ctx context.Context, pkg *loadPkg, flags loadPkgFlags)</code></pre>
         </article>
         
         <article class="function" data-name="preloadRootModules">
            <h2>preloadRootModules</h2>
            <hr />
            
            <p>preloadRootModules loads the module requirements needed to identify the
selected version of each module providing a package in rootPkgs,
adding new root modules to the module graph if needed.</p>
            
            <pre><code>func preloadRootModules(ctx context.Context, rootPkgs []string) changedBuildList bool</code></pre>
         </article>
         
         <article class="function" data-name="load">
            <h2>load</h2>
            <hr />
            
            <p>load loads an individual package.</p>
            
            <pre><code>func load(ctx context.Context, pkg *loadPkg)</code></pre>
         </article>
         
         <article class="function" data-name="pkgTest">
            <h2>pkgTest</h2>
            <hr />
            
            <p>pkgTest locates the test of pkg, creating it if needed, and updates its state
to reflect the given flags.

pkgTest requires that the imports of pkg have already been loaded (flagged
with pkgImportsLoaded).</p>
            
            <pre><code>func pkgTest(ctx context.Context, pkg *loadPkg, testFlags loadPkgFlags) *loadPkg</code></pre>
         </article>
         
         <article class="function" data-name="stdVendor">
            <h2>stdVendor</h2>
            <hr />
            
            <p>stdVendor returns the canonical import path for the package with the given
path when imported from the standard-library package at parentPath.</p>
            
            <pre><code>func stdVendor(parentPath string, path string) string</code></pre>
         </article>
         
         <article class="function" data-name="computePatternAll">
            <h2>computePatternAll</h2>
            <hr />
            
            <p>computePatternAll returns the list of packages matching pattern "all",
starting with a list of the import paths for the packages in the main module.</p>
            
            <pre><code>func computePatternAll() all []string</code></pre>
         </article>
         
         <article class="function" data-name="checkMultiplePaths">
            <h2>checkMultiplePaths</h2>
            <hr />
            
            <p>checkMultiplePaths verifies that a given module path is used as itself
or as a replacement for another module, but not both at the same time.

(See https://golang.org/issue/26607 and https://golang.org/issue/34650.)</p>
            
            <pre><code>func checkMultiplePaths()</code></pre>
         </article>
         
         <article class="function" data-name="checkTidyCompatibility">
            <h2>checkTidyCompatibility</h2>
            <hr />
            
            <p>checkTidyCompatibility emits an error if any package would be loaded from a
different module under rs than under ld.requirements.</p>
            
            <pre><code>func checkTidyCompatibility(ctx context.Context, rs *Requirements, compatVersion string)</code></pre>
         </article>
         
         <article class="function" data-name="scanDir">
            <h2>scanDir</h2>
            <hr />
            
            <p>scanDir is like imports.ScanDir but elides known magic imports from the list,
so that we do not go looking for packages that don't really exist.

The standard magic import is "C", for cgo.

The only other known magic imports are appengine and appengine/*.
These are so old that they predate "go get" and did not use URL-like paths.
Most code today now uses google.golang.org/appengine instead,
but not all code has been so updated. When we mostly ignore build tags
during "go vendor", we look into "// +build appengine" files and
may see these legacy imports. We drop them so that the module
search does not look for modules to try to satisfy them.</p>
            
            <pre><code>func scanDir(modroot string, dir string, tags *ast.MapType) (imports_ []string, testImports []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="buildStacks">
            <h2>buildStacks</h2>
            <hr />
            
            <p>buildStacks computes minimal import stacks for each package,
for use in error messages. When it completes, packages that
are part of the original root set have pkg.stack == nil,
and other packages have pkg.stack pointing at the next
package up the import stack in their minimal chain.
As a side effect, buildStacks also constructs ld.pkgs,
the list of all packages loaded.</p>
            
            <pre><code>func buildStacks()</code></pre>
         </article>
         
         <article class="function" data-name="stackText">
            <h2>stackText</h2>
            <hr />
            
            <p>stackText builds the import stack text to use when
reporting an error in pkg. It has the general form

	root imports
		other imports
		other2 tested by
		other2.test imports
		pkg</p>
            
            <pre><code>func stackText() string</code></pre>
         </article>
         
         <article class="function" data-name="why">
            <h2>why</h2>
            <hr />
            
            <p>why returns the text to use in "go mod why" output about the given package.
It is less ornate than the stackText but contains the same information.</p>
            
            <pre><code>func why() string</code></pre>
         </article>
         
         <article class="function" data-name="Why">
            <h2>Why</h2>
            <hr />
            
            <p>Why returns the "go mod why" output stanza for the given package,
without the leading # comment.
The package graph must have been loaded already, usually by LoadPackages.
If there is no reason for the package to be in the current build,
Why returns an empty string.</p>
            
            <pre><code>func Why(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="WhyDepth">
            <h2>WhyDepth</h2>
            <hr />
            
            <p>WhyDepth returns the number of steps in the Why listing.
If there is no reason for the package to be in the current build,
WhyDepth returns 0.</p>
            
            <pre><code>func WhyDepth(path string) int</code></pre>
         </article>
         
         <article class="function" data-name="Query">
            <h2>Query</h2>
            <hr />
            
            <p>Query looks up a revision of a given module given a version query string.
The module must be a complete module path.
The version must take one of the following forms:

  - the literal string "latest", denoting the latest available, allowed
    tagged version, with non-prereleases preferred over prereleases.
    If there are no tagged versions in the repo, latest returns the most
    recent commit.

  - the literal string "upgrade", equivalent to "latest" except that if
    current is a newer version, current will be returned (see below).

  - the literal string "patch", denoting the latest available tagged version
    with the same major and minor number as current (see below).

  - v1, denoting the latest available tagged version v1.x.x.

  - v1.2, denoting the latest available tagged version v1.2.x.

  - v1.2.3, a semantic version string denoting that tagged version.

  - <v1.2.3, <=v1.2.3, >v1.2.3, >=v1.2.3,
    denoting the version closest to the target and satisfying the given operator,
    with non-prereleases preferred over prereleases.

  - a repository commit identifier or tag, denoting that commit.

current denotes the currently-selected version of the module; it may be
"none" if no version is currently selected, or "" if the currently-selected
version is unknown or should not be considered. If query is
"upgrade" or "patch", current will be returned if it is a newer
semantic version or a chronologically later pseudo-version than the
version that would otherwise be chosen. This prevents accidental downgrades
from newer pre-release or development versions.

The allowed function (which may be nil) is used to filter out unsuitable
versions (see AllowedFunc documentation for details). If the query refers to
a specific revision (for example, "master"; see IsRevisionQuery), and the
revision is disallowed by allowed, Query returns the error. If the query
does not refer to a specific revision (for example, "latest"), Query
acts as if versions disallowed by allowed do not exist.

If path is the path of the main module and the query is "latest",
Query returns Target.Version as the version.

Query often returns a non-nil *RevInfo with a non-nil error,
to provide an info.Origin that can allow the error to be cached.</p>
            
            <pre><code>func Query(ctx context.Context, path string, query string, current string, allowed AllowedFunc) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="queryReuse">
            <h2>queryReuse</h2>
            <hr />
            
            <p>queryReuse is like Query but also takes a map of module info that can be reused
if the validation criteria in Origin are met.</p>
            
            <pre><code>func queryReuse(ctx context.Context, path string, query string, current string, allowed AllowedFunc, reuse *ast.MapType) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="checkReuse">
            <h2>checkReuse</h2>
            <hr />
            
            <p>checkReuse checks whether a revision of a given module
for a given module may be reused, according to the information in origin.</p>
            
            <pre><code>func checkReuse(ctx context.Context, m module.Version, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="checkReuseRepo">
            <h2>checkReuseRepo</h2>
            <hr />
            
            <pre><code>func checkReuseRepo(ctx context.Context, repo versionRepo, path string, query string, origin *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="queryProxy">
            <h2>queryProxy</h2>
            <hr />
            
            <pre><code>func queryProxy(ctx context.Context, proxy string, path string, query string, current string, allowed AllowedFunc, reuse *ast.MapType) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="IsRevisionQuery">
            <h2>IsRevisionQuery</h2>
            <hr />
            
            <p>IsRevisionQuery returns true if vers is a version query that may refer to
a particular version or revision in a repository like "v1.0.0", "master",
or "0123abcd". IsRevisionQuery returns false if vers is a query that
chooses from among available versions like "latest" or ">v1.0.0".</p>
            
            <pre><code>func IsRevisionQuery(path string, vers string) bool</code></pre>
         </article>
         
         <article class="function" data-name="newQueryMatcher">
            <h2>newQueryMatcher</h2>
            <hr />
            
            <p>newQueryMatcher returns a new queryMatcher that matches the versions
specified by the given query on the module with the given path.

If the query can only be resolved by statting a non-SemVer revision,
newQueryMatcher returns errRevQuery.</p>
            
            <pre><code>func newQueryMatcher(path string, query string, current string, allowed AllowedFunc) (*queryMatcher, error)</code></pre>
         </article>
         
         <article class="function" data-name="allowsVersion">
            <h2>allowsVersion</h2>
            <hr />
            
            <p>allowsVersion reports whether version v is allowed by the prefix, filter, and
AllowedFunc of qm.</p>
            
            <pre><code>func allowsVersion(ctx context.Context, v string) bool</code></pre>
         </article>
         
         <article class="function" data-name="filterVersions">
            <h2>filterVersions</h2>
            <hr />
            
            <p>filterVersions classifies versions into releases and pre-releases, filtering
out:
 1. versions that do not satisfy the 'allowed' predicate, and
 2. "+incompatible" versions, if a compatible one satisfies the predicate
    and the incompatible version is not preferred.

If the allowed predicate returns an error not equivalent to ErrDisallowed,
filterVersions returns that error.</p>
            
            <pre><code>func filterVersions(ctx context.Context, versions []string) (releases []string, prereleases []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="QueryPackages">
            <h2>QueryPackages</h2>
            <hr />
            
            <p>QueryPackages is like QueryPattern, but requires that the pattern match at
least one package and omits the non-package result (if any).</p>
            
            <pre><code>func QueryPackages(ctx context.Context, pattern string, query string, current func, allowed AllowedFunc) ([]QueryResult, error)</code></pre>
         </article>
         
         <article class="function" data-name="QueryPattern">
            <h2>QueryPattern</h2>
            <hr />
            
            <p>QueryPattern looks up the module(s) containing at least one package matching
the given pattern at the given version. The results are sorted by module path
length in descending order. If any proxy provides a non-empty set of candidate
modules, no further proxies are tried.

For wildcard patterns, QueryPattern looks in modules with package paths up to
the first "..." in the pattern. For the pattern "example.com/a/b.../c",
QueryPattern would consider prefixes of "example.com/a".

If any matching package is in the main module, QueryPattern considers only
the main module and only the version "latest", without checking for other
possible modules.

QueryPattern always returns at least one QueryResult (which may be only
modOnly) or a non-nil error.</p>
            
            <pre><code>func QueryPattern(ctx context.Context, pattern string, query string, current func, allowed AllowedFunc) (pkgMods []QueryResult, modOnly *QueryResult, err error)</code></pre>
         </article>
         
         <article class="function" data-name="modulePrefixesExcludingTarget">
            <h2>modulePrefixesExcludingTarget</h2>
            <hr />
            
            <p>modulePrefixesExcludingTarget returns all prefixes of path that may plausibly
exist as a module, excluding targetPrefix but otherwise including path
itself, sorted by descending length. Prefixes that are not valid module paths
but are valid package paths (like "m" or "example.com/.gen") are included,
since they might be replaced.</p>
            
            <pre><code>func modulePrefixesExcludingTarget(path string) []string</code></pre>
         </article>
         
         <article class="function" data-name="queryPrefixModules">
            <h2>queryPrefixModules</h2>
            <hr />
            
            <pre><code>func queryPrefixModules(ctx context.Context, candidateModules []string, queryModule func) (found []QueryResult, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="versionHasGoMod">
            <h2>versionHasGoMod</h2>
            <hr />
            
            <p>versionHasGoMod returns whether a version has a go.mod file.

versionHasGoMod fetches the go.mod file (possibly a fake) and true if it
contains anything other than a module directive with the same path. When a
module does not have a real go.mod file, the go command acts as if it had one
that only contained a module directive. Normal go.mod files created after
1.12 at least have a go directive.

This function is a heuristic, since it's possible to commit a file that would
pass this test. However, we only need a heuristic for determining whether
+incompatible versions may be "latest", which is what this function is used
for.

This heuristic is useful for two reasons: first, when using a proxy,
this lets us fetch from the .mod endpoint which is much faster than the .zip
endpoint. The .mod file is used anyway, even if the .zip file contains a
go.mod with different content. Second, if we don't fetch the .zip, then
we don't need to verify it in go.sum. This makes 'go list -m -u' faster
and simpler.</p>
            
            <pre><code>func versionHasGoMod(_ context.Context, m module.Version) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="lookupRepo">
            <h2>lookupRepo</h2>
            <hr />
            
            <pre><code>func lookupRepo(ctx context.Context, proxy string, path string) (repo versionRepo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <p>Versions returns the versions from rr.repo augmented with any matching
replacement versions.</p>
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*modfetch.Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="replacementStat">
            <h2>replacementStat</h2>
            <hr />
            
            <pre><code>func replacementStat(v string) (*modfetch.RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="testMain">
            <h2>testMain</h2>
            <hr />
            
            <pre><code>func testMain(m *testing.M) err error</code></pre>
         </article>
         
         <article class="function" data-name="TestQuery">
            <h2>TestQuery</h2>
            <hr />
            
            <pre><code>func TestQuery(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="matchPackages">
            <h2>matchPackages</h2>
            <hr />
            
            <p>matchPackages is like m.MatchPackages, but uses a local variable (rather than
a global) for tags, can include or exclude packages in the standard library,
and is restricted to the given list of modules.</p>
            
            <pre><code>func matchPackages(ctx context.Context, m *search.Match, tags *ast.MapType, filter stdFilter, modules []module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="walkFromIndex">
            <h2>walkFromIndex</h2>
            <hr />
            
            <p>walkFromIndex matches packages in a module using the module index. modroot
is the module's root directory on disk, index is the modindex.Module for the
module, and importPathRoot is the module's path prefix.</p>
            
            <pre><code>func walkFromIndex(index *modindex.Module, importPathRoot string, isMatch func, treeCanMatch func, tags *ast.MapType, have *ast.MapType, addPkg func)</code></pre>
         </article>
         
         <article class="function" data-name="MatchInModule">
            <h2>MatchInModule</h2>
            <hr />
            
            <p>MatchInModule identifies the packages matching the given pattern within the
given module version, which does not need to be in the build list or module
requirement graph.

If m is the zero module.Version, MatchInModule matches the pattern
against the standard library (std and cmd) in GOROOT/src.</p>
            
            <pre><code>func MatchInModule(ctx context.Context, pattern string, m module.Version, tags *ast.MapType) *search.Match</code></pre>
         </article>
         
         <article class="function" data-name="hasWritePerm">
            <h2>hasWritePerm</h2>
            <hr />
            
            <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.</p>
            
            <pre><code>func hasWritePerm(path string, _ fs.FileInfo) bool</code></pre>
         </article>
         
         <article class="function" data-name="EnterModule">
            <h2>EnterModule</h2>
            <hr />
            
            <p>EnterModule resets MainModules and requirements to refer to just this one module.</p>
            
            <pre><code>func EnterModule(ctx context.Context, enterModroot string)</code></pre>
         </article>
         
         <article class="function" data-name="PathPrefix">
            <h2>PathPrefix</h2>
            <hr />
            
            <pre><code>func PathPrefix(m module.Version) string</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <p>Versions returns the module.Version values of each of the main modules.
For each of them, the Path fields are ordinary module paths and the Version
fields are empty strings.
Callers should not modify the returned slice.</p>
            
            <pre><code>func Versions() []module.Version</code></pre>
         </article>
         
         <article class="function" data-name="Tools">
            <h2>Tools</h2>
            <hr />
            
            <p>Tools returns the tools defined by all the main modules.
The key is the absolute package path of the tool.</p>
            
            <pre><code>func Tools() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="Contains">
            <h2>Contains</h2>
            <hr />
            
            <pre><code>func Contains(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="ModRoot">
            <h2>ModRoot</h2>
            <hr />
            
            <pre><code>func ModRoot(m module.Version) string</code></pre>
         </article>
         
         <article class="function" data-name="InGorootSrc">
            <h2>InGorootSrc</h2>
            <hr />
            
            <pre><code>func InGorootSrc(m module.Version) bool</code></pre>
         </article>
         
         <article class="function" data-name="mustGetSingleMainModule">
            <h2>mustGetSingleMainModule</h2>
            <hr />
            
            <pre><code>func mustGetSingleMainModule() module.Version</code></pre>
         </article>
         
         <article class="function" data-name="GetSingleIndexOrNil">
            <h2>GetSingleIndexOrNil</h2>
            <hr />
            
            <pre><code>func GetSingleIndexOrNil() *modFileIndex</code></pre>
         </article>
         
         <article class="function" data-name="Index">
            <h2>Index</h2>
            <hr />
            
            <pre><code>func Index(m module.Version) *modFileIndex</code></pre>
         </article>
         
         <article class="function" data-name="SetIndex">
            <h2>SetIndex</h2>
            <hr />
            
            <pre><code>func SetIndex(m module.Version, index *modFileIndex)</code></pre>
         </article>
         
         <article class="function" data-name="ModFile">
            <h2>ModFile</h2>
            <hr />
            
            <pre><code>func ModFile(m module.Version) *modfile.File</code></pre>
         </article>
         
         <article class="function" data-name="WorkFile">
            <h2>WorkFile</h2>
            <hr />
            
            <pre><code>func WorkFile() *modfile.WorkFile</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="ModContainingCWD">
            <h2>ModContainingCWD</h2>
            <hr />
            
            <p>ModContainingCWD returns the main module containing the working directory,
or module.Version{} if none of the main modules contain the working
directory.</p>
            
            <pre><code>func ModContainingCWD() module.Version</code></pre>
         </article>
         
         <article class="function" data-name="HighestReplaced">
            <h2>HighestReplaced</h2>
            <hr />
            
            <pre><code>func HighestReplaced() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="GoVersion">
            <h2>GoVersion</h2>
            <hr />
            
            <p>GoVersion returns the go version set on the single module, in module mode,
or the go.work file in workspace mode.</p>
            
            <pre><code>func GoVersion() string</code></pre>
         </article>
         
         <article class="function" data-name="Godebugs">
            <h2>Godebugs</h2>
            <hr />
            
            <p>Godebugs returns the godebug lines set on the single module, in module mode,
or on the go.work file in workspace mode.
The caller must not modify the result.</p>
            
            <pre><code>func Godebugs() []*modfile.Godebug</code></pre>
         </article>
         
         <article class="function" data-name="Toolchain">
            <h2>Toolchain</h2>
            <hr />
            
            <p>Toolchain returns the toolchain set on the single module, in module mode,
or the go.work file in workspace mode.</p>
            
            <pre><code>func Toolchain() string</code></pre>
         </article>
         
         <article class="function" data-name="WorkFileReplaceMap">
            <h2>WorkFileReplaceMap</h2>
            <hr />
            
            <pre><code>func WorkFileReplaceMap() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="ModFile">
            <h2>ModFile</h2>
            <hr />
            
            <p>ModFile returns the parsed go.mod file.

Note that after calling LoadPackages or LoadModGraph,
the require statements in the modfile.File are no longer
the source of truth and will be ignored: edits made directly
will be lost at the next call to WriteGoMod.
To make permanent changes to the require statements
in go.mod, edit it before loading.</p>
            
            <pre><code>func ModFile() *modfile.File</code></pre>
         </article>
         
         <article class="function" data-name="BinDir">
            <h2>BinDir</h2>
            <hr />
            
            <pre><code>func BinDir() string</code></pre>
         </article>
         
         <article class="function" data-name="InitWorkfile">
            <h2>InitWorkfile</h2>
            <hr />
            
            <p>InitWorkfile initializes the workFilePath variable for commands that
operate in workspace mode. It should not be called by other commands,
for example 'go mod tidy', that don't operate in workspace mode.</p>
            
            <pre><code>func InitWorkfile()</code></pre>
         </article>
         
         <article class="function" data-name="FindGoWork">
            <h2>FindGoWork</h2>
            <hr />
            
            <p>FindGoWork returns the name of the go.work file for this command,
or the empty string if there isn't one.
Most code should use Init and Enabled rather than use this directly.
It is exported mainly for Go toolchain switching, which must process
the go.work very early at startup.</p>
            
            <pre><code>func FindGoWork(wd string) string</code></pre>
         </article>
         
         <article class="function" data-name="WorkFilePath">
            <h2>WorkFilePath</h2>
            <hr />
            
            <p>WorkFilePath returns the absolute path of the go.work file, or "" if not in
workspace mode. WorkFilePath must be called after InitWorkfile.</p>
            
            <pre><code>func WorkFilePath() string</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset clears all the initialized, cached state about the use of modules,
so that we can start over.</p>
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="Init">
            <h2>Init</h2>
            <hr />
            
            <p>Init determines whether module mode is enabled, locates the root of the
current module (if any), sets environment variables for Git subprocesses, and
configures the cfg, codehost, load, modfetch, and search packages for use
with modules.</p>
            
            <pre><code>func Init()</code></pre>
         </article>
         
         <article class="function" data-name="WillBeEnabled">
            <h2>WillBeEnabled</h2>
            <hr />
            
            <p>WillBeEnabled checks whether modules should be enabled but does not
initialize modules by installing hooks. If Init has already been called,
WillBeEnabled returns the same result as Enabled.

This function is needed to break a cycle. The main package needs to know
whether modules are enabled in order to install the module or GOPATH version
of 'go get', but Init reads the -modfile flag in 'go get', so it shouldn't
be called until the command is installed and flags are parsed. Instead of
calling Init and Enabled, the main package can call this function.</p>
            
            <pre><code>func WillBeEnabled() bool</code></pre>
         </article>
         
         <article class="function" data-name="FindGoMod">
            <h2>FindGoMod</h2>
            <hr />
            
            <p>FindGoMod returns the name of the go.mod file for this command,
or the empty string if there isn't one.
Most code should use Init and Enabled rather than use this directly.
It is exported mainly for Go toolchain switching, which must process
the go.mod very early at startup.</p>
            
            <pre><code>func FindGoMod(wd string) string</code></pre>
         </article>
         
         <article class="function" data-name="Enabled">
            <h2>Enabled</h2>
            <hr />
            
            <p>Enabled reports whether modules are (or must be) enabled.
If modules are enabled but there is no main module, Enabled returns true
and then the first use of module information will call die
(usually through MustModRoot).</p>
            
            <pre><code>func Enabled() bool</code></pre>
         </article>
         
         <article class="function" data-name="VendorDir">
            <h2>VendorDir</h2>
            <hr />
            
            <pre><code>func VendorDir() string</code></pre>
         </article>
         
         <article class="function" data-name="inWorkspaceMode">
            <h2>inWorkspaceMode</h2>
            <hr />
            
            <pre><code>func inWorkspaceMode() bool</code></pre>
         </article>
         
         <article class="function" data-name="HasModRoot">
            <h2>HasModRoot</h2>
            <hr />
            
            <p>HasModRoot reports whether a main module is present.
HasModRoot may return false even if Enabled returns true: for example, 'get'
does not require a main module.</p>
            
            <pre><code>func HasModRoot() bool</code></pre>
         </article>
         
         <article class="function" data-name="MustHaveModRoot">
            <h2>MustHaveModRoot</h2>
            <hr />
            
            <p>MustHaveModRoot checks that a main module or main modules are present,
and calls base.Fatalf if there are no main modules.</p>
            
            <pre><code>func MustHaveModRoot()</code></pre>
         </article>
         
         <article class="function" data-name="ModFilePath">
            <h2>ModFilePath</h2>
            <hr />
            
            <p>ModFilePath returns the path that would be used for the go.mod
file, if in module mode. ModFilePath calls base.Fatalf if there is no main
module, even if -modfile is set.</p>
            
            <pre><code>func ModFilePath() string</code></pre>
         </article>
         
         <article class="function" data-name="modFilePath">
            <h2>modFilePath</h2>
            <hr />
            
            <pre><code>func modFilePath(modRoot string) string</code></pre>
         </article>
         
         <article class="function" data-name="die">
            <h2>die</h2>
            <hr />
            
            <pre><code>func die()</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="loadWorkFile">
            <h2>loadWorkFile</h2>
            <hr />
            
            <pre><code>func loadWorkFile(path string) (workFile *modfile.WorkFile, modRoots []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadWorkFile">
            <h2>ReadWorkFile</h2>
            <hr />
            
            <p>ReadWorkFile reads and parses the go.work file at the given path.</p>
            
            <pre><code>func ReadWorkFile(path string) (*modfile.WorkFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteWorkFile">
            <h2>WriteWorkFile</h2>
            <hr />
            
            <p>WriteWorkFile cleans and writes out the go.work file to the given path.</p>
            
            <pre><code>func WriteWorkFile(path string, wf *modfile.WorkFile) error</code></pre>
         </article>
         
         <article class="function" data-name="UpdateWorkGoVersion">
            <h2>UpdateWorkGoVersion</h2>
            <hr />
            
            <p>UpdateWorkGoVersion updates the go line in wf to be at least goVers,
reporting whether it changed the file.</p>
            
            <pre><code>func UpdateWorkGoVersion(wf *modfile.WorkFile, goVers string) changed bool</code></pre>
         </article>
         
         <article class="function" data-name="UpdateWorkFile">
            <h2>UpdateWorkFile</h2>
            <hr />
            
            <p>UpdateWorkFile updates comments on directory directives in the go.work
file to include the associated module path.</p>
            
            <pre><code>func UpdateWorkFile(wf *modfile.WorkFile)</code></pre>
         </article>
         
         <article class="function" data-name="LoadModFile">
            <h2>LoadModFile</h2>
            <hr />
            
            <p>LoadModFile sets Target and, if there is a main module, parses the initial
build list from its go.mod file.

LoadModFile may make changes in memory, like adding a go directive and
ensuring requirements are consistent. The caller is responsible for ensuring
those changes are written to disk by calling LoadPackages or ListModules
(unless ExplicitWriteGoMod is set) or by calling WriteGoMod directly.

As a side-effect, LoadModFile may change cfg.BuildMod to "vendor" if
-mod wasn't set explicitly and automatic vendoring should be enabled.

If LoadModFile or CreateModFile has already been called, LoadModFile returns
the existing in-memory requirements (rather than re-reading them from disk).

LoadModFile checks the roots of the module graph for consistency with each
other, but unlike LoadModGraph does not load the full module graph or check
it for global consistency. Most callers outside of the modload package should
use LoadModGraph instead.</p>
            
            <pre><code>func LoadModFile(ctx context.Context) *Requirements</code></pre>
         </article>
         
         <article class="function" data-name="loadModFile">
            <h2>loadModFile</h2>
            <hr />
            
            <pre><code>func loadModFile(ctx context.Context, opts *PackageOpts) (*Requirements, error)</code></pre>
         </article>
         
         <article class="function" data-name="errWorkTooOld">
            <h2>errWorkTooOld</h2>
            <hr />
            
            <pre><code>func errWorkTooOld(gomod string, wf *modfile.WorkFile, goVers string) error</code></pre>
         </article>
         
         <article class="function" data-name="CreateModFile">
            <h2>CreateModFile</h2>
            <hr />
            
            <p>CreateModFile initializes a new module by creating a go.mod file.

If modPath is empty, CreateModFile will attempt to infer the path from the
directory location within GOPATH.

If a vendoring configuration file is present, CreateModFile will attempt to
translate it to go.mod directives. The resulting build list may not be
exactly the same as in the legacy configuration (for example, we can't get
packages at multiple versions from the same module).</p>
            
            <pre><code>func CreateModFile(ctx context.Context, modPath string)</code></pre>
         </article>
         
         <article class="function" data-name="fixVersion">
            <h2>fixVersion</h2>
            <hr />
            
            <p>fixVersion returns a modfile.VersionFixer implemented using the Query function.

It resolves commit hashes and branch names to versions,
canonicalizes versions that appeared in early vgo drafts,
and does nothing for versions that already appear to be canonical.

The VersionFixer sets 'fixed' if it ever returns a non-canonical version.</p>
            
            <pre><code>func fixVersion(ctx context.Context, fixed *bool) modfile.VersionFixer</code></pre>
         </article>
         
         <article class="function" data-name="AllowMissingModuleImports">
            <h2>AllowMissingModuleImports</h2>
            <hr />
            
            <p>AllowMissingModuleImports allows import paths to be resolved to modules
when there is no module root. Normally, this is forbidden because it's slow
and there's no way to make the result reproducible, but some commands
like 'go get' are expected to do this.

This function affects the default cfg.BuildMod when outside of a module,
so it can only be called prior to Init.</p>
            
            <pre><code>func AllowMissingModuleImports()</code></pre>
         </article>
         
         <article class="function" data-name="makeMainModules">
            <h2>makeMainModules</h2>
            <hr />
            
            <p>makeMainModules creates a MainModuleSet and associated variables according to
the given main modules.</p>
            
            <pre><code>func makeMainModules(ms []module.Version, rootDirs []string, modFiles []*modfile.File, indices []*modFileIndex, workFile *modfile.WorkFile) *MainModuleSet</code></pre>
         </article>
         
         <article class="function" data-name="requirementsFromModFiles">
            <h2>requirementsFromModFiles</h2>
            <hr />
            
            <p>requirementsFromModFiles returns the set of non-excluded requirements from
the global modFile.</p>
            
            <pre><code>func requirementsFromModFiles(ctx context.Context, workFile *modfile.WorkFile, modFiles []*modfile.File, opts *PackageOpts) *Requirements</code></pre>
         </article>
         
         <article class="function" data-name="directRequirements">
            <h2>directRequirements</h2>
            <hr />
            
            <pre><code>func directRequirements(modFiles []*modfile.File) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="rootsFromModFile">
            <h2>rootsFromModFile</h2>
            <hr />
            
            <pre><code>func rootsFromModFile(m module.Version, modFile *modfile.File, addToolchainRoot addToolchainRoot) (roots []module.Version, direct *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="appendGoAndToolchainRoots">
            <h2>appendGoAndToolchainRoots</h2>
            <hr />
            
            <pre><code>func appendGoAndToolchainRoots(roots []module.Version, goVersion string, toolchain string, direct *ast.MapType) []module.Version</code></pre>
         </article>
         
         <article class="function" data-name="setDefaultBuildMod">
            <h2>setDefaultBuildMod</h2>
            <hr />
            
            <p>setDefaultBuildMod sets a default value for cfg.BuildMod if the -mod flag
wasn't provided. setDefaultBuildMod may be called multiple times.</p>
            
            <pre><code>func setDefaultBuildMod()</code></pre>
         </article>
         
         <article class="function" data-name="modulesTextIsForWorkspace">
            <h2>modulesTextIsForWorkspace</h2>
            <hr />
            
            <pre><code>func modulesTextIsForWorkspace(vendorDir string) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="mustHaveCompleteRequirements">
            <h2>mustHaveCompleteRequirements</h2>
            <hr />
            
            <pre><code>func mustHaveCompleteRequirements() bool</code></pre>
         </article>
         
         <article class="function" data-name="addGoStmt">
            <h2>addGoStmt</h2>
            <hr />
            
            <p>addGoStmt adds a go directive to the go.mod file if it does not already
include one. The 'go' version added, if any, is the latest version supported
by this toolchain.</p>
            
            <pre><code>func addGoStmt(modFile *modfile.File, mod module.Version, v string)</code></pre>
         </article>
         
         <article class="function" data-name="forceGoStmt">
            <h2>forceGoStmt</h2>
            <hr />
            
            <pre><code>func forceGoStmt(modFile *modfile.File, mod module.Version, v string)</code></pre>
         </article>
         
         <article class="function" data-name="findModuleRoot">
            <h2>findModuleRoot</h2>
            <hr />
            
            <pre><code>func findModuleRoot(dir string) roots string</code></pre>
         </article>
         
         <article class="function" data-name="findWorkspaceFile">
            <h2>findWorkspaceFile</h2>
            <hr />
            
            <pre><code>func findWorkspaceFile(dir string) root string</code></pre>
         </article>
         
         <article class="function" data-name="findAltConfig">
            <h2>findAltConfig</h2>
            <hr />
            
            <pre><code>func findAltConfig(dir string) (root string, name string)</code></pre>
         </article>
         
         <article class="function" data-name="findModulePath">
            <h2>findModulePath</h2>
            <hr />
            
            <pre><code>func findModulePath(dir string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="findImportComment">
            <h2>findImportComment</h2>
            <hr />
            
            <pre><code>func findImportComment(file string) string</code></pre>
         </article>
         
         <article class="function" data-name="WriteGoMod">
            <h2>WriteGoMod</h2>
            <hr />
            
            <p>WriteGoMod writes the current build list back to go.mod.</p>
            
            <pre><code>func WriteGoMod(ctx context.Context, opts WriteOpts) error</code></pre>
         </article>
         
         <article class="function" data-name="UpdateGoModFromReqs">
            <h2>UpdateGoModFromReqs</h2>
            <hr />
            
            <p>UpdateGoModFromReqs returns a modified go.mod file using the current
requirements. It does not commit these changes to disk.</p>
            
            <pre><code>func UpdateGoModFromReqs(ctx context.Context, opts WriteOpts) (before []byte, after []byte, modFile *modfile.File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="commitRequirements">
            <h2>commitRequirements</h2>
            <hr />
            
            <p>commitRequirements ensures go.mod and go.sum are up to date with the current
requirements.

In "mod" mode, commitRequirements writes changes to go.mod and go.sum.

In "readonly" and "vendor" modes, commitRequirements returns an error if
go.mod or go.sum are out of date in a semantically significant way.

In workspace mode, commitRequirements only writes changes to go.work.sum.</p>
            
            <pre><code>func commitRequirements(ctx context.Context, opts WriteOpts) err error</code></pre>
         </article>
         
         <article class="function" data-name="keepSums">
            <h2>keepSums</h2>
            <hr />
            
            <p>keepSums returns the set of modules (and go.mod file entries) for which
checksums would be needed in order to reload the same set of packages
loaded by the most recent call to LoadPackages or ImportFromFiles,
including any go.mod files needed to reconstruct the MVS result
or identify go versions,
in addition to the checksums for every module in keepMods.</p>
            
            <pre><code>func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="modkey">
            <h2>modkey</h2>
            <hr />
            
            <p>modkey returns the module.Version under which the checksum for m's go.mod
file is stored in the go.sum file.</p>
            
            <pre><code>func modkey(m module.Version) module.Version</code></pre>
         </article>
         
         <article class="function" data-name="suggestModulePath">
            <h2>suggestModulePath</h2>
            <hr />
            
            <pre><code>func suggestModulePath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="suggestGopkgIn">
            <h2>suggestGopkgIn</h2>
            <hr />
            
            <pre><code>func suggestGopkgIn(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="CheckGodebug">
            <h2>CheckGodebug</h2>
            <hr />
            
            <pre><code>func CheckGodebug(verb string, k string, v string) error</code></pre>
         </article>
         
         <article class="function" data-name="ListModules">
            <h2>ListModules</h2>
            <hr />
            
            <p>ListModules returns a description of the modules matching args, if known,
along with any error preventing additional matches from being identified.

The returned slice can be nonempty even if the error is non-nil.</p>
            
            <pre><code>func ListModules(ctx context.Context, args []string, mode ListMode, reuseFile string) ([]*modinfo.ModulePublic, error)</code></pre>
         </article>
         
         <article class="function" data-name="listModules">
            <h2>listModules</h2>
            <hr />
            
            <pre><code>func listModules(ctx context.Context, rs *Requirements, args []string, mode ListMode, reuse *ast.MapType) (_ *Requirements, mods []*modinfo.ModulePublic, mgErr error)</code></pre>
         </article>
         
         <article class="function" data-name="modinfoError">
            <h2>modinfoError</h2>
            <hr />
            
            <p>modinfoError wraps an error to create an error message in
modinfo.ModuleError with minimal redundancy.</p>
            
            <pre><code>func modinfoError(path string, vers string, err error) *modinfo.ModuleError</code></pre>
         </article>
         
         <article class="function" data-name="ReadModFile">
            <h2>ReadModFile</h2>
            <hr />
            
            <p>ReadModFile reads and parses the mod file at gomod. ReadModFile properly applies the
overlay, locks the file while reading, and applies fix, if applicable.</p>
            
            <pre><code>func ReadModFile(gomod string, fix modfile.VersionFixer) (data []byte, f *modfile.File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="shortPathErrorList">
            <h2>shortPathErrorList</h2>
            <hr />
            
            <pre><code>func shortPathErrorList(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="pruningForGoVersion">
            <h2>pruningForGoVersion</h2>
            <hr />
            
            <pre><code>func pruningForGoVersion(goVersion string) modPruning</code></pre>
         </article>
         
         <article class="function" data-name="CheckAllowed">
            <h2>CheckAllowed</h2>
            <hr />
            
            <p>CheckAllowed returns an error equivalent to ErrDisallowed if m is excluded by
the main module's go.mod or retracted by its author. Most version queries use
this to filter out versions that should not be used.</p>
            
            <pre><code>func CheckAllowed(ctx context.Context, m module.Version) error</code></pre>
         </article>
         
         <article class="function" data-name="CheckExclusions">
            <h2>CheckExclusions</h2>
            <hr />
            
            <p>CheckExclusions returns an error equivalent to ErrDisallowed if module m is
excluded by the main module's go.mod file.</p>
            
            <pre><code>func CheckExclusions(ctx context.Context, m module.Version) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Is">
            <h2>Is</h2>
            <hr />
            
            <pre><code>func Is(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="CheckRetractions">
            <h2>CheckRetractions</h2>
            <hr />
            
            <p>CheckRetractions returns an error if module m has been retracted by
its author.</p>
            
            <pre><code>func CheckRetractions(ctx context.Context, m module.Version) err error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Is">
            <h2>Is</h2>
            <hr />
            
            <pre><code>func Is(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="ShortMessage">
            <h2>ShortMessage</h2>
            <hr />
            
            <p>ShortMessage returns a string from go.mod (for example, a retraction
rationale or deprecation message) that is safe to print in a terminal.

If the given string is empty, ShortMessage returns the given default. If the
given string is too long or contains non-printable characters, ShortMessage
returns a hard-coded string.</p>
            
            <pre><code>func ShortMessage(message string, emptyDefault string) string</code></pre>
         </article>
         
         <article class="function" data-name="CheckDeprecation">
            <h2>CheckDeprecation</h2>
            <hr />
            
            <p>CheckDeprecation returns a deprecation message from the go.mod file of the
latest version of the given module. Deprecation messages are comments
before or on the same line as the module directives that start with
"Deprecated:" and run until the end of the paragraph.

CheckDeprecation returns an error if the message can't be loaded.
CheckDeprecation returns "", nil if there is no deprecation message.</p>
            
            <pre><code>func CheckDeprecation(ctx context.Context, m module.Version) (deprecation string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="replacement">
            <h2>replacement</h2>
            <hr />
            
            <pre><code>func replacement(mod module.Version, replace *ast.MapType) (fromVersion string, to module.Version, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="Replacement">
            <h2>Replacement</h2>
            <hr />
            
            <p>Replacement returns the replacement for mod, if any. If the path in the
module.Version is relative it's relative to the single main module outside
workspace mode, or the workspace's directory in workspace mode.</p>
            
            <pre><code>func Replacement(mod module.Version) module.Version</code></pre>
         </article>
         
         <article class="function" data-name="replacementFrom">
            <h2>replacementFrom</h2>
            <hr />
            
            <p>replacementFrom returns the replacement for mod, if any, the modroot of the replacement if it appeared in a go.mod,
and the source of the replacement. The replacement is relative to the go.work or go.mod file it appears in.</p>
            
            <pre><code>func replacementFrom(mod module.Version) (r module.Version, modroot string, fromFile string)</code></pre>
         </article>
         
         <article class="function" data-name="replaceRelativeTo">
            <h2>replaceRelativeTo</h2>
            <hr />
            
            <pre><code>func replaceRelativeTo() string</code></pre>
         </article>
         
         <article class="function" data-name="canonicalizeReplacePath">
            <h2>canonicalizeReplacePath</h2>
            <hr />
            
            <p>canonicalizeReplacePath ensures that relative, on-disk, replaced module paths
are relative to the workspace directory (in workspace mode) or to the module's
directory (in module mode, as they already are).</p>
            
            <pre><code>func canonicalizeReplacePath(r module.Version, modRoot string) module.Version</code></pre>
         </article>
         
         <article class="function" data-name="resolveReplacement">
            <h2>resolveReplacement</h2>
            <hr />
            
            <p>resolveReplacement returns the module actually used to load the source code
for m: either m itself, or the replacement for m (iff m is replaced).
It also returns the modroot of the module providing the replacement if
one was found.</p>
            
            <pre><code>func resolveReplacement(m module.Version) module.Version</code></pre>
         </article>
         
         <article class="function" data-name="toReplaceMap">
            <h2>toReplaceMap</h2>
            <hr />
            
            <pre><code>func toReplaceMap(replacements []*modfile.Replace) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="indexModFile">
            <h2>indexModFile</h2>
            <hr />
            
            <p>indexModFile rebuilds the index of modFile.
If modFile has been changed since it was first read,
modFile.Cleanup must be called before indexModFile.</p>
            
            <pre><code>func indexModFile(data []byte, modFile *modfile.File, mod module.Version, needsFix bool) *modFileIndex</code></pre>
         </article>
         
         <article class="function" data-name="modFileIsDirty">
            <h2>modFileIsDirty</h2>
            <hr />
            
            <p>modFileIsDirty reports whether the go.mod file differs meaningfully
from what was indexed.
If modFile has been changed (even cosmetically) since it was first read,
modFile.Cleanup must be called before modFileIsDirty.</p>
            
            <pre><code>func modFileIsDirty(modFile *modfile.File) bool</code></pre>
         </article>
         
         <article class="function" data-name="goModSummary">
            <h2>goModSummary</h2>
            <hr />
            
            <p>goModSummary returns a summary of the go.mod file for module m,
taking into account any replacements for m, exclusions of its dependencies,
and/or vendoring.

m must be a version in the module graph, reachable from the Target module.
In readonly mode, the go.sum file must contain an entry for m's go.mod file
(or its replacement). goModSummary must not be called for the Target module
itself, as its requirements may change. Use rawGoModSummary for other
module versions.

The caller must not modify the returned summary.</p>
            
            <pre><code>func goModSummary(m module.Version) (*modFileSummary, error)</code></pre>
         </article>
         
         <article class="function" data-name="rawGoModSummary">
            <h2>rawGoModSummary</h2>
            <hr />
            
            <p>rawGoModSummary returns a new summary of the go.mod file for module m,
ignoring all replacements that may apply to m and excludes that may apply to
its dependencies.

rawGoModSummary cannot be used on the main module outside of workspace mode.
The modFileSummary can still be used for retractions and deprecations
even if a TooNewError is returned.</p>
            
            <pre><code>func rawGoModSummary(m module.Version) (*modFileSummary, error)</code></pre>
         </article>
         
         <article class="function" data-name="rawGoModData">
            <h2>rawGoModData</h2>
            <hr />
            
            <p>rawGoModData returns the content of the go.mod file for module m, ignoring
all replacements that may apply to m.

rawGoModData cannot be used on the main module outside of workspace mode.

Unlike rawGoModSummary, rawGoModData does not cache its results in memory.
Use rawGoModSummary instead unless you specifically need these bytes.</p>
            
            <pre><code>func rawGoModData(m module.Version) (name string, data []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="queryLatestVersionIgnoringRetractions">
            <h2>queryLatestVersionIgnoringRetractions</h2>
            <hr />
            
            <p>queryLatestVersionIgnoringRetractions looks up the latest version of the
module with the given path without considering retracted or excluded
versions.

If all versions of the module are replaced,
queryLatestVersionIgnoringRetractions returns the replacement without making
a query.

If the queried latest version is replaced,
queryLatestVersionIgnoringRetractions returns the replacement.</p>
            
            <pre><code>func queryLatestVersionIgnoringRetractions(ctx context.Context, path string) (latest module.Version, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ToDirectoryPath">
            <h2>ToDirectoryPath</h2>
            <hr />
            
            <p>ToDirectoryPath adds a prefix if necessary so that path in unambiguously
an absolute path or a relative path starting with a '.' or '..'
path component.</p>
            
            <pre><code>func ToDirectoryPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="cmpVersion">
            <h2>cmpVersion</h2>
            <hr />
            
            <p>cmpVersion implements the comparison for versions in the module loader.

It is consistent with gover.ModCompare except that as a special case,
the version "" is considered higher than all other versions.
The main module (also known as the target) has no version and must be chosen
over other versions of the same module in the module dependency graph.</p>
            
            <pre><code>func cmpVersion(p string, v1 string, v2 string) int</code></pre>
         </article>
         
         <article class="function" data-name="Required">
            <h2>Required</h2>
            <hr />
            
            <pre><code>func Required(mod module.Version) ([]module.Version, error)</code></pre>
         </article>
         
         <article class="function" data-name="Max">
            <h2>Max</h2>
            <hr />
            
            <p>Max returns the maximum of v1 and v2 according to gover.ModCompare.

As a special case, the version "" is considered higher than all other
versions. The main module (also known as the target) has no version and must
be chosen over other versions of the same module in the module dependency
graph.</p>
            
            <pre><code>func Max(p string, v1 string, v2 string) string</code></pre>
         </article>
         
         <article class="function" data-name="Upgrade">
            <h2>Upgrade</h2>
            <hr />
            
            <p>Upgrade is a no-op, here to implement mvs.Reqs.
The upgrade logic for go get -u is in ../modget/get.go.</p>
            
            <pre><code>func Upgrade(m module.Version) (module.Version, error)</code></pre>
         </article>
         
         <article class="function" data-name="versions">
            <h2>versions</h2>
            <hr />
            
            <pre><code>func versions(ctx context.Context, path string, allowed AllowedFunc) (versions []string, origin *codehost.Origin, err error)</code></pre>
         </article>
         
         <article class="function" data-name="previousVersion">
            <h2>previousVersion</h2>
            <hr />
            
            <p>previousVersion returns the tagged version of m.Path immediately prior to
m.Version, or version "none" if no prior version is tagged.

Since the version of a main module is not found in the version list,
it has no previous version.</p>
            
            <pre><code>func previousVersion(ctx context.Context, m module.Version) (module.Version, error)</code></pre>
         </article>
         
         <article class="function" data-name="Previous">
            <h2>Previous</h2>
            <hr />
            
            <pre><code>func Previous(m module.Version) (module.Version, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestReqsMax">
            <h2>TestReqsMax</h2>
            <hr />
            
            <pre><code>func TestReqsMax(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="hasWritePerm">
            <h2>hasWritePerm</h2>
            <hr />
            
            <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.</p>
            
            <pre><code>func hasWritePerm(_ string, fi fs.FileInfo) bool</code></pre>
         </article>
         
         <article class="function" data-name="editRequirements">
            <h2>editRequirements</h2>
            <hr />
            
            <p>editRequirements returns an edited version of rs such that:

 1. Each module version in mustSelect is selected.

 2. Each module version in tryUpgrade is upgraded toward the indicated
    version as far as can be done without violating (1).
    (Other upgrades are also allowed if they are caused by
    transitive requirements of versions in mustSelect or
    tryUpgrade.)

 3. Each module version in rs.rootModules (or rs.graph, if rs is unpruned)
    is downgraded or upgraded from its original version only to the extent
    needed to satisfy (1) and (2).

Generally, the module versions in mustSelect are due to the module or a
package within the module matching an explicit command line argument to 'go
get', and the versions in tryUpgrade are transitive dependencies that are
either being upgraded by 'go get -u' or being added to satisfy some
otherwise-missing package import.

If pruning is enabled, the roots of the edited requirements include an
explicit entry for each module path in tryUpgrade, mustSelect, and the roots
of rs, unless the selected version for the module path is "none".</p>
            
            <pre><code>func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade []module.Version, mustSelect []module.Version) (edited *Requirements, changed bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="extendGraph">
            <h2>extendGraph</h2>
            <hr />
            
            <p>extendGraph loads the module graph from roots, and iteratively extends it by
unpruning the selected version of each module path that is a root in rs or in
the roots slice until the graph reaches a fixed point.

The graph is guaranteed to converge to a fixed point because unpruning a
module version can only increase (never decrease) the selected versions,
and the set of versions for each module is finite.

The extended graph is useful for diagnosing version conflicts: for each
selected module version, it can provide a complete path of requirements from
some root to that version.</p>
            
            <pre><code>func extendGraph(ctx context.Context, rootPruning modPruning, roots []module.Version, selectedRoot *ast.MapType) (mg *ModuleGraph, upgradedRoot *ast.MapType, err error)</code></pre>
         </article>
         
         <article class="function" data-name="from">
            <h2>from</h2>
            <hr />
            
            <pre><code>func from(p modPruning) T</code></pre>
         </article>
         
         <article class="function" data-name="isDisqualified">
            <h2>isDisqualified</h2>
            <hr />
            
            <pre><code>func isDisqualified() bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="require">
            <h2>require</h2>
            <hr />
            
            <p>require records that m directly requires r, in case r becomes disqualified.
(These edges are in the opposite direction from the edges in an mvs.Graph.)

If r is already disqualified, require propagates the disqualification to m
and returns the reason for the disqualification.</p>
            
            <pre><code>func require(m module.Version, r module.Version) ok bool</code></pre>
         </article>
         
         <article class="function" data-name="disqualify">
            <h2>disqualify</h2>
            <hr />
            
            <p>disqualify records why the dependencies of m cannot be included in the module
graph if reached from a part of the graph with the given pruning.

Since the pruned graph is a subgraph of the unpruned graph, disqualifying a
module from a pruned part of the graph also disqualifies it in the unpruned
parts.</p>
            
            <pre><code>func disqualify(m module.Version, fromPruning modPruning, reason dqState)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <p>check reports whether m is disqualified in the given pruning context.</p>
            
            <pre><code>func check(m module.Version, pruning modPruning) dqState</code></pre>
         </article>
         
         <article class="function" data-name="path">
            <h2>path</h2>
            <hr />
            
            <p>path returns the path from m to the reason it is disqualified, which may be
either a module that violates constraints or an error in loading
requirements.

If m is not disqualified, path returns (nil, nil).</p>
            
            <pre><code>func path(m module.Version, pruning modPruning) (path []module.Version, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="importFromModules">
            <h2>importFromModules</h2>
            <hr />
            
            <p>importFromModules finds the module and directory in the dependency graph of
rs containing the package with the given import path. If mg is nil,
importFromModules attempts to locate the module using only the main module
and the roots of rs before it loads the full graph.

The answer must be unique: importFromModules returns an error if multiple
modules are observed to provide the same package.

importFromModules can return a module with an empty m.Path, for packages in
the standard library.

importFromModules can return an empty directory string, for fake packages
like "C" and "unsafe".

If the package is not present in any module selected from the requirement
graph, importFromModules returns an *ImportMissingError.

If the package is present in exactly one module, importFromModules will
return the module, its root directory, and a list of other modules that
lexically could have provided the package but did not.

If skipModFile is true, the go.mod file for the package is not loaded. This
allows 'go mod tidy' to preserve a minor checksum-preservation bug
(https://go.dev/issue/56222) for modules with 'go' versions between 1.17 and
1.20, preventing unnecessary go.sum churn and network access in those
modules.</p>
            
            <pre><code>func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph, skipModFile bool) (m module.Version, modroot string, dir string, altMods []module.Version, err error)</code></pre>
         </article>
         
         <article class="function" data-name="queryImport">
            <h2>queryImport</h2>
            <hr />
            
            <p>queryImport attempts to locate a module that can be added to the current
build list to provide the package with the given import path.

Unlike QueryPattern, queryImport prefers to add a replaced version of a
module *before* checking the proxies for a version to add.</p>
            
            <pre><code>func queryImport(ctx context.Context, path string, rs *Requirements) (module.Version, error)</code></pre>
         </article>
         
         <article class="function" data-name="maybeInModule">
            <h2>maybeInModule</h2>
            <hr />
            
            <p>maybeInModule reports whether, syntactically,
a package with the given import path could be supplied
by a module with the given module path (mpath).</p>
            
            <pre><code>func maybeInModule(path string, mpath string) bool</code></pre>
         </article>
         
         <article class="function" data-name="dirInModule">
            <h2>dirInModule</h2>
            <hr />
            
            <p>dirInModule locates the directory that would hold the package named by the given path,
if it were in the module with module path mpath and root mdir.
If path is syntactically not within mpath,
or if mdir is a local file tree (isLocal == true) and the directory
that would hold path is in a sub-module (covered by a go.mod below mdir),
dirInModule returns "", false, nil.

Otherwise, dirInModule returns the name of the directory where
Go source files would be expected, along with a boolean indicating
whether there are in fact Go source files in that directory.
A non-nil error indicates that the existence of the directory and/or
source files could not be determined, for example due to a permission error.</p>
            
            <pre><code>func dirInModule(path string, mpath string, mdir string, isLocal bool) (dir string, haveGoFiles bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="fetch">
            <h2>fetch</h2>
            <hr />
            
            <p>fetch downloads the given module (or its replacement)
and returns its location.

The isLocal return value reports whether the replacement,
if any, is local to the filesystem.</p>
            
            <pre><code>func fetch(ctx context.Context, mod module.Version) (dir string, isLocal bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="mustHaveSums">
            <h2>mustHaveSums</h2>
            <hr />
            
            <p>mustHaveSums reports whether we require that all checksums
needed to load or build packages are already present in the go.sum file.</p>
            
            <pre><code>func mustHaveSums() bool</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="hasWritePerm">
            <h2>hasWritePerm</h2>
            <hr />
            
            <p>hasWritePerm reports whether the current user has permission to write to the
file with the given info.

Although the root user on most Unix systems can write to files even without
permission, hasWritePerm reports false if no appropriate permission bit is
set even if the current user is root.</p>
            
            <pre><code>func hasWritePerm(path string, fi fs.FileInfo) bool</code></pre>
         </article>
         
         <article class="function" data-name="readVendorList">
            <h2>readVendorList</h2>
            <hr />
            
            <p>readVendorList reads the list of vendored modules from vendor/modules.txt.</p>
            
            <pre><code>func readVendorList(vendorDir string)</code></pre>
         </article>
         
         <article class="function" data-name="checkVendorConsistency">
            <h2>checkVendorConsistency</h2>
            <hr />
            
            <p>checkVendorConsistency verifies that the vendor/modules.txt file matches (if
go 1.14) or at least does not contradict (go 1.13 or earlier) the
requirements and replacements listed in the main module's go.mod file.</p>
            
            <pre><code>func checkVendorConsistency(indexes []*modFileIndex, modFiles []*modfile.File, modRoots []string)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
