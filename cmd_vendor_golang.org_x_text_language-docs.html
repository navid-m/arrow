<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - language</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>language</code>
         </h1>
         <hr />
         
         <article class="global" data-name="DeprecatedBase">
            <h2>DeprecatedBase</h2>
            <hr />
            
            <p>Replace deprecated base languages with their preferred replacements.</p>
            
            <pre><code>DeprecatedBase CanonType</code></pre>
         </article>
         
         <article class="global" data-name="DeprecatedScript">
            <h2>DeprecatedScript</h2>
            <hr />
            
            <p>Replace deprecated scripts with their preferred replacements.</p>
            
            <pre><code>DeprecatedScript</code></pre>
         </article>
         
         <article class="global" data-name="DeprecatedRegion">
            <h2>DeprecatedRegion</h2>
            <hr />
            
            <p>Replace deprecated regions with their preferred replacements.</p>
            
            <pre><code>DeprecatedRegion</code></pre>
         </article>
         
         <article class="global" data-name="SuppressScript">
            <h2>SuppressScript</h2>
            <hr />
            
            <p>Remove redundant scripts.</p>
            
            <pre><code>SuppressScript</code></pre>
         </article>
         
         <article class="global" data-name="Legacy">
            <h2>Legacy</h2>
            <hr />
            
            <p>Normalize legacy encodings. This includes legacy languages defined in
CLDR as well as bibliographic codes defined in ISO-639.</p>
            
            <pre><code>Legacy</code></pre>
         </article>
         
         <article class="global" data-name="Macro">
            <h2>Macro</h2>
            <hr />
            
            <p>Map the dominant language of a macro language group to the macro language
subtag. For example cmn -> zh.</p>
            
            <pre><code>Macro</code></pre>
         </article>
         
         <article class="global" data-name="CLDR">
            <h2>CLDR</h2>
            <hr />
            
            <p>The CLDR flag should be used if full compatibility with CLDR is required.
There are a few cases where language.Tag may differ from CLDR. To follow all
of CLDR's suggestions, use All|CLDR.</p>
            
            <pre><code>CLDR</code></pre>
         </article>
         
         <article class="global" data-name="Raw">
            <h2>Raw</h2>
            <hr />
            
            <p>Raw can be used to Compose or Parse without Canonicalization.</p>
            
            <pre><code>Raw CanonType</code></pre>
         </article>
         
         <article class="global" data-name="Deprecated">
            <h2>Deprecated</h2>
            <hr />
            
            <p>Replace all deprecated tags with their preferred replacements.</p>
            
            <pre><code>Deprecated</code></pre>
         </article>
         
         <article class="global" data-name="BCP47">
            <h2>BCP47</h2>
            <hr />
            
            <p>All canonicalizations recommended by BCP 47.</p>
            
            <pre><code>BCP47</code></pre>
         </article>
         
         <article class="global" data-name="All">
            <h2>All</h2>
            <hr />
            
            <p>All canonicalizations.</p>
            
            <pre><code>All</code></pre>
         </article>
         
         <article class="global" data-name="Default">
            <h2>Default</h2>
            <hr />
            
            <p>Default is the canonicalization used by Parse, Make and Compose. To
preserve as much information as possible, canonicalizations that remove
potentially valuable information are not included. The Matcher is
designed to recognize similar tags that would be the same if
they were canonicalized using All.</p>
            
            <pre><code>Default</code></pre>
         </article>
         
         <article class="global" data-name="canonLang">
            <h2>canonLang</h2>
            <hr />
            
            <pre><code>canonLang</code></pre>
         </article>
         
         <article class="global" data-name="No">
            <h2>No</h2>
            <hr />
            
            <pre><code>No Confidence</code></pre>
         </article>
         
         <article class="global" data-name="Low">
            <h2>Low</h2>
            <hr />
            
            <pre><code>Low</code></pre>
         </article>
         
         <article class="global" data-name="High">
            <h2>High</h2>
            <hr />
            
            <pre><code>High</code></pre>
         </article>
         
         <article class="global" data-name="Exact">
            <h2>Exact</h2>
            <hr />
            
            <pre><code>Exact</code></pre>
         </article>
         
         <article class="global" data-name="confName">
            <h2>confName</h2>
            <hr />
            
            <pre><code>confName</code></pre>
         </article>
         
         <article class="global" data-name="NumCompactTags">
            <h2>NumCompactTags</h2>
            <hr />
            
            <p>NumCompactTags is the number of compact tags. The maximum tag is
NumCompactTags-1.</p>
            
            <pre><code>NumCompactTags</code></pre>
         </article>
         
         <article class="global" data-name="root">
            <h2>root</h2>
            <hr />
            
            <pre><code>root</code></pre>
         </article>
         
         <article class="global" data-name="ErrMissingLikelyTagsData">
            <h2>ErrMissingLikelyTagsData</h2>
            <hr />
            
            <p>ErrMissingLikelyTagsData indicates no information was available
to compute likely values of missing tags.</p>
            
            <pre><code>ErrMissingLikelyTagsData</code></pre>
         </article>
         
         <article class="global" data-name="notEquivalent">
            <h2>notEquivalent</h2>
            <hr />
            
            <pre><code>notEquivalent []language.Language</code></pre>
         </article>
         
         <article class="global" data-name="errInvalidArgument">
            <h2>errInvalidArgument</h2>
            <hr />
            
            <pre><code>errInvalidArgument</code></pre>
         </article>
         
         <article class="global" data-name="errInvalidWeight">
            <h2>errInvalidWeight</h2>
            <hr />
            
            <pre><code>errInvalidWeight</code></pre>
         </article>
         
         <article class="global" data-name="errTagListTooLarge">
            <h2>errTagListTooLarge</h2>
            <hr />
            
            <pre><code>errTagListTooLarge</code></pre>
         </article>
         
         <article class="global" data-name="acceptFallback">
            <h2>acceptFallback</h2>
            <hr />
            
            <p>Add hack mapping to deal with a small number of cases that occur
in Accept-Language (with reasonable frequency).</p>
            
            <pre><code>acceptFallback</code></pre>
         </article>
         
         <article class="global" data-name="CLDRVersion">
            <h2>CLDRVersion</h2>
            <hr />
            
            <p>CLDRVersion is the CLDR version from which the tables in this package are derived.</p>
            
            <pre><code>CLDRVersion</code></pre>
         </article>
         
         <article class="global" data-name="_de">
            <h2>_de</h2>
            <hr />
            
            <pre><code>_de</code></pre>
         </article>
         
         <article class="global" data-name="_en">
            <h2>_en</h2>
            <hr />
            
            <pre><code>_en</code></pre>
         </article>
         
         <article class="global" data-name="_fr">
            <h2>_fr</h2>
            <hr />
            
            <pre><code>_fr</code></pre>
         </article>
         
         <article class="global" data-name="_it">
            <h2>_it</h2>
            <hr />
            
            <pre><code>_it</code></pre>
         </article>
         
         <article class="global" data-name="_mo">
            <h2>_mo</h2>
            <hr />
            
            <pre><code>_mo</code></pre>
         </article>
         
         <article class="global" data-name="_no">
            <h2>_no</h2>
            <hr />
            
            <pre><code>_no</code></pre>
         </article>
         
         <article class="global" data-name="_nb">
            <h2>_nb</h2>
            <hr />
            
            <pre><code>_nb</code></pre>
         </article>
         
         <article class="global" data-name="_pt">
            <h2>_pt</h2>
            <hr />
            
            <pre><code>_pt</code></pre>
         </article>
         
         <article class="global" data-name="_sh">
            <h2>_sh</h2>
            <hr />
            
            <pre><code>_sh</code></pre>
         </article>
         
         <article class="global" data-name="_mul">
            <h2>_mul</h2>
            <hr />
            
            <pre><code>_mul</code></pre>
         </article>
         
         <article class="global" data-name="_und">
            <h2>_und</h2>
            <hr />
            
            <pre><code>_und</code></pre>
         </article>
         
         <article class="global" data-name="_001">
            <h2>_001</h2>
            <hr />
            
            <pre><code>_001</code></pre>
         </article>
         
         <article class="global" data-name="_419">
            <h2>_419</h2>
            <hr />
            
            <pre><code>_419</code></pre>
         </article>
         
         <article class="global" data-name="_BR">
            <h2>_BR</h2>
            <hr />
            
            <pre><code>_BR</code></pre>
         </article>
         
         <article class="global" data-name="_CA">
            <h2>_CA</h2>
            <hr />
            
            <pre><code>_CA</code></pre>
         </article>
         
         <article class="global" data-name="_ES">
            <h2>_ES</h2>
            <hr />
            
            <pre><code>_ES</code></pre>
         </article>
         
         <article class="global" data-name="_GB">
            <h2>_GB</h2>
            <hr />
            
            <pre><code>_GB</code></pre>
         </article>
         
         <article class="global" data-name="_MD">
            <h2>_MD</h2>
            <hr />
            
            <pre><code>_MD</code></pre>
         </article>
         
         <article class="global" data-name="_PT">
            <h2>_PT</h2>
            <hr />
            
            <pre><code>_PT</code></pre>
         </article>
         
         <article class="global" data-name="_UK">
            <h2>_UK</h2>
            <hr />
            
            <pre><code>_UK</code></pre>
         </article>
         
         <article class="global" data-name="_US">
            <h2>_US</h2>
            <hr />
            
            <pre><code>_US</code></pre>
         </article>
         
         <article class="global" data-name="_ZZ">
            <h2>_ZZ</h2>
            <hr />
            
            <pre><code>_ZZ</code></pre>
         </article>
         
         <article class="global" data-name="_XA">
            <h2>_XA</h2>
            <hr />
            
            <pre><code>_XA</code></pre>
         </article>
         
         <article class="global" data-name="_XC">
            <h2>_XC</h2>
            <hr />
            
            <pre><code>_XC</code></pre>
         </article>
         
         <article class="global" data-name="_XK">
            <h2>_XK</h2>
            <hr />
            
            <pre><code>_XK</code></pre>
         </article>
         
         <article class="global" data-name="_Latn">
            <h2>_Latn</h2>
            <hr />
            
            <pre><code>_Latn</code></pre>
         </article>
         
         <article class="global" data-name="_Hani">
            <h2>_Hani</h2>
            <hr />
            
            <pre><code>_Hani</code></pre>
         </article>
         
         <article class="global" data-name="_Hans">
            <h2>_Hans</h2>
            <hr />
            
            <pre><code>_Hans</code></pre>
         </article>
         
         <article class="global" data-name="_Hant">
            <h2>_Hant</h2>
            <hr />
            
            <pre><code>_Hant</code></pre>
         </article>
         
         <article class="global" data-name="_Qaaa">
            <h2>_Qaaa</h2>
            <hr />
            
            <pre><code>_Qaaa</code></pre>
         </article>
         
         <article class="global" data-name="_Qaai">
            <h2>_Qaai</h2>
            <hr />
            
            <pre><code>_Qaai</code></pre>
         </article>
         
         <article class="global" data-name="_Qabx">
            <h2>_Qabx</h2>
            <hr />
            
            <pre><code>_Qabx</code></pre>
         </article>
         
         <article class="global" data-name="_Zinh">
            <h2>_Zinh</h2>
            <hr />
            
            <pre><code>_Zinh</code></pre>
         </article>
         
         <article class="global" data-name="_Zyyy">
            <h2>_Zyyy</h2>
            <hr />
            
            <pre><code>_Zyyy</code></pre>
         </article>
         
         <article class="global" data-name="_Zzzz">
            <h2>_Zzzz</h2>
            <hr />
            
            <pre><code>_Zzzz</code></pre>
         </article>
         
         <article class="global" data-name="regionToGroups">
            <h2>regionToGroups</h2>
            <hr />
            
            <pre><code>regionToGroups</code></pre>
         </article>
         
         <article class="global" data-name="paradigmLocales">
            <h2>paradigmLocales</h2>
            <hr />
            
            <pre><code>paradigmLocales</code></pre>
         </article>
         
         <article class="global" data-name="matchLang">
            <h2>matchLang</h2>
            <hr />
            
            <p>matchLang holds pairs of langIDs of base languages that are typically
mutually intelligible. Each pair is associated with a confidence and
whether the intelligibility goes one or both ways.</p>
            
            <pre><code>matchLang</code></pre>
         </article>
         
         <article class="global" data-name="matchScript">
            <h2>matchScript</h2>
            <hr />
            
            <p>matchScript holds pairs of scriptIDs where readers of one script
can typically also read the other. Each is associated with a confidence.</p>
            
            <pre><code>matchScript</code></pre>
         </article>
         
         <article class="global" data-name="matchRegion">
            <h2>matchRegion</h2>
            <hr />
            
            <pre><code>matchRegion</code></pre>
         </article>
         
         <article class="global" data-name="und">
            <h2>und</h2>
            <hr />
            
            <pre><code>und</code></pre>
         </article>
         
         <article class="global" data-name="Und">
            <h2>Und</h2>
            <hr />
            
            <pre><code>Und Tag</code></pre>
         </article>
         
         <article class="global" data-name="Afrikaans">
            <h2>Afrikaans</h2>
            <hr />
            
            <pre><code>Afrikaans Tag</code></pre>
         </article>
         
         <article class="global" data-name="Amharic">
            <h2>Amharic</h2>
            <hr />
            
            <pre><code>Amharic Tag</code></pre>
         </article>
         
         <article class="global" data-name="Arabic">
            <h2>Arabic</h2>
            <hr />
            
            <pre><code>Arabic Tag</code></pre>
         </article>
         
         <article class="global" data-name="ModernStandardArabic">
            <h2>ModernStandardArabic</h2>
            <hr />
            
            <pre><code>ModernStandardArabic Tag</code></pre>
         </article>
         
         <article class="global" data-name="Azerbaijani">
            <h2>Azerbaijani</h2>
            <hr />
            
            <pre><code>Azerbaijani Tag</code></pre>
         </article>
         
         <article class="global" data-name="Bulgarian">
            <h2>Bulgarian</h2>
            <hr />
            
            <pre><code>Bulgarian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Bengali">
            <h2>Bengali</h2>
            <hr />
            
            <pre><code>Bengali Tag</code></pre>
         </article>
         
         <article class="global" data-name="Catalan">
            <h2>Catalan</h2>
            <hr />
            
            <pre><code>Catalan Tag</code></pre>
         </article>
         
         <article class="global" data-name="Czech">
            <h2>Czech</h2>
            <hr />
            
            <pre><code>Czech Tag</code></pre>
         </article>
         
         <article class="global" data-name="Danish">
            <h2>Danish</h2>
            <hr />
            
            <pre><code>Danish Tag</code></pre>
         </article>
         
         <article class="global" data-name="German">
            <h2>German</h2>
            <hr />
            
            <pre><code>German Tag</code></pre>
         </article>
         
         <article class="global" data-name="Greek">
            <h2>Greek</h2>
            <hr />
            
            <pre><code>Greek Tag</code></pre>
         </article>
         
         <article class="global" data-name="English">
            <h2>English</h2>
            <hr />
            
            <pre><code>English Tag</code></pre>
         </article>
         
         <article class="global" data-name="AmericanEnglish">
            <h2>AmericanEnglish</h2>
            <hr />
            
            <pre><code>AmericanEnglish Tag</code></pre>
         </article>
         
         <article class="global" data-name="BritishEnglish">
            <h2>BritishEnglish</h2>
            <hr />
            
            <pre><code>BritishEnglish Tag</code></pre>
         </article>
         
         <article class="global" data-name="Spanish">
            <h2>Spanish</h2>
            <hr />
            
            <pre><code>Spanish Tag</code></pre>
         </article>
         
         <article class="global" data-name="EuropeanSpanish">
            <h2>EuropeanSpanish</h2>
            <hr />
            
            <pre><code>EuropeanSpanish Tag</code></pre>
         </article>
         
         <article class="global" data-name="LatinAmericanSpanish">
            <h2>LatinAmericanSpanish</h2>
            <hr />
            
            <pre><code>LatinAmericanSpanish Tag</code></pre>
         </article>
         
         <article class="global" data-name="Estonian">
            <h2>Estonian</h2>
            <hr />
            
            <pre><code>Estonian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Persian">
            <h2>Persian</h2>
            <hr />
            
            <pre><code>Persian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Finnish">
            <h2>Finnish</h2>
            <hr />
            
            <pre><code>Finnish Tag</code></pre>
         </article>
         
         <article class="global" data-name="Filipino">
            <h2>Filipino</h2>
            <hr />
            
            <pre><code>Filipino Tag</code></pre>
         </article>
         
         <article class="global" data-name="French">
            <h2>French</h2>
            <hr />
            
            <pre><code>French Tag</code></pre>
         </article>
         
         <article class="global" data-name="CanadianFrench">
            <h2>CanadianFrench</h2>
            <hr />
            
            <pre><code>CanadianFrench Tag</code></pre>
         </article>
         
         <article class="global" data-name="Gujarati">
            <h2>Gujarati</h2>
            <hr />
            
            <pre><code>Gujarati Tag</code></pre>
         </article>
         
         <article class="global" data-name="Hebrew">
            <h2>Hebrew</h2>
            <hr />
            
            <pre><code>Hebrew Tag</code></pre>
         </article>
         
         <article class="global" data-name="Hindi">
            <h2>Hindi</h2>
            <hr />
            
            <pre><code>Hindi Tag</code></pre>
         </article>
         
         <article class="global" data-name="Croatian">
            <h2>Croatian</h2>
            <hr />
            
            <pre><code>Croatian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Hungarian">
            <h2>Hungarian</h2>
            <hr />
            
            <pre><code>Hungarian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Armenian">
            <h2>Armenian</h2>
            <hr />
            
            <pre><code>Armenian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Indonesian">
            <h2>Indonesian</h2>
            <hr />
            
            <pre><code>Indonesian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Icelandic">
            <h2>Icelandic</h2>
            <hr />
            
            <pre><code>Icelandic Tag</code></pre>
         </article>
         
         <article class="global" data-name="Italian">
            <h2>Italian</h2>
            <hr />
            
            <pre><code>Italian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Japanese">
            <h2>Japanese</h2>
            <hr />
            
            <pre><code>Japanese Tag</code></pre>
         </article>
         
         <article class="global" data-name="Georgian">
            <h2>Georgian</h2>
            <hr />
            
            <pre><code>Georgian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Kazakh">
            <h2>Kazakh</h2>
            <hr />
            
            <pre><code>Kazakh Tag</code></pre>
         </article>
         
         <article class="global" data-name="Khmer">
            <h2>Khmer</h2>
            <hr />
            
            <pre><code>Khmer Tag</code></pre>
         </article>
         
         <article class="global" data-name="Kannada">
            <h2>Kannada</h2>
            <hr />
            
            <pre><code>Kannada Tag</code></pre>
         </article>
         
         <article class="global" data-name="Korean">
            <h2>Korean</h2>
            <hr />
            
            <pre><code>Korean Tag</code></pre>
         </article>
         
         <article class="global" data-name="Kirghiz">
            <h2>Kirghiz</h2>
            <hr />
            
            <pre><code>Kirghiz Tag</code></pre>
         </article>
         
         <article class="global" data-name="Lao">
            <h2>Lao</h2>
            <hr />
            
            <pre><code>Lao Tag</code></pre>
         </article>
         
         <article class="global" data-name="Lithuanian">
            <h2>Lithuanian</h2>
            <hr />
            
            <pre><code>Lithuanian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Latvian">
            <h2>Latvian</h2>
            <hr />
            
            <pre><code>Latvian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Macedonian">
            <h2>Macedonian</h2>
            <hr />
            
            <pre><code>Macedonian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Malayalam">
            <h2>Malayalam</h2>
            <hr />
            
            <pre><code>Malayalam Tag</code></pre>
         </article>
         
         <article class="global" data-name="Mongolian">
            <h2>Mongolian</h2>
            <hr />
            
            <pre><code>Mongolian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Marathi">
            <h2>Marathi</h2>
            <hr />
            
            <pre><code>Marathi Tag</code></pre>
         </article>
         
         <article class="global" data-name="Malay">
            <h2>Malay</h2>
            <hr />
            
            <pre><code>Malay Tag</code></pre>
         </article>
         
         <article class="global" data-name="Burmese">
            <h2>Burmese</h2>
            <hr />
            
            <pre><code>Burmese Tag</code></pre>
         </article>
         
         <article class="global" data-name="Nepali">
            <h2>Nepali</h2>
            <hr />
            
            <pre><code>Nepali Tag</code></pre>
         </article>
         
         <article class="global" data-name="Dutch">
            <h2>Dutch</h2>
            <hr />
            
            <pre><code>Dutch Tag</code></pre>
         </article>
         
         <article class="global" data-name="Norwegian">
            <h2>Norwegian</h2>
            <hr />
            
            <pre><code>Norwegian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Punjabi">
            <h2>Punjabi</h2>
            <hr />
            
            <pre><code>Punjabi Tag</code></pre>
         </article>
         
         <article class="global" data-name="Polish">
            <h2>Polish</h2>
            <hr />
            
            <pre><code>Polish Tag</code></pre>
         </article>
         
         <article class="global" data-name="Portuguese">
            <h2>Portuguese</h2>
            <hr />
            
            <pre><code>Portuguese Tag</code></pre>
         </article>
         
         <article class="global" data-name="BrazilianPortuguese">
            <h2>BrazilianPortuguese</h2>
            <hr />
            
            <pre><code>BrazilianPortuguese Tag</code></pre>
         </article>
         
         <article class="global" data-name="EuropeanPortuguese">
            <h2>EuropeanPortuguese</h2>
            <hr />
            
            <pre><code>EuropeanPortuguese Tag</code></pre>
         </article>
         
         <article class="global" data-name="Romanian">
            <h2>Romanian</h2>
            <hr />
            
            <pre><code>Romanian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Russian">
            <h2>Russian</h2>
            <hr />
            
            <pre><code>Russian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Sinhala">
            <h2>Sinhala</h2>
            <hr />
            
            <pre><code>Sinhala Tag</code></pre>
         </article>
         
         <article class="global" data-name="Slovak">
            <h2>Slovak</h2>
            <hr />
            
            <pre><code>Slovak Tag</code></pre>
         </article>
         
         <article class="global" data-name="Slovenian">
            <h2>Slovenian</h2>
            <hr />
            
            <pre><code>Slovenian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Albanian">
            <h2>Albanian</h2>
            <hr />
            
            <pre><code>Albanian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Serbian">
            <h2>Serbian</h2>
            <hr />
            
            <pre><code>Serbian Tag</code></pre>
         </article>
         
         <article class="global" data-name="SerbianLatin">
            <h2>SerbianLatin</h2>
            <hr />
            
            <pre><code>SerbianLatin Tag</code></pre>
         </article>
         
         <article class="global" data-name="Swedish">
            <h2>Swedish</h2>
            <hr />
            
            <pre><code>Swedish Tag</code></pre>
         </article>
         
         <article class="global" data-name="Swahili">
            <h2>Swahili</h2>
            <hr />
            
            <pre><code>Swahili Tag</code></pre>
         </article>
         
         <article class="global" data-name="Tamil">
            <h2>Tamil</h2>
            <hr />
            
            <pre><code>Tamil Tag</code></pre>
         </article>
         
         <article class="global" data-name="Telugu">
            <h2>Telugu</h2>
            <hr />
            
            <pre><code>Telugu Tag</code></pre>
         </article>
         
         <article class="global" data-name="Thai">
            <h2>Thai</h2>
            <hr />
            
            <pre><code>Thai Tag</code></pre>
         </article>
         
         <article class="global" data-name="Turkish">
            <h2>Turkish</h2>
            <hr />
            
            <pre><code>Turkish Tag</code></pre>
         </article>
         
         <article class="global" data-name="Ukrainian">
            <h2>Ukrainian</h2>
            <hr />
            
            <pre><code>Ukrainian Tag</code></pre>
         </article>
         
         <article class="global" data-name="Urdu">
            <h2>Urdu</h2>
            <hr />
            
            <pre><code>Urdu Tag</code></pre>
         </article>
         
         <article class="global" data-name="Uzbek">
            <h2>Uzbek</h2>
            <hr />
            
            <pre><code>Uzbek Tag</code></pre>
         </article>
         
         <article class="global" data-name="Vietnamese">
            <h2>Vietnamese</h2>
            <hr />
            
            <pre><code>Vietnamese Tag</code></pre>
         </article>
         
         <article class="global" data-name="Chinese">
            <h2>Chinese</h2>
            <hr />
            
            <pre><code>Chinese Tag</code></pre>
         </article>
         
         <article class="global" data-name="SimplifiedChinese">
            <h2>SimplifiedChinese</h2>
            <hr />
            
            <pre><code>SimplifiedChinese Tag</code></pre>
         </article>
         
         <article class="global" data-name="TraditionalChinese">
            <h2>TraditionalChinese</h2>
            <hr />
            
            <pre><code>TraditionalChinese Tag</code></pre>
         </article>
         
         <article class="global" data-name="Zulu">
            <h2>Zulu</h2>
            <hr />
            
            <pre><code>Zulu Tag</code></pre>
         </article>
         
         <article class="global" data-name="Supported">
            <h2>Supported</h2>
            <hr />
            
            <p>Supported defines a Coverage that lists all supported subtags. Tags
always returns nil.</p>
            
            <pre><code>Supported Coverage</code></pre>
         </article>
          
         <article class="struct" data-name="Extension">
            <h2>type Extension struct</h2>
            <hr />
            
            <p>Extension is a single BCP 47 extension.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">s string</code></pre>
         </article>
         
         <article class="struct" data-name="Base">
            <h2>type Base struct</h2>
            <hr />
            
            <p>Base is an ISO 639 language code, used for encoding the base language
of a language tag.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">langID language.Language</code></pre>
         </article>
         
         <article class="struct" data-name="Script">
            <h2>type Script struct</h2>
            <hr />
            
            <p>Script is a 4-letter ISO 15924 code for representing scripts.
It is idiomatically represented in title case.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">scriptID language.Script</code></pre>
         </article>
         
         <article class="struct" data-name="Region">
            <h2>type Region struct</h2>
            <hr />
            
            <p>Region is an ISO 3166-1 or UN M.49 code for representing countries and regions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">regionID language.Region</code></pre>
         </article>
         
         <article class="struct" data-name="Variant">
            <h2>type Variant struct</h2>
            <hr />
            
            <p>Variant represents a registered variant of a language as defined by BCP 47.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">variant string</code></pre>
         </article>
         
         <article class="struct" data-name="matcher">
            <h2>type matcher struct</h2>
            <hr />
            
            <p>matcher keeps a set of supported language tags, indexed by language.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">default_ *haveTag
supported []*haveTag
index *ast.MapType
passSettings bool
preferSameScript bool</code></pre>
         </article>
         
         <article class="struct" data-name="matchHeader">
            <h2>type matchHeader struct</h2>
            <hr />
            
            <p>matchHeader has the lists of tags for exact matches and matches based on
maximized and canonicalized tags for a given language.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">haveTags []*haveTag
original bool</code></pre>
         </article>
         
         <article class="struct" data-name="haveTag">
            <h2>type haveTag struct</h2>
            <hr />
            
            <p>haveTag holds a supported Tag and its maximized script and region. The maximized
or canonicalized language is not stored as it is not needed during matching.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tag language.Tag
index int
conf Confidence
maxRegion language.Region
maxScript language.Script
altScript language.Script
nextMax uint16</code></pre>
         </article>
         
         <article class="struct" data-name="bestMatch">
            <h2>type bestMatch struct</h2>
            <hr />
            
            <p>bestMatch accumulates the best match so far.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">have *haveTag
want language.Tag
conf Confidence
pinnedRegion language.Region
pinLanguage bool
sameRegionGroup bool
origLang bool
origReg bool
paradigmReg bool
regGroupDist uint8
origScript bool</code></pre>
         </article>
         
         <article class="struct" data-name="tagSort">
            <h2>type tagSort struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">tag []Tag
q []float32</code></pre>
         </article>
         
         <article class="struct" data-name="mutualIntelligibility">
            <h2>type mutualIntelligibility struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">want uint16
have uint16
distance uint8
oneway bool</code></pre>
         </article>
         
         <article class="struct" data-name="scriptIntelligibility">
            <h2>type scriptIntelligibility struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">wantLang uint16
haveLang uint16
wantScript uint8
haveScript uint8
distance uint8</code></pre>
         </article>
         
         <article class="struct" data-name="regionIntelligibility">
            <h2>type regionIntelligibility struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">lang uint16
script uint8
group uint8
distance uint8</code></pre>
         </article>
         
         <article class="struct" data-name="allSubtags">
            <h2>type allSubtags struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="coverage">
            <h2>type coverage struct</h2>
            <hr />
            
            <p>coverage is used by NewCoverage which is used as a convenient way for
creating Coverage implementations for partially defined data. Very often a
package will only need to define a subset of slices. coverage provides a
convenient way to do this. Moreover, packages using NewCoverage, instead of
their own implementation, will not break if later new slice types are added.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tags func
bases func
scripts func
regions func</code></pre>
         </article>
          
         <article class="function" data-name="makeTag">
            <h2>makeTag</h2>
            <hr />
            
            <pre><code>func makeTag(t language.Tag) tag Tag</code></pre>
         </article>
         
         <article class="function" data-name="tag">
            <h2>tag</h2>
            <hr />
            
            <pre><code>func tag() language.Tag</code></pre>
         </article>
         
         <article class="function" data-name="isCompact">
            <h2>isCompact</h2>
            <hr />
            
            <pre><code>func isCompact() bool</code></pre>
         </article>
         
         <article class="function" data-name="lang">
            <h2>lang</h2>
            <hr />
            
            <p>TODO: improve performance.</p>
            
            <pre><code>func lang() language.Language</code></pre>
         </article>
         
         <article class="function" data-name="region">
            <h2>region</h2>
            <hr />
            
            <pre><code>func region() language.Region</code></pre>
         </article>
         
         <article class="function" data-name="script">
            <h2>script</h2>
            <hr />
            
            <pre><code>func script() language.Script</code></pre>
         </article>
         
         <article class="function" data-name="Make">
            <h2>Make</h2>
            <hr />
            
            <p>Make is a convenience wrapper for Parse that omits the error.
In case of an error, a sensible default is returned.</p>
            
            <pre><code>func Make(s string) Tag</code></pre>
         </article>
         
         <article class="function" data-name="Make">
            <h2>Make</h2>
            <hr />
            
            <p>Make is a convenience wrapper for c.Parse that omits the error.
In case of an error, a sensible default is returned.</p>
            
            <pre><code>func Make(s string) Tag</code></pre>
         </article>
         
         <article class="function" data-name="Raw">
            <h2>Raw</h2>
            <hr />
            
            <p>Raw returns the raw base language, script and region, without making an
attempt to infer their values.</p>
            
            <pre><code>func Raw() (b Base, s Script, r Region)</code></pre>
         </article>
         
         <article class="function" data-name="IsRoot">
            <h2>IsRoot</h2>
            <hr />
            
            <p>IsRoot returns true if t is equal to language "und".</p>
            
            <pre><code>func IsRoot() bool</code></pre>
         </article>
         
         <article class="function" data-name="canonicalize">
            <h2>canonicalize</h2>
            <hr />
            
            <p>canonicalize returns the canonicalized equivalent of the tag and
whether there was any change.</p>
            
            <pre><code>func canonicalize(c CanonType, t language.Tag) (language.Tag, bool)</code></pre>
         </article>
         
         <article class="function" data-name="Canonicalize">
            <h2>Canonicalize</h2>
            <hr />
            
            <p>Canonicalize returns the canonicalized equivalent of the tag.</p>
            
            <pre><code>func Canonicalize(t Tag) (Tag, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the canonical string representation of the language tag.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="MarshalText">
            <h2>MarshalText</h2>
            <hr />
            
            <p>MarshalText implements encoding.TextMarshaler.</p>
            
            <pre><code>func MarshalText() (text []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalText">
            <h2>UnmarshalText</h2>
            <hr />
            
            <p>UnmarshalText implements encoding.TextUnmarshaler.</p>
            
            <pre><code>func UnmarshalText(text []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="Base">
            <h2>Base</h2>
            <hr />
            
            <p>Base returns the base language of the language tag. If the base language is
unspecified, an attempt will be made to infer it from the context.
It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.</p>
            
            <pre><code>func Base() (Base, Confidence)</code></pre>
         </article>
         
         <article class="function" data-name="Script">
            <h2>Script</h2>
            <hr />
            
            <p>Script infers the script for the language tag. If it was not explicitly given, it will infer
a most likely candidate.
If more than one script is commonly used for a language, the most likely one
is returned with a low confidence indication. For example, it returns (Cyrl, Low)
for Serbian.
If a script cannot be inferred (Zzzz, No) is returned. We do not use Zyyy (undetermined)
as one would suspect from the IANA registry for BCP 47. In a Unicode context Zyyy marks
common characters (like 1, 2, 3, '.', etc.) and is therefore more like multiple scripts.
See https://www.unicode.org/reports/tr24/#Values for more details. Zzzz is also used for
unknown value in CLDR.  (Zzzz, Exact) is returned if Zzzz was explicitly specified.
Note that an inferred script is never guaranteed to be the correct one. Latin is
almost exclusively used for Afrikaans, but Arabic has been used for some texts
in the past.  Also, the script that is commonly used may change over time.
It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.</p>
            
            <pre><code>func Script() (Script, Confidence)</code></pre>
         </article>
         
         <article class="function" data-name="Region">
            <h2>Region</h2>
            <hr />
            
            <p>Region returns the region for the language tag. If it was not explicitly given, it will
infer a most likely candidate from the context.
It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.</p>
            
            <pre><code>func Region() (Region, Confidence)</code></pre>
         </article>
         
         <article class="function" data-name="Variants">
            <h2>Variants</h2>
            <hr />
            
            <p>Variants returns the variants specified explicitly for this language tag.
or nil if no variant was specified.</p>
            
            <pre><code>func Variants() []Variant</code></pre>
         </article>
         
         <article class="function" data-name="Parent">
            <h2>Parent</h2>
            <hr />
            
            <p>Parent returns the CLDR parent of t. In CLDR, missing fields in data for a
specific language are substituted with fields from the parent language.
The parent for a language may change for newer versions of CLDR.

Parent returns a tag for a less specific language that is mutually
intelligible or Und if there is no such language. This may not be the same as
simply stripping the last BCP 47 subtag. For instance, the parent of "zh-TW"
is "zh-Hant", and the parent of "zh-Hant" is "und".</p>
            
            <pre><code>func Parent() Tag</code></pre>
         </article>
         
         <article class="function" data-name="nextToken">
            <h2>nextToken</h2>
            <hr />
            
            <p>nextToken returns token t and the rest of the string.</p>
            
            <pre><code>func nextToken(s string) (t string, tail string)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the string representation of the extension, including the
type tag.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ParseExtension">
            <h2>ParseExtension</h2>
            <hr />
            
            <p>ParseExtension parses s as an extension and returns it on success.</p>
            
            <pre><code>func ParseExtension(s string) (e Extension, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <p>Type returns the one-byte extension type of e. It returns 0 for the zero
exception.</p>
            
            <pre><code>func Type() byte</code></pre>
         </article>
         
         <article class="function" data-name="Tokens">
            <h2>Tokens</h2>
            <hr />
            
            <p>Tokens returns the list of tokens of e.</p>
            
            <pre><code>func Tokens() []string</code></pre>
         </article>
         
         <article class="function" data-name="Extension">
            <h2>Extension</h2>
            <hr />
            
            <p>Extension returns the extension of type x for tag t. It will return
false for ok if t does not have the requested extension. The returned
extension will be invalid in this case.</p>
            
            <pre><code>func Extension(x byte) (ext Extension, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="Extensions">
            <h2>Extensions</h2>
            <hr />
            
            <p>Extensions returns all extensions of t.</p>
            
            <pre><code>func Extensions() []Extension</code></pre>
         </article>
         
         <article class="function" data-name="TypeForKey">
            <h2>TypeForKey</h2>
            <hr />
            
            <p>TypeForKey returns the type associated with the given key, where key and type
are of the allowed values defined for the Unicode locale extension ('u') in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
TypeForKey will traverse the inheritance chain to get the correct value.

If there are multiple types associated with a key, only the first will be
returned. If there is no type associated with a key, it returns the empty
string.</p>
            
            <pre><code>func TypeForKey(key string) string</code></pre>
         </article>
         
         <article class="function" data-name="SetTypeForKey">
            <h2>SetTypeForKey</h2>
            <hr />
            
            <p>SetTypeForKey returns a new Tag with the key set to type, where key and type
are of the allowed values defined for the Unicode locale extension ('u') in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
An empty value removes an existing pair with the same key.</p>
            
            <pre><code>func SetTypeForKey(key string, value string) (Tag, error)</code></pre>
         </article>
         
         <article class="function" data-name="CompactIndex">
            <h2>CompactIndex</h2>
            <hr />
            
            <p>CompactIndex returns an index, where 0 <= index < NumCompactTags, for tags
for which data exists in the text repository.The index will change over time
and should not be stored in persistent storage. If t does not match a compact
index, exact will be false and the compact index will be returned for the
first match after repeatedly taking the Parent of t.</p>
            
            <pre><code>func CompactIndex(t Tag) (index int, exact bool)</code></pre>
         </article>
         
         <article class="function" data-name="ParseBase">
            <h2>ParseBase</h2>
            <hr />
            
            <p>ParseBase parses a 2- or 3-letter ISO 639 code.
It returns a ValueError if s is a well-formed but unknown language identifier
or another error if another error occurred.</p>
            
            <pre><code>func ParseBase(s string) (Base, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the BCP 47 representation of the base language.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ISO3">
            <h2>ISO3</h2>
            <hr />
            
            <p>ISO3 returns the ISO 639-3 language code.</p>
            
            <pre><code>func ISO3() string</code></pre>
         </article>
         
         <article class="function" data-name="IsPrivateUse">
            <h2>IsPrivateUse</h2>
            <hr />
            
            <p>IsPrivateUse reports whether this language code is reserved for private use.</p>
            
            <pre><code>func IsPrivateUse() bool</code></pre>
         </article>
         
         <article class="function" data-name="ParseScript">
            <h2>ParseScript</h2>
            <hr />
            
            <p>ParseScript parses a 4-letter ISO 15924 code.
It returns a ValueError if s is a well-formed but unknown script identifier
or another error if another error occurred.</p>
            
            <pre><code>func ParseScript(s string) (Script, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the script code in title case.
It returns "Zzzz" for an unspecified script.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="IsPrivateUse">
            <h2>IsPrivateUse</h2>
            <hr />
            
            <p>IsPrivateUse reports whether this script code is reserved for private use.</p>
            
            <pre><code>func IsPrivateUse() bool</code></pre>
         </article>
         
         <article class="function" data-name="EncodeM49">
            <h2>EncodeM49</h2>
            <hr />
            
            <p>EncodeM49 returns the Region for the given UN M.49 code.
It returns an error if r is not a valid code.</p>
            
            <pre><code>func EncodeM49(r int) (Region, error)</code></pre>
         </article>
         
         <article class="function" data-name="ParseRegion">
            <h2>ParseRegion</h2>
            <hr />
            
            <p>ParseRegion parses a 2- or 3-letter ISO 3166-1 or a UN M.49 code.
It returns a ValueError if s is a well-formed but unknown region identifier
or another error if another error occurred.</p>
            
            <pre><code>func ParseRegion(s string) (Region, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the BCP 47 representation for the region.
It returns "ZZ" for an unspecified region.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ISO3">
            <h2>ISO3</h2>
            <hr />
            
            <p>ISO3 returns the 3-letter ISO code of r.
Note that not all regions have a 3-letter ISO code.
In such cases this method returns "ZZZ".</p>
            
            <pre><code>func ISO3() string</code></pre>
         </article>
         
         <article class="function" data-name="M49">
            <h2>M49</h2>
            <hr />
            
            <p>M49 returns the UN M.49 encoding of r, or 0 if this encoding
is not defined for r.</p>
            
            <pre><code>func M49() int</code></pre>
         </article>
         
         <article class="function" data-name="IsPrivateUse">
            <h2>IsPrivateUse</h2>
            <hr />
            
            <p>IsPrivateUse reports whether r has the ISO 3166 User-assigned status. This
may include private-use tags that are assigned by CLDR and used in this
implementation. So IsPrivateUse and IsCountry can be simultaneously true.</p>
            
            <pre><code>func IsPrivateUse() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsCountry">
            <h2>IsCountry</h2>
            <hr />
            
            <p>IsCountry returns whether this region is a country or autonomous area. This
includes non-standard definitions from CLDR.</p>
            
            <pre><code>func IsCountry() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsGroup">
            <h2>IsGroup</h2>
            <hr />
            
            <p>IsGroup returns whether this region defines a collection of regions. This
includes non-standard definitions from CLDR.</p>
            
            <pre><code>func IsGroup() bool</code></pre>
         </article>
         
         <article class="function" data-name="Contains">
            <h2>Contains</h2>
            <hr />
            
            <p>Contains returns whether Region c is contained by Region r. It returns true
if c == r.</p>
            
            <pre><code>func Contains(c Region) bool</code></pre>
         </article>
         
         <article class="function" data-name="TLD">
            <h2>TLD</h2>
            <hr />
            
            <p>TLD returns the country code top-level domain (ccTLD). UK is returned for GB.
In all other cases it returns either the region itself or an error.

This method may return an error for a region for which there exists a
canonical form with a ccTLD. To get that ccTLD canonicalize r first. The
region will already be canonicalized it was obtained from a Tag that was
obtained using any of the default methods.</p>
            
            <pre><code>func TLD() (Region, error)</code></pre>
         </article>
         
         <article class="function" data-name="Canonicalize">
            <h2>Canonicalize</h2>
            <hr />
            
            <p>Canonicalize returns the region or a possible replacement if the region is
deprecated. It will not return a replacement for deprecated regions that
are split into multiple regions.</p>
            
            <pre><code>func Canonicalize() Region</code></pre>
         </article>
         
         <article class="function" data-name="ParseVariant">
            <h2>ParseVariant</h2>
            <hr />
            
            <p>ParseVariant parses and returns a Variant. An error is returned if s is not
a valid variant.</p>
            
            <pre><code>func ParseVariant(s string) (Variant, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the string representation of the variant.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="PreferSameScript">
            <h2>PreferSameScript</h2>
            <hr />
            
            <p>PreferSameScript will, in the absence of a match, result in the first
preferred tag with the same script as a supported tag to match this supported
tag. The default is currently true, but this may change in the future.</p>
            
            <pre><code>func PreferSameScript(preferSame bool) MatchOption</code></pre>
         </article>
         
         <article class="function" data-name="MatchStrings">
            <h2>MatchStrings</h2>
            <hr />
            
            <p>MatchStrings parses and matches the given strings until one of them matches
the language in the Matcher. A string may be an Accept-Language header as
handled by ParseAcceptLanguage. The default language is returned if no
other language matched.</p>
            
            <pre><code>func MatchStrings(m Matcher, lang ...string) (tag Tag, index int)</code></pre>
         </article>
         
         <article class="function" data-name="Comprehends">
            <h2>Comprehends</h2>
            <hr />
            
            <p>Comprehends reports the confidence score for a speaker of a given language
to being able to comprehend the written form of an alternative language.</p>
            
            <pre><code>func Comprehends(speaker Tag, alternative Tag) Confidence</code></pre>
         </article>
         
         <article class="function" data-name="NewMatcher">
            <h2>NewMatcher</h2>
            <hr />
            
            <p>NewMatcher returns a Matcher that matches an ordered list of preferred tags
against a list of supported tags based on written intelligibility, closeness
of dialect, equivalence of subtags and various other rules. It is initialized
with the list of supported tags. The first element is used as the default
value in case no match is found.

Its Match method matches the first of the given Tags to reach a certain
confidence threshold. The tags passed to Match should therefore be specified
in order of preference. Extensions are ignored for matching.

The index returned by the Match method corresponds to the index of the
matched tag in t, but is augmented with the Unicode extension ('u')of the
corresponding preferred tag. This allows user locale options to be passed
transparently.</p>
            
            <pre><code>func NewMatcher(t []Tag, options ...MatchOption) Matcher</code></pre>
         </article>
         
         <article class="function" data-name="Match">
            <h2>Match</h2>
            <hr />
            
            <pre><code>func Match(want ...Tag) (t Tag, index int, c Confidence)</code></pre>
         </article>
         
         <article class="function" data-name="makeHaveTag">
            <h2>makeHaveTag</h2>
            <hr />
            
            <pre><code>func makeHaveTag(tag language.Tag, index int) (haveTag, language.Language)</code></pre>
         </article>
         
         <article class="function" data-name="altScript">
            <h2>altScript</h2>
            <hr />
            
            <p>altScript returns an alternative script that may match the given script with
a low confidence.  At the moment, the langMatch data allows for at most one
script to map to another and we rely on this to keep the code simple.</p>
            
            <pre><code>func altScript(l language.Language, s language.Script) language.Script</code></pre>
         </article>
         
         <article class="function" data-name="addIfNew">
            <h2>addIfNew</h2>
            <hr />
            
            <p>addIfNew adds a haveTag to the list of tags only if it is a unique tag.
Tags that have the same maximized values are linked by index.</p>
            
            <pre><code>func addIfNew(n haveTag, exact bool)</code></pre>
         </article>
         
         <article class="function" data-name="header">
            <h2>header</h2>
            <hr />
            
            <p>header returns the matchHeader for the given language. It creates one if
it doesn't already exist.</p>
            
            <pre><code>func header(l language.Language) *matchHeader</code></pre>
         </article>
         
         <article class="function" data-name="toConf">
            <h2>toConf</h2>
            <hr />
            
            <pre><code>func toConf(d uint8) Confidence</code></pre>
         </article>
         
         <article class="function" data-name="newMatcher">
            <h2>newMatcher</h2>
            <hr />
            
            <p>newMatcher builds an index for the given supported tags and returns it as
a matcher. It also expands the index by considering various equivalence classes
for a given tag.</p>
            
            <pre><code>func newMatcher(supported []Tag, options []MatchOption) *matcher</code></pre>
         </article>
         
         <article class="function" data-name="getBest">
            <h2>getBest</h2>
            <hr />
            
            <p>getBest gets the best matching tag in m for any of the given tags, taking into
account the order of preference of the given tags.</p>
            
            <pre><code>func getBest(want ...Tag) (got *haveTag, orig language.Tag, c Confidence)</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <p>update updates the existing best match if the new pair is considered to be a
better match. To determine if the given pair is a better match, it first
computes the rough confidence level. If this surpasses the current match, it
will replace it and update the tie-breaker rule cache. If there is a tie, it
proceeds with applying a series of tie-breaker rules. If there is no
conclusive winner after applying the tie-breaker rules, it leaves the current
match as the preferred match.

If pin is true and have and tag are a strong match, it will henceforth only
consider matches for this language. This corresponds to the idea that most
users have a strong preference for the first defined language. A user can
still prefer a second language over a dialect of the preferred language by
explicitly specifying dialects, e.g. "en, nl, en-GB". In this case pin should
be false.</p>
            
            <pre><code>func update(have *haveTag, tag language.Tag, maxScript language.Script, maxRegion language.Region, pin bool)</code></pre>
         </article>
         
         <article class="function" data-name="isParadigmLocale">
            <h2>isParadigmLocale</h2>
            <hr />
            
            <pre><code>func isParadigmLocale(lang language.Language, r language.Region) bool</code></pre>
         </article>
         
         <article class="function" data-name="regionGroupDist">
            <h2>regionGroupDist</h2>
            <hr />
            
            <p>regionGroupDist computes the distance between two regions based on their
CLDR grouping.</p>
            
            <pre><code>func regionGroupDist(a language.Region, b language.Region, script language.Script, lang language.Language) (dist uint8, same bool)</code></pre>
         </article>
         
         <article class="function" data-name="equalsRest">
            <h2>equalsRest</h2>
            <hr />
            
            <p>equalsRest compares everything except the language.</p>
            
            <pre><code>func equalsRest(a language.Tag, b language.Tag) bool</code></pre>
         </article>
         
         <article class="function" data-name="isExactEquivalent">
            <h2>isExactEquivalent</h2>
            <hr />
            
            <p>isExactEquivalent returns true if canonicalizing the language will not alter
the script or region of a tag.</p>
            
            <pre><code>func isExactEquivalent(l language.Language) bool</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses the given BCP 47 string and returns a valid Tag. If parsing
failed it returns an error and any part of the tag that could be parsed.
If parsing succeeded but an unknown value was found, it returns
ValueError. The Tag returned in this case is just stripped of the unknown
value. All other values are preserved. It accepts tags in the BCP 47 format
and extensions to this standard defined in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
The resulting tag is canonicalized using the default canonicalization type.</p>
            
            <pre><code>func Parse(s string) (t Tag, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses the given BCP 47 string and returns a valid Tag. If parsing
failed it returns an error and any part of the tag that could be parsed.
If parsing succeeded but an unknown value was found, it returns
ValueError. The Tag returned in this case is just stripped of the unknown
value. All other values are preserved. It accepts tags in the BCP 47 format
and extensions to this standard defined in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
The resulting tag is canonicalized using the canonicalization type c.</p>
            
            <pre><code>func Parse(s string) (t Tag, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Compose">
            <h2>Compose</h2>
            <hr />
            
            <p>Compose creates a Tag from individual parts, which may be of type Tag, Base,
Script, Region, Variant, []Variant, Extension, []Extension or error. If a
Base, Script or Region or slice of type Variant or Extension is passed more
than once, the latter will overwrite the former. Variants and Extensions are
accumulated, but if two extensions of the same type are passed, the latter
will replace the former. For -u extensions, though, the key-type pairs are
added, where later values overwrite older ones. A Tag overwrites all former
values and typically only makes sense as the first argument. The resulting
tag is returned after canonicalizing using the Default CanonType. If one or
more errors are encountered, one of the errors is returned.</p>
            
            <pre><code>func Compose(part ...*ast.InterfaceType) (t Tag, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Compose">
            <h2>Compose</h2>
            <hr />
            
            <p>Compose creates a Tag from individual parts, which may be of type Tag, Base,
Script, Region, Variant, []Variant, Extension, []Extension or error. If a
Base, Script or Region or slice of type Variant or Extension is passed more
than once, the latter will overwrite the former. Variants and Extensions are
accumulated, but if two extensions of the same type are passed, the latter
will replace the former. For -u extensions, though, the key-type pairs are
added, where later values overwrite older ones. A Tag overwrites all former
values and typically only makes sense as the first argument. The resulting
tag is returned after canonicalizing using CanonType c. If one or more errors
are encountered, one of the errors is returned.</p>
            
            <pre><code>func Compose(part ...*ast.InterfaceType) (t Tag, err error)</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>func update(b *language.Builder, part ...*ast.InterfaceType) err error</code></pre>
         </article>
         
         <article class="function" data-name="ParseAcceptLanguage">
            <h2>ParseAcceptLanguage</h2>
            <hr />
            
            <p>ParseAcceptLanguage parses the contents of an Accept-Language header as
defined in http://www.ietf.org/rfc/rfc2616.txt and returns a list of Tags and
a list of corresponding quality weights. It is more permissive than RFC 2616
and may return non-nil slices even if the input is not valid.
The Tags will be sorted by highest weight first and then by first occurrence.
Tags with a weight of zero will be dropped. An error will be returned if the
input could not be parsed.</p>
            
            <pre><code>func ParseAcceptLanguage(s string) (tag []Tag, q []float32, err error)</code></pre>
         </article>
         
         <article class="function" data-name="consume">
            <h2>consume</h2>
            <hr />
            
            <p>consume removes a leading token c from s and returns the result or the empty
string if there is no such token.</p>
            
            <pre><code>func consume(s string, c byte) string</code></pre>
         </article>
         
         <article class="function" data-name="split">
            <h2>split</h2>
            <hr />
            
            <pre><code>func split(s string, c byte) (head string, tail string)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="MustParse">
            <h2>MustParse</h2>
            <hr />
            
            <p>MustParse is like Parse, but panics if the given BCP 47 tag cannot be parsed.
It simplifies safe initialization of Tag values.</p>
            
            <pre><code>func MustParse(s string) Tag</code></pre>
         </article>
         
         <article class="function" data-name="MustParse">
            <h2>MustParse</h2>
            <hr />
            
            <p>MustParse is like Parse, but panics if the given BCP 47 tag cannot be parsed.
It simplifies safe initialization of Tag values.</p>
            
            <pre><code>func MustParse(s string) Tag</code></pre>
         </article>
         
         <article class="function" data-name="MustParseBase">
            <h2>MustParseBase</h2>
            <hr />
            
            <p>MustParseBase is like ParseBase, but panics if the given base cannot be parsed.
It simplifies safe initialization of Base values.</p>
            
            <pre><code>func MustParseBase(s string) Base</code></pre>
         </article>
         
         <article class="function" data-name="MustParseScript">
            <h2>MustParseScript</h2>
            <hr />
            
            <p>MustParseScript is like ParseScript, but panics if the given script cannot be
parsed. It simplifies safe initialization of Script values.</p>
            
            <pre><code>func MustParseScript(s string) Script</code></pre>
         </article>
         
         <article class="function" data-name="MustParseRegion">
            <h2>MustParseRegion</h2>
            <hr />
            
            <p>MustParseRegion is like ParseRegion, but panics if the given region cannot be
parsed. It simplifies safe initialization of Region values.</p>
            
            <pre><code>func MustParseRegion(s string) Region</code></pre>
         </article>
         
         <article class="function" data-name="Regions">
            <h2>Regions</h2>
            <hr />
            
            <p>Regions returns the list of supported regions. As all regions are in a
consecutive range, it simply returns a slice of numbers in increasing order.
The "undefined" region is not returned.</p>
            
            <pre><code>func Regions() []Region</code></pre>
         </article>
         
         <article class="function" data-name="Scripts">
            <h2>Scripts</h2>
            <hr />
            
            <p>Scripts returns the list of supported scripts. As all scripts are in a
consecutive range, it simply returns a slice of numbers in increasing order.
The "undefined" script is not returned.</p>
            
            <pre><code>func Scripts() []Script</code></pre>
         </article>
         
         <article class="function" data-name="BaseLanguages">
            <h2>BaseLanguages</h2>
            <hr />
            
            <p>BaseLanguages returns the list of all supported base languages. It generates
the list by traversing the internal structures.</p>
            
            <pre><code>func BaseLanguages() []Base</code></pre>
         </article>
         
         <article class="function" data-name="Tags">
            <h2>Tags</h2>
            <hr />
            
            <p>Tags always returns nil.</p>
            
            <pre><code>func Tags() []Tag</code></pre>
         </article>
         
         <article class="function" data-name="Tags">
            <h2>Tags</h2>
            <hr />
            
            <pre><code>func Tags() []Tag</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="BaseLanguages">
            <h2>BaseLanguages</h2>
            <hr />
            
            <p>BaseLanguages returns the result from calling s.bases if it is specified or
otherwise derives the set of supported base languages from tags.</p>
            
            <pre><code>func BaseLanguages() []Base</code></pre>
         </article>
         
         <article class="function" data-name="Scripts">
            <h2>Scripts</h2>
            <hr />
            
            <pre><code>func Scripts() []Script</code></pre>
         </article>
         
         <article class="function" data-name="Regions">
            <h2>Regions</h2>
            <hr />
            
            <pre><code>func Regions() []Region</code></pre>
         </article>
         
         <article class="function" data-name="NewCoverage">
            <h2>NewCoverage</h2>
            <hr />
            
            <p>NewCoverage returns a Coverage for the given lists. It is typically used by
packages providing internationalization services to define their level of
coverage. A list may be of type []T or func() []T, where T is either Tag,
Base, Script or Region. The returned Coverage derives the value for Bases
from Tags if no func or slice for []Base is specified. For other unspecified
types the returned Coverage will return nil for the respective methods.</p>
            
            <pre><code>func NewCoverage(list ...*ast.InterfaceType) Coverage</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
