<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - language</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>language</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"sort"
"strconv"
"strings"
"golang.org/x/text/internal/language"
"golang.org/x/text/internal/language/compact"
"fmt"
"sort"
"golang.org/x/text/internal/language"
"strings"
"golang.org/x/text/internal/language"
"golang.org/x/text/internal/language/compact"
"errors"
"strings"
"golang.org/x/text/internal/language"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Afrikaans">
               <h3>
                  Afrikaans 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Afrikaans Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Albanian">
               <h3>
                  Albanian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Albanian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="All">
               <h3>
                  All 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>All canonicalizations.</p>
               
               <pre><code>const All = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="AmericanEnglish">
               <h3>
                  AmericanEnglish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var AmericanEnglish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Amharic">
               <h3>
                  Amharic 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Amharic Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Arabic">
               <h3>
                  Arabic 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Arabic Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Armenian">
               <h3>
                  Armenian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Armenian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Azerbaijani">
               <h3>
                  Azerbaijani 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Azerbaijani Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="BCP47">
               <h3>
                  BCP47 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>All canonicalizations recommended by BCP 47.</p>
               
               <pre><code>const BCP47 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Bengali">
               <h3>
                  Bengali 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Bengali Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="BrazilianPortuguese">
               <h3>
                  BrazilianPortuguese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var BrazilianPortuguese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="BritishEnglish">
               <h3>
                  BritishEnglish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var BritishEnglish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Bulgarian">
               <h3>
                  Bulgarian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Bulgarian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Burmese">
               <h3>
                  Burmese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Burmese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="CLDR">
               <h3>
                  CLDR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The CLDR flag should be used if full compatibility with CLDR is required.
There are a few cases where language.Tag may differ from CLDR. To follow all
of CLDR's suggestions, use All|CLDR.</p>
               
               <pre><code>const CLDR</code></pre>
            </article>
            
            <article class="global" data-name="CLDRVersion">
               <h3>
                  CLDRVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>CLDRVersion is the CLDR version from which the tables in this package are derived.</p>
               
               <pre><code>const CLDRVersion = "32"</code></pre>
            </article>
            
            <article class="global" data-name="CanadianFrench">
               <h3>
                  CanadianFrench 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var CanadianFrench Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Catalan">
               <h3>
                  Catalan 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Catalan Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Chinese">
               <h3>
                  Chinese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Chinese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Croatian">
               <h3>
                  Croatian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Croatian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Czech">
               <h3>
                  Czech 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Czech Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Danish">
               <h3>
                  Danish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Danish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Default">
               <h3>
                  Default 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Default is the canonicalization used by Parse, Make and Compose. To
preserve as much information as possible, canonicalizations that remove
potentially valuable information are not included. The Matcher is
designed to recognize similar tags that would be the same if
they were canonicalized using All.</p>
               
               <pre><code>const Default = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Deprecated">
               <h3>
                  Deprecated 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Replace all deprecated tags with their preferred replacements.</p>
               
               <pre><code>const Deprecated = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="DeprecatedBase">
               <h3>
                  DeprecatedBase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Replace deprecated base languages with their preferred replacements.</p>
               
               <pre><code>const DeprecatedBase CanonType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="DeprecatedRegion">
               <h3>
                  DeprecatedRegion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Replace deprecated regions with their preferred replacements.</p>
               
               <pre><code>const DeprecatedRegion</code></pre>
            </article>
            
            <article class="global" data-name="DeprecatedScript">
               <h3>
                  DeprecatedScript 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Replace deprecated scripts with their preferred replacements.</p>
               
               <pre><code>const DeprecatedScript</code></pre>
            </article>
            
            <article class="global" data-name="Dutch">
               <h3>
                  Dutch 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Dutch Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="English">
               <h3>
                  English 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var English Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrMissingLikelyTagsData">
               <h3>
                  ErrMissingLikelyTagsData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrMissingLikelyTagsData indicates no information was available
to compute likely values of missing tags.</p>
               
               <pre><code>var ErrMissingLikelyTagsData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Estonian">
               <h3>
                  Estonian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Estonian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="EuropeanPortuguese">
               <h3>
                  EuropeanPortuguese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var EuropeanPortuguese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="EuropeanSpanish">
               <h3>
                  EuropeanSpanish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var EuropeanSpanish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Exact">
               <h3>
                  Exact 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Exact</code></pre>
            </article>
            
            <article class="global" data-name="Filipino">
               <h3>
                  Filipino 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Filipino Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Finnish">
               <h3>
                  Finnish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Finnish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="French">
               <h3>
                  French 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var French Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Georgian">
               <h3>
                  Georgian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Georgian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="German">
               <h3>
                  German 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var German Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Greek">
               <h3>
                  Greek 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Greek Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Gujarati">
               <h3>
                  Gujarati 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Gujarati Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Hebrew">
               <h3>
                  Hebrew 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Hebrew Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="High">
               <h3>
                  High 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const High</code></pre>
            </article>
            
            <article class="global" data-name="Hindi">
               <h3>
                  Hindi 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Hindi Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Hungarian">
               <h3>
                  Hungarian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Hungarian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Icelandic">
               <h3>
                  Icelandic 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Icelandic Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Indonesian">
               <h3>
                  Indonesian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Indonesian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Italian">
               <h3>
                  Italian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Italian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Japanese">
               <h3>
                  Japanese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Japanese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Kannada">
               <h3>
                  Kannada 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Kannada Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Kazakh">
               <h3>
                  Kazakh 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Kazakh Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Khmer">
               <h3>
                  Khmer 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Khmer Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Kirghiz">
               <h3>
                  Kirghiz 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Kirghiz Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Korean">
               <h3>
                  Korean 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Korean Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Lao">
               <h3>
                  Lao 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Lao Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="LatinAmericanSpanish">
               <h3>
                  LatinAmericanSpanish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var LatinAmericanSpanish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Latvian">
               <h3>
                  Latvian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Latvian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Legacy">
               <h3>
                  Legacy 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Normalize legacy encodings. This includes legacy languages defined in
CLDR as well as bibliographic codes defined in ISO-639.</p>
               
               <pre><code>const Legacy</code></pre>
            </article>
            
            <article class="global" data-name="Lithuanian">
               <h3>
                  Lithuanian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Lithuanian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Low">
               <h3>
                  Low 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Low</code></pre>
            </article>
            
            <article class="global" data-name="Macedonian">
               <h3>
                  Macedonian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Macedonian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Macro">
               <h3>
                  Macro 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Map the dominant language of a macro language group to the macro language
subtag. For example cmn -> zh.</p>
               
               <pre><code>const Macro</code></pre>
            </article>
            
            <article class="global" data-name="Malay">
               <h3>
                  Malay 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Malay Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Malayalam">
               <h3>
                  Malayalam 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Malayalam Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Marathi">
               <h3>
                  Marathi 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Marathi Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ModernStandardArabic">
               <h3>
                  ModernStandardArabic 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ModernStandardArabic Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Mongolian">
               <h3>
                  Mongolian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Mongolian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Nepali">
               <h3>
                  Nepali 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Nepali Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="No">
               <h3>
                  No 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const No Confidence = iota</code></pre>
            </article>
            
            <article class="global" data-name="Norwegian">
               <h3>
                  Norwegian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Norwegian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="NumCompactTags">
               <h3>
                  NumCompactTags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NumCompactTags is the number of compact tags. The maximum tag is
NumCompactTags-1.</p>
               
               <pre><code>const NumCompactTags = compact.NumCompactTags</code></pre>
            </article>
            
            <article class="global" data-name="Persian">
               <h3>
                  Persian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Persian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Polish">
               <h3>
                  Polish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Polish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Portuguese">
               <h3>
                  Portuguese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Portuguese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Punjabi">
               <h3>
                  Punjabi 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Punjabi Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Raw">
               <h3>
                  Raw 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Raw can be used to Compose or Parse without Canonicalization.</p>
               
               <pre><code>const Raw CanonType = 0</code></pre>
            </article>
            
            <article class="global" data-name="Romanian">
               <h3>
                  Romanian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Romanian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Russian">
               <h3>
                  Russian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Russian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Serbian">
               <h3>
                  Serbian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Serbian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="SerbianLatin">
               <h3>
                  SerbianLatin 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var SerbianLatin Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="SimplifiedChinese">
               <h3>
                  SimplifiedChinese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var SimplifiedChinese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Sinhala">
               <h3>
                  Sinhala 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Sinhala Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Slovak">
               <h3>
                  Slovak 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Slovak Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Slovenian">
               <h3>
                  Slovenian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Slovenian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Spanish">
               <h3>
                  Spanish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Spanish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Supported">
               <h3>
                  Supported 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Supported defines a Coverage that lists all supported subtags. Tags
always returns nil.</p>
               
               <pre><code>var Supported Coverage = allSubtags{...}</code></pre>
            </article>
            
            <article class="global" data-name="SuppressScript">
               <h3>
                  SuppressScript 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Remove redundant scripts.</p>
               
               <pre><code>const SuppressScript</code></pre>
            </article>
            
            <article class="global" data-name="Swahili">
               <h3>
                  Swahili 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Swahili Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Swedish">
               <h3>
                  Swedish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Swedish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Tamil">
               <h3>
                  Tamil 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Tamil Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Telugu">
               <h3>
                  Telugu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Telugu Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Thai">
               <h3>
                  Thai 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Thai Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="TraditionalChinese">
               <h3>
                  TraditionalChinese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TraditionalChinese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Turkish">
               <h3>
                  Turkish 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Turkish Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Ukrainian">
               <h3>
                  Ukrainian 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Ukrainian Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Und">
               <h3>
                  Und 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Und Tag = Tag{...}</code></pre>
            </article>
            
            <article class="global" data-name="Urdu">
               <h3>
                  Urdu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Urdu Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Uzbek">
               <h3>
                  Uzbek 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Uzbek Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Vietnamese">
               <h3>
                  Vietnamese 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Vietnamese Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Zulu">
               <h3>
                  Zulu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Zulu Tag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_001">
               <h3>
                  _001 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _001 = 1</code></pre>
            </article>
            
            <article class="global" data-name="_419">
               <h3>
                  _419 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _419 = 31</code></pre>
            </article>
            
            <article class="global" data-name="_BR">
               <h3>
                  _BR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _BR = 65</code></pre>
            </article>
            
            <article class="global" data-name="_CA">
               <h3>
                  _CA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _CA = 73</code></pre>
            </article>
            
            <article class="global" data-name="_ES">
               <h3>
                  _ES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ES = 111</code></pre>
            </article>
            
            <article class="global" data-name="_GB">
               <h3>
                  _GB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _GB = 124</code></pre>
            </article>
            
            <article class="global" data-name="_Hani">
               <h3>
                  _Hani 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Hani = 57</code></pre>
            </article>
            
            <article class="global" data-name="_Hans">
               <h3>
                  _Hans 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Hans = 59</code></pre>
            </article>
            
            <article class="global" data-name="_Hant">
               <h3>
                  _Hant 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Hant = 60</code></pre>
            </article>
            
            <article class="global" data-name="_Latn">
               <h3>
                  _Latn 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Latn = 91</code></pre>
            </article>
            
            <article class="global" data-name="_MD">
               <h3>
                  _MD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _MD = 189</code></pre>
            </article>
            
            <article class="global" data-name="_PT">
               <h3>
                  _PT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _PT = 239</code></pre>
            </article>
            
            <article class="global" data-name="_Qaaa">
               <h3>
                  _Qaaa 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Qaaa = 149</code></pre>
            </article>
            
            <article class="global" data-name="_Qaai">
               <h3>
                  _Qaai 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Qaai = 157</code></pre>
            </article>
            
            <article class="global" data-name="_Qabx">
               <h3>
                  _Qabx 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Qabx = 198</code></pre>
            </article>
            
            <article class="global" data-name="_UK">
               <h3>
                  _UK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _UK = 307</code></pre>
            </article>
            
            <article class="global" data-name="_US">
               <h3>
                  _US 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _US = 310</code></pre>
            </article>
            
            <article class="global" data-name="_XA">
               <h3>
                  _XA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _XA = 324</code></pre>
            </article>
            
            <article class="global" data-name="_XC">
               <h3>
                  _XC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _XC = 326</code></pre>
            </article>
            
            <article class="global" data-name="_XK">
               <h3>
                  _XK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _XK = 334</code></pre>
            </article>
            
            <article class="global" data-name="_ZZ">
               <h3>
                  _ZZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ZZ = 358</code></pre>
            </article>
            
            <article class="global" data-name="_Zinh">
               <h3>
                  _Zinh 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Zinh = 255</code></pre>
            </article>
            
            <article class="global" data-name="_Zyyy">
               <h3>
                  _Zyyy 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Zyyy = 260</code></pre>
            </article>
            
            <article class="global" data-name="_Zzzz">
               <h3>
                  _Zzzz 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Zzzz = 261</code></pre>
            </article>
            
            <article class="global" data-name="_de">
               <h3>
                  _de 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _de = 269</code></pre>
            </article>
            
            <article class="global" data-name="_en">
               <h3>
                  _en 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _en = 313</code></pre>
            </article>
            
            <article class="global" data-name="_fr">
               <h3>
                  _fr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _fr = 350</code></pre>
            </article>
            
            <article class="global" data-name="_it">
               <h3>
                  _it 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _it = 505</code></pre>
            </article>
            
            <article class="global" data-name="_mo">
               <h3>
                  _mo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _mo = 784</code></pre>
            </article>
            
            <article class="global" data-name="_mul">
               <h3>
                  _mul 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _mul = 806</code></pre>
            </article>
            
            <article class="global" data-name="_nb">
               <h3>
                  _nb 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _nb = 839</code></pre>
            </article>
            
            <article class="global" data-name="_no">
               <h3>
                  _no 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _no = 879</code></pre>
            </article>
            
            <article class="global" data-name="_pt">
               <h3>
                  _pt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _pt = 960</code></pre>
            </article>
            
            <article class="global" data-name="_sh">
               <h3>
                  _sh 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _sh = 1031</code></pre>
            </article>
            
            <article class="global" data-name="_und">
               <h3>
                  _und 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _und = 0</code></pre>
            </article>
            
            <article class="global" data-name="acceptFallback">
               <h3>
                  acceptFallback 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Add hack mapping to deal with a small number of cases that occur
in Accept-Language (with reasonable frequency).</p>
               
               <pre><code>var acceptFallback = map[string]language.Language{...}</code></pre>
            </article>
            
            <article class="global" data-name="canonLang">
               <h3>
                  canonLang 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const canonLang = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="confName">
               <h3>
                  confName 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var confName = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidArgument">
               <h3>
                  errInvalidArgument 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errInvalidArgument = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidWeight">
               <h3>
                  errInvalidWeight 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errInvalidWeight = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errTagListTooLarge">
               <h3>
                  errTagListTooLarge 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errTagListTooLarge = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="matchLang">
               <h3>
                  matchLang 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>matchLang holds pairs of langIDs of base languages that are typically
mutually intelligible. Each pair is associated with a confidence and
whether the intelligibility goes one or both ways.</p>
               
               <pre><code>var matchLang = []mutualIntelligibility{...}</code></pre>
            </article>
            
            <article class="global" data-name="matchRegion">
               <h3>
                  matchRegion 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var matchRegion = []regionIntelligibility{...}</code></pre>
            </article>
            
            <article class="global" data-name="matchScript">
               <h3>
                  matchScript 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>matchScript holds pairs of scriptIDs where readers of one script
can typically also read the other. Each is associated with a confidence.</p>
               
               <pre><code>var matchScript = []scriptIntelligibility{...}</code></pre>
            </article>
            
            <article class="global" data-name="notEquivalent">
               <h3>
                  notEquivalent 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var notEquivalent []language.Language</code></pre>
            </article>
            
            <article class="global" data-name="paradigmLocales">
               <h3>
                  paradigmLocales 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var paradigmLocales = [][3]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="regionToGroups">
               <h3>
                  regionToGroups 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var regionToGroups = []uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="root">
               <h3>
                  root 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var root = language.Tag{...}</code></pre>
            </article>
            
            <article class="global" data-name="und">
               <h3>
                  und 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var und = Tag{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="CanonType">
               <h3>
                  CanonType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>CanonType can be used to enable or disable various types of canonicalization.</p>
               
               <pre><code>type CanonType int</code></pre>
            </article>
            
            <article class="type" data-name="Confidence">
               <h3>
                  Confidence
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Confidence indicates the level of certainty for a given return value.
For example, Serbian may be written in Cyrillic or Latin script.
The confidence level indicates whether a value was explicitly specified,
whether it is typically the only possible value, or whether there is
an ambiguity.</p>
               
               <pre><code>type Confidence int</code></pre>
            </article>
            
            <article class="type" data-name="MatchOption">
               <h3>
                  MatchOption
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A MatchOption configures a Matcher.</p>
               
               <pre><code>type MatchOption func(*matcher)</code></pre>
            </article>
            
            <article class="type" data-name="Tag">
               <h3>
                  Tag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Tag represents a BCP 47 language tag. It is used to specify an instance of a
specific language or locale. All language tag values are guaranteed to be
well-formed.</p>
               
               <pre><code>type Tag compact.Tag</code></pre>
            </article>
            
            <article class="type" data-name="bases">
               <h3>
                  bases
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>bases implements sort.Interface and is used to sort base languages.</p>
               
               <pre><code>type bases []Base</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Coverage">
               <h3>
                  Coverage
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>The Coverage interface is used to define the level of coverage of an
internationalization service. Note that not all types are supported by all
services. As lists may be generated on the fly, it is recommended that users
of a Coverage cache the results.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Coverage interface {
Tags() []Tag
BaseLanguages() []Base
Scripts() []Script
Regions() []Region
}</code></pre>
            </article>
            
            <article class="interface" data-name="Matcher">
               <h3>
                  Matcher
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Matcher is the interface that wraps the Match method.
Match returns the best match for any of the given tags, along with
a unique index associated with the returned tag and a confidence
score.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Matcher interface {
Match(t ...Tag) (tag Tag, index int, c Confidence)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ValueError">
               <h3>
                  ValueError
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ValueError is returned by any of the parsing functions when the
input is well-formed but the respective subtag is not recognized
as a valid value.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ValueError interface {
error
Subtag() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Base">
               <h3>
                  Base
                  <span class="badge">struct</span>
               </h3>
               
               <p>Base is an ISO 639 language code, used for encoding the base language
of a language tag.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Base struct {
langID language.Language
}</code></pre>
            </article>
            
            <article class="struct" data-name="Extension">
               <h3>
                  Extension
                  <span class="badge">struct</span>
               </h3>
               
               <p>Extension is a single BCP 47 extension.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Extension struct {
s string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Region">
               <h3>
                  Region
                  <span class="badge">struct</span>
               </h3>
               
               <p>Region is an ISO 3166-1 or UN M.49 code for representing countries and regions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Region struct {
regionID language.Region
}</code></pre>
            </article>
            
            <article class="struct" data-name="Script">
               <h3>
                  Script
                  <span class="badge">struct</span>
               </h3>
               
               <p>Script is a 4-letter ISO 15924 code for representing scripts.
It is idiomatically represented in title case.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Script struct {
scriptID language.Script
}</code></pre>
            </article>
            
            <article class="struct" data-name="Variant">
               <h3>
                  Variant
                  <span class="badge">struct</span>
               </h3>
               
               <p>Variant represents a registered variant of a language as defined by BCP 47.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Variant struct {
variant string
}</code></pre>
            </article>
            
            <article class="struct" data-name="allSubtags">
               <h3>
                  allSubtags
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type allSubtags struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bestMatch">
               <h3>
                  bestMatch
                  <span class="badge">struct</span>
               </h3>
               
               <p>bestMatch accumulates the best match so far.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bestMatch struct {
have *haveTag
want language.Tag
conf Confidence
pinnedRegion language.Region
pinLanguage bool
sameRegionGroup bool
origLang bool
origReg bool
paradigmReg bool
regGroupDist uint8
origScript bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="coverage">
               <h3>
                  coverage
                  <span class="badge">struct</span>
               </h3>
               
               <p>coverage is used by NewCoverage which is used as a convenient way for
creating Coverage implementations for partially defined data. Very often a
package will only need to define a subset of slices. coverage provides a
convenient way to do this. Moreover, packages using NewCoverage, instead of
their own implementation, will not break if later new slice types are added.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type coverage struct {
tags func() []Tag
bases func() []Base
scripts func() []Script
regions func() []Region
}</code></pre>
            </article>
            
            <article class="struct" data-name="haveTag">
               <h3>
                  haveTag
                  <span class="badge">struct</span>
               </h3>
               
               <p>haveTag holds a supported Tag and its maximized script and region. The maximized
or canonicalized language is not stored as it is not needed during matching.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type haveTag struct {
tag language.Tag
index int
conf Confidence
maxRegion language.Region
maxScript language.Script
altScript language.Script
nextMax uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="matchHeader">
               <h3>
                  matchHeader
                  <span class="badge">struct</span>
               </h3>
               
               <p>matchHeader has the lists of tags for exact matches and matches based on
maximized and canonicalized tags for a given language.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type matchHeader struct {
haveTags []*haveTag
original bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="matcher">
               <h3>
                  matcher
                  <span class="badge">struct</span>
               </h3>
               
               <p>matcher keeps a set of supported language tags, indexed by language.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type matcher struct {
default_ *haveTag
supported []*haveTag
index map[language.Language]*matchHeader
passSettings bool
preferSameScript bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="mutualIntelligibility">
               <h3>
                  mutualIntelligibility
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mutualIntelligibility struct {
want uint16
have uint16
distance uint8
oneway bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="regionIntelligibility">
               <h3>
                  regionIntelligibility
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regionIntelligibility struct {
lang uint16
script uint8
group uint8
distance uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="scriptIntelligibility">
               <h3>
                  scriptIntelligibility
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type scriptIntelligibility struct {
wantLang uint16
haveLang uint16
wantScript uint8
haveScript uint8
distance uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="tagSort">
               <h3>
                  tagSort
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tagSort struct {
tag []Tag
q []float32
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Base returns the base language of the language tag. If the base language is
unspecified, an attempt will be made to infer it from the context.
It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.</p>
               
               <pre><code>func (t Tag) Base() (Base, Confidence)</code></pre>
            </article>
            
            <article class="function" data-name="BaseLanguages">
               <h3>
                  BaseLanguages 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BaseLanguages returns the result from calling s.bases if it is specified or
otherwise derives the set of supported base languages from tags.</p>
               
               <pre><code>func (s *coverage) BaseLanguages() []Base</code></pre>
            </article>
            
            <article class="function" data-name="BaseLanguages">
               <h3>
                  BaseLanguages 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BaseLanguages returns the list of all supported base languages. It generates
the list by traversing the internal structures.</p>
               
               <pre><code>func (s allSubtags) BaseLanguages() []Base</code></pre>
            </article>
            
            <article class="function" data-name="Canonicalize">
               <h3>
                  Canonicalize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Canonicalize returns the region or a possible replacement if the region is
deprecated. It will not return a replacement for deprecated regions that
are split into multiple regions.</p>
               
               <pre><code>func (r Region) Canonicalize() Region</code></pre>
            </article>
            
            <article class="function" data-name="Canonicalize">
               <h3>
                  Canonicalize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Canonicalize returns the canonicalized equivalent of the tag.</p>
               
               <pre><code>func (c CanonType) Canonicalize(t Tag) (Tag, error)</code></pre>
            </article>
            
            <article class="function" data-name="CompactIndex">
               <h3>
                  CompactIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CompactIndex returns an index, where 0 <= index < NumCompactTags, for tags
for which data exists in the text repository.The index will change over time
and should not be stored in persistent storage. If t does not match a compact
index, exact will be false and the compact index will be returned for the
first match after repeatedly taking the Parent of t.</p>
               
               <pre><code>func CompactIndex(t Tag) (index int, exact bool)</code></pre>
            </article>
            
            <article class="function" data-name="Compose">
               <h3>
                  Compose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Compose creates a Tag from individual parts, which may be of type Tag, Base,
Script, Region, Variant, []Variant, Extension, []Extension or error. If a
Base, Script or Region or slice of type Variant or Extension is passed more
than once, the latter will overwrite the former. Variants and Extensions are
accumulated, but if two extensions of the same type are passed, the latter
will replace the former. For -u extensions, though, the key-type pairs are
added, where later values overwrite older ones. A Tag overwrites all former
values and typically only makes sense as the first argument. The resulting
tag is returned after canonicalizing using the Default CanonType. If one or
more errors are encountered, one of the errors is returned.</p>
               
               <pre><code>func Compose(part ...interface{}) (t Tag, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Compose">
               <h3>
                  Compose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compose creates a Tag from individual parts, which may be of type Tag, Base,
Script, Region, Variant, []Variant, Extension, []Extension or error. If a
Base, Script or Region or slice of type Variant or Extension is passed more
than once, the latter will overwrite the former. Variants and Extensions are
accumulated, but if two extensions of the same type are passed, the latter
will replace the former. For -u extensions, though, the key-type pairs are
added, where later values overwrite older ones. A Tag overwrites all former
values and typically only makes sense as the first argument. The resulting
tag is returned after canonicalizing using CanonType c. If one or more errors
are encountered, one of the errors is returned.</p>
               
               <pre><code>func (c CanonType) Compose(part ...interface{}) (t Tag, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Comprehends">
               <h3>
                  Comprehends 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Comprehends reports the confidence score for a speaker of a given language
to being able to comprehend the written form of an alternative language.</p>
               
               <pre><code>func Comprehends(speaker Tag, alternative Tag) Confidence</code></pre>
            </article>
            
            <article class="function" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Contains returns whether Region c is contained by Region r. It returns true
if c == r.</p>
               
               <pre><code>func (r Region) Contains(c Region) bool</code></pre>
            </article>
            
            <article class="function" data-name="EncodeM49">
               <h3>
                  EncodeM49 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EncodeM49 returns the Region for the given UN M.49 code.
It returns an error if r is not a valid code.</p>
               
               <pre><code>func EncodeM49(r int) (Region, error)</code></pre>
            </article>
            
            <article class="function" data-name="Extension">
               <h3>
                  Extension 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Extension returns the extension of type x for tag t. It will return
false for ok if t does not have the requested extension. The returned
extension will be invalid in this case.</p>
               
               <pre><code>func (t Tag) Extension(x byte) (ext Extension, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Extensions">
               <h3>
                  Extensions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Extensions returns all extensions of t.</p>
               
               <pre><code>func (t Tag) Extensions() []Extension</code></pre>
            </article>
            
            <article class="function" data-name="ISO3">
               <h3>
                  ISO3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ISO3 returns the 3-letter ISO code of r.
Note that not all regions have a 3-letter ISO code.
In such cases this method returns "ZZZ".</p>
               
               <pre><code>func (r Region) ISO3() string</code></pre>
            </article>
            
            <article class="function" data-name="ISO3">
               <h3>
                  ISO3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ISO3 returns the ISO 639-3 language code.</p>
               
               <pre><code>func (b Base) ISO3() string</code></pre>
            </article>
            
            <article class="function" data-name="IsCountry">
               <h3>
                  IsCountry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsCountry returns whether this region is a country or autonomous area. This
includes non-standard definitions from CLDR.</p>
               
               <pre><code>func (r Region) IsCountry() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsGroup">
               <h3>
                  IsGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsGroup returns whether this region defines a collection of regions. This
includes non-standard definitions from CLDR.</p>
               
               <pre><code>func (r Region) IsGroup() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPrivateUse">
               <h3>
                  IsPrivateUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPrivateUse reports whether r has the ISO 3166 User-assigned status. This
may include private-use tags that are assigned by CLDR and used in this
implementation. So IsPrivateUse and IsCountry can be simultaneously true.</p>
               
               <pre><code>func (r Region) IsPrivateUse() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPrivateUse">
               <h3>
                  IsPrivateUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPrivateUse reports whether this language code is reserved for private use.</p>
               
               <pre><code>func (b Base) IsPrivateUse() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPrivateUse">
               <h3>
                  IsPrivateUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPrivateUse reports whether this script code is reserved for private use.</p>
               
               <pre><code>func (s Script) IsPrivateUse() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsRoot">
               <h3>
                  IsRoot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsRoot returns true if t is equal to language "und".</p>
               
               <pre><code>func (t Tag) IsRoot() bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *tagSort) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bases) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bases) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *tagSort) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="M49">
               <h3>
                  M49 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>M49 returns the UN M.49 encoding of r, or 0 if this encoding
is not defined for r.</p>
               
               <pre><code>func (r Region) M49() int</code></pre>
            </article>
            
            <article class="function" data-name="Make">
               <h3>
                  Make 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Make is a convenience wrapper for c.Parse that omits the error.
In case of an error, a sensible default is returned.</p>
               
               <pre><code>func (c CanonType) Make(s string) Tag</code></pre>
            </article>
            
            <article class="function" data-name="Make">
               <h3>
                  Make 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Make is a convenience wrapper for Parse that omits the error.
In case of an error, a sensible default is returned.</p>
               
               <pre><code>func Make(s string) Tag</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements encoding.TextMarshaler.</p>
               
               <pre><code>func (t Tag) MarshalText() (text []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Match">
               <h3>
                  Match 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *matcher) Match(want ...Tag) (t Tag, index int, c Confidence)</code></pre>
            </article>
            
            <article class="function" data-name="MatchStrings">
               <h3>
                  MatchStrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MatchStrings parses and matches the given strings until one of them matches
the language in the Matcher. A string may be an Accept-Language header as
handled by ParseAcceptLanguage. The default language is returned if no
other language matched.</p>
               
               <pre><code>func MatchStrings(m Matcher, lang ...string) (tag Tag, index int)</code></pre>
            </article>
            
            <article class="function" data-name="MustParse">
               <h3>
                  MustParse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParse is like Parse, but panics if the given BCP 47 tag cannot be parsed.
It simplifies safe initialization of Tag values.</p>
               
               <pre><code>func MustParse(s string) Tag</code></pre>
            </article>
            
            <article class="function" data-name="MustParse">
               <h3>
                  MustParse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MustParse is like Parse, but panics if the given BCP 47 tag cannot be parsed.
It simplifies safe initialization of Tag values.</p>
               
               <pre><code>func (c CanonType) MustParse(s string) Tag</code></pre>
            </article>
            
            <article class="function" data-name="MustParseBase">
               <h3>
                  MustParseBase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParseBase is like ParseBase, but panics if the given base cannot be parsed.
It simplifies safe initialization of Base values.</p>
               
               <pre><code>func MustParseBase(s string) Base</code></pre>
            </article>
            
            <article class="function" data-name="MustParseRegion">
               <h3>
                  MustParseRegion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParseRegion is like ParseRegion, but panics if the given region cannot be
parsed. It simplifies safe initialization of Region values.</p>
               
               <pre><code>func MustParseRegion(s string) Region</code></pre>
            </article>
            
            <article class="function" data-name="MustParseScript">
               <h3>
                  MustParseScript 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParseScript is like ParseScript, but panics if the given script cannot be
parsed. It simplifies safe initialization of Script values.</p>
               
               <pre><code>func MustParseScript(s string) Script</code></pre>
            </article>
            
            <article class="function" data-name="NewCoverage">
               <h3>
                  NewCoverage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCoverage returns a Coverage for the given lists. It is typically used by
packages providing internationalization services to define their level of
coverage. A list may be of type []T or func() []T, where T is either Tag,
Base, Script or Region. The returned Coverage derives the value for Bases
from Tags if no func or slice for []Base is specified. For other unspecified
types the returned Coverage will return nil for the respective methods.</p>
               
               <pre><code>func NewCoverage(list ...interface{}) Coverage</code></pre>
            </article>
            
            <article class="function" data-name="NewMatcher">
               <h3>
                  NewMatcher 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewMatcher returns a Matcher that matches an ordered list of preferred tags
against a list of supported tags based on written intelligibility, closeness
of dialect, equivalence of subtags and various other rules. It is initialized
with the list of supported tags. The first element is used as the default
value in case no match is found.
Its Match method matches the first of the given Tags to reach a certain
confidence threshold. The tags passed to Match should therefore be specified
in order of preference. Extensions are ignored for matching.
The index returned by the Match method corresponds to the index of the
matched tag in t, but is augmented with the Unicode extension ('u')of the
corresponding preferred tag. This allows user locale options to be passed
transparently.</p>
               
               <pre><code>func NewMatcher(t []Tag, options ...MatchOption) Matcher</code></pre>
            </article>
            
            <article class="function" data-name="Parent">
               <h3>
                  Parent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Parent returns the CLDR parent of t. In CLDR, missing fields in data for a
specific language are substituted with fields from the parent language.
The parent for a language may change for newer versions of CLDR.
Parent returns a tag for a less specific language that is mutually
intelligible or Und if there is no such language. This may not be the same as
simply stripping the last BCP 47 subtag. For instance, the parent of "zh-TW"
is "zh-Hant", and the parent of "zh-Hant" is "und".</p>
               
               <pre><code>func (t Tag) Parent() Tag</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Parse parses the given BCP 47 string and returns a valid Tag. If parsing
failed it returns an error and any part of the tag that could be parsed.
If parsing succeeded but an unknown value was found, it returns
ValueError. The Tag returned in this case is just stripped of the unknown
value. All other values are preserved. It accepts tags in the BCP 47 format
and extensions to this standard defined in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
The resulting tag is canonicalized using the canonicalization type c.</p>
               
               <pre><code>func (c CanonType) Parse(s string) (t Tag, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse parses the given BCP 47 string and returns a valid Tag. If parsing
failed it returns an error and any part of the tag that could be parsed.
If parsing succeeded but an unknown value was found, it returns
ValueError. The Tag returned in this case is just stripped of the unknown
value. All other values are preserved. It accepts tags in the BCP 47 format
and extensions to this standard defined in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
The resulting tag is canonicalized using the default canonicalization type.</p>
               
               <pre><code>func Parse(s string) (t Tag, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseAcceptLanguage">
               <h3>
                  ParseAcceptLanguage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseAcceptLanguage parses the contents of an Accept-Language header as
defined in http://www.ietf.org/rfc/rfc2616.txt and returns a list of Tags and
a list of corresponding quality weights. It is more permissive than RFC 2616
and may return non-nil slices even if the input is not valid.
The Tags will be sorted by highest weight first and then by first occurrence.
Tags with a weight of zero will be dropped. An error will be returned if the
input could not be parsed.</p>
               
               <pre><code>func ParseAcceptLanguage(s string) (tag []Tag, q []float32, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseBase">
               <h3>
                  ParseBase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseBase parses a 2- or 3-letter ISO 639 code.
It returns a ValueError if s is a well-formed but unknown language identifier
or another error if another error occurred.</p>
               
               <pre><code>func ParseBase(s string) (Base, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseExtension">
               <h3>
                  ParseExtension 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseExtension parses s as an extension and returns it on success.</p>
               
               <pre><code>func ParseExtension(s string) (e Extension, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseRegion">
               <h3>
                  ParseRegion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseRegion parses a 2- or 3-letter ISO 3166-1 or a UN M.49 code.
It returns a ValueError if s is a well-formed but unknown region identifier
or another error if another error occurred.</p>
               
               <pre><code>func ParseRegion(s string) (Region, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseScript">
               <h3>
                  ParseScript 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseScript parses a 4-letter ISO 15924 code.
It returns a ValueError if s is a well-formed but unknown script identifier
or another error if another error occurred.</p>
               
               <pre><code>func ParseScript(s string) (Script, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseVariant">
               <h3>
                  ParseVariant 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseVariant parses and returns a Variant. An error is returned if s is not
a valid variant.</p>
               
               <pre><code>func ParseVariant(s string) (Variant, error)</code></pre>
            </article>
            
            <article class="function" data-name="PreferSameScript">
               <h3>
                  PreferSameScript 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PreferSameScript will, in the absence of a match, result in the first
preferred tag with the same script as a supported tag to match this supported
tag. The default is currently true, but this may change in the future.</p>
               
               <pre><code>func PreferSameScript(preferSame bool) MatchOption</code></pre>
            </article>
            
            <article class="function" data-name="Raw">
               <h3>
                  Raw 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Raw returns the raw base language, script and region, without making an
attempt to infer their values.</p>
               
               <pre><code>func (t Tag) Raw() (b Base, s Script, r Region)</code></pre>
            </article>
            
            <article class="function" data-name="Region">
               <h3>
                  Region 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Region returns the region for the language tag. If it was not explicitly given, it will
infer a most likely candidate from the context.
It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.</p>
               
               <pre><code>func (t Tag) Region() (Region, Confidence)</code></pre>
            </article>
            
            <article class="function" data-name="Regions">
               <h3>
                  Regions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *coverage) Regions() []Region</code></pre>
            </article>
            
            <article class="function" data-name="Regions">
               <h3>
                  Regions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Regions returns the list of supported regions. As all regions are in a
consecutive range, it simply returns a slice of numbers in increasing order.
The "undefined" region is not returned.</p>
               
               <pre><code>func (s allSubtags) Regions() []Region</code></pre>
            </article>
            
            <article class="function" data-name="Script">
               <h3>
                  Script 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Script infers the script for the language tag. If it was not explicitly given, it will infer
a most likely candidate.
If more than one script is commonly used for a language, the most likely one
is returned with a low confidence indication. For example, it returns (Cyrl, Low)
for Serbian.
If a script cannot be inferred (Zzzz, No) is returned. We do not use Zyyy (undetermined)
as one would suspect from the IANA registry for BCP 47. In a Unicode context Zyyy marks
common characters (like 1, 2, 3, '.', etc.) and is therefore more like multiple scripts.
See https://www.unicode.org/reports/tr24/#Values for more details. Zzzz is also used for
unknown value in CLDR.  (Zzzz, Exact) is returned if Zzzz was explicitly specified.
Note that an inferred script is never guaranteed to be the correct one. Latin is
almost exclusively used for Afrikaans, but Arabic has been used for some texts
in the past.  Also, the script that is commonly used may change over time.
It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.</p>
               
               <pre><code>func (t Tag) Script() (Script, Confidence)</code></pre>
            </article>
            
            <article class="function" data-name="Scripts">
               <h3>
                  Scripts 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *coverage) Scripts() []Script</code></pre>
            </article>
            
            <article class="function" data-name="Scripts">
               <h3>
                  Scripts 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scripts returns the list of supported scripts. As all scripts are in a
consecutive range, it simply returns a slice of numbers in increasing order.
The "undefined" script is not returned.</p>
               
               <pre><code>func (s allSubtags) Scripts() []Script</code></pre>
            </article>
            
            <article class="function" data-name="SetTypeForKey">
               <h3>
                  SetTypeForKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetTypeForKey returns a new Tag with the key set to type, where key and type
are of the allowed values defined for the Unicode locale extension ('u') in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
An empty value removes an existing pair with the same key.</p>
               
               <pre><code>func (t Tag) SetTypeForKey(key string, value string) (Tag, error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the string representation of the variant.</p>
               
               <pre><code>func (v Variant) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the string representation of the extension, including the
type tag.</p>
               
               <pre><code>func (e Extension) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the BCP 47 representation of the base language.</p>
               
               <pre><code>func (b Base) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the BCP 47 representation for the region.
It returns "ZZ" for an unspecified region.</p>
               
               <pre><code>func (r Region) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the canonical string representation of the language tag.</p>
               
               <pre><code>func (t Tag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c Confidence) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the script code in title case.
It returns "Zzzz" for an unspecified script.</p>
               
               <pre><code>func (s Script) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bases) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *tagSort) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="TLD">
               <h3>
                  TLD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TLD returns the country code top-level domain (ccTLD). UK is returned for GB.
In all other cases it returns either the region itself or an error.
This method may return an error for a region for which there exists a
canonical form with a ccTLD. To get that ccTLD canonicalize r first. The
region will already be canonicalized it was obtained from a Tag that was
obtained using any of the default methods.</p>
               
               <pre><code>func (r Region) TLD() (Region, error)</code></pre>
            </article>
            
            <article class="function" data-name="Tags">
               <h3>
                  Tags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *coverage) Tags() []Tag</code></pre>
            </article>
            
            <article class="function" data-name="Tags">
               <h3>
                  Tags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Tags always returns nil.</p>
               
               <pre><code>func (s allSubtags) Tags() []Tag</code></pre>
            </article>
            
            <article class="function" data-name="Tokens">
               <h3>
                  Tokens 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Tokens returns the list of tokens of e.</p>
               
               <pre><code>func (e Extension) Tokens() []string</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Type returns the one-byte extension type of e. It returns 0 for the zero
exception.</p>
               
               <pre><code>func (e Extension) Type() byte</code></pre>
            </article>
            
            <article class="function" data-name="TypeForKey">
               <h3>
                  TypeForKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TypeForKey returns the type associated with the given key, where key and type
are of the allowed values defined for the Unicode locale extension ('u') in
https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
TypeForKey will traverse the inheritance chain to get the correct value.
If there are multiple types associated with a key, only the first will be
returned. If there is no type associated with a key, it returns the empty
string.</p>
               
               <pre><code>func (t Tag) TypeForKey(key string) string</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements encoding.TextUnmarshaler.</p>
               
               <pre><code>func (t *Tag) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Variants">
               <h3>
                  Variants 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Variants returns the variants specified explicitly for this language tag.
or nil if no variant was specified.</p>
               
               <pre><code>func (t Tag) Variants() []Variant</code></pre>
            </article>
            
            <article class="function" data-name="addIfNew">
               <h3>
                  addIfNew 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addIfNew adds a haveTag to the list of tags only if it is a unique tag.
Tags that have the same maximized values are linked by index.</p>
               
               <pre><code>func (h *matchHeader) addIfNew(n haveTag, exact bool)</code></pre>
            </article>
            
            <article class="function" data-name="altScript">
               <h3>
                  altScript 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>altScript returns an alternative script that may match the given script with
a low confidence.  At the moment, the langMatch data allows for at most one
script to map to another and we rely on this to keep the code simple.</p>
               
               <pre><code>func altScript(l language.Language, s language.Script) language.Script</code></pre>
            </article>
            
            <article class="function" data-name="canonicalize">
               <h3>
                  canonicalize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canonicalize returns the canonicalized equivalent of the tag and
whether there was any change.</p>
               
               <pre><code>func canonicalize(c CanonType, t language.Tag) (language.Tag, bool)</code></pre>
            </article>
            
            <article class="function" data-name="consume">
               <h3>
                  consume 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>consume removes a leading token c from s and returns the result or the empty
string if there is no such token.</p>
               
               <pre><code>func consume(s string, c byte) string</code></pre>
            </article>
            
            <article class="function" data-name="equalsRest">
               <h3>
                  equalsRest 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>equalsRest compares everything except the language.</p>
               
               <pre><code>func equalsRest(a language.Tag, b language.Tag) bool</code></pre>
            </article>
            
            <article class="function" data-name="getBest">
               <h3>
                  getBest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getBest gets the best matching tag in m for any of the given tags, taking into
account the order of preference of the given tags.</p>
               
               <pre><code>func (m *matcher) getBest(want ...Tag) (got *haveTag, orig language.Tag, c Confidence)</code></pre>
            </article>
            
            <article class="function" data-name="header">
               <h3>
                  header 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>header returns the matchHeader for the given language. It creates one if
it doesn't already exist.</p>
               
               <pre><code>func (m *matcher) header(l language.Language) *matchHeader</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="isCompact">
               <h3>
                  isCompact 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tag) isCompact() bool</code></pre>
            </article>
            
            <article class="function" data-name="isExactEquivalent">
               <h3>
                  isExactEquivalent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isExactEquivalent returns true if canonicalizing the language will not alter
the script or region of a tag.</p>
               
               <pre><code>func isExactEquivalent(l language.Language) bool</code></pre>
            </article>
            
            <article class="function" data-name="isParadigmLocale">
               <h3>
                  isParadigmLocale 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isParadigmLocale(lang language.Language, r language.Region) bool</code></pre>
            </article>
            
            <article class="function" data-name="lang">
               <h3>
                  lang 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TODO: improve performance.</p>
               
               <pre><code>func (t *Tag) lang() language.Language</code></pre>
            </article>
            
            <article class="function" data-name="makeHaveTag">
               <h3>
                  makeHaveTag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeHaveTag(tag language.Tag, index int) (haveTag, language.Language)</code></pre>
            </article>
            
            <article class="function" data-name="makeTag">
               <h3>
                  makeTag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeTag(t language.Tag) (tag Tag)</code></pre>
            </article>
            
            <article class="function" data-name="newMatcher">
               <h3>
                  newMatcher 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newMatcher builds an index for the given supported tags and returns it as
a matcher. It also expands the index by considering various equivalence classes
for a given tag.</p>
               
               <pre><code>func newMatcher(supported []Tag, options []MatchOption) *matcher</code></pre>
            </article>
            
            <article class="function" data-name="nextToken">
               <h3>
                  nextToken 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>nextToken returns token t and the rest of the string.</p>
               
               <pre><code>func nextToken(s string) (t string, tail string)</code></pre>
            </article>
            
            <article class="function" data-name="region">
               <h3>
                  region 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tag) region() language.Region</code></pre>
            </article>
            
            <article class="function" data-name="regionGroupDist">
               <h3>
                  regionGroupDist 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>regionGroupDist computes the distance between two regions based on their
CLDR grouping.</p>
               
               <pre><code>func regionGroupDist(a language.Region, b language.Region, script language.Script, lang language.Language) (dist uint8, same bool)</code></pre>
            </article>
            
            <article class="function" data-name="script">
               <h3>
                  script 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tag) script() language.Script</code></pre>
            </article>
            
            <article class="function" data-name="split">
               <h3>
                  split 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func split(s string, c byte) (head string, tail string)</code></pre>
            </article>
            
            <article class="function" data-name="tag">
               <h3>
                  tag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tag) tag() language.Tag</code></pre>
            </article>
            
            <article class="function" data-name="toConf">
               <h3>
                  toConf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func toConf(d uint8) Confidence</code></pre>
            </article>
            
            <article class="function" data-name="update">
               <h3>
                  update 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func update(b *language.Builder, part ...interface{}) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>update updates the existing best match if the new pair is considered to be a
better match. To determine if the given pair is a better match, it first
computes the rough confidence level. If this surpasses the current match, it
will replace it and update the tie-breaker rule cache. If there is a tie, it
proceeds with applying a series of tie-breaker rules. If there is no
conclusive winner after applying the tie-breaker rules, it leaves the current
match as the preferred match.
If pin is true and have and tag are a strong match, it will henceforth only
consider matches for this language. This corresponds to the idea that most
users have a strong preference for the first defined language. A user can
still prefer a second language over a dialect of the preferred language by
explicitly specifying dialects, e.g. "en, nl, en-GB". In this case pin should
be false.</p>
               
               <pre><code>func (m *bestMatch) update(have *haveTag, tag language.Tag, maxScript language.Script, maxRegion language.Region, pin bool)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
