<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - fstest</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>fstest</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"errors"
"fmt"
"io"
"io/fs"
"maps"
"path"
"slices"
"strings"
"testing/iotest"
"io"
"io/fs"
"path"
"slices"
"strings"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ fs.FS = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ fs.File = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="MapFS" data-name="MapFS">
               <h3>
                  MapFS
                  <span class="badge type-badge">type</span>
                  <a href="#MapFS" class="anchor" title="Link to MapFS">#</a>
               </h3>
               
               <p>A MapFS is a simple in-memory file system for use in tests,
represented as a map from path names (arguments to Open)
to information about the files or directories they represent.
The map need not include parent directories for files contained
in the map; those will be synthesized if needed.
But a directory can still be included by setting the [MapFile.Mode]'s [fs.ModeDir] bit;
this may be necessary for detailed control over the directory's [fs.FileInfo]
or to create an empty directory.
File system operations read directly from the map,
so that the file system can be changed by editing the map as needed.
An implication is that file system operations must not run concurrently
with changes to the map, which would be a race.
Another implication is that opening or reading a directory requires
iterating over the entire map, so a MapFS should typically be used with not more
than a few hundred entries or directory reads.</p>
               
               <pre><code>type MapFS map[string]*MapFile</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="MapFile" data-name="MapFile">
               <h3>
                  MapFile
                  <span class="badge">struct</span>
                  <a href="#MapFile" class="anchor" title="Link to MapFile">#</a>
               </h3>
               
               <p>A MapFile describes a single file in a [MapFS].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MapFile struct {
Data []byte
Mode fs.FileMode
ModTime time.Time
Sys any
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fsOnly" data-name="fsOnly">
               <h3>
                  fsOnly
                  <span class="badge">struct</span>
                  <a href="#fsOnly" class="anchor" title="Link to fsOnly">#</a>
               </h3>
               
               <p>fsOnly is a wrapper that hides all but the fs.FS methods,
to avoid an infinite recursion when implementing special
methods in terms of helpers that would use them.
(In general, implementing these methods using the package fs helpers
is redundant and unnecessary, but having the methods may make
MapFS exercise more code paths when used in tests.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fsOnly struct {
fs.FS
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fsTester" data-name="fsTester">
               <h3>
                  fsTester
                  <span class="badge">struct</span>
                  <a href="#fsTester" class="anchor" title="Link to fsTester">#</a>
               </h3>
               
               <p>An fsTester holds state for running the test.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fsTester struct {
fsys fs.FS
errors []error
dirs []string
files []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mapDir" data-name="mapDir">
               <h3>
                  mapDir
                  <span class="badge">struct</span>
                  <a href="#mapDir" class="anchor" title="Link to mapDir">#</a>
               </h3>
               
               <p>A mapDir is a directory fs.File (so also an fs.ReadDirFile) open for reading.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mapDir struct {
path string
mapFileInfo
entry []mapFileInfo
offset int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mapFileInfo" data-name="mapFileInfo">
               <h3>
                  mapFileInfo
                  <span class="badge">struct</span>
                  <a href="#mapFileInfo" class="anchor" title="Link to mapFileInfo">#</a>
               </h3>
               
               <p>A mapFileInfo implements fs.FileInfo and fs.DirEntry for a given map file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mapFileInfo struct {
name string
f *MapFile
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noSub" data-name="noSub">
               <h3>
                  noSub
                  <span class="badge">struct</span>
                  <a href="#noSub" class="anchor" title="Link to noSub">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noSub struct {
MapFS
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="openMapFile" data-name="openMapFile">
               <h3>
                  openMapFile
                  <span class="badge">struct</span>
                  <a href="#openMapFile" class="anchor" title="Link to openMapFile">#</a>
               </h3>
               
               <p>An openMapFile is a regular (non-directory) fs.File open for reading.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type openMapFile struct {
path string
mapFileInfo
offset int64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (d *mapDir) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (f *openMapFile) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Glob" data-name="Glob">
               <h3>
                  Glob 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Glob" class="anchor" title="Link to Glob">#</a>
               </h3>
               
               <pre><code>func (fsys MapFS) Glob(pattern string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) Info() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) Mode() fs.FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open opens the named file.</p>
               
               <pre><code>func (fsys MapFS) Open(name string) (fs.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (d *mapDir) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (f *openMapFile) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadAt" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadAt" class="anchor" title="Link to ReadAt">#</a>
               </h3>
               
               <pre><code>func (f *openMapFile) ReadAt(b []byte, offset int64) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <pre><code>func (d *mapDir) ReadDir(count int) ([]fs.DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <pre><code>func (fsys MapFS) ReadDir(name string) ([]fs.DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <pre><code>func (fsys MapFS) ReadFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seek" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seek" class="anchor" title="Link to Seek">#</a>
               </h3>
               
               <pre><code>func (f *openMapFile) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code>func (fsys MapFS) Stat(name string) (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code>func (f *openMapFile) Stat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code>func (d *mapDir) Stat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <pre><code>func (noSub) Sub()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <pre><code>func (fsys MapFS) Sub(dir string) (fs.FS, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code>func (i *mapFileInfo) Type() fs.FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkBadPath" data-name="checkBadPath">
               <h3>
                  checkBadPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkBadPath" class="anchor" title="Link to checkBadPath">#</a>
               </h3>
               
               <p>checkBadPath checks that various invalid forms of file's name cannot be opened using open.</p>
               
               <pre><code>func (t *fsTester) checkBadPath(file string, desc string, open func(string) error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkDir" data-name="checkDir">
               <h3>
                  checkDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkDir" class="anchor" title="Link to checkDir">#</a>
               </h3>
               
               <p>checkDir checks the directory dir, which is expected to exist
(it is either the root or was found in a directory listing with IsDir true).</p>
               
               <pre><code>func (t *fsTester) checkDir(dir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkDirList" data-name="checkDirList">
               <h3>
                  checkDirList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkDirList" class="anchor" title="Link to checkDirList">#</a>
               </h3>
               
               <p>checkDirList checks that two directory lists contain the same files and file info.
The order of the lists need not match.</p>
               
               <pre><code>func (t *fsTester) checkDirList(dir string, desc string, list1 []fs.DirEntry, list2 []fs.DirEntry)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFile" data-name="checkFile">
               <h3>
                  checkFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFile" class="anchor" title="Link to checkFile">#</a>
               </h3>
               
               <p>checkFile checks that basic file reading works correctly.</p>
               
               <pre><code>func (t *fsTester) checkFile(file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFileRead" data-name="checkFileRead">
               <h3>
                  checkFileRead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFileRead" class="anchor" title="Link to checkFileRead">#</a>
               </h3>
               
               <pre><code>func (t *fsTester) checkFileRead(file string, desc string, data1 []byte, data2 []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkGlob" data-name="checkGlob">
               <h3>
                  checkGlob 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkGlob" class="anchor" title="Link to checkGlob">#</a>
               </h3>
               
               <p>checkGlob checks that various glob patterns work if the file system implements GlobFS.</p>
               
               <pre><code>func (t *fsTester) checkGlob(dir string, list []fs.DirEntry)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkOpen" data-name="checkOpen">
               <h3>
                  checkOpen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkOpen" class="anchor" title="Link to checkOpen">#</a>
               </h3>
               
               <p>checkOpen validates file opening behavior by attempting to open and then close the given file path.</p>
               
               <pre><code>func (t *fsTester) checkOpen(file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkStat" data-name="checkStat">
               <h3>
                  checkStat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkStat" class="anchor" title="Link to checkStat">#</a>
               </h3>
               
               <p>checkStat checks that a direct stat of path matches entry,
which was found in the parent's directory listing.</p>
               
               <pre><code>func (t *fsTester) checkStat(path string, entry fs.DirEntry)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorf" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorf" class="anchor" title="Link to errorf">#</a>
               </h3>
               
               <p>errorf adds an error to the list of errors.</p>
               
               <pre><code>func (t *fsTester) errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatEntry" data-name="formatEntry">
               <h3>
                  formatEntry 
                  <span class="badge">function</span>
                  
                  <a href="#formatEntry" class="anchor" title="Link to formatEntry">#</a>
               </h3>
               
               <p>formatEntry formats an fs.DirEntry into a string for error messages and comparison.</p>
               
               <pre><code>func formatEntry(entry fs.DirEntry) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatInfo" data-name="formatInfo">
               <h3>
                  formatInfo 
                  <span class="badge">function</span>
                  
                  <a href="#formatInfo" class="anchor" title="Link to formatInfo">#</a>
               </h3>
               
               <p>formatInfo formats an fs.FileInfo into a string for error messages and comparison.</p>
               
               <pre><code>func formatInfo(info fs.FileInfo) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatInfoEntry" data-name="formatInfoEntry">
               <h3>
                  formatInfoEntry 
                  <span class="badge">function</span>
                  
                  <a href="#formatInfoEntry" class="anchor" title="Link to formatInfoEntry">#</a>
               </h3>
               
               <p>formatInfoEntry formats an fs.FileInfo into a string like the result of formatEntry, for error messages and comparison.</p>
               
               <pre><code>func formatInfoEntry(info fs.FileInfo) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDir" data-name="openDir">
               <h3>
                  openDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openDir" class="anchor" title="Link to openDir">#</a>
               </h3>
               
               <pre><code>func (t *fsTester) openDir(dir string) fs.ReadDirFile</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="testFS" data-name="testFS">
               <h3>
                  testFS 
                  <span class="badge">function</span>
                  
                  <a href="#testFS" class="anchor" title="Link to testFS">#</a>
               </h3>
               
               <pre><code>func testFS(fsys fs.FS, expected ...string) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>