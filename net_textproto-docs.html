<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - textproto</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>textproto</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"sync"
"bufio"
"bytes"
"errors"
"fmt"
"io"
"math"
"strconv"
"strings"
"sync"
_ "unsafe"
"bufio"
"fmt"
"io"
"net"
"bufio"
"fmt"
"io"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="colon" data-name="colon">
               <h3>
                  colon 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#colon" class="anchor" title="Link to colon">#</a>
               </h3>
               
               <pre><code>var colon = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="commonHeader" data-name="commonHeader">
               <h3>
                  commonHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#commonHeader" class="anchor" title="Link to commonHeader">#</a>
               </h3>
               
               <p>commonHeader interns common header strings.</p>
               
               <pre><code>var commonHeader map[string]string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="commonHeaderOnce" data-name="commonHeaderOnce">
               <h3>
                  commonHeaderOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#commonHeaderOnce" class="anchor" title="Link to commonHeaderOnce">#</a>
               </h3>
               
               <pre><code>var commonHeaderOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="crnl" data-name="crnl">
               <h3>
                  crnl 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#crnl" class="anchor" title="Link to crnl">#</a>
               </h3>
               
               <pre><code>var crnl = []byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dotcrnl" data-name="dotcrnl">
               <h3>
                  dotcrnl 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dotcrnl" class="anchor" title="Link to dotcrnl">#</a>
               </h3>
               
               <pre><code>var dotcrnl = []byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMessageTooLarge" data-name="errMessageTooLarge">
               <h3>
                  errMessageTooLarge 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMessageTooLarge" class="anchor" title="Link to errMessageTooLarge">#</a>
               </h3>
               
               <p>TODO: This should be a distinguishable error (ErrMessageTooLarge)
to allow mime/multipart to detect it.</p>
               
               <pre><code>var errMessageTooLarge = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nl" data-name="nl">
               <h3>
                  nl 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nl" class="anchor" title="Link to nl">#</a>
               </h3>
               
               <pre><code>var nl = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="toLower" data-name="toLower">
               <h3>
                  toLower 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#toLower" class="anchor" title="Link to toLower">#</a>
               </h3>
               
               <pre><code>const toLower = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="wstateBegin" data-name="wstateBegin">
               <h3>
                  wstateBegin 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#wstateBegin" class="anchor" title="Link to wstateBegin">#</a>
               </h3>
               
               <pre><code>const wstateBegin = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="wstateBeginLine" data-name="wstateBeginLine">
               <h3>
                  wstateBeginLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#wstateBeginLine" class="anchor" title="Link to wstateBeginLine">#</a>
               </h3>
               
               <pre><code>const wstateBeginLine</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="wstateCR" data-name="wstateCR">
               <h3>
                  wstateCR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#wstateCR" class="anchor" title="Link to wstateCR">#</a>
               </h3>
               
               <pre><code>const wstateCR</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="wstateData" data-name="wstateData">
               <h3>
                  wstateData 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#wstateData" class="anchor" title="Link to wstateData">#</a>
               </h3>
               
               <pre><code>const wstateData</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="MIMEHeader" data-name="MIMEHeader">
               <h3>
                  MIMEHeader
                  <span class="badge type-badge">type</span>
                  <a href="#MIMEHeader" class="anchor" title="Link to MIMEHeader">#</a>
               </h3>
               
               <p>A MIMEHeader represents a MIME-style header mapping
keys to sets of values.</p>
               
               <pre><code>type MIMEHeader map[string][]string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ProtocolError" data-name="ProtocolError">
               <h3>
                  ProtocolError
                  <span class="badge type-badge">type</span>
                  <a href="#ProtocolError" class="anchor" title="Link to ProtocolError">#</a>
               </h3>
               
               <p>A ProtocolError describes a protocol violation such
as an invalid response or a hung-up connection.</p>
               
               <pre><code>type ProtocolError string</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Conn" data-name="Conn">
               <h3>
                  Conn
                  <span class="badge">struct</span>
                  <a href="#Conn" class="anchor" title="Link to Conn">#</a>
               </h3>
               
               <p>A Conn represents a textual network protocol connection.
It consists of a [Reader] and [Writer] to manage I/O
and a [Pipeline] to sequence concurrent requests on the connection.
These embedded types carry methods with them;
see the documentation of those types for details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Conn struct {
Reader
Writer
Pipeline
conn io.ReadWriteCloser
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>An Error represents a numeric error response from a server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Error struct {
Code int
Msg string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Pipeline" data-name="Pipeline">
               <h3>
                  Pipeline
                  <span class="badge">struct</span>
                  <a href="#Pipeline" class="anchor" title="Link to Pipeline">#</a>
               </h3>
               
               <p>A Pipeline manages a pipelined in-order request/response sequence.
To use a Pipeline p to manage multiple clients on a connection,
each client should run:
id := p.Next()	// take a number
p.StartRequest(id)	// wait for turn to send request
«send request»
p.EndRequest(id)	// notify Pipeline that request is sent
p.StartResponse(id)	// wait for turn to read response
«read response»
p.EndResponse(id)	// notify Pipeline that response is read
A pipelined server can use the same calls to ensure that
responses computed in parallel are written in the correct order.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Pipeline struct {
mu sync.Mutex
id uint
request sequencer
response sequencer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>A Reader implements convenience methods for reading requests
or responses from a text protocol network connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
R *bufio.Reader
dot *dotReader
buf []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>A Writer implements convenience methods for writing
requests or responses to a text protocol network connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
W *bufio.Writer
dot *dotWriter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dotReader" data-name="dotReader">
               <h3>
                  dotReader
                  <span class="badge">struct</span>
                  <a href="#dotReader" class="anchor" title="Link to dotReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dotReader struct {
r *Reader
state int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dotWriter" data-name="dotWriter">
               <h3>
                  dotWriter
                  <span class="badge">struct</span>
                  <a href="#dotWriter" class="anchor" title="Link to dotWriter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dotWriter struct {
w *Writer
state int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sequencer" data-name="sequencer">
               <h3>
                  sequencer
                  <span class="badge">struct</span>
                  <a href="#sequencer" class="anchor" title="Link to sequencer">#</a>
               </h3>
               
               <p>A sequencer schedules a sequence of numbered events that must
happen in order, one after the other. The event numbering must start
at 0 and increment without skipping. The event number wraps around
safely as long as there are not 2^32 simultaneous events pending.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sequencer struct {
mu sync.Mutex
id uint
wait map[uint]chan struct{...}
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add adds the key, value pair to the header.
It appends to any existing values associated with key.</p>
               
               <pre><code>func (h MIMEHeader) Add(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanonicalMIMEHeaderKey" data-name="CanonicalMIMEHeaderKey">
               <h3>
                  CanonicalMIMEHeaderKey 
                  <span class="badge">function</span>
                  
                  <a href="#CanonicalMIMEHeaderKey" class="anchor" title="Link to CanonicalMIMEHeaderKey">#</a>
               </h3>
               
               <p>CanonicalMIMEHeaderKey returns the canonical format of the
MIME header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
MIME header keys are assumed to be ASCII only.
If s contains a space or invalid header field bytes, it is
returned without modifications.</p>
               
               <pre><code>func CanonicalMIMEHeaderKey(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (d *dotWriter) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the connection.</p>
               
               <pre><code>func (c *Conn) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cmd" data-name="Cmd">
               <h3>
                  Cmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cmd" class="anchor" title="Link to Cmd">#</a>
               </h3>
               
               <p>Cmd is a convenience method that sends a command after
waiting its turn in the pipeline. The command text is the
result of formatting format with args and appending \r\n.
Cmd returns the id of the command, for use with StartResponse and EndResponse.
For example, a client might run a HELP command that returns a dot-body
by using:
id, err := c.Cmd("HELP")
if err != nil {
return nil, err
}
c.StartResponse(id)
defer c.EndResponse(id)
if _, _, err = c.ReadCodeLine(110); err != nil {
return nil, err
}
text, err := c.ReadDotBytes()
if err != nil {
return nil, err
}
return c.ReadCodeLine(250)</p>
               
               <pre><code>func (c *Conn) Cmd(format string, args ...any) (id uint, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Del" data-name="Del">
               <h3>
                  Del 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Del" class="anchor" title="Link to Del">#</a>
               </h3>
               
               <p>Del deletes the values associated with key.</p>
               
               <pre><code>func (h MIMEHeader) Del(key string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dial" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge">function</span>
                  
                  <a href="#Dial" class="anchor" title="Link to Dial">#</a>
               </h3>
               
               <p>Dial connects to the given address on the given network using [net.Dial]
and then returns a new [Conn] for the connection.</p>
               
               <pre><code>func Dial(network string, addr string) (*Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DotReader" data-name="DotReader">
               <h3>
                  DotReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DotReader" class="anchor" title="Link to DotReader">#</a>
               </h3>
               
               <p>DotReader returns a new [Reader] that satisfies Reads using the
decoded text of a dot-encoded block read from r.
The returned Reader is only valid until the next call
to a method on r.
Dot encoding is a common framing used for data blocks
in text protocols such as SMTP.  The data consists of a sequence
of lines, each of which ends in "\r\n".  The sequence itself
ends at a line containing just a dot: ".\r\n".  Lines beginning
with a dot are escaped with an additional dot to avoid
looking like the end of the sequence.
The decoded form returned by the Reader's Read method
rewrites the "\r\n" line endings into the simpler "\n",
removes leading dot escapes if present, and stops with error [io.EOF]
after consuming (and discarding) the end-of-sequence line.</p>
               
               <pre><code>func (r *Reader) DotReader() io.Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DotWriter" data-name="DotWriter">
               <h3>
                  DotWriter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DotWriter" class="anchor" title="Link to DotWriter">#</a>
               </h3>
               
               <p>DotWriter returns a writer that can be used to write a dot-encoding to w.
It takes care of inserting leading dots when necessary,
translating line-ending \n into \r\n, and adding the final .\r\n line
when the DotWriter is closed. The caller should close the
DotWriter before the next call to a method on w.
See the documentation for the [Reader.DotReader] method for details about dot-encoding.</p>
               
               <pre><code>func (w *Writer) DotWriter() io.WriteCloser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="End" data-name="End">
               <h3>
                  End 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#End" class="anchor" title="Link to End">#</a>
               </h3>
               
               <p>End notifies the sequencer that the event numbered id has completed,
allowing it to schedule the event numbered id+1.  It is a run-time error
to call End with an id that is not the number of the active event.</p>
               
               <pre><code>func (s *sequencer) End(id uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EndRequest" data-name="EndRequest">
               <h3>
                  EndRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EndRequest" class="anchor" title="Link to EndRequest">#</a>
               </h3>
               
               <p>EndRequest notifies p that the request with the given id has been sent
(or, if this is a server, received).</p>
               
               <pre><code>func (p *Pipeline) EndRequest(id uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EndResponse" data-name="EndResponse">
               <h3>
                  EndResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EndResponse" class="anchor" title="Link to EndResponse">#</a>
               </h3>
               
               <p>EndResponse notifies p that the response with the given id has been received
(or, if this is a server, sent).</p>
               
               <pre><code>func (p *Pipeline) EndResponse(id uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (p ProtocolError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *Error) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get gets the first value associated with the given key.
It is case insensitive; [CanonicalMIMEHeaderKey] is used
to canonicalize the provided key.
If there are no values associated with the key, Get returns "".
To use non-canonical keys, access the map directly.</p>
               
               <pre><code>func (h MIMEHeader) Get(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewConn" data-name="NewConn">
               <h3>
                  NewConn 
                  <span class="badge">function</span>
                  
                  <a href="#NewConn" class="anchor" title="Link to NewConn">#</a>
               </h3>
               
               <p>NewConn returns a new [Conn] using conn for I/O.</p>
               
               <pre><code>func NewConn(conn io.ReadWriteCloser) *Conn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader returns a new [Reader] reading from r.
To avoid denial of service attacks, the provided [bufio.Reader]
should be reading from an [io.LimitReader] or similar Reader to bound
the size of responses.</p>
               
               <pre><code>func NewReader(r *bufio.Reader) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter returns a new [Writer] writing to w.</p>
               
               <pre><code>func NewWriter(w *bufio.Writer) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next returns the next id for a request/response pair.</p>
               
               <pre><code>func (p *Pipeline) Next() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PrintfLine" data-name="PrintfLine">
               <h3>
                  PrintfLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PrintfLine" class="anchor" title="Link to PrintfLine">#</a>
               </h3>
               
               <p>PrintfLine writes the formatted output followed by \r\n.</p>
               
               <pre><code>func (w *Writer) PrintfLine(format string, args ...any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read satisfies reads by decoding dot-encoded data read from d.r.</p>
               
               <pre><code>func (d *dotReader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadCodeLine" data-name="ReadCodeLine">
               <h3>
                  ReadCodeLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadCodeLine" class="anchor" title="Link to ReadCodeLine">#</a>
               </h3>
               
               <p>ReadCodeLine reads a response code line of the form
code message
where code is a three-digit status code and the message
extends to the rest of the line. An example of such a line is:
220 plan9.bell-labs.com ESMTP
If the prefix of the status does not match the digits in expectCode,
ReadCodeLine returns with err set to &Error{code, message}.
For example, if expectCode is 31, an error will be returned if
the status is not in the range [310,319].
If the response is multi-line, ReadCodeLine returns an error.
An expectCode <= 0 disables the check of the status code.</p>
               
               <pre><code>func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadContinuedLine" data-name="ReadContinuedLine">
               <h3>
                  ReadContinuedLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadContinuedLine" class="anchor" title="Link to ReadContinuedLine">#</a>
               </h3>
               
               <p>ReadContinuedLine reads a possibly continued line from r,
eliding the final trailing ASCII white space.
Lines after the first are considered continuations if they
begin with a space or tab character. In the returned data,
continuation lines are separated from the previous line
only by a single space: the newline and leading white space
are removed.
For example, consider this input:
Line 1
continued...
Line 2
The first call to ReadContinuedLine will return "Line 1 continued..."
and the second will return "Line 2".
Empty lines are never continued.</p>
               
               <pre><code>func (r *Reader) ReadContinuedLine() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadContinuedLineBytes" data-name="ReadContinuedLineBytes">
               <h3>
                  ReadContinuedLineBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadContinuedLineBytes" class="anchor" title="Link to ReadContinuedLineBytes">#</a>
               </h3>
               
               <p>ReadContinuedLineBytes is like [Reader.ReadContinuedLine] but
returns a []byte instead of a string.</p>
               
               <pre><code>func (r *Reader) ReadContinuedLineBytes() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDotBytes" data-name="ReadDotBytes">
               <h3>
                  ReadDotBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDotBytes" class="anchor" title="Link to ReadDotBytes">#</a>
               </h3>
               
               <p>ReadDotBytes reads a dot-encoding and returns the decoded data.
See the documentation for the [Reader.DotReader] method for details about dot-encoding.</p>
               
               <pre><code>func (r *Reader) ReadDotBytes() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDotLines" data-name="ReadDotLines">
               <h3>
                  ReadDotLines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDotLines" class="anchor" title="Link to ReadDotLines">#</a>
               </h3>
               
               <p>ReadDotLines reads a dot-encoding and returns a slice
containing the decoded lines, with the final \r\n or \n elided from each.
See the documentation for the [Reader.DotReader] method for details about dot-encoding.</p>
               
               <pre><code>func (r *Reader) ReadDotLines() ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadLine" data-name="ReadLine">
               <h3>
                  ReadLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadLine" class="anchor" title="Link to ReadLine">#</a>
               </h3>
               
               <p>ReadLine reads a single line from r,
eliding the final \n or \r\n from the returned string.</p>
               
               <pre><code>func (r *Reader) ReadLine() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadLineBytes" data-name="ReadLineBytes">
               <h3>
                  ReadLineBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadLineBytes" class="anchor" title="Link to ReadLineBytes">#</a>
               </h3>
               
               <p>ReadLineBytes is like [Reader.ReadLine] but returns a []byte instead of a string.</p>
               
               <pre><code>func (r *Reader) ReadLineBytes() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadMIMEHeader" data-name="ReadMIMEHeader">
               <h3>
                  ReadMIMEHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadMIMEHeader" class="anchor" title="Link to ReadMIMEHeader">#</a>
               </h3>
               
               <p>ReadMIMEHeader reads a MIME-style header from r.
The header is a sequence of possibly continued Key: Value lines
ending in a blank line.
The returned map m maps [CanonicalMIMEHeaderKey](key) to a
sequence of values in the same order encountered in the input.
For example, consider this input:
My-Key: Value 1
Long-Key: Even
Longer Value
My-Key: Value 2
Given that input, ReadMIMEHeader returns the map:
map[string][]string{
"My-Key": {"Value 1", "Value 2"},
"Long-Key": {"Even Longer Value"},
}</p>
               
               <pre><code>func (r *Reader) ReadMIMEHeader() (MIMEHeader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadResponse" data-name="ReadResponse">
               <h3>
                  ReadResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadResponse" class="anchor" title="Link to ReadResponse">#</a>
               </h3>
               
               <p>ReadResponse reads a multi-line response of the form:
code-message line 1
code-message line 2
...
code message line n
where code is a three-digit status code. The first line starts with the
code and a hyphen. The response is terminated by a line that starts
with the same code followed by a space. Each line in message is
separated by a newline (\n).
See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for
details of another form of response accepted:
code-message line 1
message line 2
...
code message line n
If the prefix of the status does not match the digits in expectCode,
ReadResponse returns with err set to &Error{code, message}.
For example, if expectCode is 31, an error will be returned if
the status is not in the range [310,319].
An expectCode <= 0 disables the check of the status code.</p>
               
               <pre><code>func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets the header entries associated with key to
the single element value. It replaces any existing
values associated with key.</p>
               
               <pre><code>func (h MIMEHeader) Set(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Start" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Start" class="anchor" title="Link to Start">#</a>
               </h3>
               
               <p>Start waits until it is time for the event numbered id to begin.
That is, except for the first event, it waits until End(id-1) has
been called.</p>
               
               <pre><code>func (s *sequencer) Start(id uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartRequest" data-name="StartRequest">
               <h3>
                  StartRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartRequest" class="anchor" title="Link to StartRequest">#</a>
               </h3>
               
               <p>StartRequest blocks until it is time to send (or, if this is a server, receive)
the request with the given id.</p>
               
               <pre><code>func (p *Pipeline) StartRequest(id uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartResponse" data-name="StartResponse">
               <h3>
                  StartResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartResponse" class="anchor" title="Link to StartResponse">#</a>
               </h3>
               
               <p>StartResponse blocks until it is time to receive (or, if this is a server, send)
the request with the given id.</p>
               
               <pre><code>func (p *Pipeline) StartResponse(id uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimBytes" data-name="TrimBytes">
               <h3>
                  TrimBytes 
                  <span class="badge">function</span>
                  
                  <a href="#TrimBytes" class="anchor" title="Link to TrimBytes">#</a>
               </h3>
               
               <p>TrimBytes returns b without leading and trailing ASCII space.</p>
               
               <pre><code>func TrimBytes(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimString" data-name="TrimString">
               <h3>
                  TrimString 
                  <span class="badge">function</span>
                  
                  <a href="#TrimString" class="anchor" title="Link to TrimString">#</a>
               </h3>
               
               <p>TrimString returns s without leading and trailing ASCII space.</p>
               
               <pre><code>func TrimString(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Values" data-name="Values">
               <h3>
                  Values 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Values" class="anchor" title="Link to Values">#</a>
               </h3>
               
               <p>Values returns all values associated with the given key.
It is case insensitive; [CanonicalMIMEHeaderKey] is
used to canonicalize the provided key. To use non-canonical
keys, access the map directly.
The returned slice is not a copy.</p>
               
               <pre><code>func (h MIMEHeader) Values(key string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (d *dotWriter) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canonicalMIMEHeaderKey" data-name="canonicalMIMEHeaderKey">
               <h3>
                  canonicalMIMEHeaderKey 
                  <span class="badge">function</span>
                  
                  <a href="#canonicalMIMEHeaderKey" class="anchor" title="Link to canonicalMIMEHeaderKey">#</a>
               </h3>
               
               <p>canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is
allowed to mutate the provided byte slice before returning the
string.
For invalid inputs (if a contains spaces or non-token bytes), a
is unchanged and a string copy is returned.
ok is true if the header key contains only valid characters and spaces.
ReadMIMEHeader accepts header keys containing spaces, but does not
canonicalize them.</p>
               
               <pre><code>func canonicalMIMEHeaderKey(a []byte) (_ string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeDot" data-name="closeDot">
               <h3>
                  closeDot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeDot" class="anchor" title="Link to closeDot">#</a>
               </h3>
               
               <pre><code>func (w *Writer) closeDot()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeDot" data-name="closeDot">
               <h3>
                  closeDot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeDot" class="anchor" title="Link to closeDot">#</a>
               </h3>
               
               <p>closeDot drains the current DotReader if any,
making sure that it reads until the ending dot line.</p>
               
               <pre><code>func (r *Reader) closeDot()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initCommonHeader" data-name="initCommonHeader">
               <h3>
                  initCommonHeader 
                  <span class="badge">function</span>
                  
                  <a href="#initCommonHeader" class="anchor" title="Link to initCommonHeader">#</a>
               </h3>
               
               <pre><code>func initCommonHeader()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isASCIILetter" data-name="isASCIILetter">
               <h3>
                  isASCIILetter 
                  <span class="badge">function</span>
                  
                  <a href="#isASCIILetter" class="anchor" title="Link to isASCIILetter">#</a>
               </h3>
               
               <pre><code>func isASCIILetter(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isASCIISpace" data-name="isASCIISpace">
               <h3>
                  isASCIISpace 
                  <span class="badge">function</span>
                  
                  <a href="#isASCIISpace" class="anchor" title="Link to isASCIISpace">#</a>
               </h3>
               
               <pre><code>func isASCIISpace(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustHaveFieldNameColon" data-name="mustHaveFieldNameColon">
               <h3>
                  mustHaveFieldNameColon 
                  <span class="badge">function</span>
                  
                  <a href="#mustHaveFieldNameColon" class="anchor" title="Link to mustHaveFieldNameColon">#</a>
               </h3>
               
               <p>mustHaveFieldNameColon ensures that, per RFC 7230, the
field-name is on a single line, so the first line must
contain a colon.</p>
               
               <pre><code>func mustHaveFieldNameColon(line []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noValidation" data-name="noValidation">
               <h3>
                  noValidation 
                  <span class="badge">function</span>
                  
                  <a href="#noValidation" class="anchor" title="Link to noValidation">#</a>
               </h3>
               
               <p>noValidation is a no-op validation func for readContinuedLineSlice
that permits any lines.</p>
               
               <pre><code>func noValidation(_ []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseCodeLine" data-name="parseCodeLine">
               <h3>
                  parseCodeLine 
                  <span class="badge">function</span>
                  
                  <a href="#parseCodeLine" class="anchor" title="Link to parseCodeLine">#</a>
               </h3>
               
               <pre><code>func parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readCodeLine" data-name="readCodeLine">
               <h3>
                  readCodeLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readCodeLine" class="anchor" title="Link to readCodeLine">#</a>
               </h3>
               
               <pre><code>func (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readContinuedLineSlice" data-name="readContinuedLineSlice">
               <h3>
                  readContinuedLineSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readContinuedLineSlice" class="anchor" title="Link to readContinuedLineSlice">#</a>
               </h3>
               
               <p>readContinuedLineSlice reads continued lines from the reader buffer,
returning a byte slice with all lines. The validateFirstLine function
is run on the first read line, and if it returns an error then this
error is returned from readContinuedLineSlice.
It reads up to lim bytes of data (or unlimited if lim is less than 0).</p>
               
               <pre><code>func (r *Reader) readContinuedLineSlice(lim int64, validateFirstLine func([]byte) error) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLineSlice" data-name="readLineSlice">
               <h3>
                  readLineSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLineSlice" class="anchor" title="Link to readLineSlice">#</a>
               </h3>
               
               <p>readLineSlice reads a single line from r,
up to lim bytes long (or unlimited if lim is less than 0),
eliding the final \r or \r\n from the returned string.</p>
               
               <pre><code>func (r *Reader) readLineSlice(lim int64) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readMIMEHeader" data-name="readMIMEHeader">
               <h3>
                  readMIMEHeader 
                  <span class="badge">function</span>
                  
                  <a href="#readMIMEHeader" class="anchor" title="Link to readMIMEHeader">#</a>
               </h3>
               
               <p>readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.
It is called by the mime/multipart package.</p>
               
               <pre><code>func readMIMEHeader(r *Reader, maxMemory int64, maxHeaders int64) (MIMEHeader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipSpace" data-name="skipSpace">
               <h3>
                  skipSpace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#skipSpace" class="anchor" title="Link to skipSpace">#</a>
               </h3>
               
               <p>skipSpace skips R over all spaces and returns the number of bytes skipped.</p>
               
               <pre><code>func (r *Reader) skipSpace() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trim" data-name="trim">
               <h3>
                  trim 
                  <span class="badge">function</span>
                  
                  <a href="#trim" class="anchor" title="Link to trim">#</a>
               </h3>
               
               <p>trim returns s with leading and trailing spaces and tabs removed.
It does not assume Unicode or UTF-8.</p>
               
               <pre><code>func trim(s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="upcomingHeaderKeys" data-name="upcomingHeaderKeys">
               <h3>
                  upcomingHeaderKeys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#upcomingHeaderKeys" class="anchor" title="Link to upcomingHeaderKeys">#</a>
               </h3>
               
               <p>upcomingHeaderKeys returns an approximation of the number of keys
that will be in this header. If it gets confused, it returns 0.</p>
               
               <pre><code>func (r *Reader) upcomingHeaderKeys() (n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validHeaderFieldByte" data-name="validHeaderFieldByte">
               <h3>
                  validHeaderFieldByte 
                  <span class="badge">function</span>
                  
                  <a href="#validHeaderFieldByte" class="anchor" title="Link to validHeaderFieldByte">#</a>
               </h3>
               
               <p>validHeaderFieldByte reports whether c is a valid byte in a header
field name. RFC 7230 says:
header-field   = field-name ":" OWS field-value OWS
field-name     = token
tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
"^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
token = 1*tchar</p>
               
               <pre><code>func validHeaderFieldByte(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validHeaderValueByte" data-name="validHeaderValueByte">
               <h3>
                  validHeaderValueByte 
                  <span class="badge">function</span>
                  
                  <a href="#validHeaderValueByte" class="anchor" title="Link to validHeaderValueByte">#</a>
               </h3>
               
               <p>validHeaderValueByte reports whether c is a valid byte in a header
field value. RFC 7230 says:
field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
field-vchar    = VCHAR / obs-text
obs-text       = %x80-FF
RFC 5234 says:
HTAB           =  %x09
SP             =  %x20
VCHAR          =  %x21-7E</p>
               
               <pre><code>func validHeaderValueByte(c byte) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>