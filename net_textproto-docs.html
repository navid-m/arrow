<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - textproto</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>textproto</code>
         </h1>
         <hr />
         
         <article class="global" data-name="canonicalHeaderKeyTests">
            <h2>canonicalHeaderKeyTests</h2>
            <hr />
            
            <pre><code>canonicalHeaderKeyTests</code></pre>
         </article>
         
         <article class="global" data-name="errMessageTooLarge">
            <h2>errMessageTooLarge</h2>
            <hr />
            
            <p>TODO: This should be a distinguishable error (ErrMessageTooLarge)
to allow mime/multipart to detect it.</p>
            
            <pre><code>errMessageTooLarge</code></pre>
         </article>
         
         <article class="global" data-name="colon">
            <h2>colon</h2>
            <hr />
            
            <pre><code>colon</code></pre>
         </article>
         
         <article class="global" data-name="nl">
            <h2>nl</h2>
            <hr />
            
            <pre><code>nl</code></pre>
         </article>
         
         <article class="global" data-name="toLower">
            <h2>toLower</h2>
            <hr />
            
            <pre><code>toLower</code></pre>
         </article>
         
         <article class="global" data-name="commonHeader">
            <h2>commonHeader</h2>
            <hr />
            
            <p>commonHeader interns common header strings.</p>
            
            <pre><code>commonHeader *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="commonHeaderOnce">
            <h2>commonHeaderOnce</h2>
            <hr />
            
            <pre><code>commonHeaderOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="readResponseTests">
            <h2>readResponseTests</h2>
            <hr />
            
            <pre><code>readResponseTests</code></pre>
         </article>
         
         <article class="global" data-name="clientHeaders">
            <h2>clientHeaders</h2>
            <hr />
            
            <pre><code>clientHeaders</code></pre>
         </article>
         
         <article class="global" data-name="serverHeaders">
            <h2>serverHeaders</h2>
            <hr />
            
            <pre><code>serverHeaders</code></pre>
         </article>
         
         <article class="global" data-name="crnl">
            <h2>crnl</h2>
            <hr />
            
            <pre><code>crnl</code></pre>
         </article>
         
         <article class="global" data-name="dotcrnl">
            <h2>dotcrnl</h2>
            <hr />
            
            <pre><code>dotcrnl</code></pre>
         </article>
         
         <article class="global" data-name="wstateBegin">
            <h2>wstateBegin</h2>
            <hr />
            
            <pre><code>wstateBegin</code></pre>
         </article>
         
         <article class="global" data-name="wstateBeginLine">
            <h2>wstateBeginLine</h2>
            <hr />
            
            <pre><code>wstateBeginLine</code></pre>
         </article>
         
         <article class="global" data-name="wstateCR">
            <h2>wstateCR</h2>
            <hr />
            
            <pre><code>wstateCR</code></pre>
         </article>
         
         <article class="global" data-name="wstateData">
            <h2>wstateData</h2>
            <hr />
            
            <pre><code>wstateData</code></pre>
         </article>
          
         <article class="struct" data-name="canonicalHeaderKeyTest">
            <h2>type canonicalHeaderKeyTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">in string
out string</code></pre>
         </article>
         
         <article class="struct" data-name="Pipeline">
            <h2>type Pipeline struct</h2>
            <hr />
            
            <p>A Pipeline manages a pipelined in-order request/response sequence.

To use a Pipeline p to manage multiple clients on a connection,
each client should run:

	id := p.Next()	// take a number

	p.StartRequest(id)	// wait for turn to send request
	«send request»
	p.EndRequest(id)	// notify Pipeline that request is sent

	p.StartResponse(id)	// wait for turn to read response
	«read response»
	p.EndResponse(id)	// notify Pipeline that response is read

A pipelined server can use the same calls to ensure that
responses computed in parallel are written in the correct order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
id uint
request sequencer
response sequencer</code></pre>
         </article>
         
         <article class="struct" data-name="sequencer">
            <h2>type sequencer struct</h2>
            <hr />
            
            <p>A sequencer schedules a sequence of numbered events that must
happen in order, one after the other. The event numbering must start
at 0 and increment without skipping. The event number wraps around
safely as long as there are not 2^32 simultaneous events pending.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
id uint
wait *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="Reader">
            <h2>type Reader struct</h2>
            <hr />
            
            <p>A Reader implements convenience methods for reading requests
or responses from a text protocol network connection.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">R *bufio.Reader
dot *dotReader
buf []byte</code></pre>
         </article>
         
         <article class="struct" data-name="dotReader">
            <h2>type dotReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r *Reader
state int</code></pre>
         </article>
         
         <article class="struct" data-name="readResponseTest">
            <h2>type readResponseTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">in string
inCode int
wantCode int
wantMsg string</code></pre>
         </article>
         
         <article class="struct" data-name="Error">
            <h2>type Error struct</h2>
            <hr />
            
            <p>An Error represents a numeric error response from a server.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Code int
Msg string</code></pre>
         </article>
         
         <article class="struct" data-name="Conn">
            <h2>type Conn struct</h2>
            <hr />
            
            <p>A Conn represents a textual network protocol connection.
It consists of a [Reader] and [Writer] to manage I/O
and a [Pipeline] to sequence concurrent requests on the connection.
These embedded types carry methods with them;
see the documentation of those types for details.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Reader
Writer
Pipeline
conn io.ReadWriteCloser</code></pre>
         </article>
         
         <article class="struct" data-name="Writer">
            <h2>type Writer struct</h2>
            <hr />
            
            <p>A Writer implements convenience methods for writing
requests or responses to a text protocol network connection.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">W *bufio.Writer
dot *dotWriter</code></pre>
         </article>
         
         <article class="struct" data-name="dotWriter">
            <h2>type dotWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">w *Writer
state int</code></pre>
         </article>
          
         <article class="function" data-name="TestCanonicalMIMEHeaderKey">
            <h2>TestCanonicalMIMEHeaderKey</h2>
            <hr />
            
            <pre><code>func TestCanonicalMIMEHeaderKey(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMIMEHeaderMultipleValues">
            <h2>TestMIMEHeaderMultipleValues</h2>
            <hr />
            
            <p>Issue #34799 add a Header method to get multiple values []string, with canonicalized key</p>
            
            <pre><code>func TestMIMEHeaderMultipleValues(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Next">
            <h2>Next</h2>
            <hr />
            
            <p>Next returns the next id for a request/response pair.</p>
            
            <pre><code>func Next() uint</code></pre>
         </article>
         
         <article class="function" data-name="StartRequest">
            <h2>StartRequest</h2>
            <hr />
            
            <p>StartRequest blocks until it is time to send (or, if this is a server, receive)
the request with the given id.</p>
            
            <pre><code>func StartRequest(id uint)</code></pre>
         </article>
         
         <article class="function" data-name="EndRequest">
            <h2>EndRequest</h2>
            <hr />
            
            <p>EndRequest notifies p that the request with the given id has been sent
(or, if this is a server, received).</p>
            
            <pre><code>func EndRequest(id uint)</code></pre>
         </article>
         
         <article class="function" data-name="StartResponse">
            <h2>StartResponse</h2>
            <hr />
            
            <p>StartResponse blocks until it is time to receive (or, if this is a server, send)
the request with the given id.</p>
            
            <pre><code>func StartResponse(id uint)</code></pre>
         </article>
         
         <article class="function" data-name="EndResponse">
            <h2>EndResponse</h2>
            <hr />
            
            <p>EndResponse notifies p that the response with the given id has been received
(or, if this is a server, sent).</p>
            
            <pre><code>func EndResponse(id uint)</code></pre>
         </article>
         
         <article class="function" data-name="Start">
            <h2>Start</h2>
            <hr />
            
            <p>Start waits until it is time for the event numbered id to begin.
That is, except for the first event, it waits until End(id-1) has
been called.</p>
            
            <pre><code>func Start(id uint)</code></pre>
         </article>
         
         <article class="function" data-name="End">
            <h2>End</h2>
            <hr />
            
            <p>End notifies the sequencer that the event numbered id has completed,
allowing it to schedule the event numbered id+1.  It is a run-time error
to call End with an id that is not the number of the active event.</p>
            
            <pre><code>func End(id uint)</code></pre>
         </article>
         
         <article class="function" data-name="NewReader">
            <h2>NewReader</h2>
            <hr />
            
            <p>NewReader returns a new [Reader] reading from r.

To avoid denial of service attacks, the provided [bufio.Reader]
should be reading from an [io.LimitReader] or similar Reader to bound
the size of responses.</p>
            
            <pre><code>func NewReader(r *bufio.Reader) *Reader</code></pre>
         </article>
         
         <article class="function" data-name="ReadLine">
            <h2>ReadLine</h2>
            <hr />
            
            <p>ReadLine reads a single line from r,
eliding the final \n or \r\n from the returned string.</p>
            
            <pre><code>func ReadLine() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadLineBytes">
            <h2>ReadLineBytes</h2>
            <hr />
            
            <p>ReadLineBytes is like [Reader.ReadLine] but returns a []byte instead of a string.</p>
            
            <pre><code>func ReadLineBytes() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readLineSlice">
            <h2>readLineSlice</h2>
            <hr />
            
            <p>readLineSlice reads a single line from r,
up to lim bytes long (or unlimited if lim is less than 0),
eliding the final \r or \r\n from the returned string.</p>
            
            <pre><code>func readLineSlice(lim int64) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadContinuedLine">
            <h2>ReadContinuedLine</h2>
            <hr />
            
            <p>ReadContinuedLine reads a possibly continued line from r,
eliding the final trailing ASCII white space.
Lines after the first are considered continuations if they
begin with a space or tab character. In the returned data,
continuation lines are separated from the previous line
only by a single space: the newline and leading white space
are removed.

For example, consider this input:

	Line 1
	  continued...
	Line 2

The first call to ReadContinuedLine will return "Line 1 continued..."
and the second will return "Line 2".

Empty lines are never continued.</p>
            
            <pre><code>func ReadContinuedLine() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="trim">
            <h2>trim</h2>
            <hr />
            
            <p>trim returns s with leading and trailing spaces and tabs removed.
It does not assume Unicode or UTF-8.</p>
            
            <pre><code>func trim(s []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="ReadContinuedLineBytes">
            <h2>ReadContinuedLineBytes</h2>
            <hr />
            
            <p>ReadContinuedLineBytes is like [Reader.ReadContinuedLine] but
returns a []byte instead of a string.</p>
            
            <pre><code>func ReadContinuedLineBytes() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readContinuedLineSlice">
            <h2>readContinuedLineSlice</h2>
            <hr />
            
            <p>readContinuedLineSlice reads continued lines from the reader buffer,
returning a byte slice with all lines. The validateFirstLine function
is run on the first read line, and if it returns an error then this
error is returned from readContinuedLineSlice.
It reads up to lim bytes of data (or unlimited if lim is less than 0).</p>
            
            <pre><code>func readContinuedLineSlice(lim int64, validateFirstLine func) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="skipSpace">
            <h2>skipSpace</h2>
            <hr />
            
            <p>skipSpace skips R over all spaces and returns the number of bytes skipped.</p>
            
            <pre><code>func skipSpace() int</code></pre>
         </article>
         
         <article class="function" data-name="readCodeLine">
            <h2>readCodeLine</h2>
            <hr />
            
            <pre><code>func readCodeLine(expectCode int) (code int, continued bool, message string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseCodeLine">
            <h2>parseCodeLine</h2>
            <hr />
            
            <pre><code>func parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadCodeLine">
            <h2>ReadCodeLine</h2>
            <hr />
            
            <p>ReadCodeLine reads a response code line of the form

	code message

where code is a three-digit status code and the message
extends to the rest of the line. An example of such a line is:

	220 plan9.bell-labs.com ESMTP

If the prefix of the status does not match the digits in expectCode,
ReadCodeLine returns with err set to &Error{code, message}.
For example, if expectCode is 31, an error will be returned if
the status is not in the range [310,319].

If the response is multi-line, ReadCodeLine returns an error.

An expectCode <= 0 disables the check of the status code.</p>
            
            <pre><code>func ReadCodeLine(expectCode int) (code int, message string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponse">
            <h2>ReadResponse</h2>
            <hr />
            
            <p>ReadResponse reads a multi-line response of the form:

	code-message line 1
	code-message line 2
	...
	code message line n

where code is a three-digit status code. The first line starts with the
code and a hyphen. The response is terminated by a line that starts
with the same code followed by a space. Each line in message is
separated by a newline (\n).

See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for
details of another form of response accepted:

	code-message line 1
	message line 2
	...
	code message line n

If the prefix of the status does not match the digits in expectCode,
ReadResponse returns with err set to &Error{code, message}.
For example, if expectCode is 31, an error will be returned if
the status is not in the range [310,319].

An expectCode <= 0 disables the check of the status code.</p>
            
            <pre><code>func ReadResponse(expectCode int) (code int, message string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="DotReader">
            <h2>DotReader</h2>
            <hr />
            
            <p>DotReader returns a new [Reader] that satisfies Reads using the
decoded text of a dot-encoded block read from r.
The returned Reader is only valid until the next call
to a method on r.

Dot encoding is a common framing used for data blocks
in text protocols such as SMTP.  The data consists of a sequence
of lines, each of which ends in "\r\n".  The sequence itself
ends at a line containing just a dot: ".\r\n".  Lines beginning
with a dot are escaped with an additional dot to avoid
looking like the end of the sequence.

The decoded form returned by the Reader's Read method
rewrites the "\r\n" line endings into the simpler "\n",
removes leading dot escapes if present, and stops with error [io.EOF]
after consuming (and discarding) the end-of-sequence line.</p>
            
            <pre><code>func DotReader() io.Reader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read satisfies reads by decoding dot-encoded data read from d.r.</p>
            
            <pre><code>func Read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="closeDot">
            <h2>closeDot</h2>
            <hr />
            
            <p>closeDot drains the current DotReader if any,
making sure that it reads until the ending dot line.</p>
            
            <pre><code>func closeDot()</code></pre>
         </article>
         
         <article class="function" data-name="ReadDotBytes">
            <h2>ReadDotBytes</h2>
            <hr />
            
            <p>ReadDotBytes reads a dot-encoding and returns the decoded data.

See the documentation for the [Reader.DotReader] method for details about dot-encoding.</p>
            
            <pre><code>func ReadDotBytes() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadDotLines">
            <h2>ReadDotLines</h2>
            <hr />
            
            <p>ReadDotLines reads a dot-encoding and returns a slice
containing the decoded lines, with the final \r\n or \n elided from each.

See the documentation for the [Reader.DotReader] method for details about dot-encoding.</p>
            
            <pre><code>func ReadDotLines() ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadMIMEHeader">
            <h2>ReadMIMEHeader</h2>
            <hr />
            
            <p>ReadMIMEHeader reads a MIME-style header from r.
The header is a sequence of possibly continued Key: Value lines
ending in a blank line.
The returned map m maps [CanonicalMIMEHeaderKey](key) to a
sequence of values in the same order encountered in the input.

For example, consider this input:

	My-Key: Value 1
	Long-Key: Even
	       Longer Value
	My-Key: Value 2

Given that input, ReadMIMEHeader returns the map:

	map[string][]string{
		"My-Key": {"Value 1", "Value 2"},
		"Long-Key": {"Even Longer Value"},
	}</p>
            
            <pre><code>func ReadMIMEHeader() (MIMEHeader, error)</code></pre>
         </article>
         
         <article class="function" data-name="readMIMEHeader">
            <h2>readMIMEHeader</h2>
            <hr />
            
            <p>readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.
It is called by the mime/multipart package.</p>
            
            <pre><code>func readMIMEHeader(r *Reader, maxMemory int64, maxHeaders int64) (MIMEHeader, error)</code></pre>
         </article>
         
         <article class="function" data-name="noValidation">
            <h2>noValidation</h2>
            <hr />
            
            <p>noValidation is a no-op validation func for readContinuedLineSlice
that permits any lines.</p>
            
            <pre><code>func noValidation(_ []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="mustHaveFieldNameColon">
            <h2>mustHaveFieldNameColon</h2>
            <hr />
            
            <p>mustHaveFieldNameColon ensures that, per RFC 7230, the
field-name is on a single line, so the first line must
contain a colon.</p>
            
            <pre><code>func mustHaveFieldNameColon(line []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="upcomingHeaderKeys">
            <h2>upcomingHeaderKeys</h2>
            <hr />
            
            <p>upcomingHeaderKeys returns an approximation of the number of keys
that will be in this header. If it gets confused, it returns 0.</p>
            
            <pre><code>func upcomingHeaderKeys() n int</code></pre>
         </article>
         
         <article class="function" data-name="CanonicalMIMEHeaderKey">
            <h2>CanonicalMIMEHeaderKey</h2>
            <hr />
            
            <p>CanonicalMIMEHeaderKey returns the canonical format of the
MIME header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
MIME header keys are assumed to be ASCII only.
If s contains a space or invalid header field bytes, it is
returned without modifications.</p>
            
            <pre><code>func CanonicalMIMEHeaderKey(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="validHeaderFieldByte">
            <h2>validHeaderFieldByte</h2>
            <hr />
            
            <p>validHeaderFieldByte reports whether c is a valid byte in a header
field name. RFC 7230 says:

	header-field   = field-name ":" OWS field-value OWS
	field-name     = token
	tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
	        "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
	token = 1*tchar</p>
            
            <pre><code>func validHeaderFieldByte(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="validHeaderValueByte">
            <h2>validHeaderValueByte</h2>
            <hr />
            
            <p>validHeaderValueByte reports whether c is a valid byte in a header
field value. RFC 7230 says:

	field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	field-vchar    = VCHAR / obs-text
	obs-text       = %x80-FF

RFC 5234 says:

	HTAB           =  %x09
	SP             =  %x20
	VCHAR          =  %x21-7E</p>
            
            <pre><code>func validHeaderValueByte(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="canonicalMIMEHeaderKey">
            <h2>canonicalMIMEHeaderKey</h2>
            <hr />
            
            <p>canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is
allowed to mutate the provided byte slice before returning the
string.

For invalid inputs (if a contains spaces or non-token bytes), a
is unchanged and a string copy is returned.

ok is true if the header key contains only valid characters and spaces.
ReadMIMEHeader accepts header keys containing spaces, but does not
canonicalize them.</p>
            
            <pre><code>func canonicalMIMEHeaderKey(a []byte) (_ string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="initCommonHeader">
            <h2>initCommonHeader</h2>
            <hr />
            
            <pre><code>func initCommonHeader()</code></pre>
         </article>
         
         <article class="function" data-name="reader">
            <h2>reader</h2>
            <hr />
            
            <pre><code>func reader(s string) *Reader</code></pre>
         </article>
         
         <article class="function" data-name="TestReadLine">
            <h2>TestReadLine</h2>
            <hr />
            
            <pre><code>func TestReadLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadLineLongLine">
            <h2>TestReadLineLongLine</h2>
            <hr />
            
            <pre><code>func TestReadLineLongLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadContinuedLine">
            <h2>TestReadContinuedLine</h2>
            <hr />
            
            <pre><code>func TestReadContinuedLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadCodeLine">
            <h2>TestReadCodeLine</h2>
            <hr />
            
            <pre><code>func TestReadCodeLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadDotLines">
            <h2>TestReadDotLines</h2>
            <hr />
            
            <pre><code>func TestReadDotLines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadDotBytes">
            <h2>TestReadDotBytes</h2>
            <hr />
            
            <pre><code>func TestReadDotBytes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeader">
            <h2>TestReadMIMEHeader</h2>
            <hr />
            
            <pre><code>func TestReadMIMEHeader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderSingle">
            <h2>TestReadMIMEHeaderSingle</h2>
            <hr />
            
            <pre><code>func TestReadMIMEHeaderSingle(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderUpcomingHeaderKeys">
            <h2>TestReaderUpcomingHeaderKeys</h2>
            <hr />
            
            <p>TestReaderUpcomingHeaderKeys is testing an internal function, but it's very
difficult to test well via the external API.</p>
            
            <pre><code>func TestReaderUpcomingHeaderKeys(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderNoKey">
            <h2>TestReadMIMEHeaderNoKey</h2>
            <hr />
            
            <pre><code>func TestReadMIMEHeaderNoKey(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeReadMIMEHeader">
            <h2>TestLargeReadMIMEHeader</h2>
            <hr />
            
            <pre><code>func TestLargeReadMIMEHeader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderNonCompliant">
            <h2>TestReadMIMEHeaderNonCompliant</h2>
            <hr />
            
            <p>TestReadMIMEHeaderNonCompliant checks that we don't normalize headers
with spaces before colons, and accept spaces in keys.</p>
            
            <pre><code>func TestReadMIMEHeaderNonCompliant(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderMalformed">
            <h2>TestReadMIMEHeaderMalformed</h2>
            <hr />
            
            <pre><code>func TestReadMIMEHeaderMalformed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderBytes">
            <h2>TestReadMIMEHeaderBytes</h2>
            <hr />
            
            <pre><code>func TestReadMIMEHeaderBytes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderTrimContinued">
            <h2>TestReadMIMEHeaderTrimContinued</h2>
            <hr />
            
            <p>Test that continued lines are properly trimmed. Issue 11204.</p>
            
            <pre><code>func TestReadMIMEHeaderTrimContinued(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMIMEHeaderAllocations">
            <h2>TestReadMIMEHeaderAllocations</h2>
            <hr />
            
            <p>Test that reading a header doesn't overallocate. Issue 58975.</p>
            
            <pre><code>func TestReadMIMEHeaderAllocations(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRFC959Lines">
            <h2>TestRFC959Lines</h2>
            <hr />
            
            <p>See https://www.ietf.org/rfc/rfc959.txt page 36.</p>
            
            <pre><code>func TestRFC959Lines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadMultiLineError">
            <h2>TestReadMultiLineError</h2>
            <hr />
            
            <p>Test that multi-line errors are appropriately and fully read. Issue 10230.</p>
            
            <pre><code>func TestReadMultiLineError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCommonHeaders">
            <h2>TestCommonHeaders</h2>
            <hr />
            
            <pre><code>func TestCommonHeaders(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue46363">
            <h2>TestIssue46363</h2>
            <hr />
            
            <pre><code>func TestIssue46363(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReadMIMEHeader">
            <h2>BenchmarkReadMIMEHeader</h2>
            <hr />
            
            <pre><code>func BenchmarkReadMIMEHeader(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkUncommon">
            <h2>BenchmarkUncommon</h2>
            <hr />
            
            <pre><code>func BenchmarkUncommon(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="NewConn">
            <h2>NewConn</h2>
            <hr />
            
            <p>NewConn returns a new [Conn] using conn for I/O.</p>
            
            <pre><code>func NewConn(conn io.ReadWriteCloser) *Conn</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the connection.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Dial">
            <h2>Dial</h2>
            <hr />
            
            <p>Dial connects to the given address on the given network using [net.Dial]
and then returns a new [Conn] for the connection.</p>
            
            <pre><code>func Dial(network string, addr string) (*Conn, error)</code></pre>
         </article>
         
         <article class="function" data-name="Cmd">
            <h2>Cmd</h2>
            <hr />
            
            <p>Cmd is a convenience method that sends a command after
waiting its turn in the pipeline. The command text is the
result of formatting format with args and appending \r\n.
Cmd returns the id of the command, for use with StartResponse and EndResponse.

For example, a client might run a HELP command that returns a dot-body
by using:

	id, err := c.Cmd("HELP")
	if err != nil {
		return nil, err
	}

	c.StartResponse(id)
	defer c.EndResponse(id)

	if _, _, err = c.ReadCodeLine(110); err != nil {
		return nil, err
	}
	text, err := c.ReadDotBytes()
	if err != nil {
		return nil, err
	}
	return c.ReadCodeLine(250)</p>
            
            <pre><code>func Cmd(format string, args ...any) (id uint, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TrimString">
            <h2>TrimString</h2>
            <hr />
            
            <p>TrimString returns s without leading and trailing ASCII space.</p>
            
            <pre><code>func TrimString(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="TrimBytes">
            <h2>TrimBytes</h2>
            <hr />
            
            <p>TrimBytes returns b without leading and trailing ASCII space.</p>
            
            <pre><code>func TrimBytes(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="isASCIISpace">
            <h2>isASCIISpace</h2>
            <hr />
            
            <pre><code>func isASCIISpace(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isASCIILetter">
            <h2>isASCIILetter</h2>
            <hr />
            
            <pre><code>func isASCIILetter(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="NewWriter">
            <h2>NewWriter</h2>
            <hr />
            
            <p>NewWriter returns a new [Writer] writing to w.</p>
            
            <pre><code>func NewWriter(w *bufio.Writer) *Writer</code></pre>
         </article>
         
         <article class="function" data-name="PrintfLine">
            <h2>PrintfLine</h2>
            <hr />
            
            <p>PrintfLine writes the formatted output followed by \r\n.</p>
            
            <pre><code>func PrintfLine(format string, args ...any) error</code></pre>
         </article>
         
         <article class="function" data-name="DotWriter">
            <h2>DotWriter</h2>
            <hr />
            
            <p>DotWriter returns a writer that can be used to write a dot-encoding to w.
It takes care of inserting leading dots when necessary,
translating line-ending \n into \r\n, and adding the final .\r\n line
when the DotWriter is closed. The caller should close the
DotWriter before the next call to a method on w.

See the documentation for the [Reader.DotReader] method for details about dot-encoding.</p>
            
            <pre><code>func DotWriter() io.WriteCloser</code></pre>
         </article>
         
         <article class="function" data-name="closeDot">
            <h2>closeDot</h2>
            <hr />
            
            <pre><code>func closeDot()</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="TestPrintfLine">
            <h2>TestPrintfLine</h2>
            <hr />
            
            <pre><code>func TestPrintfLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDotWriter">
            <h2>TestDotWriter</h2>
            <hr />
            
            <pre><code>func TestDotWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDotWriterCloseEmptyWrite">
            <h2>TestDotWriterCloseEmptyWrite</h2>
            <hr />
            
            <pre><code>func TestDotWriterCloseEmptyWrite(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDotWriterCloseNoWrite">
            <h2>TestDotWriterCloseNoWrite</h2>
            <hr />
            
            <pre><code>func TestDotWriterCloseNoWrite(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds the key, value pair to the header.
It appends to any existing values associated with key.</p>
            
            <pre><code>func Add(key string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets the header entries associated with key to
the single element value. It replaces any existing
values associated with key.</p>
            
            <pre><code>func Set(key string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <p>Get gets the first value associated with the given key.
It is case insensitive; [CanonicalMIMEHeaderKey] is used
to canonicalize the provided key.
If there are no values associated with the key, Get returns "".
To use non-canonical keys, access the map directly.</p>
            
            <pre><code>func Get(key string) string</code></pre>
         </article>
         
         <article class="function" data-name="Values">
            <h2>Values</h2>
            <hr />
            
            <p>Values returns all values associated with the given key.
It is case insensitive; [CanonicalMIMEHeaderKey] is
used to canonicalize the provided key. To use non-canonical
keys, access the map directly.
The returned slice is not a copy.</p>
            
            <pre><code>func Values(key string) []string</code></pre>
         </article>
         
         <article class="function" data-name="Del">
            <h2>Del</h2>
            <hr />
            
            <p>Del deletes the values associated with key.</p>
            
            <pre><code>func Del(key string)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
