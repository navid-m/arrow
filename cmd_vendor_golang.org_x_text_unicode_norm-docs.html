<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - norm</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>norm</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"unicode/utf8"
"unicode/utf8"
"golang.org/x/text/transform"
"sync"
"unicode/utf8"
"golang.org/x/text/transform"
"encoding/binary"
"fmt"
"unicode/utf8"
"io"
"sync"
"sync"
"sync"
"sync"
"sync"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="GraphemeJoiner">
               <h3>
                  GraphemeJoiner 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>GraphemeJoiner is inserted after maxNonStarters non-starter runes.</p>
               
               <pre><code>const GraphemeJoiner = "\u034F"</code></pre>
            </article>
            
            <article class="global" data-name="MaxSegmentSize">
               <h3>
                  MaxSegmentSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxSegmentSize is the maximum size of a byte buffer needed to consider any
sequence of starter and non-starter runes for the purpose of normalization.</p>
               
               <pre><code>const MaxSegmentSize = maxByteBufferSize</code></pre>
            </article>
            
            <article class="global" data-name="MaxTransformChunkSize">
               <h3>
                  MaxTransformChunkSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
               
               <pre><code>const MaxTransformChunkSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxTransformChunkSize">
               <h3>
                  MaxTransformChunkSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
               
               <pre><code>const MaxTransformChunkSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxTransformChunkSize">
               <h3>
                  MaxTransformChunkSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
               
               <pre><code>const MaxTransformChunkSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxTransformChunkSize">
               <h3>
                  MaxTransformChunkSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
               
               <pre><code>const MaxTransformChunkSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxTransformChunkSize">
               <h3>
                  MaxTransformChunkSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
               
               <pre><code>const MaxTransformChunkSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxTransformChunkSize">
               <h3>
                  MaxTransformChunkSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
               
               <pre><code>const MaxTransformChunkSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="NFC">
               <h3>
                  NFC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NFC Form = iota</code></pre>
            </article>
            
            <article class="global" data-name="NFD">
               <h3>
                  NFD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NFD</code></pre>
            </article>
            
            <article class="global" data-name="NFKC">
               <h3>
                  NFKC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NFKC</code></pre>
            </article>
            
            <article class="global" data-name="NFKD">
               <h3>
                  NFKD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NFKD</code></pre>
            </article>
            
            <article class="global" data-name="Version">
               <h3>
                  Version 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version is the Unicode edition from which the tables are derived.</p>
               
               <pre><code>const Version = "12.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="Version">
               <h3>
                  Version 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version is the Unicode edition from which the tables are derived.</p>
               
               <pre><code>const Version = "11.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="Version">
               <h3>
                  Version 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version is the Unicode edition from which the tables are derived.</p>
               
               <pre><code>const Version = "13.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="Version">
               <h3>
                  Version 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version is the Unicode edition from which the tables are derived.</p>
               
               <pre><code>const Version = "15.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="Version">
               <h3>
                  Version 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version is the Unicode edition from which the tables are derived.</p>
               
               <pre><code>const Version = "9.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="Version">
               <h3>
                  Version 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version is the Unicode edition from which the tables are derived.</p>
               
               <pre><code>const Version = "10.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="ccc">
               <h3>
                  ccc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ccc = [55]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="ccc">
               <h3>
                  ccc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ccc = [55]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="ccc">
               <h3>
                  ccc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ccc = [56]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="ccc">
               <h3>
                  ccc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ccc = [55]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="ccc">
               <h3>
                  ccc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ccc = [55]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="ccc">
               <h3>
                  ccc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ccc = [56]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="decomps">
               <h3>
                  decomps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>decomps: 19128 bytes</p>
               
               <pre><code>var decomps = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="decomps">
               <h3>
                  decomps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>decomps: 19105 bytes</p>
               
               <pre><code>var decomps = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="decomps">
               <h3>
                  decomps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>decomps: 19108 bytes</p>
               
               <pre><code>var decomps = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="decomps">
               <h3>
                  decomps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>decomps: 19105 bytes</p>
               
               <pre><code>var decomps = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="decomps">
               <h3>
                  decomps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>decomps: 19105 bytes</p>
               
               <pre><code>var decomps = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="decomps">
               <h3>
                  decomps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>decomps: 19426 bytes</p>
               
               <pre><code>var decomps = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="endMulti">
               <h3>
                  endMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const endMulti = 0x2F77</code></pre>
            </article>
            
            <article class="global" data-name="endMulti">
               <h3>
                  endMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const endMulti = 0x2F63</code></pre>
            </article>
            
            <article class="global" data-name="endMulti">
               <h3>
                  endMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const endMulti = 0x2F60</code></pre>
            </article>
            
            <article class="global" data-name="endMulti">
               <h3>
                  endMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const endMulti = 0x2F60</code></pre>
            </article>
            
            <article class="global" data-name="endMulti">
               <h3>
                  endMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const endMulti = 0x30A1</code></pre>
            </article>
            
            <article class="global" data-name="endMulti">
               <h3>
                  endMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const endMulti = 0x2F60</code></pre>
            </article>
            
            <article class="global" data-name="errs">
               <h3>
                  errs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errs = []error{...}</code></pre>
            </article>
            
            <article class="global" data-name="firstCCC">
               <h3>
                  firstCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCC = 0x2CA1</code></pre>
            </article>
            
            <article class="global" data-name="firstCCC">
               <h3>
                  firstCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCC = 0x2C9E</code></pre>
            </article>
            
            <article class="global" data-name="firstCCC">
               <h3>
                  firstCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCC = 0x2C9E</code></pre>
            </article>
            
            <article class="global" data-name="firstCCC">
               <h3>
                  firstCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCC = 0x2DD5</code></pre>
            </article>
            
            <article class="global" data-name="firstCCC">
               <h3>
                  firstCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCC = 0x2CAB</code></pre>
            </article>
            
            <article class="global" data-name="firstCCC">
               <h3>
                  firstCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCC = 0x2C9E</code></pre>
            </article>
            
            <article class="global" data-name="firstCCCZeroExcept">
               <h3>
                  firstCCCZeroExcept 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCCZeroExcept = 0x4A78</code></pre>
            </article>
            
            <article class="global" data-name="firstCCCZeroExcept">
               <h3>
                  firstCCCZeroExcept 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCCZeroExcept = 0x4A7B</code></pre>
            </article>
            
            <article class="global" data-name="firstCCCZeroExcept">
               <h3>
                  firstCCCZeroExcept 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCCZeroExcept = 0x4A78</code></pre>
            </article>
            
            <article class="global" data-name="firstCCCZeroExcept">
               <h3>
                  firstCCCZeroExcept 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCCZeroExcept = 0x4BB9</code></pre>
            </article>
            
            <article class="global" data-name="firstCCCZeroExcept">
               <h3>
                  firstCCCZeroExcept 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCCZeroExcept = 0x4A78</code></pre>
            </article>
            
            <article class="global" data-name="firstCCCZeroExcept">
               <h3>
                  firstCCCZeroExcept 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstCCCZeroExcept = 0x4A8F</code></pre>
            </article>
            
            <article class="global" data-name="firstLeadingCCC">
               <h3>
                  firstLeadingCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstLeadingCCC = 0x49B1</code></pre>
            </article>
            
            <article class="global" data-name="firstLeadingCCC">
               <h3>
                  firstLeadingCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstLeadingCCC = 0x49AE</code></pre>
            </article>
            
            <article class="global" data-name="firstLeadingCCC">
               <h3>
                  firstLeadingCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstLeadingCCC = 0x49AE</code></pre>
            </article>
            
            <article class="global" data-name="firstLeadingCCC">
               <h3>
                  firstLeadingCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstLeadingCCC = 0x49AE</code></pre>
            </article>
            
            <article class="global" data-name="firstLeadingCCC">
               <h3>
                  firstLeadingCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstLeadingCCC = 0x4AEF</code></pre>
            </article>
            
            <article class="global" data-name="firstLeadingCCC">
               <h3>
                  firstLeadingCCC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstLeadingCCC = 0x49C5</code></pre>
            </article>
            
            <article class="global" data-name="firstMulti">
               <h3>
                  firstMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstMulti = 0x199A</code></pre>
            </article>
            
            <article class="global" data-name="firstMulti">
               <h3>
                  firstMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstMulti = 0x186D</code></pre>
            </article>
            
            <article class="global" data-name="firstMulti">
               <h3>
                  firstMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstMulti = 0x186D</code></pre>
            </article>
            
            <article class="global" data-name="firstMulti">
               <h3>
                  firstMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstMulti = 0x186D</code></pre>
            </article>
            
            <article class="global" data-name="firstMulti">
               <h3>
                  firstMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstMulti = 0x1870</code></pre>
            </article>
            
            <article class="global" data-name="firstMulti">
               <h3>
                  firstMulti 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstMulti = 0x186D</code></pre>
            </article>
            
            <article class="global" data-name="firstStarterWithNLead">
               <h3>
                  firstStarterWithNLead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstStarterWithNLead = 0x4AA2</code></pre>
            </article>
            
            <article class="global" data-name="firstStarterWithNLead">
               <h3>
                  firstStarterWithNLead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstStarterWithNLead = 0x4AB6</code></pre>
            </article>
            
            <article class="global" data-name="firstStarterWithNLead">
               <h3>
                  firstStarterWithNLead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstStarterWithNLead = 0x4A9F</code></pre>
            </article>
            
            <article class="global" data-name="firstStarterWithNLead">
               <h3>
                  firstStarterWithNLead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstStarterWithNLead = 0x4BE0</code></pre>
            </article>
            
            <article class="global" data-name="firstStarterWithNLead">
               <h3>
                  firstStarterWithNLead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstStarterWithNLead = 0x4A9F</code></pre>
            </article>
            
            <article class="global" data-name="firstStarterWithNLead">
               <h3>
                  firstStarterWithNLead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const firstStarterWithNLead = 0x4A9F</code></pre>
            </article>
            
            <article class="global" data-name="formTable">
               <h3>
                  formTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var formTable = []*formInfo{...}</code></pre>
            </article>
            
            <article class="global" data-name="hangulBase">
               <h3>
                  hangulBase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulBase = 0xAC00</code></pre>
            </article>
            
            <article class="global" data-name="hangulBase0">
               <h3>
                  hangulBase0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulBase0 = 0xEA</code></pre>
            </article>
            
            <article class="global" data-name="hangulBase1">
               <h3>
                  hangulBase1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulBase1 = 0xB0</code></pre>
            </article>
            
            <article class="global" data-name="hangulBase2">
               <h3>
                  hangulBase2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulBase2 = 0x80</code></pre>
            </article>
            
            <article class="global" data-name="hangulEnd">
               <h3>
                  hangulEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulEnd = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="hangulEnd0">
               <h3>
                  hangulEnd0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulEnd0 = 0xED</code></pre>
            </article>
            
            <article class="global" data-name="hangulEnd1">
               <h3>
                  hangulEnd1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulEnd1 = 0x9E</code></pre>
            </article>
            
            <article class="global" data-name="hangulEnd2">
               <h3>
                  hangulEnd2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const hangulEnd2 = 0xA4</code></pre>
            </article>
            
            <article class="global" data-name="hangulUTF8Size">
               <h3>
                  hangulUTF8Size 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hangulUTF8Size = 3</code></pre>
            </article>
            
            <article class="global" data-name="headerFlagsMask">
               <h3>
                  headerFlagsMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const headerFlagsMask = 0xC0</code></pre>
            </article>
            
            <article class="global" data-name="headerLenMask">
               <h3>
                  headerLenMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const headerLenMask = 0x3F</code></pre>
            </article>
            
            <article class="global" data-name="iShortDst">
               <h3>
                  iShortDst 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const iShortDst</code></pre>
            </article>
            
            <article class="global" data-name="iShortSrc">
               <h3>
                  iShortSrc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const iShortSrc</code></pre>
            </article>
            
            <article class="global" data-name="iSuccess">
               <h3>
                  iSuccess 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const iSuccess insertErr = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="jamoLBase">
               <h3>
                  jamoLBase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoLBase = 0x1100</code></pre>
            </article>
            
            <article class="global" data-name="jamoLBase0">
               <h3>
                  jamoLBase0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoLBase0 = 0xE1</code></pre>
            </article>
            
            <article class="global" data-name="jamoLBase1">
               <h3>
                  jamoLBase1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoLBase1 = 0x84</code></pre>
            </article>
            
            <article class="global" data-name="jamoLEnd">
               <h3>
                  jamoLEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoLEnd = 0x1113</code></pre>
            </article>
            
            <article class="global" data-name="jamoLVTCount">
               <h3>
                  jamoLVTCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoLVTCount = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="jamoTBase">
               <h3>
                  jamoTBase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoTBase = 0x11A7</code></pre>
            </article>
            
            <article class="global" data-name="jamoTCount">
               <h3>
                  jamoTCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoTCount = 28</code></pre>
            </article>
            
            <article class="global" data-name="jamoTEnd">
               <h3>
                  jamoTEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoTEnd = 0x11C3</code></pre>
            </article>
            
            <article class="global" data-name="jamoVBase">
               <h3>
                  jamoVBase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoVBase = 0x1161</code></pre>
            </article>
            
            <article class="global" data-name="jamoVCount">
               <h3>
                  jamoVCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoVCount = 21</code></pre>
            </article>
            
            <article class="global" data-name="jamoVEnd">
               <h3>
                  jamoVEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoVEnd = 0x1176</code></pre>
            </article>
            
            <article class="global" data-name="jamoVTCount">
               <h3>
                  jamoVTCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For Hangul we combine algorithmically, instead of using tables.</p>
               
               <pre><code>const jamoVTCount = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="lastDecomp">
               <h3>
                  lastDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const lastDecomp = 0x4AA4</code></pre>
            </article>
            
            <article class="global" data-name="lastDecomp">
               <h3>
                  lastDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const lastDecomp = 0x4BE2</code></pre>
            </article>
            
            <article class="global" data-name="lastDecomp">
               <h3>
                  lastDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const lastDecomp = 0x4AA1</code></pre>
            </article>
            
            <article class="global" data-name="lastDecomp">
               <h3>
                  lastDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const lastDecomp = 0x4AA1</code></pre>
            </article>
            
            <article class="global" data-name="lastDecomp">
               <h3>
                  lastDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const lastDecomp = 0x4AA1</code></pre>
            </article>
            
            <article class="global" data-name="lastDecomp">
               <h3>
                  lastDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const lastDecomp = 0x4AB8</code></pre>
            </article>
            
            <article class="global" data-name="maxBufferSize">
               <h3>
                  maxBufferSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The maximum number of characters needed for a buffer is
maxNonStarters + 1 for the starter + 1 for the GCJ</p>
               
               <pre><code>const maxBufferSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxByteBufferSize">
               <h3>
                  maxByteBufferSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxByteBufferSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxDecomp">
               <h3>
                  maxDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDecomp = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="maxDecomp">
               <h3>
                  maxDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDecomp = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="maxDecomp">
               <h3>
                  maxDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDecomp = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="maxDecomp">
               <h3>
                  maxDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDecomp = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="maxDecomp">
               <h3>
                  maxDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDecomp = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="maxDecomp">
               <h3>
                  maxDecomp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDecomp = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="maxNFCExpansion">
               <h3>
                  maxNFCExpansion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxNFCExpansion = 3</code></pre>
            </article>
            
            <article class="global" data-name="maxNFKCExpansion">
               <h3>
                  maxNFKCExpansion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxNFKCExpansion = 18</code></pre>
            </article>
            
            <article class="global" data-name="maxNonStarters">
               <h3>
                  maxNonStarters 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxNonStarters = 30</code></pre>
            </article>
            
            <article class="global" data-name="nfcData">
               <h3>
                  nfcData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nfcData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="nfcIndex">
               <h3>
                  nfcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcIndex">
               <h3>
                  nfcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcIndex">
               <h3>
                  nfcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcIndex">
               <h3>
                  nfcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcIndex">
               <h3>
                  nfcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcIndex">
               <h3>
                  nfcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparse">
               <h3>
                  nfcSparse 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nfcSparse = sparseBlocks{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseOffset">
               <h3>
                  nfcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseOffset: 149 entries, 298 bytes</p>
               
               <pre><code>var nfcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseOffset">
               <h3>
                  nfcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseOffset: 151 entries, 302 bytes</p>
               
               <pre><code>var nfcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseOffset">
               <h3>
                  nfcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseOffset: 145 entries, 290 bytes</p>
               
               <pre><code>var nfcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseOffset">
               <h3>
                  nfcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseOffset: 163 entries, 326 bytes</p>
               
               <pre><code>var nfcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseOffset">
               <h3>
                  nfcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseOffset: 142 entries, 284 bytes</p>
               
               <pre><code>var nfcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseOffset">
               <h3>
                  nfcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseOffset: 156 entries, 312 bytes</p>
               
               <pre><code>var nfcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseValues">
               <h3>
                  nfcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseValues: 684 entries, 2736 bytes</p>
               
               <pre><code>var nfcSparseValues = [684]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseValues">
               <h3>
                  nfcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseValues: 704 entries, 2816 bytes</p>
               
               <pre><code>var nfcSparseValues = [704]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseValues">
               <h3>
                  nfcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseValues: 730 entries, 2920 bytes</p>
               
               <pre><code>var nfcSparseValues = [730]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseValues">
               <h3>
                  nfcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseValues: 689 entries, 2756 bytes</p>
               
               <pre><code>var nfcSparseValues = [689]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseValues">
               <h3>
                  nfcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseValues: 688 entries, 2752 bytes</p>
               
               <pre><code>var nfcSparseValues = [688]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcSparseValues">
               <h3>
                  nfcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcSparseValues: 682 entries, 2728 bytes</p>
               
               <pre><code>var nfcSparseValues = [682]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcValues">
               <h3>
                  nfcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfcValues = [3072]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcValues">
               <h3>
                  nfcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfcValues = [3072]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcValues">
               <h3>
                  nfcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcValues: 47 blocks, 3008 entries, 6016 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfcValues = [3008]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcValues">
               <h3>
                  nfcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcValues: 46 blocks, 2944 entries, 5888 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfcValues = [2944]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcValues">
               <h3>
                  nfcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfcValues = [3072]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfcValues">
               <h3>
                  nfcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfcValues = [3072]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcData">
               <h3>
                  nfkcData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nfkcData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="nfkcIndex">
               <h3>
                  nfkcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfkcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcIndex">
               <h3>
                  nfkcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfkcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcIndex">
               <h3>
                  nfkcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcIndex: 22 blocks, 1408 entries, 2816 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfkcIndex = [1408]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcIndex">
               <h3>
                  nfkcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcIndex: 22 blocks, 1408 entries, 2816 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfkcIndex = [1408]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcIndex">
               <h3>
                  nfkcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfkcIndex = [1408]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcIndex">
               <h3>
                  nfkcIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcIndex: 22 blocks, 1408 entries, 2816 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var nfkcIndex = [1408]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparse">
               <h3>
                  nfkcSparse 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nfkcSparse = sparseBlocks{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseOffset">
               <h3>
                  nfkcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseOffset: 158 entries, 316 bytes</p>
               
               <pre><code>var nfkcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseOffset">
               <h3>
                  nfkcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseOffset: 162 entries, 324 bytes</p>
               
               <pre><code>var nfkcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseOffset">
               <h3>
                  nfkcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseOffset: 170 entries, 340 bytes</p>
               
               <pre><code>var nfkcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseOffset">
               <h3>
                  nfkcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseOffset: 164 entries, 328 bytes</p>
               
               <pre><code>var nfkcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseOffset">
               <h3>
                  nfkcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseOffset: 176 entries, 352 bytes</p>
               
               <pre><code>var nfkcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseOffset">
               <h3>
                  nfkcSparseOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseOffset: 155 entries, 310 bytes</p>
               
               <pre><code>var nfkcSparseOffset = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseValues">
               <h3>
                  nfkcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseValues: 869 entries, 3476 bytes</p>
               
               <pre><code>var nfkcSparseValues = [869]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseValues">
               <h3>
                  nfkcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseValues: 871 entries, 3484 bytes</p>
               
               <pre><code>var nfkcSparseValues = [871]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseValues">
               <h3>
                  nfkcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseValues: 895 entries, 3580 bytes</p>
               
               <pre><code>var nfkcSparseValues = [895]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseValues">
               <h3>
                  nfkcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseValues: 875 entries, 3500 bytes</p>
               
               <pre><code>var nfkcSparseValues = [875]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseValues">
               <h3>
                  nfkcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseValues: 919 entries, 3676 bytes</p>
               
               <pre><code>var nfkcSparseValues = [919]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcSparseValues">
               <h3>
                  nfkcSparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcSparseValues: 877 entries, 3508 bytes</p>
               
               <pre><code>var nfkcSparseValues = [877]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcValues">
               <h3>
                  nfkcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcValues: 93 blocks, 5952 entries, 11904 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfkcValues = [5952]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcValues">
               <h3>
                  nfkcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcValues: 94 blocks, 6016 entries, 12032 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfkcValues = [6016]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcValues">
               <h3>
                  nfkcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcValues: 94 blocks, 6016 entries, 12032 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfkcValues = [6016]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcValues">
               <h3>
                  nfkcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcValues: 92 blocks, 5888 entries, 11776 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfkcValues = [5888]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcValues">
               <h3>
                  nfkcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcValues: 94 blocks, 6016 entries, 12032 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfkcValues = [6016]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="nfkcValues">
               <h3>
                  nfkcValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nfkcValues: 97 blocks, 6208 entries, 12416 bytes
The third block is the zero block.</p>
               
               <pre><code>var nfkcValues = [6208]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="qcInfoMask">
               <h3>
                  qcInfoMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const qcInfoMask = 0x3F</code></pre>
            </article>
            
            <article class="global" data-name="recompMap">
               <h3>
                  recompMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>recompMap: 7528 bytes (entries only)</p>
               
               <pre><code>var recompMap map[uint32]rune</code></pre>
            </article>
            
            <article class="global" data-name="recompMap">
               <h3>
                  recompMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>recompMap: 7520 bytes (entries only)</p>
               
               <pre><code>var recompMap map[uint32]rune</code></pre>
            </article>
            
            <article class="global" data-name="recompMap">
               <h3>
                  recompMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>recompMap: 7520 bytes (entries only)</p>
               
               <pre><code>var recompMap map[uint32]rune</code></pre>
            </article>
            
            <article class="global" data-name="recompMap">
               <h3>
                  recompMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>recompMap: 7528 bytes (entries only)</p>
               
               <pre><code>var recompMap map[uint32]rune</code></pre>
            </article>
            
            <article class="global" data-name="recompMap">
               <h3>
                  recompMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>recompMap: 7520 bytes (entries only)</p>
               
               <pre><code>var recompMap map[uint32]rune</code></pre>
            </article>
            
            <article class="global" data-name="recompMap">
               <h3>
                  recompMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>recompMap: 7520 bytes (entries only)</p>
               
               <pre><code>var recompMap map[uint32]rune</code></pre>
            </article>
            
            <article class="global" data-name="recompMapOnce">
               <h3>
                  recompMapOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recompMapOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="recompMapOnce">
               <h3>
                  recompMapOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recompMapOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="recompMapOnce">
               <h3>
                  recompMapOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recompMapOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="recompMapOnce">
               <h3>
                  recompMapOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recompMapOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="recompMapOnce">
               <h3>
                  recompMapOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recompMapOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="recompMapOnce">
               <h3>
                  recompMapOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recompMapOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="recompMapPacked">
               <h3>
                  recompMapPacked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recompMapPacked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="recompMapPacked">
               <h3>
                  recompMapPacked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recompMapPacked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="recompMapPacked">
               <h3>
                  recompMapPacked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recompMapPacked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="recompMapPacked">
               <h3>
                  recompMapPacked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recompMapPacked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="recompMapPacked">
               <h3>
                  recompMapPacked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recompMapPacked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="recompMapPacked">
               <h3>
                  recompMapPacked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recompMapPacked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ssOverflow">
               <h3>
                  ssOverflow 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Indicates a rune caused a segment overflow and a CGJ should be inserted.</p>
               
               <pre><code>const ssOverflow</code></pre>
            </article>
            
            <article class="global" data-name="ssStarter">
               <h3>
                  ssStarter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Indicates a rune starts a new segment and should not be added.</p>
               
               <pre><code>const ssStarter</code></pre>
            </article>
            
            <article class="global" data-name="ssSuccess">
               <h3>
                  ssSuccess 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Indicates a rune was successfully added to the segment.</p>
               
               <pre><code>const ssSuccess ssState = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Form">
               <h3>
                  Form
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Form denotes a canonical representation of Unicode code points.
The Unicode-defined normalization and equivalence forms are:
NFC   Unicode Normalization Form C
NFD   Unicode Normalization Form D
NFKC  Unicode Normalization Form KC
NFKD  Unicode Normalization Form KD
For a Form f, this documentation uses the notation f(x) to mean
the bytes or string x converted to the given form.
A position n in x is called a boundary if conversion to the form can
proceed independently on both sides:
f(x) == append(f(x[0:n]), f(x[n:])...)
References: https://unicode.org/reports/tr15/ and
https://unicode.org/notes/tn5/.</p>
               
               <pre><code>type Form int</code></pre>
            </article>
            
            <article class="type" data-name="insertErr">
               <h3>
                  insertErr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>insertErr is an error code returned by insert. Using this type instead
of error improves performance up to 20% for many of the benchmarks.</p>
               
               <pre><code>type insertErr int</code></pre>
            </article>
            
            <article class="type" data-name="iterFunc">
               <h3>
                  iterFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type iterFunc func(*Iter) []byte</code></pre>
            </article>
            
            <article class="type" data-name="lookupFunc">
               <h3>
                  lookupFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>functions dispatchable per form</p>
               
               <pre><code>type lookupFunc func(b input, i int) Properties</code></pre>
            </article>
            
            <article class="type" data-name="qcInfo">
               <h3>
                  qcInfo
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>We pack quick check data in 4 bits:
5:    Combines forward  (0 == false, 1 == true)
4..3: NFC_QC Yes(00), No (10), or Maybe (11)
2:    NFD_QC Yes (0) or No (1). No also means there is a decomposition.
1..0: Number of trailing non-starters.
When all 4 bits are zero, the character is inert, meaning it is never
influenced by normalization.</p>
               
               <pre><code>type qcInfo uint8</code></pre>
            </article>
            
            <article class="type" data-name="ssState">
               <h3>
                  ssState
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ssState is used for reporting the segment state after inserting a rune.
It is returned by streamSafe.next.</p>
               
               <pre><code>type ssState int</code></pre>
            </article>
            
            <article class="type" data-name="streamSafe">
               <h3>
                  streamSafe
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>streamSafe implements the policy of when a CGJ should be inserted.</p>
               
               <pre><code>type streamSafe uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Iter">
               <h3>
                  Iter
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Iter iterates over a string or byte slice, while normalizing it
to a given Form.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Iter struct {
rb reorderBuffer
buf [maxByteBufferSize]byte
info Properties
next iterFunc
asciiF iterFunc
p int
multiSeg []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="Properties">
               <h3>
                  Properties
                  <span class="badge">struct</span>
               </h3>
               
               <p>Properties provides access to normalization properties of a rune.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Properties struct {
pos uint8
size uint8
ccc uint8
tccc uint8
nLead uint8
flags qcInfo
index uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="formInfo">
               <h3>
                  formInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>formInfo holds Form-specific functions and tables.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type formInfo struct {
form Form
composing bool
compatibility bool
info lookupFunc
nextMain iterFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="input">
               <h3>
                  input
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type input struct {
str string
bytes []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="nfcTrie">
               <h3>
                  nfcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfcTrie. Total size: 10442 bytes (10.20 KiB). Checksum: 4ba400a9d8208e03.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfcTrie">
               <h3>
                  nfcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfcTrie. Total size: 10332 bytes (10.09 KiB). Checksum: 51cc525b297fc970.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfcTrie">
               <h3>
                  nfcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfcTrie. Total size: 10798 bytes (10.54 KiB). Checksum: b5981cc85e3bd14.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfcTrie">
               <h3>
                  nfcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfcTrie. Total size: 10680 bytes (10.43 KiB). Checksum: a555db76d4becdd2.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfcTrie">
               <h3>
                  nfcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfcTrie. Total size: 10610 bytes (10.36 KiB). Checksum: 95e8869a9f81e5e6.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfcTrie">
               <h3>
                  nfcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfcTrie. Total size: 10586 bytes (10.34 KiB). Checksum: dd926e82067bee11.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfkcTrie">
               <h3>
                  nfkcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfkcTrie. Total size: 18768 bytes (18.33 KiB). Checksum: c51186dd2412943d.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfkcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfkcTrie">
               <h3>
                  nfkcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfkcTrie. Total size: 17104 bytes (16.70 KiB). Checksum: d985061cf5307b35.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfkcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfkcTrie">
               <h3>
                  nfkcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfkcTrie. Total size: 17248 bytes (16.84 KiB). Checksum: 4fb368372b6b1b27.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfkcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfkcTrie">
               <h3>
                  nfkcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfkcTrie. Total size: 18684 bytes (18.25 KiB). Checksum: 113e23c477adfabd.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfkcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfkcTrie">
               <h3>
                  nfkcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfkcTrie. Total size: 16994 bytes (16.60 KiB). Checksum: c3ed54ee046f3c46.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfkcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="nfkcTrie">
               <h3>
                  nfkcTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>nfkcTrie. Total size: 19260 bytes (18.81 KiB). Checksum: 1a0bbc4c8c24da49.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nfkcTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="normReader">
               <h3>
                  normReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type normReader struct {
rb reorderBuffer
r io.Reader
inbuf []byte
outbuf []byte
bufStart int
lastBoundary int
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="normWriter">
               <h3>
                  normWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type normWriter struct {
rb reorderBuffer
w io.Writer
buf []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="reorderBuffer">
               <h3>
                  reorderBuffer
                  <span class="badge">struct</span>
               </h3>
               
               <p>reorderBuffer is used to normalize a single segment.  Characters inserted with
insert are decomposed and reordered based on CCC. The compose method can
be used to recombine characters.  Note that the byte buffer does not hold
the UTF-8 characters in order.  Only the rune array is maintained in sorted
order. flush writes the resulting segment to a byte array.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reorderBuffer struct {
rune [maxBufferSize]Properties
byte [maxByteBufferSize]byte
nbyte uint8
ss streamSafe
nrune int
f formInfo
src input
nsrc int
tmpBytes input
out []byte
flushF func(*reorderBuffer) bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="sparseBlocks">
               <h3>
                  sparseBlocks
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sparseBlocks struct {
values []valueRange
offset []uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="valueRange">
               <h3>
                  valueRange
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type valueRange struct {
value uint16
lo byte
hi byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Append">
               <h3>
                  Append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Append returns f(append(out, b...)).
The buffer out must be nil, empty, or equal to f(out).</p>
               
               <pre><code>func (f Form) Append(out []byte, src ...byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="AppendString">
               <h3>
                  AppendString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendString returns f(append(out, []byte(s))).
The buffer out must be nil, empty, or equal to f(out).</p>
               
               <pre><code>func (f Form) AppendString(out []byte, src string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="BoundaryAfter">
               <h3>
                  BoundaryAfter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BoundaryAfter returns true if runes cannot combine with or otherwise
interact with this or previous runes.</p>
               
               <pre><code>func (p Properties) BoundaryAfter() bool</code></pre>
            </article>
            
            <article class="function" data-name="BoundaryBefore">
               <h3>
                  BoundaryBefore 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BoundaryBefore returns true if this rune starts a new segment and
cannot combine with any rune on the left.</p>
               
               <pre><code>func (p Properties) BoundaryBefore() bool</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns f(b). May return b if f(b) = b.</p>
               
               <pre><code>func (f Form) Bytes(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="CCC">
               <h3>
                  CCC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CCC returns the canonical combining class of the underlying rune.</p>
               
               <pre><code>func (p Properties) CCC() uint8</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close forces data that remains in the buffer to be written.</p>
               
               <pre><code>func (w *normWriter) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Decomposition">
               <h3>
                  Decomposition 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Decomposition returns the decomposition for the underlying rune
or nil if there is none.</p>
               
               <pre><code>func (p Properties) Decomposition() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Done returns true if there is no more input to process.</p>
               
               <pre><code>func (i *Iter) Done() bool</code></pre>
            </article>
            
            <article class="function" data-name="FirstBoundary">
               <h3>
                  FirstBoundary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FirstBoundary returns the position i of the first boundary in b
or -1 if b contains no boundary.</p>
               
               <pre><code>func (f Form) FirstBoundary(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="FirstBoundaryInString">
               <h3>
                  FirstBoundaryInString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FirstBoundaryInString returns the position i of the first boundary in s
or -1 if s contains no boundary.</p>
               
               <pre><code>func (f Form) FirstBoundaryInString(s string) int</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Init initializes i to iterate over src after normalizing it to Form f.</p>
               
               <pre><code>func (i *Iter) Init(f Form, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="InitString">
               <h3>
                  InitString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InitString initializes i to iterate over src after normalizing it to Form f.</p>
               
               <pre><code>func (i *Iter) InitString(f Form, src string)</code></pre>
            </article>
            
            <article class="function" data-name="IsNormal">
               <h3>
                  IsNormal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsNormal returns true if b == f(b).</p>
               
               <pre><code>func (f Form) IsNormal(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNormalString">
               <h3>
                  IsNormalString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsNormalString returns true if s == f(s).</p>
               
               <pre><code>func (f Form) IsNormalString(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="LastBoundary">
               <h3>
                  LastBoundary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LastBoundary returns the position i of the last boundary in b
or -1 if b contains no boundary.</p>
               
               <pre><code>func (f Form) LastBoundary(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="LeadCCC">
               <h3>
                  LeadCCC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LeadCCC returns the CCC of the first rune in the decomposition.
If there is no decomposition, LeadCCC equals CCC.</p>
               
               <pre><code>func (p Properties) LeadCCC() uint8</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next returns f(i.input[i.Pos():n]), where n is a boundary of i.input.
For any input a and b for which f(a) == f(b), subsequent calls
to Next will return the same segments.
Modifying runes are grouped together with the preceding starter, if such a starter exists.
Although not guaranteed, n will typically be the smallest possible n.</p>
               
               <pre><code>func (i *Iter) Next() []byte</code></pre>
            </article>
            
            <article class="function" data-name="NextBoundary">
               <h3>
                  NextBoundary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NextBoundary reports the index of the boundary between the first and next
segment in b or -1 if atEOF is false and there are not enough bytes to
determine this boundary.</p>
               
               <pre><code>func (f Form) NextBoundary(b []byte, atEOF bool) int</code></pre>
            </article>
            
            <article class="function" data-name="NextBoundaryInString">
               <h3>
                  NextBoundaryInString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NextBoundaryInString reports the index of the boundary between the first and
next segment in b or -1 if atEOF is false and there are not enough bytes to
determine this boundary.</p>
               
               <pre><code>func (f Form) NextBoundaryInString(s string, atEOF bool) int</code></pre>
            </article>
            
            <article class="function" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pos returns the byte position at which the next call to Next will commence processing.</p>
               
               <pre><code>func (i *Iter) Pos() int</code></pre>
            </article>
            
            <article class="function" data-name="Properties">
               <h3>
                  Properties 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Properties returns properties for the first rune in s.</p>
               
               <pre><code>func (f Form) Properties(s []byte) Properties</code></pre>
            </article>
            
            <article class="function" data-name="PropertiesString">
               <h3>
                  PropertiesString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PropertiesString returns properties for the first rune in s.</p>
               
               <pre><code>func (f Form) PropertiesString(s string) Properties</code></pre>
            </article>
            
            <article class="function" data-name="QuickSpan">
               <h3>
                  QuickSpan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QuickSpan returns a boundary n such that b[0:n] == f(b[0:n]).
It is not guaranteed to return the largest such n.</p>
               
               <pre><code>func (f Form) QuickSpan(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="QuickSpanString">
               <h3>
                  QuickSpanString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QuickSpanString returns a boundary n such that s[0:n] == f(s[0:n]).
It is not guaranteed to return the largest such n.</p>
               
               <pre><code>func (f Form) QuickSpanString(s string) int</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements the standard read interface.</p>
               
               <pre><code>func (r *normReader) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Reader">
               <h3>
                  Reader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reader returns a new reader that implements Read
by reading data from r and returning f(data).</p>
               
               <pre><code>func (f Form) Reader(r io.Reader) io.Reader</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset implements the Reset method of the transform.Transformer interface.</p>
               
               <pre><code>func (Form) Reset()</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seek sets the segment to be returned by the next call to Next to start
at position p.  It is the responsibility of the caller to set p to the
start of a segment.</p>
               
               <pre><code>func (i *Iter) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the length of UTF-8 encoding of the rune.</p>
               
               <pre><code>func (p Properties) Size() int</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Span implements transform.SpanningTransformer. It returns a boundary n such
that b[0:n] == f(b[0:n]). It is not guaranteed to return the largest such n.</p>
               
               <pre><code>func (f Form) Span(b []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="SpanString">
               <h3>
                  SpanString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SpanString returns a boundary n such that s[0:n] == f(s[0:n]).
It is not guaranteed to return the largest such n.</p>
               
               <pre><code>func (f Form) SpanString(s string, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns f(s).</p>
               
               <pre><code>func (f Form) String(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="TrailCCC">
               <h3>
                  TrailCCC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TrailCCC returns the CCC of the last rune in the decomposition.
If there is no decomposition, TrailCCC equals CCC.</p>
               
               <pre><code>func (p Properties) TrailCCC() uint8</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Transform implements the Transform method of the transform.Transformer
interface. It may need to write segments of up to MaxSegmentSize at once.
Users should either catch ErrShortDst and allow dst to grow or have dst be at
least of size MaxTransformChunkSize to be guaranteed of progress.</p>
               
               <pre><code>func (f Form) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements the standard write interface.  If the last characters are
not at a normalization boundary, the bytes will be buffered for the next
write. The remaining bytes will be written on close.</p>
               
               <pre><code>func (w *normWriter) Write(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Writer">
               <h3>
                  Writer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Writer returns a new writer that implements Write(b)
by writing f(b) to w. The returned writer may use an
internal buffer to maintain state across Write calls.
Calling its Close method writes any buffered data to w.</p>
               
               <pre><code>func (f Form) Writer(w io.Writer) io.WriteCloser</code></pre>
            </article>
            
            <article class="function" data-name="_byte">
               <h3>
                  _byte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) _byte(p int) byte</code></pre>
            </article>
            
            <article class="function" data-name="appendFlush">
               <h3>
                  appendFlush 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendFlush appends the normalized segment to rb.out.</p>
               
               <pre><code>func appendFlush(rb *reorderBuffer) bool</code></pre>
            </article>
            
            <article class="function" data-name="appendQuick">
               <h3>
                  appendQuick 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendQuick(rb *reorderBuffer, i int) int</code></pre>
            </article>
            
            <article class="function" data-name="appendRune">
               <h3>
                  appendRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>appendRune inserts a rune at the end of the buffer. It is used for Hangul.</p>
               
               <pre><code>func (rb *reorderBuffer) appendRune(r rune)</code></pre>
            </article>
            
            <article class="function" data-name="appendSlice">
               <h3>
                  appendSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) appendSlice(buf []byte, b int, e int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="assignRune">
               <h3>
                  assignRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignRune sets a rune at position pos. It is used for Hangul and recomposition.</p>
               
               <pre><code>func (rb *reorderBuffer) assignRune(pos int, r rune)</code></pre>
            </article>
            
            <article class="function" data-name="backwards">
               <h3>
                  backwards 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>backwards is used for checking for overflow and segment starts
when traversing a string backwards. Users do not need to call first
for the first rune. The state of the streamSafe retains the count of
the non-starters loaded.</p>
               
               <pre><code>func (ss *streamSafe) backwards(p Properties) ssState</code></pre>
            </article>
            
            <article class="function" data-name="buildRecompMap">
               <h3>
                  buildRecompMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func buildRecompMap()</code></pre>
            </article>
            
            <article class="function" data-name="bytesAt">
               <h3>
                  bytesAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bytesAt returns the UTF-8 encoding of the rune at position n.
It is used for Hangul and recomposition.</p>
               
               <pre><code>func (rb *reorderBuffer) bytesAt(n int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="charinfoNFC">
               <h3>
                  charinfoNFC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) charinfoNFC(p int) (uint16, int)</code></pre>
            </article>
            
            <article class="function" data-name="charinfoNFKC">
               <h3>
                  charinfoNFKC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) charinfoNFKC(p int) (uint16, int)</code></pre>
            </article>
            
            <article class="function" data-name="cmpNormalBytes">
               <h3>
                  cmpNormalBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cmpNormalBytes(rb *reorderBuffer) bool</code></pre>
            </article>
            
            <article class="function" data-name="combine">
               <h3>
                  combine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>combine returns the combined rune or 0 if it doesn't exist.
The caller is responsible for calling
recompMapOnce.Do(buildRecompMap) sometime before this is called.</p>
               
               <pre><code>func combine(a rune, b rune) rune</code></pre>
            </article>
            
            <article class="function" data-name="combineHangul">
               <h3>
                  combineHangul 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>combineHangul algorithmically combines Jamo character components into Hangul.
See https://unicode.org/reports/tr15/#Hangul for details on combining Hangul.</p>
               
               <pre><code>func (rb *reorderBuffer) combineHangul(s int, i int, k int)</code></pre>
            </article>
            
            <article class="function" data-name="combinesBackward">
               <h3>
                  combinesBackward 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) combinesBackward() bool</code></pre>
            </article>
            
            <article class="function" data-name="combinesForward">
               <h3>
                  combinesForward 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) combinesForward() bool</code></pre>
            </article>
            
            <article class="function" data-name="compInfo">
               <h3>
                  compInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>compInfo converts the information contained in v and sz
to a Properties.  See the comment at the top of the file
for more information on the format.</p>
               
               <pre><code>func compInfo(v uint16, sz int) Properties</code></pre>
            </article>
            
            <article class="function" data-name="compose">
               <h3>
                  compose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>compose recombines the runes in the buffer.
It should only be used to recompose a single segment, as it will not
handle alternations between Hangul and non-Hangul characters correctly.</p>
               
               <pre><code>func (rb *reorderBuffer) compose()</code></pre>
            </article>
            
            <article class="function" data-name="copySlice">
               <h3>
                  copySlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) copySlice(buf []byte, b int, e int) int</code></pre>
            </article>
            
            <article class="function" data-name="decomposeHangul">
               <h3>
                  decomposeHangul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decomposeHangul writes the decomposed Hangul to buf and returns the number
of bytes written.  len(buf) should be at least 9.</p>
               
               <pre><code>func decomposeHangul(buf []byte, r rune) int</code></pre>
            </article>
            
            <article class="function" data-name="decomposeHangul">
               <h3>
                  decomposeHangul 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>decomposeHangul algorithmically decomposes a Hangul rune into
its Jamo components.
See https://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul.</p>
               
               <pre><code>func (rb *reorderBuffer) decomposeHangul(r rune)</code></pre>
            </article>
            
            <article class="function" data-name="decomposeSegment">
               <h3>
                  decomposeSegment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decomposeSegment scans the first segment in src into rb. It inserts 0x034f
(Grapheme Joiner) when it encounters a sequence of more than 30 non-starters
and returns the number of bytes consumed from src or iShortDst or iShortSrc.</p>
               
               <pre><code>func decomposeSegment(rb *reorderBuffer, sp int, atEOF bool) int</code></pre>
            </article>
            
            <article class="function" data-name="decomposeToLastBoundary">
               <h3>
                  decomposeToLastBoundary 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decomposeToLastBoundary finds an open segment at the end of the buffer
and scans it into rb. Returns the buffer minus the last segment.</p>
               
               <pre><code>func decomposeToLastBoundary(rb *reorderBuffer)</code></pre>
            </article>
            
            <article class="function" data-name="doAppend">
               <h3>
                  doAppend 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doAppend(rb *reorderBuffer, out []byte, p int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="doAppend">
               <h3>
                  doAppend 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f Form) doAppend(out []byte, src input, n int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="doAppendInner">
               <h3>
                  doAppendInner 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doAppendInner(rb *reorderBuffer, p int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="doFlush">
               <h3>
                  doFlush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rb *reorderBuffer) doFlush() bool</code></pre>
            </article>
            
            <article class="function" data-name="doNormComposed">
               <h3>
                  doNormComposed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doNormComposed(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="doNormDecomposed">
               <h3>
                  doNormDecomposed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doNormDecomposed(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="first">
               <h3>
                  first 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>first inserts the first rune of a segment. It is a faster version of next if
it is known p represents the first rune in a segment.</p>
               
               <pre><code>func (ss *streamSafe) first(p Properties)</code></pre>
            </article>
            
            <article class="function" data-name="firstBoundary">
               <h3>
                  firstBoundary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f Form) firstBoundary(src input, nsrc int) int</code></pre>
            </article>
            
            <article class="function" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>flush appends the normalized segment to out and resets rb.</p>
               
               <pre><code>func (rb *reorderBuffer) flush(out []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="flushCopy">
               <h3>
                  flushCopy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>flushCopy copies the normalized segment to buf and resets rb.
It returns the number of bytes written to buf.</p>
               
               <pre><code>func (rb *reorderBuffer) flushCopy(buf []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="flushTransform">
               <h3>
                  flushTransform 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func flushTransform(rb *reorderBuffer) bool</code></pre>
            </article>
            
            <article class="function" data-name="hangul">
               <h3>
                  hangul 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) hangul(p int) (r rune)</code></pre>
            </article>
            
            <article class="function" data-name="hasDecomposition">
               <h3>
                  hasDecomposition 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) hasDecomposition() bool</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rb *reorderBuffer) init(f Form, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="initString">
               <h3>
                  initString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rb *reorderBuffer) initString(f Form, src string)</code></pre>
            </article>
            
            <article class="function" data-name="inputBytes">
               <h3>
                  inputBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func inputBytes(str []byte) input</code></pre>
            </article>
            
            <article class="function" data-name="inputString">
               <h3>
                  inputString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func inputString(str string) input</code></pre>
            </article>
            
            <article class="function" data-name="insertCGJ">
               <h3>
                  insertCGJ 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertCGJ inserts a Combining Grapheme Joiner (0x034f) into rb.</p>
               
               <pre><code>func (rb *reorderBuffer) insertCGJ()</code></pre>
            </article>
            
            <article class="function" data-name="insertDecomposed">
               <h3>
                  insertDecomposed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertDecomposed inserts an entry in to the reorderBuffer for each rune
in dcomp. dcomp must be a sequence of decomposed UTF-8-encoded runes.
It flushes the buffer on each new segment start.</p>
               
               <pre><code>func (rb *reorderBuffer) insertDecomposed(dcomp []byte) insertErr</code></pre>
            </article>
            
            <article class="function" data-name="insertFlush">
               <h3>
                  insertFlush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertFlush inserts the given rune in the buffer ordered by CCC.
If a decomposition with multiple segments are encountered, they leading
ones are flushed.
It returns a non-zero error code if the rune was not inserted.</p>
               
               <pre><code>func (rb *reorderBuffer) insertFlush(src input, i int, info Properties) insertErr</code></pre>
            </article>
            
            <article class="function" data-name="insertOrdered">
               <h3>
                  insertOrdered 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertOrdered inserts a rune in the buffer, ordered by Canonical Combining Class.
It returns false if the buffer is not large enough to hold the rune.
It is used internally by insert and insertString only.</p>
               
               <pre><code>func (rb *reorderBuffer) insertOrdered(info Properties)</code></pre>
            </article>
            
            <article class="function" data-name="insertSingle">
               <h3>
                  insertSingle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertSingle inserts an entry in the reorderBuffer for the rune at
position i. info is the runeInfo for the rune at position i.</p>
               
               <pre><code>func (rb *reorderBuffer) insertSingle(src input, i int, info Properties)</code></pre>
            </article>
            
            <article class="function" data-name="insertUnsafe">
               <h3>
                  insertUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertUnsafe inserts the given rune in the buffer ordered by CCC.
It is assumed there is sufficient space to hold the runes. It is the
responsibility of the caller to ensure this. This can be done by checking
the state returned by the streamSafe type.</p>
               
               <pre><code>func (rb *reorderBuffer) insertUnsafe(src input, i int, info Properties)</code></pre>
            </article>
            
            <article class="function" data-name="isHangul">
               <h3>
                  isHangul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isHangul(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isHangulString">
               <h3>
                  isHangulString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isHangulString(b string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isHangulWithoutJamoT">
               <h3>
                  isHangulWithoutJamoT 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isHangulWithoutJamoT(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isInert">
               <h3>
                  isInert 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) isInert() bool</code></pre>
            </article>
            
            <article class="function" data-name="isJamoVT">
               <h3>
                  isJamoVT 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Caller must ensure len(b) >= 2.</p>
               
               <pre><code>func isJamoVT(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isMax">
               <h3>
                  isMax 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ss streamSafe) isMax() bool</code></pre>
            </article>
            
            <article class="function" data-name="isYesC">
               <h3>
                  isYesC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) isYesC() bool</code></pre>
            </article>
            
            <article class="function" data-name="isYesD">
               <h3>
                  isYesD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) isYesD() bool</code></pre>
            </article>
            
            <article class="function" data-name="lastBoundary">
               <h3>
                  lastBoundary 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lastBoundary(fd *formInfo, b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="lastRuneStart">
               <h3>
                  lastRuneStart 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lastRuneStart returns the runeInfo and position of the last
rune in buf or the zero runeInfo and -1 if no rune was found.</p>
               
               <pre><code>func lastRuneStart(fd *formInfo, buf []byte) (Properties, int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup determines the type of block n and looks up the value for b.
For n < t.cutoff, the block is a simple lookup table. Otherwise, the block
is a list of ranges with an accompanying value. Given a matching range r,
the value for b is by r.value + (b - r.lo) * stride.</p>
               
               <pre><code>func (t *sparseBlocks) lookup(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupInfoNFC">
               <h3>
                  lookupInfoNFC 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupInfoNFC(b input, i int) Properties</code></pre>
            </article>
            
            <article class="function" data-name="lookupInfoNFKC">
               <h3>
                  lookupInfoNFKC 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupInfoNFKC(b input, i int) Properties</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfkcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *nfcTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfkcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *nfcTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfkcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfkcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfkcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfkcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfkcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfkcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *nfcTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="multiSegment">
               <h3>
                  multiSegment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) multiSegment() bool</code></pre>
            </article>
            
            <article class="function" data-name="nLeadingNonStarters">
               <h3>
                  nLeadingNonStarters 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) nLeadingNonStarters() uint8</code></pre>
            </article>
            
            <article class="function" data-name="nTrailingNonStarters">
               <h3>
                  nTrailingNonStarters 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Properties) nTrailingNonStarters() uint8</code></pre>
            </article>
            
            <article class="function" data-name="newNfcTrie">
               <h3>
                  newNfcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfcTrie">
               <h3>
                  newNfcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfcTrie">
               <h3>
                  newNfcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfcTrie">
               <h3>
                  newNfcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfcTrie">
               <h3>
                  newNfcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfcTrie">
               <h3>
                  newNfcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfkcTrie">
               <h3>
                  newNfkcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfkcTrie">
               <h3>
                  newNfkcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfkcTrie">
               <h3>
                  newNfkcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfkcTrie">
               <h3>
                  newNfkcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfkcTrie">
               <h3>
                  newNfkcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
            </article>
            
            <article class="function" data-name="newNfkcTrie">
               <h3>
                  newNfkcTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insert returns a ssState value to indicate whether a rune represented by p
can be inserted.</p>
               
               <pre><code>func (ss *streamSafe) next(p Properties) ssState</code></pre>
            </article>
            
            <article class="function" data-name="nextASCIIBytes">
               <h3>
                  nextASCIIBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextASCIIBytes(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextASCIIString">
               <h3>
                  nextASCIIString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextASCIIString(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextBoundary">
               <h3>
                  nextBoundary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f Form) nextBoundary(src input, nsrc int, atEOF bool) int</code></pre>
            </article>
            
            <article class="function" data-name="nextCGJCompose">
               <h3>
                  nextCGJCompose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextCGJCompose(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextCGJDecompose">
               <h3>
                  nextCGJDecompose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextCGJDecompose(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextComposed">
               <h3>
                  nextComposed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>nextComposed is the implementation of Next for forms NFC and NFKC.</p>
               
               <pre><code>func nextComposed(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextDecomposed">
               <h3>
                  nextDecomposed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>nextDecomposed is the implementation of Next for forms NFD and NFKD.</p>
               
               <pre><code>func nextDecomposed(i *Iter) (next []byte)</code></pre>
            </article>
            
            <article class="function" data-name="nextDone">
               <h3>
                  nextDone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextDone(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextHangul">
               <h3>
                  nextHangul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextHangul(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextMulti">
               <h3>
                  nextMulti 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>nextMulti is used for iterating over multi-segment decompositions
for decomposing normal forms.</p>
               
               <pre><code>func nextMulti(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nextMultiNorm">
               <h3>
                  nextMultiNorm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>nextMultiNorm is used for iterating over multi-segment decompositions
for composing normal forms.</p>
               
               <pre><code>func nextMultiNorm(i *Iter) []byte</code></pre>
            </article>
            
            <article class="function" data-name="patchTail">
               <h3>
                  patchTail 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>patchTail fixes a case where a rune may be incorrectly normalized
if it is followed by illegal continuation bytes. It returns the
patched buffer and whether the decomposition is still in progress.</p>
               
               <pre><code>func patchTail(rb *reorderBuffer) bool</code></pre>
            </article>
            
            <article class="function" data-name="quickSpan">
               <h3>
                  quickSpan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>quickSpan returns a boundary n such that src[0:n] == f(src[0:n]) and
whether any non-normalized parts were found. If atEOF is false, n will
not point past the last segment if this segment might be become
non-normalized by appending other runes.</p>
               
               <pre><code>func (f *formInfo) quickSpan(src input, i int, end int, atEOF bool) (n int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reset discards all characters from the buffer.</p>
               
               <pre><code>func (rb *reorderBuffer) reset()</code></pre>
            </article>
            
            <article class="function" data-name="returnSlice">
               <h3>
                  returnSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>returnSlice returns a slice of the underlying input type as a byte slice.
If the underlying is of type []byte, it will simply return a slice.
If the underlying is of type string, it will copy the slice to the buffer
and return that.</p>
               
               <pre><code>func (i *Iter) returnSlice(a int, b int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="runeAt">
               <h3>
                  runeAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>runeAt returns the rune at position n. It is used for Hangul and recomposition.</p>
               
               <pre><code>func (rb *reorderBuffer) runeAt(n int) rune</code></pre>
            </article>
            
            <article class="function" data-name="setBytes">
               <h3>
                  setBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) setBytes(str []byte)</code></pre>
            </article>
            
            <article class="function" data-name="setDone">
               <h3>
                  setDone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *Iter) setDone()</code></pre>
            </article>
            
            <article class="function" data-name="setFlusher">
               <h3>
                  setFlusher 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rb *reorderBuffer) setFlusher(out []byte, f func(*reorderBuffer) bool)</code></pre>
            </article>
            
            <article class="function" data-name="setString">
               <h3>
                  setString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) setString(str string)</code></pre>
            </article>
            
            <article class="function" data-name="skipASCII">
               <h3>
                  skipASCII 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) skipASCII(p int, max int) int</code></pre>
            </article>
            
            <article class="function" data-name="skipContinuationBytes">
               <h3>
                  skipContinuationBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) skipContinuationBytes(p int) int</code></pre>
            </article>
            
            <article class="function" data-name="transform">
               <h3>
                  transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>transform implements the transform.Transformer interface. It is only called
when quickSpan does not pass for a given string.</p>
               
               <pre><code>func (f Form) transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
