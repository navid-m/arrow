<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - norm</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>norm</code>
         </h1>
         <hr />
         
         <article class="global" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version is the Unicode edition from which the tables are derived.</p>
            
            <pre><code>Version</code></pre>
         </article>
         
         <article class="global" data-name="MaxTransformChunkSize">
            <h2>MaxTransformChunkSize</h2>
            <hr />
            
            <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
            
            <pre><code>MaxTransformChunkSize</code></pre>
         </article>
         
         <article class="global" data-name="ccc">
            <h2>ccc</h2>
            <hr />
            
            <pre><code>ccc</code></pre>
         </article>
         
         <article class="global" data-name="firstMulti">
            <h2>firstMulti</h2>
            <hr />
            
            <pre><code>firstMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstCCC">
            <h2>firstCCC</h2>
            <hr />
            
            <pre><code>firstCCC</code></pre>
         </article>
         
         <article class="global" data-name="endMulti">
            <h2>endMulti</h2>
            <hr />
            
            <pre><code>endMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstLeadingCCC">
            <h2>firstLeadingCCC</h2>
            <hr />
            
            <pre><code>firstLeadingCCC</code></pre>
         </article>
         
         <article class="global" data-name="firstCCCZeroExcept">
            <h2>firstCCCZeroExcept</h2>
            <hr />
            
            <pre><code>firstCCCZeroExcept</code></pre>
         </article>
         
         <article class="global" data-name="firstStarterWithNLead">
            <h2>firstStarterWithNLead</h2>
            <hr />
            
            <pre><code>firstStarterWithNLead</code></pre>
         </article>
         
         <article class="global" data-name="lastDecomp">
            <h2>lastDecomp</h2>
            <hr />
            
            <pre><code>lastDecomp</code></pre>
         </article>
         
         <article class="global" data-name="maxDecomp">
            <h2>maxDecomp</h2>
            <hr />
            
            <pre><code>maxDecomp</code></pre>
         </article>
         
         <article class="global" data-name="decomps">
            <h2>decomps</h2>
            <hr />
            
            <p>decomps: 19105 bytes</p>
            
            <pre><code>decomps</code></pre>
         </article>
         
         <article class="global" data-name="nfcValues">
            <h2>nfcValues</h2>
            <hr />
            
            <p>nfcValues: 47 blocks, 3008 entries, 6016 bytes
The third block is the zero block.</p>
            
            <pre><code>nfcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfcIndex">
            <h2>nfcIndex</h2>
            <hr />
            
            <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseOffset">
            <h2>nfcSparseOffset</h2>
            <hr />
            
            <p>nfcSparseOffset: 145 entries, 290 bytes</p>
            
            <pre><code>nfcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseValues">
            <h2>nfcSparseValues</h2>
            <hr />
            
            <p>nfcSparseValues: 682 entries, 2728 bytes</p>
            
            <pre><code>nfcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcValues">
            <h2>nfkcValues</h2>
            <hr />
            
            <p>nfkcValues: 93 blocks, 5952 entries, 11904 bytes
The third block is the zero block.</p>
            
            <pre><code>nfkcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcIndex">
            <h2>nfkcIndex</h2>
            <hr />
            
            <p>nfkcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfkcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseOffset">
            <h2>nfkcSparseOffset</h2>
            <hr />
            
            <p>nfkcSparseOffset: 158 entries, 316 bytes</p>
            
            <pre><code>nfkcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseValues">
            <h2>nfkcSparseValues</h2>
            <hr />
            
            <p>nfkcSparseValues: 869 entries, 3476 bytes</p>
            
            <pre><code>nfkcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="recompMap">
            <h2>recompMap</h2>
            <hr />
            
            <p>recompMap: 7520 bytes (entries only)</p>
            
            <pre><code>recompMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="recompMapOnce">
            <h2>recompMapOnce</h2>
            <hr />
            
            <pre><code>recompMapOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="recompMapPacked">
            <h2>recompMapPacked</h2>
            <hr />
            
            <pre><code>recompMapPacked</code></pre>
         </article>
         
         <article class="global" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version is the Unicode edition from which the tables are derived.</p>
            
            <pre><code>Version</code></pre>
         </article>
         
         <article class="global" data-name="MaxTransformChunkSize">
            <h2>MaxTransformChunkSize</h2>
            <hr />
            
            <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
            
            <pre><code>MaxTransformChunkSize</code></pre>
         </article>
         
         <article class="global" data-name="ccc">
            <h2>ccc</h2>
            <hr />
            
            <pre><code>ccc</code></pre>
         </article>
         
         <article class="global" data-name="firstMulti">
            <h2>firstMulti</h2>
            <hr />
            
            <pre><code>firstMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstCCC">
            <h2>firstCCC</h2>
            <hr />
            
            <pre><code>firstCCC</code></pre>
         </article>
         
         <article class="global" data-name="endMulti">
            <h2>endMulti</h2>
            <hr />
            
            <pre><code>endMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstLeadingCCC">
            <h2>firstLeadingCCC</h2>
            <hr />
            
            <pre><code>firstLeadingCCC</code></pre>
         </article>
         
         <article class="global" data-name="firstCCCZeroExcept">
            <h2>firstCCCZeroExcept</h2>
            <hr />
            
            <pre><code>firstCCCZeroExcept</code></pre>
         </article>
         
         <article class="global" data-name="firstStarterWithNLead">
            <h2>firstStarterWithNLead</h2>
            <hr />
            
            <pre><code>firstStarterWithNLead</code></pre>
         </article>
         
         <article class="global" data-name="lastDecomp">
            <h2>lastDecomp</h2>
            <hr />
            
            <pre><code>lastDecomp</code></pre>
         </article>
         
         <article class="global" data-name="maxDecomp">
            <h2>maxDecomp</h2>
            <hr />
            
            <pre><code>maxDecomp</code></pre>
         </article>
         
         <article class="global" data-name="decomps">
            <h2>decomps</h2>
            <hr />
            
            <p>decomps: 19128 bytes</p>
            
            <pre><code>decomps</code></pre>
         </article>
         
         <article class="global" data-name="nfcValues">
            <h2>nfcValues</h2>
            <hr />
            
            <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
            
            <pre><code>nfcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfcIndex">
            <h2>nfcIndex</h2>
            <hr />
            
            <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseOffset">
            <h2>nfcSparseOffset</h2>
            <hr />
            
            <p>nfcSparseOffset: 156 entries, 312 bytes</p>
            
            <pre><code>nfcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseValues">
            <h2>nfcSparseValues</h2>
            <hr />
            
            <p>nfcSparseValues: 704 entries, 2816 bytes</p>
            
            <pre><code>nfcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcValues">
            <h2>nfkcValues</h2>
            <hr />
            
            <p>nfkcValues: 94 blocks, 6016 entries, 12032 bytes
The third block is the zero block.</p>
            
            <pre><code>nfkcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcIndex">
            <h2>nfkcIndex</h2>
            <hr />
            
            <p>nfkcIndex: 22 blocks, 1408 entries, 2816 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfkcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseOffset">
            <h2>nfkcSparseOffset</h2>
            <hr />
            
            <p>nfkcSparseOffset: 170 entries, 340 bytes</p>
            
            <pre><code>nfkcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseValues">
            <h2>nfkcSparseValues</h2>
            <hr />
            
            <p>nfkcSparseValues: 895 entries, 3580 bytes</p>
            
            <pre><code>nfkcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="recompMap">
            <h2>recompMap</h2>
            <hr />
            
            <p>recompMap: 7528 bytes (entries only)</p>
            
            <pre><code>recompMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="recompMapOnce">
            <h2>recompMapOnce</h2>
            <hr />
            
            <pre><code>recompMapOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="recompMapPacked">
            <h2>recompMapPacked</h2>
            <hr />
            
            <pre><code>recompMapPacked</code></pre>
         </article>
         
         <article class="global" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version is the Unicode edition from which the tables are derived.</p>
            
            <pre><code>Version</code></pre>
         </article>
         
         <article class="global" data-name="MaxTransformChunkSize">
            <h2>MaxTransformChunkSize</h2>
            <hr />
            
            <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
            
            <pre><code>MaxTransformChunkSize</code></pre>
         </article>
         
         <article class="global" data-name="ccc">
            <h2>ccc</h2>
            <hr />
            
            <pre><code>ccc</code></pre>
         </article>
         
         <article class="global" data-name="firstMulti">
            <h2>firstMulti</h2>
            <hr />
            
            <pre><code>firstMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstCCC">
            <h2>firstCCC</h2>
            <hr />
            
            <pre><code>firstCCC</code></pre>
         </article>
         
         <article class="global" data-name="endMulti">
            <h2>endMulti</h2>
            <hr />
            
            <pre><code>endMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstLeadingCCC">
            <h2>firstLeadingCCC</h2>
            <hr />
            
            <pre><code>firstLeadingCCC</code></pre>
         </article>
         
         <article class="global" data-name="firstCCCZeroExcept">
            <h2>firstCCCZeroExcept</h2>
            <hr />
            
            <pre><code>firstCCCZeroExcept</code></pre>
         </article>
         
         <article class="global" data-name="firstStarterWithNLead">
            <h2>firstStarterWithNLead</h2>
            <hr />
            
            <pre><code>firstStarterWithNLead</code></pre>
         </article>
         
         <article class="global" data-name="lastDecomp">
            <h2>lastDecomp</h2>
            <hr />
            
            <pre><code>lastDecomp</code></pre>
         </article>
         
         <article class="global" data-name="maxDecomp">
            <h2>maxDecomp</h2>
            <hr />
            
            <pre><code>maxDecomp</code></pre>
         </article>
         
         <article class="global" data-name="decomps">
            <h2>decomps</h2>
            <hr />
            
            <p>decomps: 19105 bytes</p>
            
            <pre><code>decomps</code></pre>
         </article>
         
         <article class="global" data-name="nfcValues">
            <h2>nfcValues</h2>
            <hr />
            
            <p>nfcValues: 46 blocks, 2944 entries, 5888 bytes
The third block is the zero block.</p>
            
            <pre><code>nfcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfcIndex">
            <h2>nfcIndex</h2>
            <hr />
            
            <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseOffset">
            <h2>nfcSparseOffset</h2>
            <hr />
            
            <p>nfcSparseOffset: 142 entries, 284 bytes</p>
            
            <pre><code>nfcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseValues">
            <h2>nfcSparseValues</h2>
            <hr />
            
            <p>nfcSparseValues: 688 entries, 2752 bytes</p>
            
            <pre><code>nfcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcValues">
            <h2>nfkcValues</h2>
            <hr />
            
            <p>nfkcValues: 92 blocks, 5888 entries, 11776 bytes
The third block is the zero block.</p>
            
            <pre><code>nfkcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcIndex">
            <h2>nfkcIndex</h2>
            <hr />
            
            <p>nfkcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfkcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseOffset">
            <h2>nfkcSparseOffset</h2>
            <hr />
            
            <p>nfkcSparseOffset: 155 entries, 310 bytes</p>
            
            <pre><code>nfkcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseValues">
            <h2>nfkcSparseValues</h2>
            <hr />
            
            <p>nfkcSparseValues: 875 entries, 3500 bytes</p>
            
            <pre><code>nfkcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="recompMap">
            <h2>recompMap</h2>
            <hr />
            
            <p>recompMap: 7520 bytes (entries only)</p>
            
            <pre><code>recompMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="recompMapOnce">
            <h2>recompMapOnce</h2>
            <hr />
            
            <pre><code>recompMapOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="recompMapPacked">
            <h2>recompMapPacked</h2>
            <hr />
            
            <pre><code>recompMapPacked</code></pre>
         </article>
         
         <article class="global" data-name="errs">
            <h2>errs</h2>
            <hr />
            
            <pre><code>errs</code></pre>
         </article>
         
         <article class="global" data-name="NFC">
            <h2>NFC</h2>
            <hr />
            
            <pre><code>NFC Form</code></pre>
         </article>
         
         <article class="global" data-name="NFD">
            <h2>NFD</h2>
            <hr />
            
            <pre><code>NFD</code></pre>
         </article>
         
         <article class="global" data-name="NFKC">
            <h2>NFKC</h2>
            <hr />
            
            <pre><code>NFKC</code></pre>
         </article>
         
         <article class="global" data-name="NFKD">
            <h2>NFKD</h2>
            <hr />
            
            <pre><code>NFKD</code></pre>
         </article>
         
         <article class="global" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version is the Unicode edition from which the tables are derived.</p>
            
            <pre><code>Version</code></pre>
         </article>
         
         <article class="global" data-name="MaxTransformChunkSize">
            <h2>MaxTransformChunkSize</h2>
            <hr />
            
            <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
            
            <pre><code>MaxTransformChunkSize</code></pre>
         </article>
         
         <article class="global" data-name="ccc">
            <h2>ccc</h2>
            <hr />
            
            <pre><code>ccc</code></pre>
         </article>
         
         <article class="global" data-name="firstMulti">
            <h2>firstMulti</h2>
            <hr />
            
            <pre><code>firstMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstCCC">
            <h2>firstCCC</h2>
            <hr />
            
            <pre><code>firstCCC</code></pre>
         </article>
         
         <article class="global" data-name="endMulti">
            <h2>endMulti</h2>
            <hr />
            
            <pre><code>endMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstLeadingCCC">
            <h2>firstLeadingCCC</h2>
            <hr />
            
            <pre><code>firstLeadingCCC</code></pre>
         </article>
         
         <article class="global" data-name="firstCCCZeroExcept">
            <h2>firstCCCZeroExcept</h2>
            <hr />
            
            <pre><code>firstCCCZeroExcept</code></pre>
         </article>
         
         <article class="global" data-name="firstStarterWithNLead">
            <h2>firstStarterWithNLead</h2>
            <hr />
            
            <pre><code>firstStarterWithNLead</code></pre>
         </article>
         
         <article class="global" data-name="lastDecomp">
            <h2>lastDecomp</h2>
            <hr />
            
            <pre><code>lastDecomp</code></pre>
         </article>
         
         <article class="global" data-name="maxDecomp">
            <h2>maxDecomp</h2>
            <hr />
            
            <pre><code>maxDecomp</code></pre>
         </article>
         
         <article class="global" data-name="decomps">
            <h2>decomps</h2>
            <hr />
            
            <p>decomps: 19105 bytes</p>
            
            <pre><code>decomps</code></pre>
         </article>
         
         <article class="global" data-name="nfcValues">
            <h2>nfcValues</h2>
            <hr />
            
            <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
            
            <pre><code>nfcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfcIndex">
            <h2>nfcIndex</h2>
            <hr />
            
            <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseOffset">
            <h2>nfcSparseOffset</h2>
            <hr />
            
            <p>nfcSparseOffset: 149 entries, 298 bytes</p>
            
            <pre><code>nfcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseValues">
            <h2>nfcSparseValues</h2>
            <hr />
            
            <p>nfcSparseValues: 684 entries, 2736 bytes</p>
            
            <pre><code>nfcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcValues">
            <h2>nfkcValues</h2>
            <hr />
            
            <p>nfkcValues: 94 blocks, 6016 entries, 12032 bytes
The third block is the zero block.</p>
            
            <pre><code>nfkcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcIndex">
            <h2>nfkcIndex</h2>
            <hr />
            
            <p>nfkcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfkcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseOffset">
            <h2>nfkcSparseOffset</h2>
            <hr />
            
            <p>nfkcSparseOffset: 162 entries, 324 bytes</p>
            
            <pre><code>nfkcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseValues">
            <h2>nfkcSparseValues</h2>
            <hr />
            
            <p>nfkcSparseValues: 871 entries, 3484 bytes</p>
            
            <pre><code>nfkcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="recompMap">
            <h2>recompMap</h2>
            <hr />
            
            <p>recompMap: 7520 bytes (entries only)</p>
            
            <pre><code>recompMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="recompMapOnce">
            <h2>recompMapOnce</h2>
            <hr />
            
            <pre><code>recompMapOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="recompMapPacked">
            <h2>recompMapPacked</h2>
            <hr />
            
            <pre><code>recompMapPacked</code></pre>
         </article>
         
         <article class="global" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version is the Unicode edition from which the tables are derived.</p>
            
            <pre><code>Version</code></pre>
         </article>
         
         <article class="global" data-name="MaxTransformChunkSize">
            <h2>MaxTransformChunkSize</h2>
            <hr />
            
            <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
            
            <pre><code>MaxTransformChunkSize</code></pre>
         </article>
         
         <article class="global" data-name="ccc">
            <h2>ccc</h2>
            <hr />
            
            <pre><code>ccc</code></pre>
         </article>
         
         <article class="global" data-name="firstMulti">
            <h2>firstMulti</h2>
            <hr />
            
            <pre><code>firstMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstCCC">
            <h2>firstCCC</h2>
            <hr />
            
            <pre><code>firstCCC</code></pre>
         </article>
         
         <article class="global" data-name="endMulti">
            <h2>endMulti</h2>
            <hr />
            
            <pre><code>endMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstLeadingCCC">
            <h2>firstLeadingCCC</h2>
            <hr />
            
            <pre><code>firstLeadingCCC</code></pre>
         </article>
         
         <article class="global" data-name="firstCCCZeroExcept">
            <h2>firstCCCZeroExcept</h2>
            <hr />
            
            <pre><code>firstCCCZeroExcept</code></pre>
         </article>
         
         <article class="global" data-name="firstStarterWithNLead">
            <h2>firstStarterWithNLead</h2>
            <hr />
            
            <pre><code>firstStarterWithNLead</code></pre>
         </article>
         
         <article class="global" data-name="lastDecomp">
            <h2>lastDecomp</h2>
            <hr />
            
            <pre><code>lastDecomp</code></pre>
         </article>
         
         <article class="global" data-name="maxDecomp">
            <h2>maxDecomp</h2>
            <hr />
            
            <pre><code>maxDecomp</code></pre>
         </article>
         
         <article class="global" data-name="decomps">
            <h2>decomps</h2>
            <hr />
            
            <p>decomps: 19108 bytes</p>
            
            <pre><code>decomps</code></pre>
         </article>
         
         <article class="global" data-name="nfcValues">
            <h2>nfcValues</h2>
            <hr />
            
            <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
            
            <pre><code>nfcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfcIndex">
            <h2>nfcIndex</h2>
            <hr />
            
            <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseOffset">
            <h2>nfcSparseOffset</h2>
            <hr />
            
            <p>nfcSparseOffset: 151 entries, 302 bytes</p>
            
            <pre><code>nfcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseValues">
            <h2>nfcSparseValues</h2>
            <hr />
            
            <p>nfcSparseValues: 689 entries, 2756 bytes</p>
            
            <pre><code>nfcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcValues">
            <h2>nfkcValues</h2>
            <hr />
            
            <p>nfkcValues: 94 blocks, 6016 entries, 12032 bytes
The third block is the zero block.</p>
            
            <pre><code>nfkcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcIndex">
            <h2>nfkcIndex</h2>
            <hr />
            
            <p>nfkcIndex: 22 blocks, 1408 entries, 2816 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfkcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseOffset">
            <h2>nfkcSparseOffset</h2>
            <hr />
            
            <p>nfkcSparseOffset: 164 entries, 328 bytes</p>
            
            <pre><code>nfkcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseValues">
            <h2>nfkcSparseValues</h2>
            <hr />
            
            <p>nfkcSparseValues: 877 entries, 3508 bytes</p>
            
            <pre><code>nfkcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="recompMap">
            <h2>recompMap</h2>
            <hr />
            
            <p>recompMap: 7520 bytes (entries only)</p>
            
            <pre><code>recompMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="recompMapOnce">
            <h2>recompMapOnce</h2>
            <hr />
            
            <pre><code>recompMapOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="recompMapPacked">
            <h2>recompMapPacked</h2>
            <hr />
            
            <pre><code>recompMapPacked</code></pre>
         </article>
         
         <article class="global" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version is the Unicode edition from which the tables are derived.</p>
            
            <pre><code>Version</code></pre>
         </article>
         
         <article class="global" data-name="MaxTransformChunkSize">
            <h2>MaxTransformChunkSize</h2>
            <hr />
            
            <p>MaxTransformChunkSize indicates the maximum number of bytes that Transform
may need to write atomically for any Form. Making a destination buffer at
least this size ensures that Transform can always make progress and that
the user does not need to grow the buffer on an ErrShortDst.</p>
            
            <pre><code>MaxTransformChunkSize</code></pre>
         </article>
         
         <article class="global" data-name="ccc">
            <h2>ccc</h2>
            <hr />
            
            <pre><code>ccc</code></pre>
         </article>
         
         <article class="global" data-name="firstMulti">
            <h2>firstMulti</h2>
            <hr />
            
            <pre><code>firstMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstCCC">
            <h2>firstCCC</h2>
            <hr />
            
            <pre><code>firstCCC</code></pre>
         </article>
         
         <article class="global" data-name="endMulti">
            <h2>endMulti</h2>
            <hr />
            
            <pre><code>endMulti</code></pre>
         </article>
         
         <article class="global" data-name="firstLeadingCCC">
            <h2>firstLeadingCCC</h2>
            <hr />
            
            <pre><code>firstLeadingCCC</code></pre>
         </article>
         
         <article class="global" data-name="firstCCCZeroExcept">
            <h2>firstCCCZeroExcept</h2>
            <hr />
            
            <pre><code>firstCCCZeroExcept</code></pre>
         </article>
         
         <article class="global" data-name="firstStarterWithNLead">
            <h2>firstStarterWithNLead</h2>
            <hr />
            
            <pre><code>firstStarterWithNLead</code></pre>
         </article>
         
         <article class="global" data-name="lastDecomp">
            <h2>lastDecomp</h2>
            <hr />
            
            <pre><code>lastDecomp</code></pre>
         </article>
         
         <article class="global" data-name="maxDecomp">
            <h2>maxDecomp</h2>
            <hr />
            
            <pre><code>maxDecomp</code></pre>
         </article>
         
         <article class="global" data-name="decomps">
            <h2>decomps</h2>
            <hr />
            
            <p>decomps: 19426 bytes</p>
            
            <pre><code>decomps</code></pre>
         </article>
         
         <article class="global" data-name="nfcValues">
            <h2>nfcValues</h2>
            <hr />
            
            <p>nfcValues: 48 blocks, 3072 entries, 6144 bytes
The third block is the zero block.</p>
            
            <pre><code>nfcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfcIndex">
            <h2>nfcIndex</h2>
            <hr />
            
            <p>nfcIndex: 22 blocks, 1408 entries, 1408 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseOffset">
            <h2>nfcSparseOffset</h2>
            <hr />
            
            <p>nfcSparseOffset: 163 entries, 326 bytes</p>
            
            <pre><code>nfcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparseValues">
            <h2>nfcSparseValues</h2>
            <hr />
            
            <p>nfcSparseValues: 730 entries, 2920 bytes</p>
            
            <pre><code>nfcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcValues">
            <h2>nfkcValues</h2>
            <hr />
            
            <p>nfkcValues: 97 blocks, 6208 entries, 12416 bytes
The third block is the zero block.</p>
            
            <pre><code>nfkcValues</code></pre>
         </article>
         
         <article class="global" data-name="nfkcIndex">
            <h2>nfkcIndex</h2>
            <hr />
            
            <p>nfkcIndex: 22 blocks, 1408 entries, 2816 bytes
Block 0 is the zero block.</p>
            
            <pre><code>nfkcIndex</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseOffset">
            <h2>nfkcSparseOffset</h2>
            <hr />
            
            <p>nfkcSparseOffset: 176 entries, 352 bytes</p>
            
            <pre><code>nfkcSparseOffset</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparseValues">
            <h2>nfkcSparseValues</h2>
            <hr />
            
            <p>nfkcSparseValues: 919 entries, 3676 bytes</p>
            
            <pre><code>nfkcSparseValues</code></pre>
         </article>
         
         <article class="global" data-name="recompMap">
            <h2>recompMap</h2>
            <hr />
            
            <p>recompMap: 7528 bytes (entries only)</p>
            
            <pre><code>recompMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="recompMapOnce">
            <h2>recompMapOnce</h2>
            <hr />
            
            <pre><code>recompMapOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="recompMapPacked">
            <h2>recompMapPacked</h2>
            <hr />
            
            <pre><code>recompMapPacked</code></pre>
         </article>
         
         <article class="global" data-name="nfcSparse">
            <h2>nfcSparse</h2>
            <hr />
            
            <pre><code>nfcSparse</code></pre>
         </article>
         
         <article class="global" data-name="nfkcSparse">
            <h2>nfkcSparse</h2>
            <hr />
            
            <pre><code>nfkcSparse</code></pre>
         </article>
         
         <article class="global" data-name="nfcData">
            <h2>nfcData</h2>
            <hr />
            
            <pre><code>nfcData</code></pre>
         </article>
         
         <article class="global" data-name="nfkcData">
            <h2>nfkcData</h2>
            <hr />
            
            <pre><code>nfkcData</code></pre>
         </article>
         
         <article class="global" data-name="maxNonStarters">
            <h2>maxNonStarters</h2>
            <hr />
            
            <pre><code>maxNonStarters</code></pre>
         </article>
         
         <article class="global" data-name="maxBufferSize">
            <h2>maxBufferSize</h2>
            <hr />
            
            <p>The maximum number of characters needed for a buffer is
maxNonStarters + 1 for the starter + 1 for the GCJ</p>
            
            <pre><code>maxBufferSize</code></pre>
         </article>
         
         <article class="global" data-name="maxNFCExpansion">
            <h2>maxNFCExpansion</h2>
            <hr />
            
            <pre><code>maxNFCExpansion</code></pre>
         </article>
         
         <article class="global" data-name="maxNFKCExpansion">
            <h2>maxNFKCExpansion</h2>
            <hr />
            
            <pre><code>maxNFKCExpansion</code></pre>
         </article>
         
         <article class="global" data-name="maxByteBufferSize">
            <h2>maxByteBufferSize</h2>
            <hr />
            
            <pre><code>maxByteBufferSize</code></pre>
         </article>
         
         <article class="global" data-name="ssSuccess">
            <h2>ssSuccess</h2>
            <hr />
            
            <p>Indicates a rune was successfully added to the segment.</p>
            
            <pre><code>ssSuccess ssState</code></pre>
         </article>
         
         <article class="global" data-name="ssStarter">
            <h2>ssStarter</h2>
            <hr />
            
            <p>Indicates a rune starts a new segment and should not be added.</p>
            
            <pre><code>ssStarter</code></pre>
         </article>
         
         <article class="global" data-name="ssOverflow">
            <h2>ssOverflow</h2>
            <hr />
            
            <p>Indicates a rune caused a segment overflow and a CGJ should be inserted.</p>
            
            <pre><code>ssOverflow</code></pre>
         </article>
         
         <article class="global" data-name="GraphemeJoiner">
            <h2>GraphemeJoiner</h2>
            <hr />
            
            <p>GraphemeJoiner is inserted after maxNonStarters non-starter runes.</p>
            
            <pre><code>GraphemeJoiner</code></pre>
         </article>
         
         <article class="global" data-name="iSuccess">
            <h2>iSuccess</h2>
            <hr />
            
            <pre><code>iSuccess insertErr</code></pre>
         </article>
         
         <article class="global" data-name="iShortDst">
            <h2>iShortDst</h2>
            <hr />
            
            <pre><code>iShortDst</code></pre>
         </article>
         
         <article class="global" data-name="iShortSrc">
            <h2>iShortSrc</h2>
            <hr />
            
            <pre><code>iShortSrc</code></pre>
         </article>
         
         <article class="global" data-name="hangulBase">
            <h2>hangulBase</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulBase</code></pre>
         </article>
         
         <article class="global" data-name="hangulBase0">
            <h2>hangulBase0</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulBase0</code></pre>
         </article>
         
         <article class="global" data-name="hangulBase1">
            <h2>hangulBase1</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulBase1</code></pre>
         </article>
         
         <article class="global" data-name="hangulBase2">
            <h2>hangulBase2</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulBase2</code></pre>
         </article>
         
         <article class="global" data-name="hangulEnd">
            <h2>hangulEnd</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulEnd</code></pre>
         </article>
         
         <article class="global" data-name="hangulEnd0">
            <h2>hangulEnd0</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulEnd0</code></pre>
         </article>
         
         <article class="global" data-name="hangulEnd1">
            <h2>hangulEnd1</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulEnd1</code></pre>
         </article>
         
         <article class="global" data-name="hangulEnd2">
            <h2>hangulEnd2</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>hangulEnd2</code></pre>
         </article>
         
         <article class="global" data-name="jamoLBase">
            <h2>jamoLBase</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoLBase</code></pre>
         </article>
         
         <article class="global" data-name="jamoLBase0">
            <h2>jamoLBase0</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoLBase0</code></pre>
         </article>
         
         <article class="global" data-name="jamoLBase1">
            <h2>jamoLBase1</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoLBase1</code></pre>
         </article>
         
         <article class="global" data-name="jamoLEnd">
            <h2>jamoLEnd</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoLEnd</code></pre>
         </article>
         
         <article class="global" data-name="jamoVBase">
            <h2>jamoVBase</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoVBase</code></pre>
         </article>
         
         <article class="global" data-name="jamoVEnd">
            <h2>jamoVEnd</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoVEnd</code></pre>
         </article>
         
         <article class="global" data-name="jamoTBase">
            <h2>jamoTBase</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoTBase</code></pre>
         </article>
         
         <article class="global" data-name="jamoTEnd">
            <h2>jamoTEnd</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoTEnd</code></pre>
         </article>
         
         <article class="global" data-name="jamoTCount">
            <h2>jamoTCount</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoTCount</code></pre>
         </article>
         
         <article class="global" data-name="jamoVCount">
            <h2>jamoVCount</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoVCount</code></pre>
         </article>
         
         <article class="global" data-name="jamoVTCount">
            <h2>jamoVTCount</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoVTCount</code></pre>
         </article>
         
         <article class="global" data-name="jamoLVTCount">
            <h2>jamoLVTCount</h2>
            <hr />
            
            <p>For Hangul we combine algorithmically, instead of using tables.</p>
            
            <pre><code>jamoLVTCount</code></pre>
         </article>
         
         <article class="global" data-name="hangulUTF8Size">
            <h2>hangulUTF8Size</h2>
            <hr />
            
            <pre><code>hangulUTF8Size</code></pre>
         </article>
         
         <article class="global" data-name="qcInfoMask">
            <h2>qcInfoMask</h2>
            <hr />
            
            <pre><code>qcInfoMask</code></pre>
         </article>
         
         <article class="global" data-name="headerLenMask">
            <h2>headerLenMask</h2>
            <hr />
            
            <pre><code>headerLenMask</code></pre>
         </article>
         
         <article class="global" data-name="headerFlagsMask">
            <h2>headerFlagsMask</h2>
            <hr />
            
            <pre><code>headerFlagsMask</code></pre>
         </article>
         
         <article class="global" data-name="formTable">
            <h2>formTable</h2>
            <hr />
            
            <pre><code>formTable</code></pre>
         </article>
         
         <article class="global" data-name="MaxSegmentSize">
            <h2>MaxSegmentSize</h2>
            <hr />
            
            <p>MaxSegmentSize is the maximum size of a byte buffer needed to consider any
sequence of starter and non-starter runes for the purpose of normalization.</p>
            
            <pre><code>MaxSegmentSize</code></pre>
         </article>
          
         <article class="struct" data-name="normWriter">
            <h2>type normWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rb reorderBuffer
w io.Writer
buf []byte</code></pre>
         </article>
         
         <article class="struct" data-name="normReader">
            <h2>type normReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rb reorderBuffer
r io.Reader
inbuf []byte
outbuf []byte
bufStart int
lastBoundary int
err error</code></pre>
         </article>
         
         <article class="struct" data-name="nfcTrie">
            <h2>type nfcTrie struct</h2>
            <hr />
            
            <p>nfcTrie. Total size: 10442 bytes (10.20 KiB). Checksum: 4ba400a9d8208e03.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfkcTrie">
            <h2>type nfkcTrie struct</h2>
            <hr />
            
            <p>nfkcTrie. Total size: 17104 bytes (16.70 KiB). Checksum: d985061cf5307b35.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfcTrie">
            <h2>type nfcTrie struct</h2>
            <hr />
            
            <p>nfcTrie. Total size: 10680 bytes (10.43 KiB). Checksum: a555db76d4becdd2.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfkcTrie">
            <h2>type nfkcTrie struct</h2>
            <hr />
            
            <p>nfkcTrie. Total size: 18768 bytes (18.33 KiB). Checksum: c51186dd2412943d.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfcTrie">
            <h2>type nfcTrie struct</h2>
            <hr />
            
            <p>nfcTrie. Total size: 10332 bytes (10.09 KiB). Checksum: 51cc525b297fc970.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfkcTrie">
            <h2>type nfkcTrie struct</h2>
            <hr />
            
            <p>nfkcTrie. Total size: 16994 bytes (16.60 KiB). Checksum: c3ed54ee046f3c46.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="input">
            <h2>type input struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">str string
bytes []byte</code></pre>
         </article>
         
         <article class="struct" data-name="nfcTrie">
            <h2>type nfcTrie struct</h2>
            <hr />
            
            <p>nfcTrie. Total size: 10586 bytes (10.34 KiB). Checksum: dd926e82067bee11.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfkcTrie">
            <h2>type nfkcTrie struct</h2>
            <hr />
            
            <p>nfkcTrie. Total size: 17248 bytes (16.84 KiB). Checksum: 4fb368372b6b1b27.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfcTrie">
            <h2>type nfcTrie struct</h2>
            <hr />
            
            <p>nfcTrie. Total size: 10610 bytes (10.36 KiB). Checksum: 95e8869a9f81e5e6.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfkcTrie">
            <h2>type nfkcTrie struct</h2>
            <hr />
            
            <p>nfkcTrie. Total size: 18684 bytes (18.25 KiB). Checksum: 113e23c477adfabd.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfcTrie">
            <h2>type nfcTrie struct</h2>
            <hr />
            
            <p>nfcTrie. Total size: 10798 bytes (10.54 KiB). Checksum: b5981cc85e3bd14.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nfkcTrie">
            <h2>type nfkcTrie struct</h2>
            <hr />
            
            <p>nfkcTrie. Total size: 19260 bytes (18.81 KiB). Checksum: 1a0bbc4c8c24da49.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="valueRange">
            <h2>type valueRange struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">value uint16
lo byte
hi byte</code></pre>
         </article>
         
         <article class="struct" data-name="sparseBlocks">
            <h2>type sparseBlocks struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">values []valueRange
offset []uint16</code></pre>
         </article>
         
         <article class="struct" data-name="reorderBuffer">
            <h2>type reorderBuffer struct</h2>
            <hr />
            
            <p>reorderBuffer is used to normalize a single segment.  Characters inserted with
insert are decomposed and reordered based on CCC. The compose method can
be used to recombine characters.  Note that the byte buffer does not hold
the UTF-8 characters in order.  Only the rune array is maintained in sorted
order. flush writes the resulting segment to a byte array.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">rune []Properties
byte []byte
nbyte uint8
ss streamSafe
nrune int
f formInfo
src input
nsrc int
tmpBytes input
out []byte
flushF func</code></pre>
         </article>
         
         <article class="struct" data-name="Properties">
            <h2>type Properties struct</h2>
            <hr />
            
            <p>Properties provides access to normalization properties of a rune.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos uint8
size uint8
ccc uint8
tccc uint8
nLead uint8
flags qcInfo
index uint16</code></pre>
         </article>
         
         <article class="struct" data-name="formInfo">
            <h2>type formInfo struct</h2>
            <hr />
            
            <p>formInfo holds Form-specific functions and tables.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">form Form
composing bool
compatibility bool
info lookupFunc
nextMain iterFunc</code></pre>
         </article>
         
         <article class="struct" data-name="Iter">
            <h2>type Iter struct</h2>
            <hr />
            
            <p>An Iter iterates over a string or byte slice, while normalizing it
to a given Form.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">rb reorderBuffer
buf []byte
info Properties
next iterFunc
asciiF iterFunc
p int
multiSeg []byte</code></pre>
         </article>
          
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write implements the standard write interface.  If the last characters are
not at a normalization boundary, the bytes will be buffered for the next
write. The remaining bytes will be written on close.</p>
            
            <pre><code>func Write(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close forces data that remains in the buffer to be written.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Writer">
            <h2>Writer</h2>
            <hr />
            
            <p>Writer returns a new writer that implements Write(b)
by writing f(b) to w. The returned writer may use an
internal buffer to maintain state across Write calls.
Calling its Close method writes any buffered data to w.</p>
            
            <pre><code>func Writer(w io.Writer) io.WriteCloser</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read implements the standard read interface.</p>
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Reader">
            <h2>Reader</h2>
            <hr />
            
            <p>Reader returns a new reader that implements Read
by reading data from r and returning f(data).</p>
            
            <pre><code>func Reader(r io.Reader) io.Reader</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfcTrie">
            <h2>newNfcTrie</h2>
            <hr />
            
            <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfkcTrie">
            <h2>newNfkcTrie</h2>
            <hr />
            
            <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfcTrie">
            <h2>newNfcTrie</h2>
            <hr />
            
            <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfkcTrie">
            <h2>newNfkcTrie</h2>
            <hr />
            
            <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfcTrie">
            <h2>newNfcTrie</h2>
            <hr />
            
            <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfkcTrie">
            <h2>newNfkcTrie</h2>
            <hr />
            
            <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset implements the Reset method of the transform.Transformer interface.</p>
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <p>Transform implements the Transform method of the transform.Transformer
interface. It may need to write segments of up to MaxSegmentSize at once.
Users should either catch ErrShortDst and allow dst to grow or have dst be at
least of size MaxTransformChunkSize to be guaranteed of progress.</p>
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="flushTransform">
            <h2>flushTransform</h2>
            <hr />
            
            <pre><code>func flushTransform(rb *reorderBuffer) bool</code></pre>
         </article>
         
         <article class="function" data-name="transform">
            <h2>transform</h2>
            <hr />
            
            <p>transform implements the transform.Transformer interface. It is only called
when quickSpan does not pass for a given string.</p>
            
            <pre><code>func transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="inputBytes">
            <h2>inputBytes</h2>
            <hr />
            
            <pre><code>func inputBytes(str []byte) input</code></pre>
         </article>
         
         <article class="function" data-name="inputString">
            <h2>inputString</h2>
            <hr />
            
            <pre><code>func inputString(str string) input</code></pre>
         </article>
         
         <article class="function" data-name="setBytes">
            <h2>setBytes</h2>
            <hr />
            
            <pre><code>func setBytes(str []byte)</code></pre>
         </article>
         
         <article class="function" data-name="setString">
            <h2>setString</h2>
            <hr />
            
            <pre><code>func setString(str string)</code></pre>
         </article>
         
         <article class="function" data-name="_byte">
            <h2>_byte</h2>
            <hr />
            
            <pre><code>func _byte(p int) byte</code></pre>
         </article>
         
         <article class="function" data-name="skipASCII">
            <h2>skipASCII</h2>
            <hr />
            
            <pre><code>func skipASCII(p int, max int) int</code></pre>
         </article>
         
         <article class="function" data-name="skipContinuationBytes">
            <h2>skipContinuationBytes</h2>
            <hr />
            
            <pre><code>func skipContinuationBytes(p int) int</code></pre>
         </article>
         
         <article class="function" data-name="appendSlice">
            <h2>appendSlice</h2>
            <hr />
            
            <pre><code>func appendSlice(buf []byte, b int, e int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="copySlice">
            <h2>copySlice</h2>
            <hr />
            
            <pre><code>func copySlice(buf []byte, b int, e int) int</code></pre>
         </article>
         
         <article class="function" data-name="charinfoNFC">
            <h2>charinfoNFC</h2>
            <hr />
            
            <pre><code>func charinfoNFC(p int) (uint16, int)</code></pre>
         </article>
         
         <article class="function" data-name="charinfoNFKC">
            <h2>charinfoNFKC</h2>
            <hr />
            
            <pre><code>func charinfoNFKC(p int) (uint16, int)</code></pre>
         </article>
         
         <article class="function" data-name="hangul">
            <h2>hangul</h2>
            <hr />
            
            <pre><code>func hangul(p int) r rune</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns f(b). May return b if f(b) = b.</p>
            
            <pre><code>func Bytes(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns f(s).</p>
            
            <pre><code>func String(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="IsNormal">
            <h2>IsNormal</h2>
            <hr />
            
            <p>IsNormal returns true if b == f(b).</p>
            
            <pre><code>func IsNormal(b []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="cmpNormalBytes">
            <h2>cmpNormalBytes</h2>
            <hr />
            
            <pre><code>func cmpNormalBytes(rb *reorderBuffer) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsNormalString">
            <h2>IsNormalString</h2>
            <hr />
            
            <p>IsNormalString returns true if s == f(s).</p>
            
            <pre><code>func IsNormalString(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="patchTail">
            <h2>patchTail</h2>
            <hr />
            
            <p>patchTail fixes a case where a rune may be incorrectly normalized
if it is followed by illegal continuation bytes. It returns the
patched buffer and whether the decomposition is still in progress.</p>
            
            <pre><code>func patchTail(rb *reorderBuffer) bool</code></pre>
         </article>
         
         <article class="function" data-name="appendQuick">
            <h2>appendQuick</h2>
            <hr />
            
            <pre><code>func appendQuick(rb *reorderBuffer, i int) int</code></pre>
         </article>
         
         <article class="function" data-name="Append">
            <h2>Append</h2>
            <hr />
            
            <p>Append returns f(append(out, b...)).
The buffer out must be nil, empty, or equal to f(out).</p>
            
            <pre><code>func Append(out []byte, src ...byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="doAppend">
            <h2>doAppend</h2>
            <hr />
            
            <pre><code>func doAppend(out []byte, src input, n int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="doAppend">
            <h2>doAppend</h2>
            <hr />
            
            <pre><code>func doAppend(rb *reorderBuffer, out []byte, p int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="doAppendInner">
            <h2>doAppendInner</h2>
            <hr />
            
            <pre><code>func doAppendInner(rb *reorderBuffer, p int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="AppendString">
            <h2>AppendString</h2>
            <hr />
            
            <p>AppendString returns f(append(out, []byte(s))).
The buffer out must be nil, empty, or equal to f(out).</p>
            
            <pre><code>func AppendString(out []byte, src string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="QuickSpan">
            <h2>QuickSpan</h2>
            <hr />
            
            <p>QuickSpan returns a boundary n such that b[0:n] == f(b[0:n]).
It is not guaranteed to return the largest such n.</p>
            
            <pre><code>func QuickSpan(b []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <p>Span implements transform.SpanningTransformer. It returns a boundary n such
that b[0:n] == f(b[0:n]). It is not guaranteed to return the largest such n.</p>
            
            <pre><code>func Span(b []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="SpanString">
            <h2>SpanString</h2>
            <hr />
            
            <p>SpanString returns a boundary n such that s[0:n] == f(s[0:n]).
It is not guaranteed to return the largest such n.</p>
            
            <pre><code>func SpanString(s string, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="quickSpan">
            <h2>quickSpan</h2>
            <hr />
            
            <p>quickSpan returns a boundary n such that src[0:n] == f(src[0:n]) and
whether any non-normalized parts were found. If atEOF is false, n will
not point past the last segment if this segment might be become
non-normalized by appending other runes.</p>
            
            <pre><code>func quickSpan(src input, i int, end int, atEOF bool) (n int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="QuickSpanString">
            <h2>QuickSpanString</h2>
            <hr />
            
            <p>QuickSpanString returns a boundary n such that s[0:n] == f(s[0:n]).
It is not guaranteed to return the largest such n.</p>
            
            <pre><code>func QuickSpanString(s string) int</code></pre>
         </article>
         
         <article class="function" data-name="FirstBoundary">
            <h2>FirstBoundary</h2>
            <hr />
            
            <p>FirstBoundary returns the position i of the first boundary in b
or -1 if b contains no boundary.</p>
            
            <pre><code>func FirstBoundary(b []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="firstBoundary">
            <h2>firstBoundary</h2>
            <hr />
            
            <pre><code>func firstBoundary(src input, nsrc int) int</code></pre>
         </article>
         
         <article class="function" data-name="FirstBoundaryInString">
            <h2>FirstBoundaryInString</h2>
            <hr />
            
            <p>FirstBoundaryInString returns the position i of the first boundary in s
or -1 if s contains no boundary.</p>
            
            <pre><code>func FirstBoundaryInString(s string) int</code></pre>
         </article>
         
         <article class="function" data-name="NextBoundary">
            <h2>NextBoundary</h2>
            <hr />
            
            <p>NextBoundary reports the index of the boundary between the first and next
segment in b or -1 if atEOF is false and there are not enough bytes to
determine this boundary.</p>
            
            <pre><code>func NextBoundary(b []byte, atEOF bool) int</code></pre>
         </article>
         
         <article class="function" data-name="NextBoundaryInString">
            <h2>NextBoundaryInString</h2>
            <hr />
            
            <p>NextBoundaryInString reports the index of the boundary between the first and
next segment in b or -1 if atEOF is false and there are not enough bytes to
determine this boundary.</p>
            
            <pre><code>func NextBoundaryInString(s string, atEOF bool) int</code></pre>
         </article>
         
         <article class="function" data-name="nextBoundary">
            <h2>nextBoundary</h2>
            <hr />
            
            <pre><code>func nextBoundary(src input, nsrc int, atEOF bool) int</code></pre>
         </article>
         
         <article class="function" data-name="LastBoundary">
            <h2>LastBoundary</h2>
            <hr />
            
            <p>LastBoundary returns the position i of the last boundary in b
or -1 if b contains no boundary.</p>
            
            <pre><code>func LastBoundary(b []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="lastBoundary">
            <h2>lastBoundary</h2>
            <hr />
            
            <pre><code>func lastBoundary(fd *formInfo, b []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="decomposeSegment">
            <h2>decomposeSegment</h2>
            <hr />
            
            <p>decomposeSegment scans the first segment in src into rb. It inserts 0x034f
(Grapheme Joiner) when it encounters a sequence of more than 30 non-starters
and returns the number of bytes consumed from src or iShortDst or iShortSrc.</p>
            
            <pre><code>func decomposeSegment(rb *reorderBuffer, sp int, atEOF bool) int</code></pre>
         </article>
         
         <article class="function" data-name="lastRuneStart">
            <h2>lastRuneStart</h2>
            <hr />
            
            <p>lastRuneStart returns the runeInfo and position of the last
rune in buf or the zero runeInfo and -1 if no rune was found.</p>
            
            <pre><code>func lastRuneStart(fd *formInfo, buf []byte) (Properties, int)</code></pre>
         </article>
         
         <article class="function" data-name="decomposeToLastBoundary">
            <h2>decomposeToLastBoundary</h2>
            <hr />
            
            <p>decomposeToLastBoundary finds an open segment at the end of the buffer
and scans it into rb. Returns the buffer minus the last segment.</p>
            
            <pre><code>func decomposeToLastBoundary(rb *reorderBuffer)</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfcTrie">
            <h2>newNfcTrie</h2>
            <hr />
            
            <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfkcTrie">
            <h2>newNfkcTrie</h2>
            <hr />
            
            <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfcTrie">
            <h2>newNfcTrie</h2>
            <hr />
            
            <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfkcTrie">
            <h2>newNfkcTrie</h2>
            <hr />
            
            <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfcTrie">
            <h2>newNfcTrie</h2>
            <hr />
            
            <pre><code>func newNfcTrie(i int) *nfcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newNfkcTrie">
            <h2>newNfkcTrie</h2>
            <hr />
            
            <pre><code>func newNfkcTrie(i int) *nfkcTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup determines the type of block n and looks up the value for b.
For n < t.cutoff, the block is a simple lookup table. Otherwise, the block
is a list of ranges with an accompanying value. Given a matching range r,
the value for b is by r.value + (b - r.lo) * stride.</p>
            
            <pre><code>func lookup(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="first">
            <h2>first</h2>
            <hr />
            
            <p>first inserts the first rune of a segment. It is a faster version of next if
it is known p represents the first rune in a segment.</p>
            
            <pre><code>func first(p Properties)</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>insert returns a ssState value to indicate whether a rune represented by p
can be inserted.</p>
            
            <pre><code>func next(p Properties) ssState</code></pre>
         </article>
         
         <article class="function" data-name="backwards">
            <h2>backwards</h2>
            <hr />
            
            <p>backwards is used for checking for overflow and segment starts
when traversing a string backwards. Users do not need to call first
for the first rune. The state of the streamSafe retains the count of
the non-starters loaded.</p>
            
            <pre><code>func backwards(p Properties) ssState</code></pre>
         </article>
         
         <article class="function" data-name="isMax">
            <h2>isMax</h2>
            <hr />
            
            <pre><code>func isMax() bool</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(f Form, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="initString">
            <h2>initString</h2>
            <hr />
            
            <pre><code>func initString(f Form, src string)</code></pre>
         </article>
         
         <article class="function" data-name="setFlusher">
            <h2>setFlusher</h2>
            <hr />
            
            <pre><code>func setFlusher(out []byte, f func)</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <p>reset discards all characters from the buffer.</p>
            
            <pre><code>func reset()</code></pre>
         </article>
         
         <article class="function" data-name="doFlush">
            <h2>doFlush</h2>
            <hr />
            
            <pre><code>func doFlush() bool</code></pre>
         </article>
         
         <article class="function" data-name="appendFlush">
            <h2>appendFlush</h2>
            <hr />
            
            <p>appendFlush appends the normalized segment to rb.out.</p>
            
            <pre><code>func appendFlush(rb *reorderBuffer) bool</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <p>flush appends the normalized segment to out and resets rb.</p>
            
            <pre><code>func flush(out []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="flushCopy">
            <h2>flushCopy</h2>
            <hr />
            
            <p>flushCopy copies the normalized segment to buf and resets rb.
It returns the number of bytes written to buf.</p>
            
            <pre><code>func flushCopy(buf []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="insertOrdered">
            <h2>insertOrdered</h2>
            <hr />
            
            <p>insertOrdered inserts a rune in the buffer, ordered by Canonical Combining Class.
It returns false if the buffer is not large enough to hold the rune.
It is used internally by insert and insertString only.</p>
            
            <pre><code>func insertOrdered(info Properties)</code></pre>
         </article>
         
         <article class="function" data-name="insertFlush">
            <h2>insertFlush</h2>
            <hr />
            
            <p>insertFlush inserts the given rune in the buffer ordered by CCC.
If a decomposition with multiple segments are encountered, they leading
ones are flushed.
It returns a non-zero error code if the rune was not inserted.</p>
            
            <pre><code>func insertFlush(src input, i int, info Properties) insertErr</code></pre>
         </article>
         
         <article class="function" data-name="insertUnsafe">
            <h2>insertUnsafe</h2>
            <hr />
            
            <p>insertUnsafe inserts the given rune in the buffer ordered by CCC.
It is assumed there is sufficient space to hold the runes. It is the
responsibility of the caller to ensure this. This can be done by checking
the state returned by the streamSafe type.</p>
            
            <pre><code>func insertUnsafe(src input, i int, info Properties)</code></pre>
         </article>
         
         <article class="function" data-name="insertDecomposed">
            <h2>insertDecomposed</h2>
            <hr />
            
            <p>insertDecomposed inserts an entry in to the reorderBuffer for each rune
in dcomp. dcomp must be a sequence of decomposed UTF-8-encoded runes.
It flushes the buffer on each new segment start.</p>
            
            <pre><code>func insertDecomposed(dcomp []byte) insertErr</code></pre>
         </article>
         
         <article class="function" data-name="insertSingle">
            <h2>insertSingle</h2>
            <hr />
            
            <p>insertSingle inserts an entry in the reorderBuffer for the rune at
position i. info is the runeInfo for the rune at position i.</p>
            
            <pre><code>func insertSingle(src input, i int, info Properties)</code></pre>
         </article>
         
         <article class="function" data-name="insertCGJ">
            <h2>insertCGJ</h2>
            <hr />
            
            <p>insertCGJ inserts a Combining Grapheme Joiner (0x034f) into rb.</p>
            
            <pre><code>func insertCGJ()</code></pre>
         </article>
         
         <article class="function" data-name="appendRune">
            <h2>appendRune</h2>
            <hr />
            
            <p>appendRune inserts a rune at the end of the buffer. It is used for Hangul.</p>
            
            <pre><code>func appendRune(r rune)</code></pre>
         </article>
         
         <article class="function" data-name="assignRune">
            <h2>assignRune</h2>
            <hr />
            
            <p>assignRune sets a rune at position pos. It is used for Hangul and recomposition.</p>
            
            <pre><code>func assignRune(pos int, r rune)</code></pre>
         </article>
         
         <article class="function" data-name="runeAt">
            <h2>runeAt</h2>
            <hr />
            
            <p>runeAt returns the rune at position n. It is used for Hangul and recomposition.</p>
            
            <pre><code>func runeAt(n int) rune</code></pre>
         </article>
         
         <article class="function" data-name="bytesAt">
            <h2>bytesAt</h2>
            <hr />
            
            <p>bytesAt returns the UTF-8 encoding of the rune at position n.
It is used for Hangul and recomposition.</p>
            
            <pre><code>func bytesAt(n int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="isHangul">
            <h2>isHangul</h2>
            <hr />
            
            <pre><code>func isHangul(b []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isHangulString">
            <h2>isHangulString</h2>
            <hr />
            
            <pre><code>func isHangulString(b string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isJamoVT">
            <h2>isJamoVT</h2>
            <hr />
            
            <p>Caller must ensure len(b) >= 2.</p>
            
            <pre><code>func isJamoVT(b []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isHangulWithoutJamoT">
            <h2>isHangulWithoutJamoT</h2>
            <hr />
            
            <pre><code>func isHangulWithoutJamoT(b []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="decomposeHangul">
            <h2>decomposeHangul</h2>
            <hr />
            
            <p>decomposeHangul writes the decomposed Hangul to buf and returns the number
of bytes written.  len(buf) should be at least 9.</p>
            
            <pre><code>func decomposeHangul(buf []byte, r rune) int</code></pre>
         </article>
         
         <article class="function" data-name="decomposeHangul">
            <h2>decomposeHangul</h2>
            <hr />
            
            <p>decomposeHangul algorithmically decomposes a Hangul rune into
its Jamo components.
See https://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul.</p>
            
            <pre><code>func decomposeHangul(r rune)</code></pre>
         </article>
         
         <article class="function" data-name="combineHangul">
            <h2>combineHangul</h2>
            <hr />
            
            <p>combineHangul algorithmically combines Jamo character components into Hangul.
See https://unicode.org/reports/tr15/#Hangul for details on combining Hangul.</p>
            
            <pre><code>func combineHangul(s int, i int, k int)</code></pre>
         </article>
         
         <article class="function" data-name="compose">
            <h2>compose</h2>
            <hr />
            
            <p>compose recombines the runes in the buffer.
It should only be used to recompose a single segment, as it will not
handle alternations between Hangul and non-Hangul characters correctly.</p>
            
            <pre><code>func compose()</code></pre>
         </article>
         
         <article class="function" data-name="BoundaryBefore">
            <h2>BoundaryBefore</h2>
            <hr />
            
            <p>BoundaryBefore returns true if this rune starts a new segment and
cannot combine with any rune on the left.</p>
            
            <pre><code>func BoundaryBefore() bool</code></pre>
         </article>
         
         <article class="function" data-name="BoundaryAfter">
            <h2>BoundaryAfter</h2>
            <hr />
            
            <p>BoundaryAfter returns true if runes cannot combine with or otherwise
interact with this or previous runes.</p>
            
            <pre><code>func BoundaryAfter() bool</code></pre>
         </article>
         
         <article class="function" data-name="isYesC">
            <h2>isYesC</h2>
            <hr />
            
            <pre><code>func isYesC() bool</code></pre>
         </article>
         
         <article class="function" data-name="isYesD">
            <h2>isYesD</h2>
            <hr />
            
            <pre><code>func isYesD() bool</code></pre>
         </article>
         
         <article class="function" data-name="combinesForward">
            <h2>combinesForward</h2>
            <hr />
            
            <pre><code>func combinesForward() bool</code></pre>
         </article>
         
         <article class="function" data-name="combinesBackward">
            <h2>combinesBackward</h2>
            <hr />
            
            <pre><code>func combinesBackward() bool</code></pre>
         </article>
         
         <article class="function" data-name="hasDecomposition">
            <h2>hasDecomposition</h2>
            <hr />
            
            <pre><code>func hasDecomposition() bool</code></pre>
         </article>
         
         <article class="function" data-name="isInert">
            <h2>isInert</h2>
            <hr />
            
            <pre><code>func isInert() bool</code></pre>
         </article>
         
         <article class="function" data-name="multiSegment">
            <h2>multiSegment</h2>
            <hr />
            
            <pre><code>func multiSegment() bool</code></pre>
         </article>
         
         <article class="function" data-name="nLeadingNonStarters">
            <h2>nLeadingNonStarters</h2>
            <hr />
            
            <pre><code>func nLeadingNonStarters() uint8</code></pre>
         </article>
         
         <article class="function" data-name="nTrailingNonStarters">
            <h2>nTrailingNonStarters</h2>
            <hr />
            
            <pre><code>func nTrailingNonStarters() uint8</code></pre>
         </article>
         
         <article class="function" data-name="Decomposition">
            <h2>Decomposition</h2>
            <hr />
            
            <p>Decomposition returns the decomposition for the underlying rune
or nil if there is none.</p>
            
            <pre><code>func Decomposition() []byte</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <p>Size returns the length of UTF-8 encoding of the rune.</p>
            
            <pre><code>func Size() int</code></pre>
         </article>
         
         <article class="function" data-name="CCC">
            <h2>CCC</h2>
            <hr />
            
            <p>CCC returns the canonical combining class of the underlying rune.</p>
            
            <pre><code>func CCC() uint8</code></pre>
         </article>
         
         <article class="function" data-name="LeadCCC">
            <h2>LeadCCC</h2>
            <hr />
            
            <p>LeadCCC returns the CCC of the first rune in the decomposition.
If there is no decomposition, LeadCCC equals CCC.</p>
            
            <pre><code>func LeadCCC() uint8</code></pre>
         </article>
         
         <article class="function" data-name="TrailCCC">
            <h2>TrailCCC</h2>
            <hr />
            
            <p>TrailCCC returns the CCC of the last rune in the decomposition.
If there is no decomposition, TrailCCC equals CCC.</p>
            
            <pre><code>func TrailCCC() uint8</code></pre>
         </article>
         
         <article class="function" data-name="buildRecompMap">
            <h2>buildRecompMap</h2>
            <hr />
            
            <pre><code>func buildRecompMap()</code></pre>
         </article>
         
         <article class="function" data-name="combine">
            <h2>combine</h2>
            <hr />
            
            <p>combine returns the combined rune or 0 if it doesn't exist.

The caller is responsible for calling
recompMapOnce.Do(buildRecompMap) sometime before this is called.</p>
            
            <pre><code>func combine(a rune, b rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="lookupInfoNFC">
            <h2>lookupInfoNFC</h2>
            <hr />
            
            <pre><code>func lookupInfoNFC(b input, i int) Properties</code></pre>
         </article>
         
         <article class="function" data-name="lookupInfoNFKC">
            <h2>lookupInfoNFKC</h2>
            <hr />
            
            <pre><code>func lookupInfoNFKC(b input, i int) Properties</code></pre>
         </article>
         
         <article class="function" data-name="Properties">
            <h2>Properties</h2>
            <hr />
            
            <p>Properties returns properties for the first rune in s.</p>
            
            <pre><code>func Properties(s []byte) Properties</code></pre>
         </article>
         
         <article class="function" data-name="PropertiesString">
            <h2>PropertiesString</h2>
            <hr />
            
            <p>PropertiesString returns properties for the first rune in s.</p>
            
            <pre><code>func PropertiesString(s string) Properties</code></pre>
         </article>
         
         <article class="function" data-name="compInfo">
            <h2>compInfo</h2>
            <hr />
            
            <p>compInfo converts the information contained in v and sz
to a Properties.  See the comment at the top of the file
for more information on the format.</p>
            
            <pre><code>func compInfo(v uint16, sz int) Properties</code></pre>
         </article>
         
         <article class="function" data-name="Init">
            <h2>Init</h2>
            <hr />
            
            <p>Init initializes i to iterate over src after normalizing it to Form f.</p>
            
            <pre><code>func Init(f Form, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="InitString">
            <h2>InitString</h2>
            <hr />
            
            <p>InitString initializes i to iterate over src after normalizing it to Form f.</p>
            
            <pre><code>func InitString(f Form, src string)</code></pre>
         </article>
         
         <article class="function" data-name="Seek">
            <h2>Seek</h2>
            <hr />
            
            <p>Seek sets the segment to be returned by the next call to Next to start
at position p.  It is the responsibility of the caller to set p to the
start of a segment.</p>
            
            <pre><code>func Seek(offset int64, whence int) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="returnSlice">
            <h2>returnSlice</h2>
            <hr />
            
            <p>returnSlice returns a slice of the underlying input type as a byte slice.
If the underlying is of type []byte, it will simply return a slice.
If the underlying is of type string, it will copy the slice to the buffer
and return that.</p>
            
            <pre><code>func returnSlice(a int, b int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <p>Pos returns the byte position at which the next call to Next will commence processing.</p>
            
            <pre><code>func Pos() int</code></pre>
         </article>
         
         <article class="function" data-name="setDone">
            <h2>setDone</h2>
            <hr />
            
            <pre><code>func setDone()</code></pre>
         </article>
         
         <article class="function" data-name="Done">
            <h2>Done</h2>
            <hr />
            
            <p>Done returns true if there is no more input to process.</p>
            
            <pre><code>func Done() bool</code></pre>
         </article>
         
         <article class="function" data-name="Next">
            <h2>Next</h2>
            <hr />
            
            <p>Next returns f(i.input[i.Pos():n]), where n is a boundary of i.input.
For any input a and b for which f(a) == f(b), subsequent calls
to Next will return the same segments.
Modifying runes are grouped together with the preceding starter, if such a starter exists.
Although not guaranteed, n will typically be the smallest possible n.</p>
            
            <pre><code>func Next() []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextASCIIBytes">
            <h2>nextASCIIBytes</h2>
            <hr />
            
            <pre><code>func nextASCIIBytes(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextASCIIString">
            <h2>nextASCIIString</h2>
            <hr />
            
            <pre><code>func nextASCIIString(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextHangul">
            <h2>nextHangul</h2>
            <hr />
            
            <pre><code>func nextHangul(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextDone">
            <h2>nextDone</h2>
            <hr />
            
            <pre><code>func nextDone(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextMulti">
            <h2>nextMulti</h2>
            <hr />
            
            <p>nextMulti is used for iterating over multi-segment decompositions
for decomposing normal forms.</p>
            
            <pre><code>func nextMulti(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextMultiNorm">
            <h2>nextMultiNorm</h2>
            <hr />
            
            <p>nextMultiNorm is used for iterating over multi-segment decompositions
for composing normal forms.</p>
            
            <pre><code>func nextMultiNorm(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextDecomposed">
            <h2>nextDecomposed</h2>
            <hr />
            
            <p>nextDecomposed is the implementation of Next for forms NFD and NFKD.</p>
            
            <pre><code>func nextDecomposed(i *Iter) next []byte</code></pre>
         </article>
         
         <article class="function" data-name="doNormDecomposed">
            <h2>doNormDecomposed</h2>
            <hr />
            
            <pre><code>func doNormDecomposed(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextCGJDecompose">
            <h2>nextCGJDecompose</h2>
            <hr />
            
            <pre><code>func nextCGJDecompose(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextComposed">
            <h2>nextComposed</h2>
            <hr />
            
            <p>nextComposed is the implementation of Next for forms NFC and NFKC.</p>
            
            <pre><code>func nextComposed(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="doNormComposed">
            <h2>doNormComposed</h2>
            <hr />
            
            <pre><code>func doNormComposed(i *Iter) []byte</code></pre>
         </article>
         
         <article class="function" data-name="nextCGJCompose">
            <h2>nextCGJCompose</h2>
            <hr />
            
            <pre><code>func nextCGJCompose(i *Iter) []byte</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
