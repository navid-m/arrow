<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - module</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>module</code>
         </h1>
         <hr />
         
         <article class="global" data-name="modulePath">
            <h2>modulePath</h2>
            <hr />
            
            <pre><code>modulePath pathKind</code></pre>
         </article>
         
         <article class="global" data-name="importPath">
            <h2>importPath</h2>
            <hr />
            
            <pre><code>importPath</code></pre>
         </article>
         
         <article class="global" data-name="filePath">
            <h2>filePath</h2>
            <hr />
            
            <pre><code>filePath</code></pre>
         </article>
         
         <article class="global" data-name="badWindowsNames">
            <h2>badWindowsNames</h2>
            <hr />
            
            <p>badWindowsNames are the reserved file path elements on Windows.
See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file</p>
            
            <pre><code>badWindowsNames</code></pre>
         </article>
         
         <article class="global" data-name="pseudoVersionRE">
            <h2>pseudoVersionRE</h2>
            <hr />
            
            <pre><code>pseudoVersionRE</code></pre>
         </article>
         
         <article class="global" data-name="PseudoVersionTimestampFormat">
            <h2>PseudoVersionTimestampFormat</h2>
            <hr />
            
            <pre><code>PseudoVersionTimestampFormat</code></pre>
         </article>
         
         <article class="global" data-name="errPseudoSyntax">
            <h2>errPseudoSyntax</h2>
            <hr />
            
            <pre><code>errPseudoSyntax</code></pre>
         </article>
          
         <article class="struct" data-name="Version">
            <h2>type Version struct</h2>
            <hr />
            
            <p>A Version (for clients, a module.Version) is defined by a module path and version pair.
These are stored in their plain (unescaped) form.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Version string</code></pre>
         </article>
         
         <article class="struct" data-name="ModuleError">
            <h2>type ModuleError struct</h2>
            <hr />
            
            <p>A ModuleError indicates an error specific to a module.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Version string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="InvalidVersionError">
            <h2>type InvalidVersionError struct</h2>
            <hr />
            
            <p>An InvalidVersionError indicates an error specific to a version, with the
module path unknown or specified externally.

A [ModuleError] may wrap an InvalidVersionError, but an InvalidVersionError
must not wrap a ModuleError.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Version string
Pseudo bool
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="InvalidPathError">
            <h2>type InvalidPathError struct</h2>
            <hr />
            
            <p>An InvalidPathError indicates a module, import, or file path doesn't
satisfy all naming constraints. See [CheckPath], [CheckImportPath],
and [CheckFilePath] for specific restrictions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Kind string
Path string
Err error</code></pre>
         </article>
          
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a representation of the Version suitable for logging
(Path@Version, or just Path if Version is empty).</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="VersionError">
            <h2>VersionError</h2>
            <hr />
            
            <p>VersionError returns a [ModuleError] derived from a [Version] and error,
or err itself if it is already such an error.</p>
            
            <pre><code>func VersionError(v Version, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="noun">
            <h2>noun</h2>
            <hr />
            
            <p>noun returns either "version" or "pseudo-version", depending on whether
e.Version is a pseudo-version.</p>
            
            <pre><code>func noun() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="Check">
            <h2>Check</h2>
            <hr />
            
            <p>Check checks that a given module path, version pair is valid.
In addition to the path being a valid module path
and the version being a valid semantic version,
the two must correspond.
For example, the path "yaml/v2" only corresponds to
semantic versions beginning with "v2.".</p>
            
            <pre><code>func Check(path string, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="firstPathOK">
            <h2>firstPathOK</h2>
            <hr />
            
            <p>firstPathOK reports whether r can appear in the first element of a module path.
The first element of the path must be an LDH domain name, at least for now.
To avoid case ambiguity, the domain name must be entirely lower case.</p>
            
            <pre><code>func firstPathOK(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="modPathOK">
            <h2>modPathOK</h2>
            <hr />
            
            <p>modPathOK reports whether r can appear in a module path element.
Paths can be ASCII letters, ASCII digits, and limited ASCII punctuation: - . _ and ~.

This matches what "go get" has historically recognized in import paths,
and avoids confusing sequences like '%20' or '+' that would change meaning
if used in a URL.

TODO(rsc): We would like to allow Unicode letters, but that requires additional
care in the safe encoding (see "escaped paths" above).</p>
            
            <pre><code>func modPathOK(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="importPathOK">
            <h2>importPathOK</h2>
            <hr />
            
            <p>importPathOK reports whether r can appear in a package import path element.

Import paths are intermediate between module paths and file paths: we allow
disallow characters that would be confusing or ambiguous as arguments to
'go get' (such as '@' and ' ' ), but allow certain characters that are
otherwise-unambiguous on the command line and historically used for some
binary names (such as '++' as a suffix for compiler binaries and wrappers).</p>
            
            <pre><code>func importPathOK(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="fileNameOK">
            <h2>fileNameOK</h2>
            <hr />
            
            <p>fileNameOK reports whether r can appear in a file name.
For now we allow all Unicode letters but otherwise limit to pathOK plus a few more punctuation characters.
If we expand the set of allowed characters here, we have to
work harder at detecting potential case-folding and normalization collisions.
See note about "escaped paths" above.</p>
            
            <pre><code>func fileNameOK(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="CheckPath">
            <h2>CheckPath</h2>
            <hr />
            
            <p>CheckPath checks that a module path is valid.
A valid module path is a valid import path, as checked by [CheckImportPath],
with three additional constraints.
First, the leading path element (up to the first slash, if any),
by convention a domain name, must contain only lower-case ASCII letters,
ASCII digits, dots (U+002E), and dashes (U+002D);
it must contain at least one dot and cannot start with a dash.
Second, for a final path element of the form /vN, where N looks numeric
(ASCII digits and dots) must not begin with a leading zero, must not be /v1,
and must not contain any dots. For paths beginning with "gopkg.in/",
this second requirement is replaced by a requirement that the path
follow the gopkg.in server's conventions.
Third, no path element may begin with a dot.</p>
            
            <pre><code>func CheckPath(path string) err error</code></pre>
         </article>
         
         <article class="function" data-name="CheckImportPath">
            <h2>CheckImportPath</h2>
            <hr />
            
            <p>CheckImportPath checks that an import path is valid.

A valid import path consists of one or more valid path elements
separated by slashes (U+002F). (It must not begin with nor end in a slash.)

A valid path element is a non-empty string made up of
ASCII letters, ASCII digits, and limited ASCII punctuation: - . _ and ~.
It must not end with a dot (U+002E), nor contain two dots in a row.

The element prefix up to the first dot must not be a reserved file name
on Windows, regardless of case (CON, com1, NuL, and so on). The element
must not have a suffix of a tilde followed by one or more ASCII digits
(to exclude paths elements that look like Windows short-names).

CheckImportPath may be less restrictive in the future, but see the
top-level package documentation for additional information about
subtleties of Unicode.</p>
            
            <pre><code>func CheckImportPath(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkPath">
            <h2>checkPath</h2>
            <hr />
            
            <p>checkPath checks that a general path is valid. kind indicates what
specific constraints should be applied.

checkPath returns an error describing why the path is not valid.
Because these checks apply to module, import, and file paths,
and because other checks may be applied, the caller is expected to wrap
this error with [InvalidPathError].</p>
            
            <pre><code>func checkPath(path string, kind pathKind) error</code></pre>
         </article>
         
         <article class="function" data-name="checkElem">
            <h2>checkElem</h2>
            <hr />
            
            <p>checkElem checks whether an individual path element is valid.</p>
            
            <pre><code>func checkElem(elem string, kind pathKind) error</code></pre>
         </article>
         
         <article class="function" data-name="CheckFilePath">
            <h2>CheckFilePath</h2>
            <hr />
            
            <p>CheckFilePath checks that a slash-separated file path is valid.
The definition of a valid file path is the same as the definition
of a valid import path except that the set of allowed characters is larger:
all Unicode letters, ASCII digits, the ASCII space character (U+0020),
and the ASCII punctuation characters
“!#$%&()+,-.=@[]^_{}~”.
(The excluded punctuation characters, " * < > ? ` ' | / \ and :,
have special meanings in certain shells or operating systems.)

CheckFilePath may be less restrictive in the future, but see the
top-level package documentation for additional information about
subtleties of Unicode.</p>
            
            <pre><code>func CheckFilePath(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="SplitPathVersion">
            <h2>SplitPathVersion</h2>
            <hr />
            
            <p>SplitPathVersion returns prefix and major version such that prefix+pathMajor == path
and version is either empty or "/vN" for N >= 2.
As a special case, gopkg.in paths are recognized directly;
they require ".vN" instead of "/vN", and for all N, not just N >= 2.
SplitPathVersion returns with ok = false when presented with
a path whose last path element does not satisfy the constraints
applied by [CheckPath], such as "example.com/pkg/v1" or "example.com/pkg/v1.2".</p>
            
            <pre><code>func SplitPathVersion(path string) (prefix string, pathMajor string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="splitGopkgIn">
            <h2>splitGopkgIn</h2>
            <hr />
            
            <p>splitGopkgIn is like SplitPathVersion but only for gopkg.in paths.</p>
            
            <pre><code>func splitGopkgIn(path string) (prefix string, pathMajor string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="MatchPathMajor">
            <h2>MatchPathMajor</h2>
            <hr />
            
            <p>MatchPathMajor reports whether the semantic version v
matches the path major version pathMajor.

MatchPathMajor returns true if and only if [CheckPathMajor] returns nil.</p>
            
            <pre><code>func MatchPathMajor(v string, pathMajor string) bool</code></pre>
         </article>
         
         <article class="function" data-name="CheckPathMajor">
            <h2>CheckPathMajor</h2>
            <hr />
            
            <p>CheckPathMajor returns a non-nil error if the semantic version v
does not match the path major version pathMajor.</p>
            
            <pre><code>func CheckPathMajor(v string, pathMajor string) error</code></pre>
         </article>
         
         <article class="function" data-name="PathMajorPrefix">
            <h2>PathMajorPrefix</h2>
            <hr />
            
            <p>PathMajorPrefix returns the major-version tag prefix implied by pathMajor.
An empty PathMajorPrefix allows either v0 or v1.

Note that [MatchPathMajor] may accept some versions that do not actually begin
with this prefix: namely, it accepts a 'v0.0.0-' prefix for a '.v1'
pathMajor, even though that pathMajor implies 'v1' tagging.</p>
            
            <pre><code>func PathMajorPrefix(pathMajor string) string</code></pre>
         </article>
         
         <article class="function" data-name="CanonicalVersion">
            <h2>CanonicalVersion</h2>
            <hr />
            
            <p>CanonicalVersion returns the canonical form of the version string v.
It is the same as [semver.Canonical] except that it preserves the special build suffix "+incompatible".</p>
            
            <pre><code>func CanonicalVersion(v string) string</code></pre>
         </article>
         
         <article class="function" data-name="Sort">
            <h2>Sort</h2>
            <hr />
            
            <p>Sort sorts the list by Path, breaking ties by comparing [Version] fields.
The Version fields are interpreted as semantic versions (using [semver.Compare])
optionally followed by a tie-breaking suffix introduced by a slash character,
like in "v0.0.1/go.mod".</p>
            
            <pre><code>func Sort(list []Version)</code></pre>
         </article>
         
         <article class="function" data-name="EscapePath">
            <h2>EscapePath</h2>
            <hr />
            
            <p>EscapePath returns the escaped form of the given module path.
It fails if the module path is invalid.</p>
            
            <pre><code>func EscapePath(path string) (escaped string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="EscapeVersion">
            <h2>EscapeVersion</h2>
            <hr />
            
            <p>EscapeVersion returns the escaped form of the given module version.
Versions are allowed to be in non-semver form but must be valid file names
and not contain exclamation marks.</p>
            
            <pre><code>func EscapeVersion(v string) (escaped string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="escapeString">
            <h2>escapeString</h2>
            <hr />
            
            <pre><code>func escapeString(s string) (escaped string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="UnescapePath">
            <h2>UnescapePath</h2>
            <hr />
            
            <p>UnescapePath returns the module path for the given escaped path.
It fails if the escaped path is invalid or describes an invalid path.</p>
            
            <pre><code>func UnescapePath(escaped string) (path string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="UnescapeVersion">
            <h2>UnescapeVersion</h2>
            <hr />
            
            <p>UnescapeVersion returns the version string for the given escaped version.
It fails if the escaped form is invalid or describes an invalid version.
Versions are allowed to be in non-semver form but must be valid file names
and not contain exclamation marks.</p>
            
            <pre><code>func UnescapeVersion(escaped string) (v string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="unescapeString">
            <h2>unescapeString</h2>
            <hr />
            
            <pre><code>func unescapeString(escaped string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="MatchPrefixPatterns">
            <h2>MatchPrefixPatterns</h2>
            <hr />
            
            <p>MatchPrefixPatterns reports whether any path prefix of target matches one of
the glob patterns (as defined by [path.Match]) in the comma-separated globs
list. This implements the algorithm used when matching a module path to the
GOPRIVATE environment variable, as described by 'go help module-private'.

It ignores any empty or malformed patterns in the list.
Trailing slashes on patterns are ignored.</p>
            
            <pre><code>func MatchPrefixPatterns(globs string, target string) bool</code></pre>
         </article>
         
         <article class="function" data-name="PseudoVersion">
            <h2>PseudoVersion</h2>
            <hr />
            
            <p>PseudoVersion returns a pseudo-version for the given major version ("v1")
preexisting older tagged version ("" or "v1.2.3" or "v1.2.3-pre"), revision time,
and revision identifier (usually a 12-byte commit hash prefix).</p>
            
            <pre><code>func PseudoVersion(major string, older string, t time.Time, rev string) string</code></pre>
         </article>
         
         <article class="function" data-name="ZeroPseudoVersion">
            <h2>ZeroPseudoVersion</h2>
            <hr />
            
            <p>ZeroPseudoVersion returns a pseudo-version with a zero timestamp and
revision, which may be used as a placeholder.</p>
            
            <pre><code>func ZeroPseudoVersion(major string) string</code></pre>
         </article>
         
         <article class="function" data-name="incDecimal">
            <h2>incDecimal</h2>
            <hr />
            
            <p>incDecimal returns the decimal string incremented by 1.</p>
            
            <pre><code>func incDecimal(decimal string) string</code></pre>
         </article>
         
         <article class="function" data-name="decDecimal">
            <h2>decDecimal</h2>
            <hr />
            
            <p>decDecimal returns the decimal string decremented by 1, or the empty string
if the decimal is all zeroes.</p>
            
            <pre><code>func decDecimal(decimal string) string</code></pre>
         </article>
         
         <article class="function" data-name="IsPseudoVersion">
            <h2>IsPseudoVersion</h2>
            <hr />
            
            <p>IsPseudoVersion reports whether v is a pseudo-version.</p>
            
            <pre><code>func IsPseudoVersion(v string) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsZeroPseudoVersion">
            <h2>IsZeroPseudoVersion</h2>
            <hr />
            
            <p>IsZeroPseudoVersion returns whether v is a pseudo-version with a zero base,
timestamp, and revision, as returned by [ZeroPseudoVersion].</p>
            
            <pre><code>func IsZeroPseudoVersion(v string) bool</code></pre>
         </article>
         
         <article class="function" data-name="PseudoVersionTime">
            <h2>PseudoVersionTime</h2>
            <hr />
            
            <p>PseudoVersionTime returns the time stamp of the pseudo-version v.
It returns an error if v is not a pseudo-version or if the time stamp
embedded in the pseudo-version is not a valid time.</p>
            
            <pre><code>func PseudoVersionTime(v string) (time.Time, error)</code></pre>
         </article>
         
         <article class="function" data-name="PseudoVersionRev">
            <h2>PseudoVersionRev</h2>
            <hr />
            
            <p>PseudoVersionRev returns the revision identifier of the pseudo-version v.
It returns an error if v is not a pseudo-version.</p>
            
            <pre><code>func PseudoVersionRev(v string) (rev string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="PseudoVersionBase">
            <h2>PseudoVersionBase</h2>
            <hr />
            
            <p>PseudoVersionBase returns the canonical parent version, if any, upon which
the pseudo-version v is based.

If v has no parent version (that is, if it is "vX.0.0-[…]"),
PseudoVersionBase returns the empty string and a nil error.</p>
            
            <pre><code>func PseudoVersionBase(v string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="parsePseudoVersion">
            <h2>parsePseudoVersion</h2>
            <hr />
            
            <pre><code>func parsePseudoVersion(v string) (base string, timestamp string, rev string, build string, err error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
