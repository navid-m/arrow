<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - module</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>module</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"fmt"
"path"
"sort"
"strings"
"unicode"
"unicode/utf8"
"golang.org/x/mod/semver"
"errors"
"fmt"
"strings"
"time"
"golang.org/x/mod/internal/lazyregexp"
"golang.org/x/mod/semver"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="PseudoVersionTimestampFormat">
               <h3>
                  PseudoVersionTimestampFormat 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PseudoVersionTimestampFormat = "20060102150405"</code></pre>
            </article>
            
            <article class="global" data-name="badWindowsNames">
               <h3>
                  badWindowsNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>badWindowsNames are the reserved file path elements on Windows.
See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file</p>
               
               <pre><code>var badWindowsNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="errPseudoSyntax">
               <h3>
                  errPseudoSyntax 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errPseudoSyntax = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="filePath">
               <h3>
                  filePath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const filePath</code></pre>
            </article>
            
            <article class="global" data-name="importPath">
               <h3>
                  importPath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const importPath</code></pre>
            </article>
            
            <article class="global" data-name="modulePath">
               <h3>
                  modulePath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const modulePath pathKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="pseudoVersionRE">
               <h3>
                  pseudoVersionRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pseudoVersionRE = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="pathKind">
               <h3>
                  pathKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>pathKind indicates what kind of path we're checking. Module paths,
import paths, and file paths have different restrictions.</p>
               
               <pre><code>type pathKind int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="InvalidPathError">
               <h3>
                  InvalidPathError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An InvalidPathError indicates a module, import, or file path doesn't
satisfy all naming constraints. See [CheckPath], [CheckImportPath],
and [CheckFilePath] for specific restrictions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InvalidPathError struct {
Kind string
Path string
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="InvalidVersionError">
               <h3>
                  InvalidVersionError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An InvalidVersionError indicates an error specific to a version, with the
module path unknown or specified externally.
A [ModuleError] may wrap an InvalidVersionError, but an InvalidVersionError
must not wrap a ModuleError.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InvalidVersionError struct {
Version string
Pseudo bool
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="ModuleError">
               <h3>
                  ModuleError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ModuleError indicates an error specific to a module.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ModuleError struct {
Path string
Version string
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="Version">
               <h3>
                  Version
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Version (for clients, a module.Version) is defined by a module path and version pair.
These are stored in their plain (unescaped) form.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Version struct {
Path string
Version string `json:",omitempty"`
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="CanonicalVersion">
               <h3>
                  CanonicalVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CanonicalVersion returns the canonical form of the version string v.
It is the same as [semver.Canonical] except that it preserves the special build suffix "+incompatible".</p>
               
               <pre><code>func CanonicalVersion(v string) string</code></pre>
            </article>
            
            <article class="function" data-name="Check">
               <h3>
                  Check 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Check checks that a given module path, version pair is valid.
In addition to the path being a valid module path
and the version being a valid semantic version,
the two must correspond.
For example, the path "yaml/v2" only corresponds to
semantic versions beginning with "v2.".</p>
               
               <pre><code>func Check(path string, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckFilePath">
               <h3>
                  CheckFilePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckFilePath checks that a slash-separated file path is valid.
The definition of a valid file path is the same as the definition
of a valid import path except that the set of allowed characters is larger:
all Unicode letters, ASCII digits, the ASCII space character (U+0020),
and the ASCII punctuation characters
“!#$%&()+,-.=@[]^_{}~”.
(The excluded punctuation characters, " * < > ? ` ' | / \ and :,
have special meanings in certain shells or operating systems.)
CheckFilePath may be less restrictive in the future, but see the
top-level package documentation for additional information about
subtleties of Unicode.</p>
               
               <pre><code>func CheckFilePath(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckImportPath">
               <h3>
                  CheckImportPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckImportPath checks that an import path is valid.
A valid import path consists of one or more valid path elements
separated by slashes (U+002F). (It must not begin with nor end in a slash.)
A valid path element is a non-empty string made up of
ASCII letters, ASCII digits, and limited ASCII punctuation: - . _ and ~.
It must not end with a dot (U+002E), nor contain two dots in a row.
The element prefix up to the first dot must not be a reserved file name
on Windows, regardless of case (CON, com1, NuL, and so on). The element
must not have a suffix of a tilde followed by one or more ASCII digits
(to exclude paths elements that look like Windows short-names).
CheckImportPath may be less restrictive in the future, but see the
top-level package documentation for additional information about
subtleties of Unicode.</p>
               
               <pre><code>func CheckImportPath(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckPath">
               <h3>
                  CheckPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckPath checks that a module path is valid.
A valid module path is a valid import path, as checked by [CheckImportPath],
with three additional constraints.
First, the leading path element (up to the first slash, if any),
by convention a domain name, must contain only lower-case ASCII letters,
ASCII digits, dots (U+002E), and dashes (U+002D);
it must contain at least one dot and cannot start with a dash.
Second, for a final path element of the form /vN, where N looks numeric
(ASCII digits and dots) must not begin with a leading zero, must not be /v1,
and must not contain any dots. For paths beginning with "gopkg.in/",
this second requirement is replaced by a requirement that the path
follow the gopkg.in server's conventions.
Third, no path element may begin with a dot.</p>
               
               <pre><code>func CheckPath(path string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckPathMajor">
               <h3>
                  CheckPathMajor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckPathMajor returns a non-nil error if the semantic version v
does not match the path major version pathMajor.</p>
               
               <pre><code>func CheckPathMajor(v string, pathMajor string) error</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ModuleError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *InvalidVersionError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *InvalidPathError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="EscapePath">
               <h3>
                  EscapePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EscapePath returns the escaped form of the given module path.
It fails if the module path is invalid.</p>
               
               <pre><code>func EscapePath(path string) (escaped string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="EscapeVersion">
               <h3>
                  EscapeVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EscapeVersion returns the escaped form of the given module version.
Versions are allowed to be in non-semver form but must be valid file names
and not contain exclamation marks.</p>
               
               <pre><code>func EscapeVersion(v string) (escaped string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="IsPseudoVersion">
               <h3>
                  IsPseudoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsPseudoVersion reports whether v is a pseudo-version.</p>
               
               <pre><code>func IsPseudoVersion(v string) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsZeroPseudoVersion">
               <h3>
                  IsZeroPseudoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsZeroPseudoVersion returns whether v is a pseudo-version with a zero base,
timestamp, and revision, as returned by [ZeroPseudoVersion].</p>
               
               <pre><code>func IsZeroPseudoVersion(v string) bool</code></pre>
            </article>
            
            <article class="function" data-name="MatchPathMajor">
               <h3>
                  MatchPathMajor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MatchPathMajor reports whether the semantic version v
matches the path major version pathMajor.
MatchPathMajor returns true if and only if [CheckPathMajor] returns nil.</p>
               
               <pre><code>func MatchPathMajor(v string, pathMajor string) bool</code></pre>
            </article>
            
            <article class="function" data-name="MatchPrefixPatterns">
               <h3>
                  MatchPrefixPatterns 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MatchPrefixPatterns reports whether any path prefix of target matches one of
the glob patterns (as defined by [path.Match]) in the comma-separated globs
list. This implements the algorithm used when matching a module path to the
GOPRIVATE environment variable, as described by 'go help module-private'.
It ignores any empty or malformed patterns in the list.
Trailing slashes on patterns are ignored.</p>
               
               <pre><code>func MatchPrefixPatterns(globs string, target string) bool</code></pre>
            </article>
            
            <article class="function" data-name="PathMajorPrefix">
               <h3>
                  PathMajorPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PathMajorPrefix returns the major-version tag prefix implied by pathMajor.
An empty PathMajorPrefix allows either v0 or v1.
Note that [MatchPathMajor] may accept some versions that do not actually begin
with this prefix: namely, it accepts a 'v0.0.0-' prefix for a '.v1'
pathMajor, even though that pathMajor implies 'v1' tagging.</p>
               
               <pre><code>func PathMajorPrefix(pathMajor string) string</code></pre>
            </article>
            
            <article class="function" data-name="PseudoVersion">
               <h3>
                  PseudoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PseudoVersion returns a pseudo-version for the given major version ("v1")
preexisting older tagged version ("" or "v1.2.3" or "v1.2.3-pre"), revision time,
and revision identifier (usually a 12-byte commit hash prefix).</p>
               
               <pre><code>func PseudoVersion(major string, older string, t time.Time, rev string) string</code></pre>
            </article>
            
            <article class="function" data-name="PseudoVersionBase">
               <h3>
                  PseudoVersionBase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PseudoVersionBase returns the canonical parent version, if any, upon which
the pseudo-version v is based.
If v has no parent version (that is, if it is "vX.0.0-[…]"),
PseudoVersionBase returns the empty string and a nil error.</p>
               
               <pre><code>func PseudoVersionBase(v string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="PseudoVersionRev">
               <h3>
                  PseudoVersionRev 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PseudoVersionRev returns the revision identifier of the pseudo-version v.
It returns an error if v is not a pseudo-version.</p>
               
               <pre><code>func PseudoVersionRev(v string) (rev string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="PseudoVersionTime">
               <h3>
                  PseudoVersionTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PseudoVersionTime returns the time stamp of the pseudo-version v.
It returns an error if v is not a pseudo-version or if the time stamp
embedded in the pseudo-version is not a valid time.</p>
               
               <pre><code>func PseudoVersionTime(v string) (time.Time, error)</code></pre>
            </article>
            
            <article class="function" data-name="Sort">
               <h3>
                  Sort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sort sorts the list by Path, breaking ties by comparing [Version] fields.
The Version fields are interpreted as semantic versions (using [semver.Compare])
optionally followed by a tie-breaking suffix introduced by a slash character,
like in "v0.0.1/go.mod".</p>
               
               <pre><code>func Sort(list []Version)</code></pre>
            </article>
            
            <article class="function" data-name="SplitPathVersion">
               <h3>
                  SplitPathVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitPathVersion returns prefix and major version such that prefix+pathMajor == path
and version is either empty or "/vN" for N >= 2.
As a special case, gopkg.in paths are recognized directly;
they require ".vN" instead of "/vN", and for all N, not just N >= 2.
SplitPathVersion returns with ok = false when presented with
a path whose last path element does not satisfy the constraints
applied by [CheckPath], such as "example.com/pkg/v1" or "example.com/pkg/v1.2".</p>
               
               <pre><code>func SplitPathVersion(path string) (prefix string, pathMajor string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a representation of the Version suitable for logging
(Path@Version, or just Path if Version is empty).</p>
               
               <pre><code>func (m Version) String() string</code></pre>
            </article>
            
            <article class="function" data-name="UnescapePath">
               <h3>
                  UnescapePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UnescapePath returns the module path for the given escaped path.
It fails if the escaped path is invalid or describes an invalid path.</p>
               
               <pre><code>func UnescapePath(escaped string) (path string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="UnescapeVersion">
               <h3>
                  UnescapeVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UnescapeVersion returns the version string for the given escaped version.
It fails if the escaped form is invalid or describes an invalid version.
Versions are allowed to be in non-semver form but must be valid file names
and not contain exclamation marks.</p>
               
               <pre><code>func UnescapeVersion(escaped string) (v string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *InvalidPathError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *InvalidVersionError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ModuleError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="VersionError">
               <h3>
                  VersionError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>VersionError returns a [ModuleError] derived from a [Version] and error,
or err itself if it is already such an error.</p>
               
               <pre><code>func VersionError(v Version, err error) error</code></pre>
            </article>
            
            <article class="function" data-name="ZeroPseudoVersion">
               <h3>
                  ZeroPseudoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ZeroPseudoVersion returns a pseudo-version with a zero timestamp and
revision, which may be used as a placeholder.</p>
               
               <pre><code>func ZeroPseudoVersion(major string) string</code></pre>
            </article>
            
            <article class="function" data-name="checkElem">
               <h3>
                  checkElem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkElem checks whether an individual path element is valid.</p>
               
               <pre><code>func checkElem(elem string, kind pathKind) error</code></pre>
            </article>
            
            <article class="function" data-name="checkPath">
               <h3>
                  checkPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkPath checks that a general path is valid. kind indicates what
specific constraints should be applied.
checkPath returns an error describing why the path is not valid.
Because these checks apply to module, import, and file paths,
and because other checks may be applied, the caller is expected to wrap
this error with [InvalidPathError].</p>
               
               <pre><code>func checkPath(path string, kind pathKind) error</code></pre>
            </article>
            
            <article class="function" data-name="decDecimal">
               <h3>
                  decDecimal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decDecimal returns the decimal string decremented by 1, or the empty string
if the decimal is all zeroes.</p>
               
               <pre><code>func decDecimal(decimal string) string</code></pre>
            </article>
            
            <article class="function" data-name="escapeString">
               <h3>
                  escapeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func escapeString(s string) (escaped string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="fileNameOK">
               <h3>
                  fileNameOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fileNameOK reports whether r can appear in a file name.
For now we allow all Unicode letters but otherwise limit to pathOK plus a few more punctuation characters.
If we expand the set of allowed characters here, we have to
work harder at detecting potential case-folding and normalization collisions.
See note about "escaped paths" above.</p>
               
               <pre><code>func fileNameOK(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="firstPathOK">
               <h3>
                  firstPathOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>firstPathOK reports whether r can appear in the first element of a module path.
The first element of the path must be an LDH domain name, at least for now.
To avoid case ambiguity, the domain name must be entirely lower case.</p>
               
               <pre><code>func firstPathOK(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="importPathOK">
               <h3>
                  importPathOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>importPathOK reports whether r can appear in a package import path element.
Import paths are intermediate between module paths and file paths: we allow
disallow characters that would be confusing or ambiguous as arguments to
'go get' (such as '@' and ' ' ), but allow certain characters that are
otherwise-unambiguous on the command line and historically used for some
binary names (such as '++' as a suffix for compiler binaries and wrappers).</p>
               
               <pre><code>func importPathOK(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="incDecimal">
               <h3>
                  incDecimal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>incDecimal returns the decimal string incremented by 1.</p>
               
               <pre><code>func incDecimal(decimal string) string</code></pre>
            </article>
            
            <article class="function" data-name="modPathOK">
               <h3>
                  modPathOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>modPathOK reports whether r can appear in a module path element.
Paths can be ASCII letters, ASCII digits, and limited ASCII punctuation: - . _ and ~.
This matches what "go get" has historically recognized in import paths,
and avoids confusing sequences like '%20' or '+' that would change meaning
if used in a URL.
TODO(rsc): We would like to allow Unicode letters, but that requires additional
care in the safe encoding (see "escaped paths" above).</p>
               
               <pre><code>func modPathOK(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="noun">
               <h3>
                  noun 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>noun returns either "version" or "pseudo-version", depending on whether
e.Version is a pseudo-version.</p>
               
               <pre><code>func (e *InvalidVersionError) noun() string</code></pre>
            </article>
            
            <article class="function" data-name="parsePseudoVersion">
               <h3>
                  parsePseudoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parsePseudoVersion(v string) (base string, timestamp string, rev string, build string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="splitGopkgIn">
               <h3>
                  splitGopkgIn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitGopkgIn is like SplitPathVersion but only for gopkg.in paths.</p>
               
               <pre><code>func splitGopkgIn(path string) (prefix string, pathMajor string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="unescapeString">
               <h3>
                  unescapeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unescapeString(escaped string) (string, bool)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
