<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - logopt</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>logopt</code>
         </h1>
         <hr />
         
         <article class="global" data-name="SeverityInformation">
            <h2>SeverityInformation</h2>
            <hr />
            
            <p>SeverityInformation defined:
	 * Reports an information.</p>
            
            <pre><code>SeverityInformation DiagnosticSeverity</code></pre>
         </article>
         
         <article class="global" data-name="None">
            <h2>None</h2>
            <hr />
            
            <pre><code>None logFormat</code></pre>
         </article>
         
         <article class="global" data-name="Json0">
            <h2>Json0</h2>
            <hr />
            
            <pre><code>Json0</code></pre>
         </article>
         
         <article class="global" data-name="Format">
            <h2>Format</h2>
            <hr />
            
            <pre><code>Format</code></pre>
         </article>
         
         <article class="global" data-name="dest">
            <h2>dest</h2>
            <hr />
            
            <pre><code>dest string</code></pre>
         </article>
         
         <article class="global" data-name="loggedOpts">
            <h2>loggedOpts</h2>
            <hr />
            
            <pre><code>loggedOpts []*LoggedOpt</code></pre>
         </article>
         
         <article class="global" data-name="mu">
            <h2>mu</h2>
            <hr />
            
            <pre><code>mu</code></pre>
         </article>
         
         <article class="global" data-name="srcCode">
            <h2>srcCode</h2>
            <hr />
            
            <pre><code>srcCode</code></pre>
         </article>
          
         <article class="struct" data-name="VersionHeader">
            <h2>type VersionHeader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Version int
Package string
Goos string
Goarch string
GcVersion string
File string</code></pre>
         </article>
         
         <article class="struct" data-name="Position">
            <h2>type Position struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Line uint
Character uint</code></pre>
         </article>
         
         <article class="struct" data-name="Range">
            <h2>type Range struct</h2>
            <hr />
            
            <p>A Range in a text document expressed as (zero-based) start and end positions.
A range is comparable to a selection in an editor. Therefore the end position is exclusive.
If you want to specify a range that contains a line including the line ending character(s)
then use an end position denoting the start of the next line.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Start Position
End Position</code></pre>
         </article>
         
         <article class="struct" data-name="Location">
            <h2>type Location struct</h2>
            <hr />
            
            <p>A Location represents a location inside a resource, such as a line inside a text file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">URI DocumentURI
Range Range</code></pre>
         </article>
         
         <article class="struct" data-name="DiagnosticRelatedInformation">
            <h2>type DiagnosticRelatedInformation struct</h2>
            <hr />
            
            <p>DiagnosticRelatedInformation defined:
 * Represents a related message and source code location for a diagnostic. This should be
 * used to point to code locations that cause or related to a diagnostics, e.g when duplicating
 * a symbol in a scope.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Location Location
Message string</code></pre>
         </article>
         
         <article class="struct" data-name="Diagnostic">
            <h2>type Diagnostic struct</h2>
            <hr />
            
            <p>Diagnostic defined:
 * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
 * are only valid in the scope of a resource.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Range Range
Severity DiagnosticSeverity
Code string
Source string
Message string
Tags []DiagnosticTag
RelatedInformation []DiagnosticRelatedInformation</code></pre>
         </article>
         
         <article class="struct" data-name="LoggedOpt">
            <h2>type LoggedOpt struct</h2>
            <hr />
            
            <p>A LoggedOpt is what the compiler produces and accumulates,
to be converted to JSON for human or IDE consumption.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos src.XPos
lastPos src.XPos
compilerPass string
functionName string
what string
target []*ast.InterfaceType</code></pre>
         </article>
         
         <article class="struct" data-name="byPos">
            <h2>type byPos struct</h2>
            <hr />
            
            <p>byPos sorts diagnostics by source position.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctxt *obj.Link
a []*LoggedOpt</code></pre>
         </article>
          
         <article class="function" data-name="LogJsonOption">
            <h2>LogJsonOption</h2>
            <hr />
            
            <p>LogJsonOption parses and validates the version,directory value attached to the -json compiler flag.</p>
            
            <pre><code>func LogJsonOption(flagValue string)</code></pre>
         </article>
         
         <article class="function" data-name="parseLogFlag">
            <h2>parseLogFlag</h2>
            <hr />
            
            <p>parseLogFlag checks the flag passed to -json
for version,destination format and returns the two parts.</p>
            
            <pre><code>func parseLogFlag(flag string, value string) (version int, directory string)</code></pre>
         </article>
         
         <article class="function" data-name="isWindowsDriveURIPath">
            <h2>isWindowsDriveURIPath</h2>
            <hr />
            
            <p>isWindowsDriveURIPath returns true if the file URI is of the format used by
Windows URIs. The url.Parse package does not specially handle Windows paths
(see golang/go#6027), so we check if the URI path has a drive prefix (e.g. "/C:").
(copied from tools/internal/span/uri.go)
this is less comprehensive that the processing in filepath.IsAbs on Windows.</p>
            
            <pre><code>func isWindowsDriveURIPath(uri string) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseLogPath">
            <h2>parseLogPath</h2>
            <hr />
            
            <pre><code>func parseLogPath(destination string) (string, string)</code></pre>
         </article>
         
         <article class="function" data-name="checkLogPath">
            <h2>checkLogPath</h2>
            <hr />
            
            <p>checkLogPath does superficial early checking of the string specifying
the directory to which optimizer logging is directed, and if
it passes the test, stores the string in LO_dir.</p>
            
            <pre><code>func checkLogPath(destination string) string</code></pre>
         </article>
         
         <article class="function" data-name="NewLoggedOpt">
            <h2>NewLoggedOpt</h2>
            <hr />
            
            <p>NewLoggedOpt allocates a new LoggedOpt, to later be passed to either NewLoggedOpt or LogOpt as "args".
Pos is the source position (including inlining), what is the message, pass is which pass created the message,
funcName is the name of the function
A typical use for this to accumulate an explanation for a missed optimization, for example, why did something escape?</p>
            
            <pre><code>func NewLoggedOpt(pos src.XPos, lastPos src.XPos, what string, pass string, funcName string, args ...*ast.InterfaceType) *LoggedOpt</code></pre>
         </article>
         
         <article class="function" data-name="LogOpt">
            <h2>LogOpt</h2>
            <hr />
            
            <p>LogOpt logs information about a (usually missed) optimization performed by the compiler.
Pos is the source position (including inlining), what is the message, pass is which pass created the message,
funcName is the name of the function.</p>
            
            <pre><code>func LogOpt(pos src.XPos, what string, pass string, funcName string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="LogOptRange">
            <h2>LogOptRange</h2>
            <hr />
            
            <p>LogOptRange is the same as LogOpt, but includes the ability to express a range of positions,
not just a point.</p>
            
            <pre><code>func LogOptRange(pos src.XPos, lastPos src.XPos, what string, pass string, funcName string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Enabled">
            <h2>Enabled</h2>
            <hr />
            
            <p>Enabled returns whether optimization logging is enabled.</p>
            
            <pre><code>func Enabled() bool</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="writerForLSP">
            <h2>writerForLSP</h2>
            <hr />
            
            <pre><code>func writerForLSP(subdirpath string, file string) io.WriteCloser</code></pre>
         </article>
         
         <article class="function" data-name="fixSlash">
            <h2>fixSlash</h2>
            <hr />
            
            <pre><code>func fixSlash(f string) string</code></pre>
         </article>
         
         <article class="function" data-name="uriIfy">
            <h2>uriIfy</h2>
            <hr />
            
            <pre><code>func uriIfy(f string) DocumentURI</code></pre>
         </article>
         
         <article class="function" data-name="uprootedPath">
            <h2>uprootedPath</h2>
            <hr />
            
            <p>Return filename, replacing a first occurrence of $GOROOT with the
actual value of the GOROOT (because LSP does not speak "$GOROOT").</p>
            
            <pre><code>func uprootedPath(filename string) string</code></pre>
         </article>
         
         <article class="function" data-name="FlushLoggedOpts">
            <h2>FlushLoggedOpts</h2>
            <hr />
            
            <p>FlushLoggedOpts flushes all the accumulated optimization log entries.</p>
            
            <pre><code>func FlushLoggedOpts(ctxt *obj.Link, slashPkgPath string)</code></pre>
         </article>
         
         <article class="function" data-name="newRange">
            <h2>newRange</h2>
            <hr />
            
            <p>newRange returns a single-position Range for the compiler source location p.</p>
            
            <pre><code>func newRange(p src.Pos, last src.Pos) Range</code></pre>
         </article>
         
         <article class="function" data-name="newLocation">
            <h2>newLocation</h2>
            <hr />
            
            <p>newLocation returns the Location for the compiler source location p.</p>
            
            <pre><code>func newLocation(p src.Pos, last src.Pos) Location</code></pre>
         </article>
         
         <article class="function" data-name="appendInlinedPos">
            <h2>appendInlinedPos</h2>
            <hr />
            
            <p>appendInlinedPos extracts inlining information from posTmp and append it to diagnostic.</p>
            
            <pre><code>func appendInlinedPos(posTmp []src.Pos, lastTmp []src.Pos, diagnostic *Diagnostic)</code></pre>
         </article>
         
         <article class="function" data-name="parsePos">
            <h2>parsePos</h2>
            <hr />
            
            <p>parsePos expands a src.XPos into a slice of src.Pos, with the outermost first.
It returns the slice, and the outermost.</p>
            
            <pre><code>func parsePos(ctxt *obj.Link, pos src.XPos, posTmp []src.Pos) ([]src.Pos, src.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="want">
            <h2>want</h2>
            <hr />
            
            <pre><code>func want(t *testing.T, out string, desired string)</code></pre>
         </article>
         
         <article class="function" data-name="wantN">
            <h2>wantN</h2>
            <hr />
            
            <pre><code>func wantN(t *testing.T, out string, desired string, n int)</code></pre>
         </article>
         
         <article class="function" data-name="TestPathStuff">
            <h2>TestPathStuff</h2>
            <hr />
            
            <pre><code>func TestPathStuff(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLogOpt">
            <h2>TestLogOpt</h2>
            <hr />
            
            <pre><code>func TestLogOpt(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testLogOpt">
            <h2>testLogOpt</h2>
            <hr />
            
            <pre><code>func testLogOpt(t *testing.T, flag string, src string, outfile string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="testLogOptDir">
            <h2>testLogOptDir</h2>
            <hr />
            
            <pre><code>func testLogOptDir(t *testing.T, dir string, flag string, src string, outfile string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="testCopy">
            <h2>testCopy</h2>
            <hr />
            
            <pre><code>func testCopy(t *testing.T, dir string, goarch string, goos string, src string, outfile string) (string, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
