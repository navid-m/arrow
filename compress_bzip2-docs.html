<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>bzip2 - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>bzip2</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bufio"
"io"
"io"
"cmp"
"slices"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="bzip2BlockMagic" data-name="bzip2BlockMagic">
               <h3>
                  bzip2BlockMagic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bzip2BlockMagic" class="anchor" title="Link to bzip2BlockMagic">#</a>
               </h3>
               
               <pre><code class="language-go">const bzip2BlockMagic = 0x314159265359</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bzip2FileMagic" data-name="bzip2FileMagic">
               <h3>
                  bzip2FileMagic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bzip2FileMagic" class="anchor" title="Link to bzip2FileMagic">#</a>
               </h3>
               
               <pre><code class="language-go">const bzip2FileMagic = 0x425a</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bzip2FinalMagic" data-name="bzip2FinalMagic">
               <h3>
                  bzip2FinalMagic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bzip2FinalMagic" class="anchor" title="Link to bzip2FinalMagic">#</a>
               </h3>
               
               <pre><code class="language-go">const bzip2FinalMagic = 0x177245385090</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="crctab" data-name="crctab">
               <h3>
                  crctab 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#crctab" class="anchor" title="Link to crctab">#</a>
               </h3>
               
               <pre><code class="language-go">var crctab [256]uint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidNodeValue" data-name="invalidNodeValue">
               <h3>
                  invalidNodeValue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidNodeValue" class="anchor" title="Link to invalidNodeValue">#</a>
               </h3>
               
                  <p class="doc-comment">invalidNodeValue is an invalid index which marks a leaf node in the tree.</p>
               
               <pre><code class="language-go">const invalidNodeValue = 0xffff</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="StructuralError" data-name="StructuralError">
               <h3>
                  StructuralError
                  <span class="badge type-badge">type</span>
                  <a href="#StructuralError" class="anchor" title="Link to StructuralError">#</a>
               </h3>
               
               <p>A StructuralError is returned when the bzip2 data is found to be
syntactically invalid.</p>
               
               <pre><code class="language-go">type StructuralError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="moveToFrontDecoder" data-name="moveToFrontDecoder">
               <h3>
                  moveToFrontDecoder
                  <span class="badge type-badge">type</span>
                  <a href="#moveToFrontDecoder" class="anchor" title="Link to moveToFrontDecoder">#</a>
               </h3>
               
               <p>moveToFrontDecoder implements a move-to-front list. Such a list is an
efficient way to transform a string with repeating elements into one with
many small valued numbers, which is suitable for entropy encoding. It works
by starting with an initial list of symbols and references symbols by their
index into that list. When a symbol is referenced, it's moved to the front
of the list. Thus, a repeated symbol ends up being encoded with many zeros,
as the symbol will be at the front of the list after the first access.</p>
               
               <pre><code class="language-go">type moveToFrontDecoder []byte</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="bitReader" data-name="bitReader">
               <h3>
                  bitReader
                  <span class="badge">struct</span>
                  <a href="#bitReader" class="anchor" title="Link to bitReader">#</a>
               </h3>
               
               <p>bitReader wraps an io.Reader and provides the ability to read values,
bit-by-bit, from it. Its Read* methods don't return the usual error
because the error handling was verbose. Instead, any error is kept and can
be checked afterwards.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type bitReader struct {
r io.ByteReader
n uint64
bits uint
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="huffmanCode" data-name="huffmanCode">
               <h3>
                  huffmanCode
                  <span class="badge">struct</span>
                  <a href="#huffmanCode" class="anchor" title="Link to huffmanCode">#</a>
               </h3>
               
               <p>huffmanCode contains a symbol, its code and code length.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type huffmanCode struct {
code uint32
codeLen uint8
value uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="huffmanNode" data-name="huffmanNode">
               <h3>
                  huffmanNode
                  <span class="badge">struct</span>
                  <a href="#huffmanNode" class="anchor" title="Link to huffmanNode">#</a>
               </h3>
               
               <p>A huffmanNode is a node in the tree. left and right contain indexes into the
nodes slice of the tree. If left or right is invalidNodeValue then the child
is a left node and its value is in leftValue/rightValue.
The symbols are uint16s because bzip2 encodes not only MTF indexes in the
tree, but also two magic values for run-length encoding and an EOF symbol.
Thus there are more than 256 possible symbols.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type huffmanNode struct {
left uint16
right uint16
leftValue uint16
rightValue uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="huffmanSymbolLengthPair" data-name="huffmanSymbolLengthPair">
               <h3>
                  huffmanSymbolLengthPair
                  <span class="badge">struct</span>
                  <a href="#huffmanSymbolLengthPair" class="anchor" title="Link to huffmanSymbolLengthPair">#</a>
               </h3>
               
               <p>huffmanSymbolLengthPair contains a symbol and its code length.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type huffmanSymbolLengthPair struct {
value uint16
length uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="huffmanTree" data-name="huffmanTree">
               <h3>
                  huffmanTree
                  <span class="badge">struct</span>
                  <a href="#huffmanTree" class="anchor" title="Link to huffmanTree">#</a>
               </h3>
               
               <p>A huffmanTree is a binary tree which is navigated, bit-by-bit to reach a
symbol.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type huffmanTree struct {
nodes []huffmanNode
nextNode int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="reader" data-name="reader">
               <h3>
                  reader
                  <span class="badge">struct</span>
                  <a href="#reader" class="anchor" title="Link to reader">#</a>
               </h3>
               
               <p>A reader decompresses bzip2 compressed data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type reader struct {
br bitReader
fileCRC uint32
blockCRC uint32
wantBlockCRC uint32
setupDone bool
eof bool
blockSize int
c [256]uint
tt []uint32
tPos uint32
preRLE []uint32
preRLEUsed int
lastByte int
byteRepeats uint
repeats uint
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Decode" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Decode" class="anchor" title="Link to Decode">#</a>
               </h3>
               
               <p>Decode reads bits from the given bitReader and navigates the tree until a
symbol is found.</p>
               
               <pre><code class="language-go">func (t *huffmanTree) Decode(br *bitReader) (v uint16)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Decode" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Decode" class="anchor" title="Link to Decode">#</a>
               </h3>
               
               <pre><code class="language-go">func (m moveToFrontDecoder) Decode(n int) (b byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <pre><code class="language-go">func (br *bitReader) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (s StructuralError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="First" data-name="First">
               <h3>
                  First 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#First" class="anchor" title="Link to First">#</a>
               </h3>
               
               <p>First returns the symbol at the front of the list.</p>
               
               <pre><code class="language-go">func (m moveToFrontDecoder) First() byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader returns an io.Reader which decompresses bzip2 data from r.
If r does not also implement [io.ByteReader],
the decompressor may read more data than necessary from r.</p>
               
               <pre><code class="language-go">func NewReader(r io.Reader) io.Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (bz2 *reader) Read(buf []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadBit" data-name="ReadBit">
               <h3>
                  ReadBit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadBit" class="anchor" title="Link to ReadBit">#</a>
               </h3>
               
               <pre><code class="language-go">func (br *bitReader) ReadBit() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadBits" data-name="ReadBits">
               <h3>
                  ReadBits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadBits" class="anchor" title="Link to ReadBits">#</a>
               </h3>
               
               <pre><code class="language-go">func (br *bitReader) ReadBits(bits uint) (n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadBits64" data-name="ReadBits64">
               <h3>
                  ReadBits64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadBits64" class="anchor" title="Link to ReadBits64">#</a>
               </h3>
               
               <p>ReadBits64 reads the given number of bits and returns them in the
least-significant part of a uint64. In the event of an error, it returns 0
and the error can be obtained by calling bitReader.Err().</p>
               
               <pre><code class="language-go">func (br *bitReader) ReadBits64(bits uint) (n uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildHuffmanNode" data-name="buildHuffmanNode">
               <h3>
                  buildHuffmanNode 
                  <span class="badge">function</span>
                  
                  <a href="#buildHuffmanNode" class="anchor" title="Link to buildHuffmanNode">#</a>
               </h3>
               
               <p>buildHuffmanNode takes a slice of sorted huffmanCodes and builds a node in
the Huffman tree at the given level. It returns the index of the newly
constructed node.</p>
               
               <pre><code class="language-go">func buildHuffmanNode(t *huffmanTree, codes []huffmanCode, level uint32) (nodeIndex uint16, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inverseBWT" data-name="inverseBWT">
               <h3>
                  inverseBWT 
                  <span class="badge">function</span>
                  
                  <a href="#inverseBWT" class="anchor" title="Link to inverseBWT">#</a>
               </h3>
               
               <p>inverseBWT implements the inverse Burrows-Wheeler transform as described in
http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf, section 4.2.
In that document, origPtr is called “I” and c is the “C” array after the
first pass over the data. It's an argument here because we merge the first
pass with the Huffman decoding.
This also implements the “single array” method from the bzip2 source code
which leaves the output, still shuffled, in the bottom 8 bits of tt with the
index of the next byte in the top 24-bits. The index of the first byte is
returned.</p>
               
               <pre><code class="language-go">func inverseBWT(tt []uint32, origPtr uint, c []uint) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newBitReader" data-name="newBitReader">
               <h3>
                  newBitReader 
                  <span class="badge">function</span>
                  
                  <a href="#newBitReader" class="anchor" title="Link to newBitReader">#</a>
               </h3>
               
               <p>newBitReader returns a new bitReader reading from r. If r is not
already an io.ByteReader, it will be converted via a bufio.Reader.</p>
               
               <pre><code class="language-go">func newBitReader(r io.Reader) bitReader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newHuffmanTree" data-name="newHuffmanTree">
               <h3>
                  newHuffmanTree 
                  <span class="badge">function</span>
                  
                  <a href="#newHuffmanTree" class="anchor" title="Link to newHuffmanTree">#</a>
               </h3>
               
               <p>newHuffmanTree builds a Huffman tree from a slice containing the code
lengths of each symbol. The maximum code length is 32 bits.</p>
               
               <pre><code class="language-go">func newHuffmanTree(lengths []uint8) (huffmanTree, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newMTFDecoder" data-name="newMTFDecoder">
               <h3>
                  newMTFDecoder 
                  <span class="badge">function</span>
                  
                  <a href="#newMTFDecoder" class="anchor" title="Link to newMTFDecoder">#</a>
               </h3>
               
               <p>newMTFDecoder creates a move-to-front decoder with an explicit initial list
of symbols.</p>
               
               <pre><code class="language-go">func newMTFDecoder(symbols []byte) moveToFrontDecoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newMTFDecoderWithRange" data-name="newMTFDecoderWithRange">
               <h3>
                  newMTFDecoderWithRange 
                  <span class="badge">function</span>
                  
                  <a href="#newMTFDecoderWithRange" class="anchor" title="Link to newMTFDecoderWithRange">#</a>
               </h3>
               
               <p>newMTFDecoderWithRange creates a move-to-front decoder with an initial
symbol list of 0...n-1.</p>
               
               <pre><code class="language-go">func newMTFDecoderWithRange(n int) moveToFrontDecoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <pre><code class="language-go">func (bz2 *reader) read(buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readBlock" data-name="readBlock">
               <h3>
                  readBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readBlock" class="anchor" title="Link to readBlock">#</a>
               </h3>
               
               <p>readBlock reads a bzip2 block. The magic number should already have been consumed.</p>
               
               <pre><code class="language-go">func (bz2 *reader) readBlock() (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFromBlock" data-name="readFromBlock">
               <h3>
                  readFromBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFromBlock" class="anchor" title="Link to readFromBlock">#</a>
               </h3>
               
               <pre><code class="language-go">func (bz2 *reader) readFromBlock(buf []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setup" data-name="setup">
               <h3>
                  setup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setup" class="anchor" title="Link to setup">#</a>
               </h3>
               
               <p>setup parses the bzip2 header.</p>
               
               <pre><code class="language-go">func (bz2 *reader) setup(needMagic bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateCRC" data-name="updateCRC">
               <h3>
                  updateCRC 
                  <span class="badge">function</span>
                  
                  <a href="#updateCRC" class="anchor" title="Link to updateCRC">#</a>
               </h3>
               
               <p>updateCRC updates the crc value to incorporate the data in b.
The initial value is 0.</p>
               
               <pre><code class="language-go">func updateCRC(val uint32, b []byte) uint32</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>