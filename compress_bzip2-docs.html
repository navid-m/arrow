<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bzip2</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>bzip2</code>
         </h1>
         <hr />
         
         <article class="global" data-name="bzip2FileMagic">
            <h2>bzip2FileMagic</h2>
            <hr />
            
            <pre><code>bzip2FileMagic</code></pre>
         </article>
         
         <article class="global" data-name="bzip2BlockMagic">
            <h2>bzip2BlockMagic</h2>
            <hr />
            
            <pre><code>bzip2BlockMagic</code></pre>
         </article>
         
         <article class="global" data-name="bzip2FinalMagic">
            <h2>bzip2FinalMagic</h2>
            <hr />
            
            <pre><code>bzip2FinalMagic</code></pre>
         </article>
         
         <article class="global" data-name="crctab">
            <h2>crctab</h2>
            <hr />
            
            <pre><code>crctab []uint32</code></pre>
         </article>
         
         <article class="global" data-name="digits">
            <h2>digits</h2>
            <hr />
            
            <pre><code>digits</code></pre>
         </article>
         
         <article class="global" data-name="newton">
            <h2>newton</h2>
            <hr />
            
            <pre><code>newton</code></pre>
         </article>
         
         <article class="global" data-name="random">
            <h2>random</h2>
            <hr />
            
            <pre><code>random</code></pre>
         </article>
         
         <article class="global" data-name="invalidNodeValue">
            <h2>invalidNodeValue</h2>
            <hr />
            
            <p>invalidNodeValue is an invalid index which marks a leaf node in the tree.</p>
            
            <pre><code>invalidNodeValue</code></pre>
         </article>
          
         <article class="struct" data-name="bitReader">
            <h2>type bitReader struct</h2>
            <hr />
            
            <p>bitReader wraps an io.Reader and provides the ability to read values,
bit-by-bit, from it. Its Read* methods don't return the usual error
because the error handling was verbose. Instead, any error is kept and can
be checked afterwards.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.ByteReader
n uint64
bits uint
err error</code></pre>
         </article>
         
         <article class="struct" data-name="reader">
            <h2>type reader struct</h2>
            <hr />
            
            <p>A reader decompresses bzip2 compressed data.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">br bitReader
fileCRC uint32
blockCRC uint32
wantBlockCRC uint32
setupDone bool
eof bool
blockSize int
c []uint
tt []uint32
tPos uint32
preRLE []uint32
preRLEUsed int
lastByte int
byteRepeats uint
repeats uint</code></pre>
         </article>
         
         <article class="struct" data-name="huffmanTree">
            <h2>type huffmanTree struct</h2>
            <hr />
            
            <p>A huffmanTree is a binary tree which is navigated, bit-by-bit to reach a
symbol.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nodes []huffmanNode
nextNode int</code></pre>
         </article>
         
         <article class="struct" data-name="huffmanNode">
            <h2>type huffmanNode struct</h2>
            <hr />
            
            <p>A huffmanNode is a node in the tree. left and right contain indexes into the
nodes slice of the tree. If left or right is invalidNodeValue then the child
is a left node and its value is in leftValue/rightValue.

The symbols are uint16s because bzip2 encodes not only MTF indexes in the
tree, but also two magic values for run-length encoding and an EOF symbol.
Thus there are more than 256 possible symbols.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">left uint16
right uint16
leftValue uint16
rightValue uint16</code></pre>
         </article>
         
         <article class="struct" data-name="huffmanSymbolLengthPair">
            <h2>type huffmanSymbolLengthPair struct</h2>
            <hr />
            
            <p>huffmanSymbolLengthPair contains a symbol and its code length.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">value uint16
length uint8</code></pre>
         </article>
         
         <article class="struct" data-name="huffmanCode">
            <h2>type huffmanCode struct</h2>
            <hr />
            
            <p>huffmanCode contains a symbol, its code and code length.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">code uint32
codeLen uint8
value uint16</code></pre>
         </article>
          
         <article class="function" data-name="newBitReader">
            <h2>newBitReader</h2>
            <hr />
            
            <p>newBitReader returns a new bitReader reading from r. If r is not
already an io.ByteReader, it will be converted via a bufio.Reader.</p>
            
            <pre><code>func newBitReader(r io.Reader) bitReader</code></pre>
         </article>
         
         <article class="function" data-name="ReadBits64">
            <h2>ReadBits64</h2>
            <hr />
            
            <p>ReadBits64 reads the given number of bits and returns them in the
least-significant part of a uint64. In the event of an error, it returns 0
and the error can be obtained by calling bitReader.Err().</p>
            
            <pre><code>func ReadBits64(bits uint) n uint64</code></pre>
         </article>
         
         <article class="function" data-name="ReadBits">
            <h2>ReadBits</h2>
            <hr />
            
            <pre><code>func ReadBits(bits uint) n int</code></pre>
         </article>
         
         <article class="function" data-name="ReadBit">
            <h2>ReadBit</h2>
            <hr />
            
            <pre><code>func ReadBit() bool</code></pre>
         </article>
         
         <article class="function" data-name="Err">
            <h2>Err</h2>
            <hr />
            
            <pre><code>func Err() error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="NewReader">
            <h2>NewReader</h2>
            <hr />
            
            <p>NewReader returns an io.Reader which decompresses bzip2 data from r.
If r does not also implement [io.ByteReader],
the decompressor may read more data than necessary from r.</p>
            
            <pre><code>func NewReader(r io.Reader) io.Reader</code></pre>
         </article>
         
         <article class="function" data-name="setup">
            <h2>setup</h2>
            <hr />
            
            <p>setup parses the bzip2 header.</p>
            
            <pre><code>func setup(needMagic bool) error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(buf []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readFromBlock">
            <h2>readFromBlock</h2>
            <hr />
            
            <pre><code>func readFromBlock(buf []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="read">
            <h2>read</h2>
            <hr />
            
            <pre><code>func read(buf []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="readBlock">
            <h2>readBlock</h2>
            <hr />
            
            <p>readBlock reads a bzip2 block. The magic number should already have been consumed.</p>
            
            <pre><code>func readBlock() err error</code></pre>
         </article>
         
         <article class="function" data-name="inverseBWT">
            <h2>inverseBWT</h2>
            <hr />
            
            <p>inverseBWT implements the inverse Burrows-Wheeler transform as described in
http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf, section 4.2.
In that document, origPtr is called “I” and c is the “C” array after the
first pass over the data. It's an argument here because we merge the first
pass with the Huffman decoding.

This also implements the “single array” method from the bzip2 source code
which leaves the output, still shuffled, in the bottom 8 bits of tt with the
index of the next byte in the top 24-bits. The index of the first byte is
returned.</p>
            
            <pre><code>func inverseBWT(tt []uint32, origPtr uint, c []uint) uint32</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="updateCRC">
            <h2>updateCRC</h2>
            <hr />
            
            <p>updateCRC updates the crc value to incorporate the data in b.
The initial value is 0.</p>
            
            <pre><code>func updateCRC(val uint32, b []byte) uint32</code></pre>
         </article>
         
         <article class="function" data-name="mustDecodeHex">
            <h2>mustDecodeHex</h2>
            <hr />
            
            <pre><code>func mustDecodeHex(s string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="mustLoadFile">
            <h2>mustLoadFile</h2>
            <hr />
            
            <pre><code>func mustLoadFile(f string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="trim">
            <h2>trim</h2>
            <hr />
            
            <pre><code>func trim(b []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="TestReader">
            <h2>TestReader</h2>
            <hr />
            
            <pre><code>func TestReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBitReader">
            <h2>TestBitReader</h2>
            <hr />
            
            <pre><code>func TestBitReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMTF">
            <h2>TestMTF</h2>
            <hr />
            
            <pre><code>func TestMTF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestZeroRead">
            <h2>TestZeroRead</h2>
            <hr />
            
            <pre><code>func TestZeroRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkDecode">
            <h2>benchmarkDecode</h2>
            <hr />
            
            <pre><code>func benchmarkDecode(b *testing.B, compressed []byte)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeDigits">
            <h2>BenchmarkDecodeDigits</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeDigits(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeNewton">
            <h2>BenchmarkDecodeNewton</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeNewton(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeRand">
            <h2>BenchmarkDecodeRand</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeRand(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <p>Decode reads bits from the given bitReader and navigates the tree until a
symbol is found.</p>
            
            <pre><code>func Decode(br *bitReader) v uint16</code></pre>
         </article>
         
         <article class="function" data-name="newHuffmanTree">
            <h2>newHuffmanTree</h2>
            <hr />
            
            <p>newHuffmanTree builds a Huffman tree from a slice containing the code
lengths of each symbol. The maximum code length is 32 bits.</p>
            
            <pre><code>func newHuffmanTree(lengths []uint8) (huffmanTree, error)</code></pre>
         </article>
         
         <article class="function" data-name="buildHuffmanNode">
            <h2>buildHuffmanNode</h2>
            <hr />
            
            <p>buildHuffmanNode takes a slice of sorted huffmanCodes and builds a node in
the Huffman tree at the given level. It returns the index of the newly
constructed node.</p>
            
            <pre><code>func buildHuffmanNode(t *huffmanTree, codes []huffmanCode, level uint32) (nodeIndex uint16, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newMTFDecoder">
            <h2>newMTFDecoder</h2>
            <hr />
            
            <p>newMTFDecoder creates a move-to-front decoder with an explicit initial list
of symbols.</p>
            
            <pre><code>func newMTFDecoder(symbols []byte) moveToFrontDecoder</code></pre>
         </article>
         
         <article class="function" data-name="newMTFDecoderWithRange">
            <h2>newMTFDecoderWithRange</h2>
            <hr />
            
            <p>newMTFDecoderWithRange creates a move-to-front decoder with an initial
symbol list of 0...n-1.</p>
            
            <pre><code>func newMTFDecoderWithRange(n int) moveToFrontDecoder</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <pre><code>func Decode(n int) b byte</code></pre>
         </article>
         
         <article class="function" data-name="First">
            <h2>First</h2>
            <hr />
            
            <p>First returns the symbol at the front of the list.</p>
            
            <pre><code>func First() byte</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
