<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - src</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>src</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"bytes"
"fmt"
"io"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="FileSymPrefix" data-name="FileSymPrefix">
               <h3>
                  FileSymPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FileSymPrefix" class="anchor" title="Link to FileSymPrefix">#</a>
               </h3>
               
               <p>FileSymPrefix is the linker symbol prefix that used to be used for
linker pseudo-symbols representing file names.</p>
               
               <pre><code>const FileSymPrefix = "gofile.."</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoPos" data-name="NoPos">
               <h3>
                  NoPos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#NoPos" class="anchor" title="Link to NoPos">#</a>
               </h3>
               
               <p>NoPos is a valid unknown position.</p>
               
               <pre><code>var NoPos Pos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoXPos" data-name="NoXPos">
               <h3>
                  NoXPos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#NoXPos" class="anchor" title="Link to NoXPos">#</a>
               </h3>
               
               <p>NoXPos is a valid unknown position.</p>
               
               <pre><code>var NoXPos XPos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PosDefaultLogue" data-name="PosDefaultLogue">
               <h3>
                  PosDefaultLogue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PosDefaultLogue" class="anchor" title="Link to PosDefaultLogue">#</a>
               </h3>
               
               <pre><code>const PosDefaultLogue PosXlogue = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PosDefaultStmt" data-name="PosDefaultStmt">
               <h3>
                  PosDefaultStmt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PosDefaultStmt" class="anchor" title="Link to PosDefaultStmt">#</a>
               </h3>
               
               <p>It is expected that the front end or a phase in SSA will usually generate positions tagged with
PosDefaultStmt, but note statement boundaries with PosIsStmt.  Simple statements will have a single
boundary; for loops with initialization may have one for their entry and one for their back edge
(this depends on exactly how the loop is compiled; the intent is to provide a good experience to a
user debugging a program; the goal is that a breakpoint set on the loop line fires both on entry
and on iteration).  Proper treatment of non-gofmt input with multiple simple statements on a single
line is TBD.
Optimizing compilation will move instructions around, and some of these will become known-bad as
step targets for debugging purposes (examples: register spills and reloads; code generated into
the entry block; invariant code hoisted out of loops) but those instructions will still have interesting
positions for profiling purposes. To reflect this these positions will be changed to PosNotStmt.
When the optimizer removes an instruction marked PosIsStmt; it should attempt to find a nearby
instruction with the same line marked PosDefaultStmt to be the new statement boundary.  I.e., the
optimizer should make a best-effort to conserve statement boundary positions, and might be enhanced
to note when a statement boundary is not conserved.
Code cloning, e.g. loop unrolling or loop unswitching, is an exception to the conservation rule
because a user running a debugger would expect to see breakpoints active in the copies of the code.
In non-optimizing compilation there is still a role for PosNotStmt because of code generation
into the entry block.  PosIsStmt statement positions should be conserved.
When code generation occurs any remaining default-marked positions are replaced with not-statement
positions.</p>
               
               <pre><code>const PosDefaultStmt uint = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PosEpilogueBegin" data-name="PosEpilogueBegin">
               <h3>
                  PosEpilogueBegin 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PosEpilogueBegin" class="anchor" title="Link to PosEpilogueBegin">#</a>
               </h3>
               
               <pre><code>const PosEpilogueBegin</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PosIsStmt" data-name="PosIsStmt">
               <h3>
                  PosIsStmt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PosIsStmt" class="anchor" title="Link to PosIsStmt">#</a>
               </h3>
               
               <pre><code>const PosIsStmt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PosNotStmt" data-name="PosNotStmt">
               <h3>
                  PosNotStmt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PosNotStmt" class="anchor" title="Link to PosNotStmt">#</a>
               </h3>
               
               <pre><code>const PosNotStmt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PosPrologueEnd" data-name="PosPrologueEnd">
               <h3>
                  PosPrologueEnd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PosPrologueEnd" class="anchor" title="Link to PosPrologueEnd">#</a>
               </h3>
               
               <pre><code>const PosPrologueEnd</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bogusLine" data-name="bogusLine">
               <h3>
                  bogusLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bogusLine" class="anchor" title="Link to bogusLine">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const bogusLine = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="colBits" data-name="colBits">
               <h3>
                  colBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#colBits" class="anchor" title="Link to colBits">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const colBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="colMax" data-name="colMax">
               <h3>
                  colMax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#colMax" class="anchor" title="Link to colMax">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const colMax = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="colShift" data-name="colShift">
               <h3>
                  colShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#colShift" class="anchor" title="Link to colShift">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const colShift = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isStmtBits" data-name="isStmtBits">
               <h3>
                  isStmtBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#isStmtBits" class="anchor" title="Link to isStmtBits">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const isStmtBits = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isStmtMask" data-name="isStmtMask">
               <h3>
                  isStmtMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#isStmtMask" class="anchor" title="Link to isStmtMask">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const isStmtMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isStmtMax" data-name="isStmtMax">
               <h3>
                  isStmtMax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#isStmtMax" class="anchor" title="Link to isStmtMax">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const isStmtMax = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isStmtShift" data-name="isStmtShift">
               <h3>
                  isStmtShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#isStmtShift" class="anchor" title="Link to isStmtShift">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const isStmtShift = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lineBits" data-name="lineBits">
               <h3>
                  lineBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#lineBits" class="anchor" title="Link to lineBits">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const lineBits = 20</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lineMax" data-name="lineMax">
               <h3>
                  lineMax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#lineMax" class="anchor" title="Link to lineMax">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const lineMax = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lineShift" data-name="lineShift">
               <h3>
                  lineShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#lineShift" class="anchor" title="Link to lineShift">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const lineShift = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noPos" data-name="noPos">
               <h3>
                  noPos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#noPos" class="anchor" title="Link to noPos">#</a>
               </h3>
               
               <pre><code>var noPos Pos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xlogueBits" data-name="xlogueBits">
               <h3>
                  xlogueBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xlogueBits" class="anchor" title="Link to xlogueBits">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const xlogueBits = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xlogueMask" data-name="xlogueMask">
               <h3>
                  xlogueMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xlogueMask" class="anchor" title="Link to xlogueMask">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const xlogueMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xlogueMax" data-name="xlogueMax">
               <h3>
                  xlogueMax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xlogueMax" class="anchor" title="Link to xlogueMax">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const xlogueMax = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xlogueShift" data-name="xlogueShift">
               <h3>
                  xlogueShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xlogueShift" class="anchor" title="Link to xlogueShift">#</a>
               </h3>
               
               <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
               
               <pre><code>const xlogueShift = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="PosXlogue" data-name="PosXlogue">
               <h3>
                  PosXlogue
                  <span class="badge type-badge">type</span>
                  <a href="#PosXlogue" class="anchor" title="Link to PosXlogue">#</a>
               </h3>
               
               <pre><code>type PosXlogue uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="lico" data-name="lico">
               <h3>
                  lico
                  <span class="badge type-badge">type</span>
                  <a href="#lico" class="anchor" title="Link to lico">#</a>
               </h3>
               
               <p>A lico is a compact encoding of a LIne and COlumn number.</p>
               
               <pre><code>type lico uint32</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos
                  <span class="badge">struct</span>
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <p>A Pos encodes a source position consisting of a (line, column) number pair
and a position base. A zero Pos is a ready to use "unknown" position (nil
position base and zero line number).
The (line, column) values refer to a position in a file independent of any
position base ("absolute" file position).
The position base is used to determine the "relative" position, that is the
filename and line number relative to the position base. If the base refers
to the current file, there is no difference between absolute and relative
positions. If it refers to a //line directive, a relative position is relative
to that directive. A position base in turn contains the position at which it
was introduced in the current file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Pos struct {
base *PosBase
lico
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PosBase" data-name="PosBase">
               <h3>
                  PosBase
                  <span class="badge">struct</span>
                  <a href="#PosBase" class="anchor" title="Link to PosBase">#</a>
               </h3>
               
               <p>A PosBase encodes a filename and base position.
Typically, each file and line directive introduce a PosBase.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PosBase struct {
pos Pos
filename string
absFilename string
line uint
col uint
inl int
fileIndex int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PosTable" data-name="PosTable">
               <h3>
                  PosTable
                  <span class="badge">struct</span>
                  <a href="#PosTable" class="anchor" title="Link to PosTable">#</a>
               </h3>
               
               <p>A PosTable tracks Pos -> XPos conversions and vice versa.
Its zero value is a ready-to-use PosTable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PosTable struct {
baseList []*PosBase
indexMap map[*PosBase]int
nameMap map[string]int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="XPos" data-name="XPos">
               <h3>
                  XPos
                  <span class="badge">struct</span>
                  <a href="#XPos" class="anchor" title="Link to XPos">#</a>
               </h3>
               
               <p>XPos is a more compact representation of Pos.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XPos struct {
index int32
lico
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AbsFilename" data-name="AbsFilename">
               <h3>
                  AbsFilename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AbsFilename" class="anchor" title="Link to AbsFilename">#</a>
               </h3>
               
               <p>AbsFilename returns the absolute filename recorded with the base.
If b == nil, the result is the empty string.</p>
               
               <pre><code>func (b *PosBase) AbsFilename() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AbsFilename" data-name="AbsFilename">
               <h3>
                  AbsFilename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AbsFilename" class="anchor" title="Link to AbsFilename">#</a>
               </h3>
               
               <p>AbsFilename() returns the absolute filename recorded with the position's base.</p>
               
               <pre><code>func (p Pos) AbsFilename() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="After" data-name="After">
               <h3>
                  After 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#After" class="anchor" title="Link to After">#</a>
               </h3>
               
               <p>After reports whether the position p comes after q in the source.
For positions with different bases, ordering is by base index.</p>
               
               <pre><code>func (p XPos) After(q XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="After" data-name="After">
               <h3>
                  After 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#After" class="anchor" title="Link to After">#</a>
               </h3>
               
               <p>After reports whether the position p comes after q in the source.
For positions in different files, ordering is by filename.</p>
               
               <pre><code>func (p Pos) After(q Pos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AtColumn1" data-name="AtColumn1">
               <h3>
                  AtColumn1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AtColumn1" class="anchor" title="Link to AtColumn1">#</a>
               </h3>
               
               <p>AtColumn1 returns the same location but shifted to column 1.</p>
               
               <pre><code>func (p XPos) AtColumn1() XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Base" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Base" class="anchor" title="Link to Base">#</a>
               </h3>
               
               <p>Base returns the position base.</p>
               
               <pre><code>func (p Pos) Base() *PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Before" data-name="Before">
               <h3>
                  Before 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Before" class="anchor" title="Link to Before">#</a>
               </h3>
               
               <p>Before reports whether the position p comes before q in the source.
For positions with different bases, ordering is by base index.</p>
               
               <pre><code>func (p XPos) Before(q XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Before" data-name="Before">
               <h3>
                  Before 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Before" class="anchor" title="Link to Before">#</a>
               </h3>
               
               <p>Before reports whether the position p comes before q in the source.
For positions in different files, ordering is by filename.</p>
               
               <pre><code>func (p Pos) Before(q Pos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Col" data-name="Col">
               <h3>
                  Col 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Col" class="anchor" title="Link to Col">#</a>
               </h3>
               
               <pre><code>func (x lico) Col() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Col" data-name="Col">
               <h3>
                  Col 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Col" class="anchor" title="Link to Col">#</a>
               </h3>
               
               <p>Col returns the column number recorded with the base.
If b == nil, the result is 0.</p>
               
               <pre><code>func (b *PosBase) Col() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileIndex" data-name="FileIndex">
               <h3>
                  FileIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FileIndex" class="anchor" title="Link to FileIndex">#</a>
               </h3>
               
               <p>FileIndex returns the index of the base's absolute filename within
its PosTable's FileTable. It panics if it hasn't been registered
with a PosTable. If b == nil, the result is -1.</p>
               
               <pre><code>func (b *PosBase) FileIndex() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileIndex" data-name="FileIndex">
               <h3>
                  FileIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FileIndex" class="anchor" title="Link to FileIndex">#</a>
               </h3>
               
               <p>FileIndex returns the file index of the position's base's absolute
filename within the PosTable that it was registered.</p>
               
               <pre><code>func (p Pos) FileIndex() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileIndex" data-name="FileIndex">
               <h3>
                  FileIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FileIndex" class="anchor" title="Link to FileIndex">#</a>
               </h3>
               
               <p>FileIndex returns a smallish non-negative integer corresponding to the
file for this source position.  Smallish is relative; it can be thousands
large, but not millions.</p>
               
               <pre><code>func (p XPos) FileIndex() int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileTable" data-name="FileTable">
               <h3>
                  FileTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FileTable" class="anchor" title="Link to FileTable">#</a>
               </h3>
               
               <p>FileTable returns a slice of all files used to build this package.</p>
               
               <pre><code>func (t *PosTable) FileTable() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Filename" data-name="Filename">
               <h3>
                  Filename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Filename" class="anchor" title="Link to Filename">#</a>
               </h3>
               
               <p>Filename returns the filename recorded with the base.
If b == nil, the result is the empty string.</p>
               
               <pre><code>func (b *PosBase) Filename() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Filename" data-name="Filename">
               <h3>
                  Filename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Filename" class="anchor" title="Link to Filename">#</a>
               </h3>
               
               <p>Filename returns the name of the actual file containing this position.</p>
               
               <pre><code>func (p Pos) Filename() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format formats a position as "filename:line" or "filename:line:column",
controlled by the showCol flag and if the column is known (!= 0).
For positions relative to line directives, the original position is
shown as well, as in "filename:line[origfile:origline:origcolumn]" if
showOrig is set.</p>
               
               <pre><code>func (p Pos) Format(showCol bool, showOrig bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InliningIndex" data-name="InliningIndex">
               <h3>
                  InliningIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InliningIndex" class="anchor" title="Link to InliningIndex">#</a>
               </h3>
               
               <p>InliningIndex returns the index into the global inlining
tree recorded with the base. If b == nil or the base has
not been inlined, the result is < 0.</p>
               
               <pre><code>func (b *PosBase) InliningIndex() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsKnown" data-name="IsKnown">
               <h3>
                  IsKnown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsKnown" class="anchor" title="Link to IsKnown">#</a>
               </h3>
               
               <p>IsKnown reports whether the position p is known.
XPos.IsKnown() matches Pos.IsKnown() for corresponding
positions.</p>
               
               <pre><code>func (p XPos) IsKnown() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsKnown" data-name="IsKnown">
               <h3>
                  IsKnown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsKnown" class="anchor" title="Link to IsKnown">#</a>
               </h3>
               
               <p>IsKnown reports whether the position p is known.
A position is known if it either has a non-nil
position base, or a non-zero line number.</p>
               
               <pre><code>func (p Pos) IsKnown() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsStmt" data-name="IsStmt">
               <h3>
                  IsStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsStmt" class="anchor" title="Link to IsStmt">#</a>
               </h3>
               
               <pre><code>func (x lico) IsStmt() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Line" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Line" class="anchor" title="Link to Line">#</a>
               </h3>
               
               <pre><code>func (x lico) Line() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Line" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Line" class="anchor" title="Link to Line">#</a>
               </h3>
               
               <p>Line returns the line number recorded with the base.
If b == nil, the result is 0.</p>
               
               <pre><code>func (b *PosBase) Line() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LineNumber" data-name="LineNumber">
               <h3>
                  LineNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LineNumber" class="anchor" title="Link to LineNumber">#</a>
               </h3>
               
               <p>LineNumber returns a string for the line number, "?" if it is not known.</p>
               
               <pre><code>func (p XPos) LineNumber() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LineNumber" data-name="LineNumber">
               <h3>
                  LineNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LineNumber" class="anchor" title="Link to LineNumber">#</a>
               </h3>
               
               <pre><code>func (p Pos) LineNumber() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LineNumberHTML" data-name="LineNumberHTML">
               <h3>
                  LineNumberHTML 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LineNumberHTML" class="anchor" title="Link to LineNumberHTML">#</a>
               </h3>
               
               <pre><code>func (p XPos) LineNumberHTML() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LineNumberHTML" data-name="LineNumberHTML">
               <h3>
                  LineNumberHTML 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LineNumberHTML" class="anchor" title="Link to LineNumberHTML">#</a>
               </h3>
               
               <pre><code>func (p Pos) LineNumberHTML() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakePos" data-name="MakePos">
               <h3>
                  MakePos 
                  <span class="badge">function</span>
                  
                  <a href="#MakePos" class="anchor" title="Link to MakePos">#</a>
               </h3>
               
               <p>MakePos creates a new Pos value with the given base, and (file-absolute)
line and column.</p>
               
               <pre><code>func MakePos(base *PosBase, line uint, col uint) Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFileBase" data-name="NewFileBase">
               <h3>
                  NewFileBase 
                  <span class="badge">function</span>
                  
                  <a href="#NewFileBase" class="anchor" title="Link to NewFileBase">#</a>
               </h3>
               
               <p>NewFileBase returns a new *PosBase for a file with the given (relative and
absolute) filenames.</p>
               
               <pre><code>func NewFileBase(filename string, absFilename string) *PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewInliningBase" data-name="NewInliningBase">
               <h3>
                  NewInliningBase 
                  <span class="badge">function</span>
                  
                  <a href="#NewInliningBase" class="anchor" title="Link to NewInliningBase">#</a>
               </h3>
               
               <p>NewInliningBase returns a copy of the orig PosBase with the given inlining
index. If orig == nil, NewInliningBase panics.</p>
               
               <pre><code>func NewInliningBase(orig *PosBase, inlTreeIndex int) *PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewLinePragmaBase" data-name="NewLinePragmaBase">
               <h3>
                  NewLinePragmaBase 
                  <span class="badge">function</span>
                  
                  <a href="#NewLinePragmaBase" class="anchor" title="Link to NewLinePragmaBase">#</a>
               </h3>
               
               <p>NewLinePragmaBase returns a new *PosBase for a line directive of the form
//line filename:line:col
/*line filename:line:col
at position pos.</p>
               
               <pre><code>func NewLinePragmaBase(pos Pos, filename string, absFilename string, line uint, col uint) *PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <p>Pos returns the position at which base is located.
If b == nil, the result is the zero position.</p>
               
               <pre><code>func (b *PosBase) Pos() *Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <p>Pos returns the corresponding Pos for the given p.
If p cannot be translated via t, the function panics.</p>
               
               <pre><code>func (t *PosTable) Pos(p XPos) Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RelCol" data-name="RelCol">
               <h3>
                  RelCol 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RelCol" class="anchor" title="Link to RelCol">#</a>
               </h3>
               
               <p>RelCol returns the column number relative to the position's base.</p>
               
               <pre><code>func (p Pos) RelCol() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RelFilename" data-name="RelFilename">
               <h3>
                  RelFilename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RelFilename" class="anchor" title="Link to RelFilename">#</a>
               </h3>
               
               <p>RelFilename returns the filename recorded with the position's base.</p>
               
               <pre><code>func (p Pos) RelFilename() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RelLine" data-name="RelLine">
               <h3>
                  RelLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RelLine" class="anchor" title="Link to RelLine">#</a>
               </h3>
               
               <p>RelLine returns the line number relative to the position's base.</p>
               
               <pre><code>func (p Pos) RelLine() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SameFile" data-name="SameFile">
               <h3>
                  SameFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SameFile" class="anchor" title="Link to SameFile">#</a>
               </h3>
               
               <p>SameFile reports whether p and q are positions in the same file.</p>
               
               <pre><code>func (p XPos) SameFile(q XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SameFileAndLine" data-name="SameFileAndLine">
               <h3>
                  SameFileAndLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SameFileAndLine" class="anchor" title="Link to SameFileAndLine">#</a>
               </h3>
               
               <p>SameFileAndLine reports whether p and q are positions on the same line in the same file.</p>
               
               <pre><code>func (p XPos) SameFileAndLine(q XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SameLine" data-name="SameLine">
               <h3>
                  SameLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SameLine" class="anchor" title="Link to SameLine">#</a>
               </h3>
               
               <pre><code>func (x lico) SameLine(y lico) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBase" data-name="SetBase">
               <h3>
                  SetBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBase" class="anchor" title="Link to SetBase">#</a>
               </h3>
               
               <p>SetBase sets the position base.</p>
               
               <pre><code>func (p *Pos) SetBase(base *PosBase)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p Pos) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithBogusLine" data-name="WithBogusLine">
               <h3>
                  WithBogusLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithBogusLine" class="anchor" title="Link to WithBogusLine">#</a>
               </h3>
               
               <p>WithBogusLine returns a bogus line that won't match any recorded for the source code.
Its use is to disrupt the statements within an infinite loop so that the debugger
will not itself loop infinitely waiting for the line number to change.
gdb chooses not to display the bogus line; delve shows it with a complaint, but the
alternative behavior is to hang.</p>
               
               <pre><code>func (p XPos) WithBogusLine() XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithDefaultStmt" data-name="WithDefaultStmt">
               <h3>
                  WithDefaultStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithDefaultStmt" class="anchor" title="Link to WithDefaultStmt">#</a>
               </h3>
               
               <p>WithDefaultStmt returns the same location with undetermined is_stmt</p>
               
               <pre><code>func (p XPos) WithDefaultStmt() XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithIsStmt" data-name="WithIsStmt">
               <h3>
                  WithIsStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithIsStmt" class="anchor" title="Link to WithIsStmt">#</a>
               </h3>
               
               <p>WithIsStmt returns the same location to be marked with DWARF is_stmt=1</p>
               
               <pre><code>func (p XPos) WithIsStmt() XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithNotStmt" data-name="WithNotStmt">
               <h3>
                  WithNotStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithNotStmt" class="anchor" title="Link to WithNotStmt">#</a>
               </h3>
               
               <p>WithNotStmt returns the same location to be marked with DWARF is_stmt=0</p>
               
               <pre><code>func (p XPos) WithNotStmt() XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithXlogue" data-name="WithXlogue">
               <h3>
                  WithXlogue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithXlogue" class="anchor" title="Link to WithXlogue">#</a>
               </h3>
               
               <p>WithXlogue returns the same location but marked with DWARF function prologue/epilogue</p>
               
               <pre><code>func (p XPos) WithXlogue(x PosXlogue) XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo a position to w, formatted as Format does.</p>
               
               <pre><code>func (p Pos) WriteTo(w io.Writer, showCol bool, showOrig bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XPos" data-name="XPos">
               <h3>
                  XPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#XPos" class="anchor" title="Link to XPos">#</a>
               </h3>
               
               <p>XPos returns the corresponding XPos for the given pos,
adding pos to t if necessary.</p>
               
               <pre><code>func (t *PosTable) XPos(pos Pos) XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Xlogue" data-name="Xlogue">
               <h3>
                  Xlogue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Xlogue" class="anchor" title="Link to Xlogue">#</a>
               </h3>
               
               <pre><code>func (x lico) Xlogue() PosXlogue</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atColumn1" data-name="atColumn1">
               <h3>
                  atColumn1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#atColumn1" class="anchor" title="Link to atColumn1">#</a>
               </h3>
               
               <pre><code>func (x lico) atColumn1() lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="baseIndex" data-name="baseIndex">
               <h3>
                  baseIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#baseIndex" class="anchor" title="Link to baseIndex">#</a>
               </h3>
               
               <pre><code>func (t *PosTable) baseIndex(base *PosBase) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="format" data-name="format">
               <h3>
                  format 
                  <span class="badge">function</span>
                  
                  <a href="#format" class="anchor" title="Link to format">#</a>
               </h3>
               
               <p>format formats a (filename, line, col) tuple as "filename:line" (showCol
is false or col == 0) or "filename:line:column" (showCol is true and col != 0).</p>
               
               <pre><code>func format(w io.Writer, filename string, line uint, col uint, showCol bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatstr" data-name="formatstr">
               <h3>
                  formatstr 
                  <span class="badge">function</span>
                  
                  <a href="#formatstr" class="anchor" title="Link to formatstr">#</a>
               </h3>
               
               <p>formatstr wraps format to return a string.</p>
               
               <pre><code>func formatstr(filename string, line uint, col uint, showCol bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineNumber" data-name="lineNumber">
               <h3>
                  lineNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lineNumber" class="anchor" title="Link to lineNumber">#</a>
               </h3>
               
               <pre><code>func (x lico) lineNumber() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineNumberHTML" data-name="lineNumberHTML">
               <h3>
                  lineNumberHTML 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lineNumberHTML" class="anchor" title="Link to lineNumberHTML">#</a>
               </h3>
               
               <pre><code>func (x lico) lineNumberHTML() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeBogusLico" data-name="makeBogusLico">
               <h3>
                  makeBogusLico 
                  <span class="badge">function</span>
                  
                  <a href="#makeBogusLico" class="anchor" title="Link to makeBogusLico">#</a>
               </h3>
               
               <p>This is a not-position that will not be elided.
Depending on the debugger (gdb or delve) it may or may not be displayed.</p>
               
               <pre><code>func makeBogusLico() lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeLico" data-name="makeLico">
               <h3>
                  makeLico 
                  <span class="badge">function</span>
                  
                  <a href="#makeLico" class="anchor" title="Link to makeLico">#</a>
               </h3>
               
               <pre><code>func makeLico(line uint, col uint) lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeLicoRaw" data-name="makeLicoRaw">
               <h3>
                  makeLicoRaw 
                  <span class="badge">function</span>
                  
                  <a href="#makeLicoRaw" class="anchor" title="Link to makeLicoRaw">#</a>
               </h3>
               
               <pre><code>func makeLicoRaw(line uint, col uint) lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withDefaultStmt" data-name="withDefaultStmt">
               <h3>
                  withDefaultStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withDefaultStmt" class="anchor" title="Link to withDefaultStmt">#</a>
               </h3>
               
               <p>withDefaultStmt returns a lico for the same location, with default isStmt</p>
               
               <pre><code>func (x lico) withDefaultStmt() lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withIsStmt" data-name="withIsStmt">
               <h3>
                  withIsStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withIsStmt" class="anchor" title="Link to withIsStmt">#</a>
               </h3>
               
               <p>withIsStmt returns a lico for the same location, tagged as definitely a statement</p>
               
               <pre><code>func (x lico) withIsStmt() lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withNotStmt" data-name="withNotStmt">
               <h3>
                  withNotStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withNotStmt" class="anchor" title="Link to withNotStmt">#</a>
               </h3>
               
               <p>withNotStmt returns a lico for the same location, but not a statement</p>
               
               <pre><code>func (x lico) withNotStmt() lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withStmt" data-name="withStmt">
               <h3>
                  withStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withStmt" class="anchor" title="Link to withStmt">#</a>
               </h3>
               
               <p>withStmt returns a lico for the same location with specified is_stmt attribute</p>
               
               <pre><code>func (x lico) withStmt(stmt uint) lico</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withXlogue" data-name="withXlogue">
               <h3>
                  withXlogue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withXlogue" class="anchor" title="Link to withXlogue">#</a>
               </h3>
               
               <p>withXlogue attaches a prologue/epilogue attribute to a lico</p>
               
               <pre><code>func (x lico) withXlogue(xlogue PosXlogue) lico</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>