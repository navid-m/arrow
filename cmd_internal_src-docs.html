<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - src</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>src</code>
         </h1>
         <hr />
         
         <article class="global" data-name="NoPos">
            <h2>NoPos</h2>
            <hr />
            
            <p>NoPos is a valid unknown position.</p>
            
            <pre><code>NoPos Pos</code></pre>
         </article>
         
         <article class="global" data-name="noPos">
            <h2>noPos</h2>
            <hr />
            
            <pre><code>noPos Pos</code></pre>
         </article>
         
         <article class="global" data-name="FileSymPrefix">
            <h2>FileSymPrefix</h2>
            <hr />
            
            <p>FileSymPrefix is the linker symbol prefix that used to be used for
linker pseudo-symbols representing file names.</p>
            
            <pre><code>FileSymPrefix</code></pre>
         </article>
         
         <article class="global" data-name="lineBits">
            <h2>lineBits</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>lineBits</code></pre>
         </article>
         
         <article class="global" data-name="lineMax">
            <h2>lineMax</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>lineMax</code></pre>
         </article>
         
         <article class="global" data-name="bogusLine">
            <h2>bogusLine</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>bogusLine</code></pre>
         </article>
         
         <article class="global" data-name="isStmtBits">
            <h2>isStmtBits</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>isStmtBits</code></pre>
         </article>
         
         <article class="global" data-name="isStmtMax">
            <h2>isStmtMax</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>isStmtMax</code></pre>
         </article>
         
         <article class="global" data-name="xlogueBits">
            <h2>xlogueBits</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>xlogueBits</code></pre>
         </article>
         
         <article class="global" data-name="xlogueMax">
            <h2>xlogueMax</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>xlogueMax</code></pre>
         </article>
         
         <article class="global" data-name="colBits">
            <h2>colBits</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>colBits</code></pre>
         </article>
         
         <article class="global" data-name="colMax">
            <h2>colMax</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>colMax</code></pre>
         </article>
         
         <article class="global" data-name="isStmtShift">
            <h2>isStmtShift</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>isStmtShift</code></pre>
         </article>
         
         <article class="global" data-name="isStmtMask">
            <h2>isStmtMask</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>isStmtMask</code></pre>
         </article>
         
         <article class="global" data-name="xlogueShift">
            <h2>xlogueShift</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>xlogueShift</code></pre>
         </article>
         
         <article class="global" data-name="xlogueMask">
            <h2>xlogueMask</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>xlogueMask</code></pre>
         </article>
         
         <article class="global" data-name="colShift">
            <h2>colShift</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>colShift</code></pre>
         </article>
         
         <article class="global" data-name="lineShift">
            <h2>lineShift</h2>
            <hr />
            
            <p>Layout constants: 20 bits for line, 8 bits for column, 2 for isStmt, 2 for pro/epilogue
(If this is too tight, we can either make lico 64b wide,
or we can introduce a tiered encoding where we remove column
information as line numbers grow bigger; similar to what gcc
does.)
The bitfield order is chosen to make IsStmt be the least significant
part of a position; its use is to communicate statement edges through
instruction scrambling in code generation, not to impose an order.
TODO: Prologue and epilogue are perhaps better handled as pseudo-ops for the assembler,
because they have almost no interaction with other uses of the position.</p>
            
            <pre><code>lineShift</code></pre>
         </article>
         
         <article class="global" data-name="PosDefaultStmt">
            <h2>PosDefaultStmt</h2>
            <hr />
            
            <p>It is expected that the front end or a phase in SSA will usually generate positions tagged with
PosDefaultStmt, but note statement boundaries with PosIsStmt.  Simple statements will have a single
boundary; for loops with initialization may have one for their entry and one for their back edge
(this depends on exactly how the loop is compiled; the intent is to provide a good experience to a
user debugging a program; the goal is that a breakpoint set on the loop line fires both on entry
and on iteration).  Proper treatment of non-gofmt input with multiple simple statements on a single
line is TBD.

Optimizing compilation will move instructions around, and some of these will become known-bad as
step targets for debugging purposes (examples: register spills and reloads; code generated into
the entry block; invariant code hoisted out of loops) but those instructions will still have interesting
positions for profiling purposes. To reflect this these positions will be changed to PosNotStmt.

When the optimizer removes an instruction marked PosIsStmt; it should attempt to find a nearby
instruction with the same line marked PosDefaultStmt to be the new statement boundary.  I.e., the
optimizer should make a best-effort to conserve statement boundary positions, and might be enhanced
to note when a statement boundary is not conserved.

Code cloning, e.g. loop unrolling or loop unswitching, is an exception to the conservation rule
because a user running a debugger would expect to see breakpoints active in the copies of the code.

In non-optimizing compilation there is still a role for PosNotStmt because of code generation
into the entry block.  PosIsStmt statement positions should be conserved.

When code generation occurs any remaining default-marked positions are replaced with not-statement
positions.</p>
            
            <pre><code>PosDefaultStmt uint</code></pre>
         </article>
         
         <article class="global" data-name="PosIsStmt">
            <h2>PosIsStmt</h2>
            <hr />
            
            <pre><code>PosIsStmt</code></pre>
         </article>
         
         <article class="global" data-name="PosNotStmt">
            <h2>PosNotStmt</h2>
            <hr />
            
            <pre><code>PosNotStmt</code></pre>
         </article>
         
         <article class="global" data-name="PosDefaultLogue">
            <h2>PosDefaultLogue</h2>
            <hr />
            
            <pre><code>PosDefaultLogue PosXlogue</code></pre>
         </article>
         
         <article class="global" data-name="PosPrologueEnd">
            <h2>PosPrologueEnd</h2>
            <hr />
            
            <pre><code>PosPrologueEnd</code></pre>
         </article>
         
         <article class="global" data-name="PosEpilogueBegin">
            <h2>PosEpilogueBegin</h2>
            <hr />
            
            <pre><code>PosEpilogueBegin</code></pre>
         </article>
         
         <article class="global" data-name="NoXPos">
            <h2>NoXPos</h2>
            <hr />
            
            <p>NoXPos is a valid unknown position.</p>
            
            <pre><code>NoXPos XPos</code></pre>
         </article>
          
         <article class="struct" data-name="Pos">
            <h2>type Pos struct</h2>
            <hr />
            
            <p>A Pos encodes a source position consisting of a (line, column) number pair
and a position base. A zero Pos is a ready to use "unknown" position (nil
position base and zero line number).

The (line, column) values refer to a position in a file independent of any
position base ("absolute" file position).

The position base is used to determine the "relative" position, that is the
filename and line number relative to the position base. If the base refers
to the current file, there is no difference between absolute and relative
positions. If it refers to a //line directive, a relative position is relative
to that directive. A position base in turn contains the position at which it
was introduced in the current file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">base *PosBase
lico</code></pre>
         </article>
         
         <article class="struct" data-name="PosBase">
            <h2>type PosBase struct</h2>
            <hr />
            
            <p>A PosBase encodes a filename and base position.
Typically, each file and line directive introduce a PosBase.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos Pos
filename string
absFilename string
line uint
col uint
inl int
fileIndex int</code></pre>
         </article>
         
         <article class="struct" data-name="XPos">
            <h2>type XPos struct</h2>
            <hr />
            
            <p>XPos is a more compact representation of Pos.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">index int32
lico</code></pre>
         </article>
         
         <article class="struct" data-name="PosTable">
            <h2>type PosTable struct</h2>
            <hr />
            
            <p>A PosTable tracks Pos -> XPos conversions and vice versa.
Its zero value is a ready-to-use PosTable.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">baseList []*PosBase
indexMap *ast.MapType
nameMap *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="MakePos">
            <h2>MakePos</h2>
            <hr />
            
            <p>MakePos creates a new Pos value with the given base, and (file-absolute)
line and column.</p>
            
            <pre><code>func MakePos(base *PosBase, line uint, col uint) Pos</code></pre>
         </article>
         
         <article class="function" data-name="IsKnown">
            <h2>IsKnown</h2>
            <hr />
            
            <p>IsKnown reports whether the position p is known.
A position is known if it either has a non-nil
position base, or a non-zero line number.</p>
            
            <pre><code>func IsKnown() bool</code></pre>
         </article>
         
         <article class="function" data-name="Before">
            <h2>Before</h2>
            <hr />
            
            <p>Before reports whether the position p comes before q in the source.
For positions in different files, ordering is by filename.</p>
            
            <pre><code>func Before(q Pos) bool</code></pre>
         </article>
         
         <article class="function" data-name="After">
            <h2>After</h2>
            <hr />
            
            <p>After reports whether the position p comes after q in the source.
For positions in different files, ordering is by filename.</p>
            
            <pre><code>func After(q Pos) bool</code></pre>
         </article>
         
         <article class="function" data-name="LineNumber">
            <h2>LineNumber</h2>
            <hr />
            
            <pre><code>func LineNumber() string</code></pre>
         </article>
         
         <article class="function" data-name="LineNumberHTML">
            <h2>LineNumberHTML</h2>
            <hr />
            
            <pre><code>func LineNumberHTML() string</code></pre>
         </article>
         
         <article class="function" data-name="Filename">
            <h2>Filename</h2>
            <hr />
            
            <p>Filename returns the name of the actual file containing this position.</p>
            
            <pre><code>func Filename() string</code></pre>
         </article>
         
         <article class="function" data-name="Base">
            <h2>Base</h2>
            <hr />
            
            <p>Base returns the position base.</p>
            
            <pre><code>func Base() *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="SetBase">
            <h2>SetBase</h2>
            <hr />
            
            <p>SetBase sets the position base.</p>
            
            <pre><code>func SetBase(base *PosBase)</code></pre>
         </article>
         
         <article class="function" data-name="RelFilename">
            <h2>RelFilename</h2>
            <hr />
            
            <p>RelFilename returns the filename recorded with the position's base.</p>
            
            <pre><code>func RelFilename() string</code></pre>
         </article>
         
         <article class="function" data-name="RelLine">
            <h2>RelLine</h2>
            <hr />
            
            <p>RelLine returns the line number relative to the position's base.</p>
            
            <pre><code>func RelLine() uint</code></pre>
         </article>
         
         <article class="function" data-name="RelCol">
            <h2>RelCol</h2>
            <hr />
            
            <p>RelCol returns the column number relative to the position's base.</p>
            
            <pre><code>func RelCol() uint</code></pre>
         </article>
         
         <article class="function" data-name="AbsFilename">
            <h2>AbsFilename</h2>
            <hr />
            
            <p>AbsFilename() returns the absolute filename recorded with the position's base.</p>
            
            <pre><code>func AbsFilename() string</code></pre>
         </article>
         
         <article class="function" data-name="FileIndex">
            <h2>FileIndex</h2>
            <hr />
            
            <p>FileIndex returns the file index of the position's base's absolute
filename within the PosTable that it was registered.</p>
            
            <pre><code>func FileIndex() int</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Format">
            <h2>Format</h2>
            <hr />
            
            <p>Format formats a position as "filename:line" or "filename:line:column",
controlled by the showCol flag and if the column is known (!= 0).
For positions relative to line directives, the original position is
shown as well, as in "filename:line[origfile:origline:origcolumn]" if
showOrig is set.</p>
            
            <pre><code>func Format(showCol bool, showOrig bool) string</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <p>WriteTo a position to w, formatted as Format does.</p>
            
            <pre><code>func WriteTo(w io.Writer, showCol bool, showOrig bool)</code></pre>
         </article>
         
         <article class="function" data-name="format">
            <h2>format</h2>
            <hr />
            
            <p>format formats a (filename, line, col) tuple as "filename:line" (showCol
is false or col == 0) or "filename:line:column" (showCol is true and col != 0).</p>
            
            <pre><code>func format(w io.Writer, filename string, line uint, col uint, showCol bool)</code></pre>
         </article>
         
         <article class="function" data-name="formatstr">
            <h2>formatstr</h2>
            <hr />
            
            <p>formatstr wraps format to return a string.</p>
            
            <pre><code>func formatstr(filename string, line uint, col uint, showCol bool) string</code></pre>
         </article>
         
         <article class="function" data-name="NewFileBase">
            <h2>NewFileBase</h2>
            <hr />
            
            <p>NewFileBase returns a new *PosBase for a file with the given (relative and
absolute) filenames.</p>
            
            <pre><code>func NewFileBase(filename string, absFilename string) *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="NewLinePragmaBase">
            <h2>NewLinePragmaBase</h2>
            <hr />
            
            <p>NewLinePragmaBase returns a new *PosBase for a line directive of the form

	//line filename:line:col
	/*line filename:line:col*/

at position pos.</p>
            
            <pre><code>func NewLinePragmaBase(pos Pos, filename string, absFilename string, line uint, col uint) *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="NewInliningBase">
            <h2>NewInliningBase</h2>
            <hr />
            
            <p>NewInliningBase returns a copy of the orig PosBase with the given inlining
index. If orig == nil, NewInliningBase panics.</p>
            
            <pre><code>func NewInliningBase(orig *PosBase, inlTreeIndex int) *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <p>Pos returns the position at which base is located.
If b == nil, the result is the zero position.</p>
            
            <pre><code>func Pos() *Pos</code></pre>
         </article>
         
         <article class="function" data-name="Filename">
            <h2>Filename</h2>
            <hr />
            
            <p>Filename returns the filename recorded with the base.
If b == nil, the result is the empty string.</p>
            
            <pre><code>func Filename() string</code></pre>
         </article>
         
         <article class="function" data-name="AbsFilename">
            <h2>AbsFilename</h2>
            <hr />
            
            <p>AbsFilename returns the absolute filename recorded with the base.
If b == nil, the result is the empty string.</p>
            
            <pre><code>func AbsFilename() string</code></pre>
         </article>
         
         <article class="function" data-name="FileIndex">
            <h2>FileIndex</h2>
            <hr />
            
            <p>FileIndex returns the index of the base's absolute filename within
its PosTable's FileTable. It panics if it hasn't been registered
with a PosTable. If b == nil, the result is -1.</p>
            
            <pre><code>func FileIndex() int</code></pre>
         </article>
         
         <article class="function" data-name="Line">
            <h2>Line</h2>
            <hr />
            
            <p>Line returns the line number recorded with the base.
If b == nil, the result is 0.</p>
            
            <pre><code>func Line() uint</code></pre>
         </article>
         
         <article class="function" data-name="Col">
            <h2>Col</h2>
            <hr />
            
            <p>Col returns the column number recorded with the base.
If b == nil, the result is 0.</p>
            
            <pre><code>func Col() uint</code></pre>
         </article>
         
         <article class="function" data-name="InliningIndex">
            <h2>InliningIndex</h2>
            <hr />
            
            <p>InliningIndex returns the index into the global inlining
tree recorded with the base. If b == nil or the base has
not been inlined, the result is < 0.</p>
            
            <pre><code>func InliningIndex() int</code></pre>
         </article>
         
         <article class="function" data-name="makeLicoRaw">
            <h2>makeLicoRaw</h2>
            <hr />
            
            <pre><code>func makeLicoRaw(line uint, col uint) lico</code></pre>
         </article>
         
         <article class="function" data-name="makeBogusLico">
            <h2>makeBogusLico</h2>
            <hr />
            
            <p>This is a not-position that will not be elided.
Depending on the debugger (gdb or delve) it may or may not be displayed.</p>
            
            <pre><code>func makeBogusLico() lico</code></pre>
         </article>
         
         <article class="function" data-name="makeLico">
            <h2>makeLico</h2>
            <hr />
            
            <pre><code>func makeLico(line uint, col uint) lico</code></pre>
         </article>
         
         <article class="function" data-name="Line">
            <h2>Line</h2>
            <hr />
            
            <pre><code>func Line() uint</code></pre>
         </article>
         
         <article class="function" data-name="SameLine">
            <h2>SameLine</h2>
            <hr />
            
            <pre><code>func SameLine(y lico) bool</code></pre>
         </article>
         
         <article class="function" data-name="Col">
            <h2>Col</h2>
            <hr />
            
            <pre><code>func Col() uint</code></pre>
         </article>
         
         <article class="function" data-name="IsStmt">
            <h2>IsStmt</h2>
            <hr />
            
            <pre><code>func IsStmt() uint</code></pre>
         </article>
         
         <article class="function" data-name="Xlogue">
            <h2>Xlogue</h2>
            <hr />
            
            <pre><code>func Xlogue() PosXlogue</code></pre>
         </article>
         
         <article class="function" data-name="withNotStmt">
            <h2>withNotStmt</h2>
            <hr />
            
            <p>withNotStmt returns a lico for the same location, but not a statement</p>
            
            <pre><code>func withNotStmt() lico</code></pre>
         </article>
         
         <article class="function" data-name="withDefaultStmt">
            <h2>withDefaultStmt</h2>
            <hr />
            
            <p>withDefaultStmt returns a lico for the same location, with default isStmt</p>
            
            <pre><code>func withDefaultStmt() lico</code></pre>
         </article>
         
         <article class="function" data-name="withIsStmt">
            <h2>withIsStmt</h2>
            <hr />
            
            <p>withIsStmt returns a lico for the same location, tagged as definitely a statement</p>
            
            <pre><code>func withIsStmt() lico</code></pre>
         </article>
         
         <article class="function" data-name="withXlogue">
            <h2>withXlogue</h2>
            <hr />
            
            <p>withXlogue attaches a prologue/epilogue attribute to a lico</p>
            
            <pre><code>func withXlogue(xlogue PosXlogue) lico</code></pre>
         </article>
         
         <article class="function" data-name="withStmt">
            <h2>withStmt</h2>
            <hr />
            
            <p>withStmt returns a lico for the same location with specified is_stmt attribute</p>
            
            <pre><code>func withStmt(stmt uint) lico</code></pre>
         </article>
         
         <article class="function" data-name="lineNumber">
            <h2>lineNumber</h2>
            <hr />
            
            <pre><code>func lineNumber() string</code></pre>
         </article>
         
         <article class="function" data-name="lineNumberHTML">
            <h2>lineNumberHTML</h2>
            <hr />
            
            <pre><code>func lineNumberHTML() string</code></pre>
         </article>
         
         <article class="function" data-name="atColumn1">
            <h2>atColumn1</h2>
            <hr />
            
            <pre><code>func atColumn1() lico</code></pre>
         </article>
         
         <article class="function" data-name="TestPos">
            <h2>TestPos</h2>
            <hr />
            
            <pre><code>func TestPos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPredicates">
            <h2>TestPredicates</h2>
            <hr />
            
            <pre><code>func TestPredicates(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLico">
            <h2>TestLico</h2>
            <hr />
            
            <pre><code>func TestLico(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsStmt">
            <h2>TestIsStmt</h2>
            <hr />
            
            <pre><code>func TestIsStmt(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLogue">
            <h2>TestLogue</h2>
            <hr />
            
            <pre><code>func TestLogue(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="IsKnown">
            <h2>IsKnown</h2>
            <hr />
            
            <p>IsKnown reports whether the position p is known.
XPos.IsKnown() matches Pos.IsKnown() for corresponding
positions.</p>
            
            <pre><code>func IsKnown() bool</code></pre>
         </article>
         
         <article class="function" data-name="Before">
            <h2>Before</h2>
            <hr />
            
            <p>Before reports whether the position p comes before q in the source.
For positions with different bases, ordering is by base index.</p>
            
            <pre><code>func Before(q XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="SameFile">
            <h2>SameFile</h2>
            <hr />
            
            <p>SameFile reports whether p and q are positions in the same file.</p>
            
            <pre><code>func SameFile(q XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="SameFileAndLine">
            <h2>SameFileAndLine</h2>
            <hr />
            
            <p>SameFileAndLine reports whether p and q are positions on the same line in the same file.</p>
            
            <pre><code>func SameFileAndLine(q XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="After">
            <h2>After</h2>
            <hr />
            
            <p>After reports whether the position p comes after q in the source.
For positions with different bases, ordering is by base index.</p>
            
            <pre><code>func After(q XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="WithNotStmt">
            <h2>WithNotStmt</h2>
            <hr />
            
            <p>WithNotStmt returns the same location to be marked with DWARF is_stmt=0</p>
            
            <pre><code>func WithNotStmt() XPos</code></pre>
         </article>
         
         <article class="function" data-name="WithDefaultStmt">
            <h2>WithDefaultStmt</h2>
            <hr />
            
            <p>WithDefaultStmt returns the same location with undetermined is_stmt</p>
            
            <pre><code>func WithDefaultStmt() XPos</code></pre>
         </article>
         
         <article class="function" data-name="WithIsStmt">
            <h2>WithIsStmt</h2>
            <hr />
            
            <p>WithIsStmt returns the same location to be marked with DWARF is_stmt=1</p>
            
            <pre><code>func WithIsStmt() XPos</code></pre>
         </article>
         
         <article class="function" data-name="WithBogusLine">
            <h2>WithBogusLine</h2>
            <hr />
            
            <p>WithBogusLine returns a bogus line that won't match any recorded for the source code.
Its use is to disrupt the statements within an infinite loop so that the debugger
will not itself loop infinitely waiting for the line number to change.
gdb chooses not to display the bogus line; delve shows it with a complaint, but the
alternative behavior is to hang.</p>
            
            <pre><code>func WithBogusLine() XPos</code></pre>
         </article>
         
         <article class="function" data-name="WithXlogue">
            <h2>WithXlogue</h2>
            <hr />
            
            <p>WithXlogue returns the same location but marked with DWARF function prologue/epilogue</p>
            
            <pre><code>func WithXlogue(x PosXlogue) XPos</code></pre>
         </article>
         
         <article class="function" data-name="LineNumber">
            <h2>LineNumber</h2>
            <hr />
            
            <p>LineNumber returns a string for the line number, "?" if it is not known.</p>
            
            <pre><code>func LineNumber() string</code></pre>
         </article>
         
         <article class="function" data-name="FileIndex">
            <h2>FileIndex</h2>
            <hr />
            
            <p>FileIndex returns a smallish non-negative integer corresponding to the
file for this source position.  Smallish is relative; it can be thousands
large, but not millions.</p>
            
            <pre><code>func FileIndex() int32</code></pre>
         </article>
         
         <article class="function" data-name="LineNumberHTML">
            <h2>LineNumberHTML</h2>
            <hr />
            
            <pre><code>func LineNumberHTML() string</code></pre>
         </article>
         
         <article class="function" data-name="AtColumn1">
            <h2>AtColumn1</h2>
            <hr />
            
            <p>AtColumn1 returns the same location but shifted to column 1.</p>
            
            <pre><code>func AtColumn1() XPos</code></pre>
         </article>
         
         <article class="function" data-name="XPos">
            <h2>XPos</h2>
            <hr />
            
            <p>XPos returns the corresponding XPos for the given pos,
adding pos to t if necessary.</p>
            
            <pre><code>func XPos(pos Pos) XPos</code></pre>
         </article>
         
         <article class="function" data-name="baseIndex">
            <h2>baseIndex</h2>
            <hr />
            
            <pre><code>func baseIndex(base *PosBase) int32</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <p>Pos returns the corresponding Pos for the given p.
If p cannot be translated via t, the function panics.</p>
            
            <pre><code>func Pos(p XPos) Pos</code></pre>
         </article>
         
         <article class="function" data-name="FileTable">
            <h2>FileTable</h2>
            <hr />
            
            <p>FileTable returns a slice of all files used to build this package.</p>
            
            <pre><code>func FileTable() []string</code></pre>
         </article>
         
         <article class="function" data-name="TestNoXPos">
            <h2>TestNoXPos</h2>
            <hr />
            
            <pre><code>func TestNoXPos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestConversion">
            <h2>TestConversion</h2>
            <hr />
            
            <pre><code>func TestConversion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSize">
            <h2>TestSize</h2>
            <hr />
            
            <pre><code>func TestSize(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSetBase">
            <h2>TestSetBase</h2>
            <hr />
            
            <pre><code>func TestSetBase(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
