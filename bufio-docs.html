<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>bufio - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>bufio</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bytes"
"errors"
"io"
"strings"
"unicode/utf8"
"bytes"
"errors"
"io"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrAdvanceTooFar" data-name="ErrAdvanceTooFar">
               <h3>
                  ErrAdvanceTooFar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrAdvanceTooFar" class="anchor" title="Link to ErrAdvanceTooFar">#</a>
               </h3>
               
                  <p class="doc-comment">Errors returned by Scanner.</p>
               
               <pre><code class="language-go">var ErrAdvanceTooFar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrBadReadCount" data-name="ErrBadReadCount">
               <h3>
                  ErrBadReadCount 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBadReadCount" class="anchor" title="Link to ErrBadReadCount">#</a>
               </h3>
               
                  <p class="doc-comment">Errors returned by Scanner.</p>
               
               <pre><code class="language-go">var ErrBadReadCount = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrBufferFull" data-name="ErrBufferFull">
               <h3>
                  ErrBufferFull 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBufferFull" class="anchor" title="Link to ErrBufferFull">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrBufferFull = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrFinalToken" data-name="ErrFinalToken">
               <h3>
                  ErrFinalToken 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrFinalToken" class="anchor" title="Link to ErrFinalToken">#</a>
               </h3>
               
                  <p class="doc-comment">ErrFinalToken is a special sentinel error value. It is intended to be
returned by a Split function to indicate that the scanning should stop
with no error. If the token being delivered with this error is not nil,
the token is the last token.
The value is useful to stop processing early or when it is necessary to
deliver a final empty token (which is different from a nil token).
One could achieve the same behavior with a custom error value but
providing one here is tidier.
See the emptyFinalToken example for a use of this value.</p>
               
               <pre><code class="language-go">var ErrFinalToken = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidUnreadByte" data-name="ErrInvalidUnreadByte">
               <h3>
                  ErrInvalidUnreadByte 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrInvalidUnreadByte" class="anchor" title="Link to ErrInvalidUnreadByte">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrInvalidUnreadByte = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidUnreadRune" data-name="ErrInvalidUnreadRune">
               <h3>
                  ErrInvalidUnreadRune 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrInvalidUnreadRune" class="anchor" title="Link to ErrInvalidUnreadRune">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrInvalidUnreadRune = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNegativeAdvance" data-name="ErrNegativeAdvance">
               <h3>
                  ErrNegativeAdvance 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNegativeAdvance" class="anchor" title="Link to ErrNegativeAdvance">#</a>
               </h3>
               
                  <p class="doc-comment">Errors returned by Scanner.</p>
               
               <pre><code class="language-go">var ErrNegativeAdvance = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNegativeCount" data-name="ErrNegativeCount">
               <h3>
                  ErrNegativeCount 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNegativeCount" class="anchor" title="Link to ErrNegativeCount">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrNegativeCount = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrTooLong" data-name="ErrTooLong">
               <h3>
                  ErrTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrTooLong" class="anchor" title="Link to ErrTooLong">#</a>
               </h3>
               
                  <p class="doc-comment">Errors returned by Scanner.</p>
               
               <pre><code class="language-go">var ErrTooLong = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxScanTokenSize" data-name="MaxScanTokenSize">
               <h3>
                  MaxScanTokenSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxScanTokenSize" class="anchor" title="Link to MaxScanTokenSize">#</a>
               </h3>
               
                  <p class="doc-comment">MaxScanTokenSize is the maximum size used to buffer a token
unless the user provides an explicit buffer with [Scanner.Buffer].
The actual maximum token size may be smaller as the buffer
may need to include, for instance, a newline.</p>
               
               <pre><code class="language-go">const MaxScanTokenSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultBufSize" data-name="defaultBufSize">
               <h3>
                  defaultBufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#defaultBufSize" class="anchor" title="Link to defaultBufSize">#</a>
               </h3>
               
               <pre><code class="language-go">const defaultBufSize = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNegativeRead" data-name="errNegativeRead">
               <h3>
                  errNegativeRead 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNegativeRead" class="anchor" title="Link to errNegativeRead">#</a>
               </h3>
               
               <pre><code class="language-go">var errNegativeRead = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNegativeWrite" data-name="errNegativeWrite">
               <h3>
                  errNegativeWrite 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNegativeWrite" class="anchor" title="Link to errNegativeWrite">#</a>
               </h3>
               
               <pre><code class="language-go">var errNegativeWrite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errorRune" data-name="errorRune">
               <h3>
                  errorRune 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errorRune" class="anchor" title="Link to errorRune">#</a>
               </h3>
               
               <pre><code class="language-go">var errorRune = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxConsecutiveEmptyReads" data-name="maxConsecutiveEmptyReads">
               <h3>
                  maxConsecutiveEmptyReads 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxConsecutiveEmptyReads" class="anchor" title="Link to maxConsecutiveEmptyReads">#</a>
               </h3>
               
               <pre><code class="language-go">const maxConsecutiveEmptyReads = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="minReadBufferSize" data-name="minReadBufferSize">
               <h3>
                  minReadBufferSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#minReadBufferSize" class="anchor" title="Link to minReadBufferSize">#</a>
               </h3>
               
               <pre><code class="language-go">const minReadBufferSize = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="startBufSize" data-name="startBufSize">
               <h3>
                  startBufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#startBufSize" class="anchor" title="Link to startBufSize">#</a>
               </h3>
               
               <pre><code class="language-go">const startBufSize = 4096</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="SplitFunc" data-name="SplitFunc">
               <h3>
                  SplitFunc
                  <span class="badge type-badge">type</span>
                  <a href="#SplitFunc" class="anchor" title="Link to SplitFunc">#</a>
               </h3>
               
               <p>SplitFunc is the signature of the split function used to tokenize the
input. The arguments are an initial substring of the remaining unprocessed
data and a flag, atEOF, that reports whether the [Reader] has no more data
to give. The return values are the number of bytes to advance the input
and the next token to return to the user, if any, plus an error, if any.
Scanning stops if the function returns an error, in which case some of
the input may be discarded. If that error is [ErrFinalToken], scanning
stops with no error. A non-nil token delivered with [ErrFinalToken]
will be the last token, and a nil token with [ErrFinalToken]
immediately stops the scanning.
Otherwise, the [Scanner] advances the input. If the token is not nil,
the [Scanner] returns it to the user. If the token is nil, the
Scanner reads more data and continues scanning; if there is no more
data--if atEOF was true--the [Scanner] returns. If the data does not
yet hold a complete token, for instance if it has no newline while
scanning lines, a [SplitFunc] can return (0, nil, nil) to signal the
[Scanner] to read more data into the slice and try again with a
longer slice starting at the same point in the input.
The function is never called with an empty data slice unless atEOF
is true. If atEOF is true, however, data may be non-empty and,
as always, holds unprocessed text.</p>
               
               <pre><code class="language-go">type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ReadWriter" data-name="ReadWriter">
               <h3>
                  ReadWriter
                  <span class="badge">struct</span>
                  <a href="#ReadWriter" class="anchor" title="Link to ReadWriter">#</a>
               </h3>
               
               <p>ReadWriter stores pointers to a [Reader] and a [Writer].
It implements [io.ReadWriter].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ReadWriter struct {
*Reader
*Writer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>Reader implements buffering for an io.Reader object.
A new Reader is created by calling [NewReader] or [NewReaderSize];
alternatively the zero value of a Reader may be used after calling [Reset]
on it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Reader struct {
buf []byte
rd io.Reader
r int
w int
err error
lastByte int
lastRuneSize int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Scanner" data-name="Scanner">
               <h3>
                  Scanner
                  <span class="badge">struct</span>
                  <a href="#Scanner" class="anchor" title="Link to Scanner">#</a>
               </h3>
               
               <p>Scanner provides a convenient interface for reading data such as
a file of newline-delimited lines of text. Successive calls to
the [Scanner.Scan] method will step through the 'tokens' of a file, skipping
the bytes between the tokens. The specification of a token is
defined by a split function of type [SplitFunc]; the default split
function breaks the input into lines with line termination stripped. [Scanner.Split]
functions are defined in this package for scanning a file into
lines, bytes, UTF-8-encoded runes, and space-delimited words. The
client may instead provide a custom split function.
Scanning stops unrecoverably at EOF, the first I/O error, or a token too
large to fit in the [Scanner.Buffer]. When a scan stops, the reader may have
advanced arbitrarily far past the last token. Programs that need more
control over error handling or large tokens, or must run sequential scans
on a reader, should use [bufio.Reader] instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Scanner struct {
r io.Reader
split SplitFunc
maxTokenSize int
token []byte
buf []byte
start int
end int
err error
empties int
scanCalled bool
done bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>Writer implements buffering for an [io.Writer] object.
If an error occurs writing to a [Writer], no more data will be
accepted and all subsequent writes, and [Writer.Flush], will return the error.
After all data has been written, the client should call the
[Writer.Flush] method to guarantee all data has been forwarded to
the underlying [io.Writer].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Writer struct {
err error
buf []byte
n int
wr io.Writer
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Available" data-name="Available">
               <h3>
                  Available 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Available" class="anchor" title="Link to Available">#</a>
               </h3>
               
               <p>Available returns how many bytes are unused in the buffer.</p>
               
               <pre><code class="language-go">func (b *Writer) Available() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AvailableBuffer" data-name="AvailableBuffer">
               <h3>
                  AvailableBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AvailableBuffer" class="anchor" title="Link to AvailableBuffer">#</a>
               </h3>
               
               <p>AvailableBuffer returns an empty buffer with b.Available() capacity.
This buffer is intended to be appended to and
passed to an immediately succeeding [Writer.Write] call.
The buffer is only valid until the next write operation on b.</p>
               
               <pre><code class="language-go">func (b *Writer) AvailableBuffer() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Buffer" data-name="Buffer">
               <h3>
                  Buffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Buffer" class="anchor" title="Link to Buffer">#</a>
               </h3>
               
               <p>Buffer sets the initial buffer to use when scanning
and the maximum size of buffer that may be allocated during scanning.
The maximum token size must be less than the larger of max and cap(buf).
If max <= cap(buf), [Scanner.Scan] will use this buffer only and do no allocation.
By default, [Scanner.Scan] uses an internal buffer and sets the
maximum token size to [MaxScanTokenSize].
Buffer panics if it is called after scanning has started.</p>
               
               <pre><code class="language-go">func (s *Scanner) Buffer(buf []byte, max int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Buffered" data-name="Buffered">
               <h3>
                  Buffered 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Buffered" class="anchor" title="Link to Buffered">#</a>
               </h3>
               
               <p>Buffered returns the number of bytes that can be read from the current buffer.</p>
               
               <pre><code class="language-go">func (b *Reader) Buffered() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Buffered" data-name="Buffered">
               <h3>
                  Buffered 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Buffered" class="anchor" title="Link to Buffered">#</a>
               </h3>
               
               <p>Buffered returns the number of bytes that have been written into the current buffer.</p>
               
               <pre><code class="language-go">func (b *Writer) Buffered() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the most recent token generated by a call to [Scanner.Scan].
The underlying array may point to data that will be overwritten
by a subsequent call to Scan. It does no allocation.</p>
               
               <pre><code class="language-go">func (s *Scanner) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Discard" data-name="Discard">
               <h3>
                  Discard 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Discard" class="anchor" title="Link to Discard">#</a>
               </h3>
               
               <p>Discard skips the next n bytes, returning the number of bytes discarded.
If Discard skips fewer than n bytes, it also returns an error.
If 0 <= n <= b.Buffered(), Discard is guaranteed to succeed without
reading from the underlying io.Reader.</p>
               
               <pre><code class="language-go">func (b *Reader) Discard(n int) (discarded int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <p>Err returns the first non-EOF error that was encountered by the [Scanner].</p>
               
               <pre><code class="language-go">func (s *Scanner) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush writes any buffered data to the underlying [io.Writer].</p>
               
               <pre><code class="language-go">func (b *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReadWriter" data-name="NewReadWriter">
               <h3>
                  NewReadWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewReadWriter" class="anchor" title="Link to NewReadWriter">#</a>
               </h3>
               
               <p>NewReadWriter allocates a new [ReadWriter] that dispatches to r and w.</p>
               
               <pre><code class="language-go">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader returns a new [Reader] whose buffer has the default size.</p>
               
               <pre><code class="language-go">func NewReader(rd io.Reader) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReaderSize" data-name="NewReaderSize">
               <h3>
                  NewReaderSize 
                  <span class="badge">function</span>
                  
                  <a href="#NewReaderSize" class="anchor" title="Link to NewReaderSize">#</a>
               </h3>
               
               <p>NewReaderSize returns a new [Reader] whose buffer has at least the specified
size. If the argument io.Reader is already a [Reader] with large enough
size, it returns the underlying [Reader].</p>
               
               <pre><code class="language-go">func NewReaderSize(rd io.Reader, size int) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewScanner" data-name="NewScanner">
               <h3>
                  NewScanner 
                  <span class="badge">function</span>
                  
                  <a href="#NewScanner" class="anchor" title="Link to NewScanner">#</a>
               </h3>
               
               <p>NewScanner returns a new [Scanner] to read from r.
The split function defaults to [ScanLines].</p>
               
               <pre><code class="language-go">func NewScanner(r io.Reader) *Scanner</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter returns a new [Writer] whose buffer has the default size.
If the argument io.Writer is already a [Writer] with large enough buffer size,
it returns the underlying [Writer].</p>
               
               <pre><code class="language-go">func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriterSize" data-name="NewWriterSize">
               <h3>
                  NewWriterSize 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriterSize" class="anchor" title="Link to NewWriterSize">#</a>
               </h3>
               
               <p>NewWriterSize returns a new [Writer] whose buffer has at least the specified
size. If the argument io.Writer is already a [Writer] with large enough
size, it returns the underlying [Writer].</p>
               
               <pre><code class="language-go">func NewWriterSize(w io.Writer, size int) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Peek" data-name="Peek">
               <h3>
                  Peek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Peek" class="anchor" title="Link to Peek">#</a>
               </h3>
               
               <p>Peek returns the next n bytes without advancing the reader. The bytes stop
being valid at the next read call. If necessary, Peek will read more bytes
into the buffer in order to make n bytes available. If Peek returns fewer
than n bytes, it also returns an error explaining why the read is short.
The error is [ErrBufferFull] if n is larger than b's buffer size.
Calling Peek prevents a [Reader.UnreadByte] or [Reader.UnreadRune] call from succeeding
until the next read operation.</p>
               
               <pre><code class="language-go">func (b *Reader) Peek(n int) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads data into p.
It returns the number of bytes read into p.
The bytes are taken from at most one Read on the underlying [Reader],
hence n may be less than len(p).
To read exactly len(p) bytes, use io.ReadFull(b, p).
If the underlying [Reader] can return a non-zero count with io.EOF,
then this Read method can do so as well; see the [io.Reader] docs.</p>
               
               <pre><code class="language-go">func (b *Reader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadByte" data-name="ReadByte">
               <h3>
                  ReadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadByte" class="anchor" title="Link to ReadByte">#</a>
               </h3>
               
               <p>ReadByte reads and returns a single byte.
If no byte is available, returns an error.</p>
               
               <pre><code class="language-go">func (b *Reader) ReadByte() (byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadBytes" data-name="ReadBytes">
               <h3>
                  ReadBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadBytes" class="anchor" title="Link to ReadBytes">#</a>
               </h3>
               
               <p>ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.
For simple uses, a Scanner may be more convenient.</p>
               
               <pre><code class="language-go">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <p>ReadFrom implements [io.ReaderFrom]. If the underlying writer
supports the ReadFrom method, this calls the underlying ReadFrom.
If there is buffered data and an underlying ReadFrom, this fills
the buffer and writes it before calling ReadFrom.</p>
               
               <pre><code class="language-go">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadLine" data-name="ReadLine">
               <h3>
                  ReadLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadLine" class="anchor" title="Link to ReadLine">#</a>
               </h3>
               
               <p>ReadLine is a low-level line-reading primitive. Most callers should use
[Reader.ReadBytes]('\n') or [Reader.ReadString]('\n') instead or use a [Scanner].
ReadLine tries to return a single line, not including the end-of-line bytes.
If the line was too long for the buffer then isPrefix is set and the
beginning of the line is returned. The rest of the line will be returned
from future calls. isPrefix will be false when returning the last fragment
of the line. The returned buffer is only valid until the next call to
ReadLine. ReadLine either returns a non-nil line or it returns an error,
never both.
The text returned from ReadLine does not include the line end ("\r\n" or "\n").
No indication or error is given if the input ends without a final line end.
Calling [Reader.UnreadByte] after ReadLine will always unread the last byte read
(possibly a character belonging to the line end) even if that byte is not
part of the line returned by ReadLine.</p>
               
               <pre><code class="language-go">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRune" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRune" class="anchor" title="Link to ReadRune">#</a>
               </h3>
               
               <p>ReadRune reads a single UTF-8 encoded Unicode character and returns the
rune and its size in bytes. If the encoded rune is invalid, it consumes one byte
and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</p>
               
               <pre><code class="language-go">func (b *Reader) ReadRune() (r rune, size int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadSlice" data-name="ReadSlice">
               <h3>
                  ReadSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadSlice" class="anchor" title="Link to ReadSlice">#</a>
               </h3>
               
               <p>ReadSlice reads until the first occurrence of delim in the input,
returning a slice pointing at the bytes in the buffer.
The bytes stop being valid at the next read.
If ReadSlice encounters an error before finding a delimiter,
it returns all the data in the buffer and the error itself (often io.EOF).
ReadSlice fails with error [ErrBufferFull] if the buffer fills without a delim.
Because the data returned from ReadSlice will be overwritten
by the next I/O operation, most clients should use
[Reader.ReadBytes] or ReadString instead.
ReadSlice returns err != nil if and only if line does not end in delim.</p>
               
               <pre><code class="language-go">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadString" data-name="ReadString">
               <h3>
                  ReadString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadString" class="anchor" title="Link to ReadString">#</a>
               </h3>
               
               <p>ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadString returns err != nil if and only if the returned data does not end in
delim.
For simple uses, a Scanner may be more convenient.</p>
               
               <pre><code class="language-go">func (b *Reader) ReadString(delim byte) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset discards any unflushed buffered data, clears any error, and
resets b to write its output to w.
Calling Reset on the zero value of [Writer] initializes the internal buffer
to the default size.
Calling w.Reset(w) (that is, resetting a [Writer] to itself) does nothing.</p>
               
               <pre><code class="language-go">func (b *Writer) Reset(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset discards any buffered data, resets all state, and switches
the buffered reader to read from r.
Calling Reset on the zero value of [Reader] initializes the internal buffer
to the default size.
Calling b.Reset(b) (that is, resetting a [Reader] to itself) does nothing.</p>
               
               <pre><code class="language-go">func (b *Reader) Reset(r io.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scan" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scan" class="anchor" title="Link to Scan">#</a>
               </h3>
               
               <p>Scan advances the [Scanner] to the next token, which will then be
available through the [Scanner.Bytes] or [Scanner.Text] method. It returns false when
there are no more tokens, either by reaching the end of the input or an error.
After Scan returns false, the [Scanner.Err] method will return any error that
occurred during scanning, except that if it was [io.EOF], [Scanner.Err]
will return nil.
Scan panics if the split function returns too many empty
tokens without advancing the input. This is a common error mode for
scanners.</p>
               
               <pre><code class="language-go">func (s *Scanner) Scan() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScanBytes" data-name="ScanBytes">
               <h3>
                  ScanBytes 
                  <span class="badge">function</span>
                  
                  <a href="#ScanBytes" class="anchor" title="Link to ScanBytes">#</a>
               </h3>
               
               <p>ScanBytes is a split function for a [Scanner] that returns each byte as a token.</p>
               
               <pre><code class="language-go">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScanLines" data-name="ScanLines">
               <h3>
                  ScanLines 
                  <span class="badge">function</span>
                  
                  <a href="#ScanLines" class="anchor" title="Link to ScanLines">#</a>
               </h3>
               
               <p>ScanLines is a split function for a [Scanner] that returns each line of
text, stripped of any trailing end-of-line marker. The returned line may
be empty. The end-of-line marker is one optional carriage return followed
by one mandatory newline. In regular expression notation, it is `\r?\n`.
The last non-empty line of input will be returned even if it has no
newline.</p>
               
               <pre><code class="language-go">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScanRunes" data-name="ScanRunes">
               <h3>
                  ScanRunes 
                  <span class="badge">function</span>
                  
                  <a href="#ScanRunes" class="anchor" title="Link to ScanRunes">#</a>
               </h3>
               
               <p>ScanRunes is a split function for a [Scanner] that returns each
UTF-8-encoded rune as a token. The sequence of runes returned is
equivalent to that from a range loop over the input as a string, which
means that erroneous UTF-8 encodings translate to U+FFFD = "\xef\xbf\xbd".
Because of the Scan interface, this makes it impossible for the client to
distinguish correctly encoded replacement runes from encoding errors.</p>
               
               <pre><code class="language-go">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScanWords" data-name="ScanWords">
               <h3>
                  ScanWords 
                  <span class="badge">function</span>
                  
                  <a href="#ScanWords" class="anchor" title="Link to ScanWords">#</a>
               </h3>
               
               <p>ScanWords is a split function for a [Scanner] that returns each
space-separated word of text, with surrounding spaces deleted. It will
never return an empty string. The definition of space is set by
unicode.IsSpace.</p>
               
               <pre><code class="language-go">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the size of the underlying buffer in bytes.</p>
               
               <pre><code class="language-go">func (b *Writer) Size() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the size of the underlying buffer in bytes.</p>
               
               <pre><code class="language-go">func (b *Reader) Size() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Split" data-name="Split">
               <h3>
                  Split 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Split" class="anchor" title="Link to Split">#</a>
               </h3>
               
               <p>Split sets the split function for the [Scanner].
The default split function is [ScanLines].
Split panics if it is called after scanning has started.</p>
               
               <pre><code class="language-go">func (s *Scanner) Split(split SplitFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Text" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Text" class="anchor" title="Link to Text">#</a>
               </h3>
               
               <p>Text returns the most recent token generated by a call to [Scanner.Scan]
as a newly allocated string holding its bytes.</p>
               
               <pre><code class="language-go">func (s *Scanner) Text() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadByte" data-name="UnreadByte">
               <h3>
                  UnreadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadByte" class="anchor" title="Link to UnreadByte">#</a>
               </h3>
               
               <p>UnreadByte unreads the last byte. Only the most recently read byte can be unread.
UnreadByte returns an error if the most recent method called on the
[Reader] was not a read operation. Notably, [Reader.Peek], [Reader.Discard], and [Reader.WriteTo] are not
considered read operations.</p>
               
               <pre><code class="language-go">func (b *Reader) UnreadByte() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadRune" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadRune" class="anchor" title="Link to UnreadRune">#</a>
               </h3>
               
               <p>UnreadRune unreads the last rune. If the most recent method called on
the [Reader] was not a [Reader.ReadRune], [Reader.UnreadRune] returns an error. (In this
regard it is stricter than [Reader.UnreadByte], which will unread the last byte
from any read operation.)</p>
               
               <pre><code class="language-go">func (b *Reader) UnreadRune() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes the contents of p into the buffer.
It returns the number of bytes written.
If nn < len(p), it also returns an error explaining
why the write is short.</p>
               
               <pre><code class="language-go">func (b *Writer) Write(p []byte) (nn int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteByte" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteByte" class="anchor" title="Link to WriteByte">#</a>
               </h3>
               
               <p>WriteByte writes a single byte.</p>
               
               <pre><code class="language-go">func (b *Writer) WriteByte(c byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteRune" data-name="WriteRune">
               <h3>
                  WriteRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteRune" class="anchor" title="Link to WriteRune">#</a>
               </h3>
               
               <p>WriteRune writes a single Unicode code point, returning
the number of bytes written and any error.</p>
               
               <pre><code class="language-go">func (b *Writer) WriteRune(r rune) (size int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString writes a string.
It returns the number of bytes written.
If the count is less than len(s), it also returns an error explaining
why the write is short.</p>
               
               <pre><code class="language-go">func (b *Writer) WriteString(s string) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo implements io.WriterTo.
This may make multiple calls to the [Reader.Read] method of the underlying [Reader].
If the underlying reader supports the [Reader.WriteTo] method,
this calls the underlying [Reader.WriteTo] without buffering.</p>
               
               <pre><code class="language-go">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="advance" data-name="advance">
               <h3>
                  advance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#advance" class="anchor" title="Link to advance">#</a>
               </h3>
               
               <p>advance consumes n bytes of the buffer. It reports whether the advance was legal.</p>
               
               <pre><code class="language-go">func (s *Scanner) advance(n int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectFragments" data-name="collectFragments">
               <h3>
                  collectFragments 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectFragments" class="anchor" title="Link to collectFragments">#</a>
               </h3>
               
               <p>collectFragments reads until the first occurrence of delim in the input. It
returns (slice of full buffers, remaining bytes before delim, total number
of bytes in the combined first two elements, error).
The complete result is equal to
`bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a
length of `totalLen`. The result is structured in this way to allow callers
to minimize allocations and copies.</p>
               
               <pre><code class="language-go">func (b *Reader) collectFragments(delim byte) (fullBuffers [][]byte, finalFragment []byte, totalLen int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dropCR" data-name="dropCR">
               <h3>
                  dropCR 
                  <span class="badge">function</span>
                  
                  <a href="#dropCR" class="anchor" title="Link to dropCR">#</a>
               </h3>
               
               <p>dropCR drops a terminal \r from the data.</p>
               
               <pre><code class="language-go">func dropCR(data []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fill" data-name="fill">
               <h3>
                  fill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fill" class="anchor" title="Link to fill">#</a>
               </h3>
               
               <p>fill reads a new chunk into the buffer.</p>
               
               <pre><code class="language-go">func (b *Reader) fill()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSpace" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
                  <a href="#isSpace" class="anchor" title="Link to isSpace">#</a>
               </h3>
               
               <p>isSpace reports whether the character is a Unicode white space character.
We avoid dependency on the unicode package, but check validity of the implementation
in the tests.</p>
               
               <pre><code class="language-go">func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readErr" data-name="readErr">
               <h3>
                  readErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readErr" class="anchor" title="Link to readErr">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Reader) readErr() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Reader) reset(buf []byte, r io.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setErr" data-name="setErr">
               <h3>
                  setErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setErr" class="anchor" title="Link to setErr">#</a>
               </h3>
               
               <p>setErr records the first error encountered.</p>
               
               <pre><code class="language-go">func (s *Scanner) setErr(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeBuf" data-name="writeBuf">
               <h3>
                  writeBuf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeBuf" class="anchor" title="Link to writeBuf">#</a>
               </h3>
               
               <p>writeBuf writes the [Reader]'s buffer to the writer.</p>
               
               <pre><code class="language-go">func (b *Reader) writeBuf(w io.Writer) (int64, error)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>