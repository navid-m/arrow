<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bufio_test</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>bufio_test</code>
         </h1>
         <hr />
         
         <article class="global" data-name="readMakers">
            <h2>readMakers</h2>
            <hr />
            
            <pre><code>readMakers</code></pre>
         </article>
         
         <article class="global" data-name="bufreaders">
            <h2>bufreaders</h2>
            <hr />
            
            <pre><code>bufreaders</code></pre>
         </article>
         
         <article class="global" data-name="minReadBufferSize">
            <h2>minReadBufferSize</h2>
            <hr />
            
            <pre><code>minReadBufferSize</code></pre>
         </article>
         
         <article class="global" data-name="bufsizes">
            <h2>bufsizes</h2>
            <hr />
            
            <pre><code>bufsizes</code></pre>
         </article>
         
         <article class="global" data-name="segmentList">
            <h2>segmentList</h2>
            <hr />
            
            <pre><code>segmentList</code></pre>
         </article>
         
         <article class="global" data-name="errorWriterTests">
            <h2>errorWriterTests</h2>
            <hr />
            
            <pre><code>errorWriterTests</code></pre>
         </article>
         
         <article class="global" data-name="testOutput">
            <h2>testOutput</h2>
            <hr />
            
            <pre><code>testOutput</code></pre>
         </article>
         
         <article class="global" data-name="testInput">
            <h2>testInput</h2>
            <hr />
            
            <pre><code>testInput</code></pre>
         </article>
         
         <article class="global" data-name="testInputrn">
            <h2>testInputrn</h2>
            <hr />
            
            <pre><code>testInputrn</code></pre>
         </article>
         
         <article class="global" data-name="readLineNewlinesTests">
            <h2>readLineNewlinesTests</h2>
            <hr />
            
            <pre><code>readLineNewlinesTests</code></pre>
         </article>
         
         <article class="global" data-name="errorWriterToTests">
            <h2>errorWriterToTests</h2>
            <hr />
            
            <pre><code>errorWriterToTests</code></pre>
         </article>
         
         <article class="global" data-name="errorReaderFromTests">
            <h2>errorReaderFromTests</h2>
            <hr />
            
            <pre><code>errorReaderFromTests</code></pre>
         </article>
         
         <article class="global" data-name="errFake">
            <h2>errFake</h2>
            <hr />
            
            <pre><code>errFake</code></pre>
         </article>
         
         <article class="global" data-name="smallMaxTokenSize">
            <h2>smallMaxTokenSize</h2>
            <hr />
            
            <pre><code>smallMaxTokenSize</code></pre>
         </article>
         
         <article class="global" data-name="scanTests">
            <h2>scanTests</h2>
            <hr />
            
            <pre><code>scanTests</code></pre>
         </article>
         
         <article class="global" data-name="wordScanTests">
            <h2>wordScanTests</h2>
            <hr />
            
            <pre><code>wordScanTests</code></pre>
         </article>
         
         <article class="global" data-name="testError">
            <h2>testError</h2>
            <hr />
            
            <pre><code>testError</code></pre>
         </article>
          
         <article class="struct" data-name="rot13Reader">
            <h2>type rot13Reader struct</h2>
            <hr />
            
            <p>Reads from a reader and rot13s the result.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="readMaker">
            <h2>type readMaker struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
fn func</code></pre>
         </article>
         
         <article class="struct" data-name="bufReader">
            <h2>type bufReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
fn func</code></pre>
         </article>
         
         <article class="struct" data-name="zeroReader">
            <h2>type zeroReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="StringReader">
            <h2>type StringReader struct</h2>
            <hr />
            
            <p>A StringReader delivers its data one string segment at a time via Read.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []string
step int</code></pre>
         </article>
         
         <article class="struct" data-name="errorWriterTest">
            <h2>type errorWriterTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">n int
m int
err error
expect error</code></pre>
         </article>
         
         <article class="struct" data-name="teststringwriter">
            <h2>type teststringwriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">write string
writeString string</code></pre>
         </article>
         
         <article class="struct" data-name="testReader">
            <h2>type testReader struct</h2>
            <hr />
            
            <p>TestReader wraps a []byte and returns reads of a specific length.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
stride int</code></pre>
         </article>
         
         <article class="struct" data-name="readLineResult">
            <h2>type readLineResult struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">line []byte
isPrefix bool
err error</code></pre>
         </article>
         
         <article class="struct" data-name="errorWriterToTest">
            <h2>type errorWriterToTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rn int
wn int
rerr error
werr error
expected error</code></pre>
         </article>
         
         <article class="struct" data-name="errorReaderFromTest">
            <h2>type errorReaderFromTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rn int
wn int
rerr error
werr error
expected error</code></pre>
         </article>
         
         <article class="struct" data-name="errorThenGoodReader">
            <h2>type errorThenGoodReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">didErr bool
nread int</code></pre>
         </article>
         
         <article class="struct" data-name="emptyThenNonEmptyReader">
            <h2>type emptyThenNonEmptyReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader
n int</code></pre>
         </article>
         
         <article class="struct" data-name="readFromWriter">
            <h2>type readFromWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">buf []byte
writeBytes int
readFromBytes int</code></pre>
         </article>
         
         <article class="struct" data-name="onlyReader">
            <h2>type onlyReader struct</h2>
            <hr />
            
            <p>An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="onlyWriter">
            <h2>type onlyWriter struct</h2>
            <hr />
            
            <p>An onlyWriter only implements io.Writer, no matter what other methods the underlying implementation may have.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">io.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="eofReader">
            <h2>type eofReader struct</h2>
            <hr />
            
            <p>eofReader returns the number of bytes read and io.EOF for the read that consumes the last of the content.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">buf []byte</code></pre>
         </article>
         
         <article class="struct" data-name="writerWithReadFromError">
            <h2>type writerWithReadFromError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="writeErrorOnlyWriter">
            <h2>type writeErrorOnlyWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="slowReader">
            <h2>type slowReader struct</h2>
            <hr />
            
            <p>slowReader is a reader that returns only a few bytes at a time, to test the incremental
reads in Scanner.Scan.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">max int
buf io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="alwaysError">
            <h2>type alwaysError struct</h2>
            <hr />
            
            <p>Test for issue 5268.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="endlessZeros">
            <h2>type endlessZeros struct</h2>
            <hr />
            
            <p>Test that Scan finishes if we have endless empty reads.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="largeReader">
            <h2>type largeReader struct</h2>
            <hr />
            
            <p>largeReader returns an invalid count that is larger than the number
of bytes requested.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
          
         <article class="function" data-name="newRot13Reader">
            <h2>newRot13Reader</h2>
            <hr />
            
            <pre><code>func newRot13Reader(r io.Reader) *rot13Reader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="readBytes">
            <h2>readBytes</h2>
            <hr />
            
            <p>Call ReadByte to accumulate the text of a file</p>
            
            <pre><code>func readBytes(buf *Reader) string</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderSimple">
            <h2>TestReaderSimple</h2>
            <hr />
            
            <pre><code>func TestReaderSimple(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="readLines">
            <h2>readLines</h2>
            <hr />
            
            <p>Call ReadString (which ends up calling everything else)
to accumulate the text of a file.</p>
            
            <pre><code>func readLines(b *Reader) string</code></pre>
         </article>
         
         <article class="function" data-name="reads">
            <h2>reads</h2>
            <hr />
            
            <p>Call Read to accumulate the text of a file</p>
            
            <pre><code>func reads(buf *Reader, m int) string</code></pre>
         </article>
         
         <article class="function" data-name="TestReader">
            <h2>TestReader</h2>
            <hr />
            
            <pre><code>func TestReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestZeroReader">
            <h2>TestZeroReader</h2>
            <hr />
            
            <pre><code>func TestZeroReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readRuneSegments">
            <h2>readRuneSegments</h2>
            <hr />
            
            <pre><code>func readRuneSegments(t *testing.T, segments []string)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadRune">
            <h2>TestReadRune</h2>
            <hr />
            
            <pre><code>func TestReadRune(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnreadRune">
            <h2>TestUnreadRune</h2>
            <hr />
            
            <pre><code>func TestUnreadRune(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoUnreadRuneAfterPeek">
            <h2>TestNoUnreadRuneAfterPeek</h2>
            <hr />
            
            <pre><code>func TestNoUnreadRuneAfterPeek(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoUnreadByteAfterPeek">
            <h2>TestNoUnreadByteAfterPeek</h2>
            <hr />
            
            <pre><code>func TestNoUnreadByteAfterPeek(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoUnreadRuneAfterDiscard">
            <h2>TestNoUnreadRuneAfterDiscard</h2>
            <hr />
            
            <pre><code>func TestNoUnreadRuneAfterDiscard(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoUnreadByteAfterDiscard">
            <h2>TestNoUnreadByteAfterDiscard</h2>
            <hr />
            
            <pre><code>func TestNoUnreadByteAfterDiscard(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoUnreadRuneAfterWriteTo">
            <h2>TestNoUnreadRuneAfterWriteTo</h2>
            <hr />
            
            <pre><code>func TestNoUnreadRuneAfterWriteTo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoUnreadByteAfterWriteTo">
            <h2>TestNoUnreadByteAfterWriteTo</h2>
            <hr />
            
            <pre><code>func TestNoUnreadByteAfterWriteTo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnreadByte">
            <h2>TestUnreadByte</h2>
            <hr />
            
            <pre><code>func TestUnreadByte(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnreadByteMultiple">
            <h2>TestUnreadByteMultiple</h2>
            <hr />
            
            <pre><code>func TestUnreadByteMultiple(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnreadByteOthers">
            <h2>TestUnreadByteOthers</h2>
            <hr />
            
            <pre><code>func TestUnreadByteOthers(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnreadRuneError">
            <h2>TestUnreadRuneError</h2>
            <hr />
            
            <p>Test that UnreadRune fails if the preceding operation was not a ReadRune.</p>
            
            <pre><code>func TestUnreadRuneError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnreadRuneAtEOF">
            <h2>TestUnreadRuneAtEOF</h2>
            <hr />
            
            <pre><code>func TestUnreadRuneAtEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadWriteRune">
            <h2>TestReadWriteRune</h2>
            <hr />
            
            <pre><code>func TestReadWriteRune(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteInvalidRune">
            <h2>TestWriteInvalidRune</h2>
            <hr />
            
            <pre><code>func TestWriteInvalidRune(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadStringAllocs">
            <h2>TestReadStringAllocs</h2>
            <hr />
            
            <pre><code>func TestReadStringAllocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriter">
            <h2>TestWriter</h2>
            <hr />
            
            <pre><code>func TestWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterAppend">
            <h2>TestWriterAppend</h2>
            <hr />
            
            <pre><code>func TestWriterAppend(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteErrors">
            <h2>TestWriteErrors</h2>
            <hr />
            
            <pre><code>func TestWriteErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNewReaderSizeIdempotent">
            <h2>TestNewReaderSizeIdempotent</h2>
            <hr />
            
            <pre><code>func TestNewReaderSizeIdempotent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNewWriterSizeIdempotent">
            <h2>TestNewWriterSizeIdempotent</h2>
            <hr />
            
            <pre><code>func TestNewWriterSizeIdempotent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteString">
            <h2>TestWriteString</h2>
            <hr />
            
            <pre><code>func TestWriteString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteStringStringWriter">
            <h2>TestWriteStringStringWriter</h2>
            <hr />
            
            <pre><code>func TestWriteStringStringWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <pre><code>func WriteString(s string) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <pre><code>func check(t *testing.T, write string, writeString string)</code></pre>
         </article>
         
         <article class="function" data-name="TestBufferFull">
            <h2>TestBufferFull</h2>
            <hr />
            
            <pre><code>func TestBufferFull(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPeek">
            <h2>TestPeek</h2>
            <hr />
            
            <pre><code>func TestPeek(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestPeekThenUnreadRune">
            <h2>TestPeekThenUnreadRune</h2>
            <hr />
            
            <pre><code>func TestPeekThenUnreadRune(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(buf []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="testReadLine">
            <h2>testReadLine</h2>
            <hr />
            
            <pre><code>func testReadLine(t *testing.T, input []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadLine">
            <h2>TestReadLine</h2>
            <hr />
            
            <pre><code>func TestReadLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineTooLong">
            <h2>TestLineTooLong</h2>
            <hr />
            
            <pre><code>func TestLineTooLong(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadAfterLines">
            <h2>TestReadAfterLines</h2>
            <hr />
            
            <pre><code>func TestReadAfterLines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadEmptyBuffer">
            <h2>TestReadEmptyBuffer</h2>
            <hr />
            
            <pre><code>func TestReadEmptyBuffer(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLinesAfterRead">
            <h2>TestLinesAfterRead</h2>
            <hr />
            
            <pre><code>func TestLinesAfterRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadLineNonNilLineOrError">
            <h2>TestReadLineNonNilLineOrError</h2>
            <hr />
            
            <pre><code>func TestReadLineNonNilLineOrError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadLineNewlines">
            <h2>TestReadLineNewlines</h2>
            <hr />
            
            <pre><code>func TestReadLineNewlines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testReadLineNewlines">
            <h2>testReadLineNewlines</h2>
            <hr />
            
            <pre><code>func testReadLineNewlines(t *testing.T, input string, expect []readLineResult)</code></pre>
         </article>
         
         <article class="function" data-name="createTestInput">
            <h2>createTestInput</h2>
            <hr />
            
            <pre><code>func createTestInput(n int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderWriteTo">
            <h2>TestReaderWriteTo</h2>
            <hr />
            
            <pre><code>func TestReaderWriteTo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderWriteToErrors">
            <h2>TestReaderWriteToErrors</h2>
            <hr />
            
            <pre><code>func TestReaderWriteToErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFrom">
            <h2>TestWriterReadFrom</h2>
            <hr />
            
            <pre><code>func TestWriterReadFrom(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromErrors">
            <h2>TestWriterReadFromErrors</h2>
            <hr />
            
            <pre><code>func TestWriterReadFromErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromCounts">
            <h2>TestWriterReadFromCounts</h2>
            <hr />
            
            <p>TestWriterReadFromCounts tests that using io.Copy to copy into a
bufio.Writer does not prematurely flush the buffer. For example, when
buffering writes to a network socket, excessive network writes should be
avoided.</p>
            
            <pre><code>func TestWriterReadFromCounts(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read([]byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestNegativeRead">
            <h2>TestNegativeRead</h2>
            <hr />
            
            <pre><code>func TestNegativeRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderClearError">
            <h2>TestReaderClearError</h2>
            <hr />
            
            <pre><code>func TestReaderClearError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromWhileFull">
            <h2>TestWriterReadFromWhileFull</h2>
            <hr />
            
            <p>Test for golang.org/issue/5947</p>
            
            <pre><code>func TestWriterReadFromWhileFull(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromUntilEOF">
            <h2>TestWriterReadFromUntilEOF</h2>
            <hr />
            
            <p>Test for golang.org/issue/7611</p>
            
            <pre><code>func TestWriterReadFromUntilEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromErrNoProgress">
            <h2>TestWriterReadFromErrNoProgress</h2>
            <hr />
            
            <pre><code>func TestWriterReadFromErrNoProgress(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFrom">
            <h2>ReadFrom</h2>
            <hr />
            
            <pre><code>func ReadFrom(r io.Reader) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromWithBufferedData">
            <h2>TestWriterReadFromWithBufferedData</h2>
            <hr />
            
            <p>Test that calling (*Writer).ReadFrom with a partially-filled buffer
fills the buffer before switching over to ReadFrom.</p>
            
            <pre><code>func TestWriterReadFromWithBufferedData(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadZero">
            <h2>TestReadZero</h2>
            <hr />
            
            <pre><code>func TestReadZero(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderReset">
            <h2>TestReaderReset</h2>
            <hr />
            
            <pre><code>func TestReaderReset(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReset">
            <h2>TestWriterReset</h2>
            <hr />
            
            <pre><code>func TestWriterReset(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderDiscard">
            <h2>TestReaderDiscard</h2>
            <hr />
            
            <pre><code>func TestReaderDiscard(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderSize">
            <h2>TestReaderSize</h2>
            <hr />
            
            <pre><code>func TestReaderSize(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterSize">
            <h2>TestWriterSize</h2>
            <hr />
            
            <pre><code>func TestWriterSize(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newScriptedReader">
            <h2>newScriptedReader</h2>
            <hr />
            
            <pre><code>func newScriptedReader(steps ...func) io.Reader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestPartialReadEOF">
            <h2>TestPartialReadEOF</h2>
            <hr />
            
            <pre><code>func TestPartialReadEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFrom">
            <h2>ReadFrom</h2>
            <hr />
            
            <pre><code>func ReadFrom(r io.Reader) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromMustSetUnderlyingError">
            <h2>TestWriterReadFromMustSetUnderlyingError</h2>
            <hr />
            
            <pre><code>func TestWriterReadFromMustSetUnderlyingError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReadFromMustReturnUnderlyingError">
            <h2>TestWriterReadFromMustReturnUnderlyingError</h2>
            <hr />
            
            <p>Ensure that previous Write errors are immediately returned
on any ReadFrom. See golang.org/issue/35194.</p>
            
            <pre><code>func TestWriterReadFromMustReturnUnderlyingError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReaderCopyOptimal">
            <h2>BenchmarkReaderCopyOptimal</h2>
            <hr />
            
            <pre><code>func BenchmarkReaderCopyOptimal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReaderCopyUnoptimal">
            <h2>BenchmarkReaderCopyUnoptimal</h2>
            <hr />
            
            <pre><code>func BenchmarkReaderCopyUnoptimal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReaderCopyNoWriteTo">
            <h2>BenchmarkReaderCopyNoWriteTo</h2>
            <hr />
            
            <pre><code>func BenchmarkReaderCopyNoWriteTo(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReaderWriteToOptimal">
            <h2>BenchmarkReaderWriteToOptimal</h2>
            <hr />
            
            <pre><code>func BenchmarkReaderWriteToOptimal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReaderReadString">
            <h2>BenchmarkReaderReadString</h2>
            <hr />
            
            <pre><code>func BenchmarkReaderReadString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWriterCopyOptimal">
            <h2>BenchmarkWriterCopyOptimal</h2>
            <hr />
            
            <pre><code>func BenchmarkWriterCopyOptimal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWriterCopyUnoptimal">
            <h2>BenchmarkWriterCopyUnoptimal</h2>
            <hr />
            
            <pre><code>func BenchmarkWriterCopyUnoptimal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWriterCopyNoReadFrom">
            <h2>BenchmarkWriterCopyNoReadFrom</h2>
            <hr />
            
            <pre><code>func BenchmarkWriterCopyNoReadFrom(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReaderEmpty">
            <h2>BenchmarkReaderEmpty</h2>
            <hr />
            
            <pre><code>func BenchmarkReaderEmpty(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWriterEmpty">
            <h2>BenchmarkWriterEmpty</h2>
            <hr />
            
            <pre><code>func BenchmarkWriterEmpty(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWriterFlush">
            <h2>BenchmarkWriterFlush</h2>
            <hr />
            
            <pre><code>func BenchmarkWriterFlush(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="ExampleWriter">
            <h2>ExampleWriter</h2>
            <hr />
            
            <pre><code>func ExampleWriter()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleWriter_AvailableBuffer">
            <h2>ExampleWriter_AvailableBuffer</h2>
            <hr />
            
            <pre><code>func ExampleWriter_AvailableBuffer()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleWriter_ReadFrom">
            <h2>ExampleWriter_ReadFrom</h2>
            <hr />
            
            <p>ExampleWriter_ReadFrom demonstrates how to use the ReadFrom method of Writer.</p>
            
            <pre><code>func ExampleWriter_ReadFrom()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScanner_lines">
            <h2>ExampleScanner_lines</h2>
            <hr />
            
            <p>The simplest use of a Scanner, to read standard input as a set of lines.</p>
            
            <pre><code>func ExampleScanner_lines()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScanner_Bytes">
            <h2>ExampleScanner_Bytes</h2>
            <hr />
            
            <p>Return the most recent call to Scan as a []byte.</p>
            
            <pre><code>func ExampleScanner_Bytes()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScanner_words">
            <h2>ExampleScanner_words</h2>
            <hr />
            
            <p>Use a Scanner to implement a simple word-count utility by scanning the
input as a sequence of space-delimited tokens.</p>
            
            <pre><code>func ExampleScanner_words()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScanner_custom">
            <h2>ExampleScanner_custom</h2>
            <hr />
            
            <p>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate
32-bit decimal input.</p>
            
            <pre><code>func ExampleScanner_custom()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScanner_emptyFinalToken">
            <h2>ExampleScanner_emptyFinalToken</h2>
            <hr />
            
            <p>Use a Scanner with a custom split function to parse a comma-separated
list with an empty final value.</p>
            
            <pre><code>func ExampleScanner_emptyFinalToken()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScanner_earlyStop">
            <h2>ExampleScanner_earlyStop</h2>
            <hr />
            
            <p>Use a Scanner with a custom split function to parse a comma-separated
list with an empty final value but stops at the token "STOP".</p>
            
            <pre><code>func ExampleScanner_earlyStop()</code></pre>
         </article>
         
         <article class="function" data-name="TestSpace">
            <h2>TestSpace</h2>
            <hr />
            
            <p>Test white space table matches the Unicode definition.</p>
            
            <pre><code>func TestSpace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanByte">
            <h2>TestScanByte</h2>
            <hr />
            
            <pre><code>func TestScanByte(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanRune">
            <h2>TestScanRune</h2>
            <hr />
            
            <p>Test that the rune splitter returns same sequence of runes (not bytes) as for range string.</p>
            
            <pre><code>func TestScanRune(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanWords">
            <h2>TestScanWords</h2>
            <hr />
            
            <p>Test that the word splitter returns the same data as strings.Fields.</p>
            
            <pre><code>func TestScanWords(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="genLine">
            <h2>genLine</h2>
            <hr />
            
            <p>genLine writes to buf a predictable but non-trivial line of text of length
n, including the terminal newline and an occasional carriage return.
If addNewline is false, the \r and \n are not emitted.</p>
            
            <pre><code>func genLine(buf *bytes.Buffer, lineNum int, n int, addNewline bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanLongLines">
            <h2>TestScanLongLines</h2>
            <hr />
            
            <p>Test the line splitter, including some carriage returns but no long lines.</p>
            
            <pre><code>func TestScanLongLines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanLineTooLong">
            <h2>TestScanLineTooLong</h2>
            <hr />
            
            <p>Test that the line splitter errors out on a long line.</p>
            
            <pre><code>func TestScanLineTooLong(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testNoNewline">
            <h2>testNoNewline</h2>
            <hr />
            
            <p>Test that the line splitter handles a final line without a newline.</p>
            
            <pre><code>func testNoNewline(text string, lines []string, t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanLineNoNewline">
            <h2>TestScanLineNoNewline</h2>
            <hr />
            
            <p>Test that the line splitter handles a final line without a newline.</p>
            
            <pre><code>func TestScanLineNoNewline(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanLineReturnButNoNewline">
            <h2>TestScanLineReturnButNoNewline</h2>
            <hr />
            
            <p>Test that the line splitter handles a final line with a carriage return but no newline.</p>
            
            <pre><code>func TestScanLineReturnButNoNewline(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanLineEmptyFinalLine">
            <h2>TestScanLineEmptyFinalLine</h2>
            <hr />
            
            <p>Test that the line splitter handles a final empty line.</p>
            
            <pre><code>func TestScanLineEmptyFinalLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanLineEmptyFinalLineWithCR">
            <h2>TestScanLineEmptyFinalLineWithCR</h2>
            <hr />
            
            <p>Test that the line splitter handles a final empty line with a carriage return but no newline.</p>
            
            <pre><code>func TestScanLineEmptyFinalLineWithCR(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSplitError">
            <h2>TestSplitError</h2>
            <hr />
            
            <p>Test the correct error is returned when the split function errors out.</p>
            
            <pre><code>func TestSplitError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestErrAtEOF">
            <h2>TestErrAtEOF</h2>
            <hr />
            
            <p>Test that an EOF is overridden by a user-generated scan error.</p>
            
            <pre><code>func TestErrAtEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestNonEOFWithEmptyRead">
            <h2>TestNonEOFWithEmptyRead</h2>
            <hr />
            
            <pre><code>func TestNonEOFWithEmptyRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestBadReader">
            <h2>TestBadReader</h2>
            <hr />
            
            <pre><code>func TestBadReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanWordsExcessiveWhiteSpace">
            <h2>TestScanWordsExcessiveWhiteSpace</h2>
            <hr />
            
            <pre><code>func TestScanWordsExcessiveWhiteSpace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="commaSplit">
            <h2>commaSplit</h2>
            <hr />
            
            <pre><code>func commaSplit(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="testEmptyTokens">
            <h2>testEmptyTokens</h2>
            <hr />
            
            <pre><code>func testEmptyTokens(t *testing.T, text string, values []string)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyTokens">
            <h2>TestEmptyTokens</h2>
            <hr />
            
            <pre><code>func TestEmptyTokens(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWithNoEmptyTokens">
            <h2>TestWithNoEmptyTokens</h2>
            <hr />
            
            <pre><code>func TestWithNoEmptyTokens(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="loopAtEOFSplit">
            <h2>loopAtEOFSplit</h2>
            <hr />
            
            <pre><code>func loopAtEOFSplit(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestDontLoopForever">
            <h2>TestDontLoopForever</h2>
            <hr />
            
            <pre><code>func TestDontLoopForever(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBlankLines">
            <h2>TestBlankLines</h2>
            <hr />
            
            <pre><code>func TestBlankLines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="split">
            <h2>split</h2>
            <hr />
            
            <pre><code>func split(data []byte, atEOF bool) (advance int, token []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyLinesOK">
            <h2>TestEmptyLinesOK</h2>
            <hr />
            
            <p>Check that the looping-at-EOF check doesn't trigger for merely empty tokens.</p>
            
            <pre><code>func TestEmptyLinesOK(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHugeBuffer">
            <h2>TestHugeBuffer</h2>
            <hr />
            
            <p>Make sure we can read a huge token if a big enough buffer is provided.</p>
            
            <pre><code>func TestHugeBuffer(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestNegativeEOFReader">
            <h2>TestNegativeEOFReader</h2>
            <hr />
            
            <p>Test that the scanner doesn't panic and returns ErrBadReadCount
on a reader that returns a negative count of bytes read (issue 38053).</p>
            
            <pre><code>func TestNegativeEOFReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeReader">
            <h2>TestLargeReader</h2>
            <hr />
            
            <p>Test that the scanner doesn't panic and returns ErrBadReadCount
on a reader that returns an impossibly large count of bytes read (issue 38053).</p>
            
            <pre><code>func TestLargeReader(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
