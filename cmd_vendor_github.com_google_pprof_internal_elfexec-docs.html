<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - elfexec</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>elfexec</code>
         </h1>
         <hr />
         
         <article class="global" data-name="maxNoteSize">
            <h2>maxNoteSize</h2>
            <hr />
            
            <pre><code>maxNoteSize</code></pre>
         </article>
         
         <article class="global" data-name="noteTypeGNUBuildID">
            <h2>noteTypeGNUBuildID</h2>
            <hr />
            
            <pre><code>noteTypeGNUBuildID</code></pre>
         </article>
          
         <article class="struct" data-name="elfNote">
            <h2>type elfNote struct</h2>
            <hr />
            
            <p>elfNote is the payload of a Note Section in an ELF file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
Desc []byte
Type uint32</code></pre>
         </article>
          
         <article class="function" data-name="parseNotes">
            <h2>parseNotes</h2>
            <hr />
            
            <p>parseNotes returns the notes from a SHT_NOTE section or PT_NOTE segment.</p>
            
            <pre><code>func parseNotes(reader io.Reader, alignment int, order binary.ByteOrder) ([]elfNote, error)</code></pre>
         </article>
         
         <article class="function" data-name="GetBuildID">
            <h2>GetBuildID</h2>
            <hr />
            
            <p>GetBuildID returns the GNU build-ID for an ELF binary.

If no build-ID was found but the binary was read without error, it returns
(nil, nil).</p>
            
            <pre><code>func GetBuildID(f *elf.File) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="kernelBase">
            <h2>kernelBase</h2>
            <hr />
            
            <p>kernelBase calculates the base for kernel mappings, which usually require
special handling. For kernel mappings, tools (like perf) use the address of
the kernel relocation symbol (_text or _stext) as the mmap start. Additionally,
for obfuscation, ChromeOS profiles have the kernel image remapped to the 0-th page.</p>
            
            <pre><code>func kernelBase(loadSegment *elf.ProgHeader, stextOffset *uint64, start uint64, limit uint64, offset uint64) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="GetBase">
            <h2>GetBase</h2>
            <hr />
            
            <p>GetBase determines the base address to subtract from virtual
address to get symbol table address. For an executable, the base
is 0. Otherwise, it's a shared library, and the base is the
address where the mapping starts. The kernel needs special handling.</p>
            
            <pre><code>func GetBase(fh *elf.FileHeader, loadSegment *elf.ProgHeader, stextOffset *uint64, start uint64, limit uint64, offset uint64) (uint64, error)</code></pre>
         </article>
         
         <article class="function" data-name="FindTextProgHeader">
            <h2>FindTextProgHeader</h2>
            <hr />
            
            <p>FindTextProgHeader finds the program segment header containing the .text
section or nil if the segment cannot be found.</p>
            
            <pre><code>func FindTextProgHeader(f *elf.File) *elf.ProgHeader</code></pre>
         </article>
         
         <article class="function" data-name="ProgramHeadersForMapping">
            <h2>ProgramHeadersForMapping</h2>
            <hr />
            
            <p>ProgramHeadersForMapping returns the program segment headers that overlap
the runtime mapping with file offset mapOff and memory size mapSz. We skip
over segments zero file size because their file offset values are unreliable.
Even if overlapping, a segment is not selected if its aligned file offset is
greater than the mapping file offset, or if the mapping includes the last
page of the segment, but not the full segment and the mapping includes
additional pages after the segment end.
The function returns a slice of pointers to the headers in the input
slice, which are valid only while phdrs is not modified or discarded.</p>
            
            <pre><code>func ProgramHeadersForMapping(phdrs []elf.ProgHeader, mapOff uint64, mapSz uint64) []*elf.ProgHeader</code></pre>
         </article>
         
         <article class="function" data-name="HeaderForFileOffset">
            <h2>HeaderForFileOffset</h2>
            <hr />
            
            <p>HeaderForFileOffset attempts to identify a unique program header that
includes the given file offset. It returns an error if it cannot identify a
unique header.</p>
            
            <pre><code>func HeaderForFileOffset(headers []*elf.ProgHeader, fileOffset uint64) (*elf.ProgHeader, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
