<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - unsafe</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>unsafe</code>
         </h1>
         <hr />
           
         <article class="function" data-name="Sizeof">
            <h2>Sizeof</h2>
            <hr />
            
            <p>Sizeof takes an expression x of any type and returns the size in bytes
of a hypothetical variable v as if v was declared via var v = x.
The size does not include any memory possibly referenced by x.
For instance, if x is a slice, Sizeof returns the size of the slice
descriptor, not the size of the memory referenced by the slice;
if x is an interface, Sizeof returns the size of the interface value itself,
not the size of the value stored in the interface.
For a struct, the size includes any padding introduced by field alignment.
The return value of Sizeof is a Go constant if the type of the argument x
does not have variable size.
(A type has variable size if it is a type parameter or if it is an array
or struct type with elements of variable size).</p>
            
            <pre><code>func Sizeof(x ArbitraryType) uintptr</code></pre>
         </article>
         
         <article class="function" data-name="Offsetof">
            <h2>Offsetof</h2>
            <hr />
            
            <p>Offsetof returns the offset within the struct of the field represented by x,
which must be of the form structValue.field. In other words, it returns the
number of bytes between the start of the struct and the start of the field.
The return value of Offsetof is a Go constant if the type of the argument x
does not have variable size.
(See the description of [Sizeof] for a definition of variable sized types.)</p>
            
            <pre><code>func Offsetof(x ArbitraryType) uintptr</code></pre>
         </article>
         
         <article class="function" data-name="Alignof">
            <h2>Alignof</h2>
            <hr />
            
            <p>Alignof takes an expression x of any type and returns the required alignment
of a hypothetical variable v as if v was declared via var v = x.
It is the largest value m such that the address of v is always zero mod m.
It is the same as the value returned by [reflect.TypeOf](x).Align().
As a special case, if a variable s is of struct type and f is a field
within that struct, then Alignof(s.f) will return the required alignment
of a field of that type within a struct. This case is the same as the
value returned by [reflect.TypeOf](s.f).FieldAlign().
The return value of Alignof is a Go constant if the type of the argument
does not have variable size.
(See the description of [Sizeof] for a definition of variable sized types.)</p>
            
            <pre><code>func Alignof(x ArbitraryType) uintptr</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>The function Add adds len to ptr and returns the updated pointer
[Pointer](uintptr(ptr) + uintptr(len)).
The len argument must be of integer type or an untyped constant.
A constant len argument must be representable by a value of type int;
if it is an untyped constant it is given type int.
The rules for valid uses of Pointer still apply.</p>
            
            <pre><code>func Add(ptr Pointer, len IntegerType) Pointer</code></pre>
         </article>
         
         <article class="function" data-name="Slice">
            <h2>Slice</h2>
            <hr />
            
            <p>The function Slice returns a slice whose underlying array starts at ptr
and whose length and capacity are len.
Slice(ptr, len) is equivalent to

	(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]

except that, as a special case, if ptr is nil and len is zero,
Slice returns nil.

The len argument must be of integer type or an untyped constant.
A constant len argument must be non-negative and representable by a value of type int;
if it is an untyped constant it is given type int.
At run time, if len is negative, or if ptr is nil and len is not zero,
a run-time panic occurs.</p>
            
            <pre><code>func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType</code></pre>
         </article>
         
         <article class="function" data-name="SliceData">
            <h2>SliceData</h2>
            <hr />
            
            <p>SliceData returns a pointer to the underlying array of the argument
slice.
  - If cap(slice) > 0, SliceData returns &slice[:1][0].
  - If slice == nil, SliceData returns nil.
  - Otherwise, SliceData returns a non-nil pointer to an
    unspecified memory address.</p>
            
            <pre><code>func SliceData(slice []ArbitraryType) *ArbitraryType</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a string value whose underlying bytes
start at ptr and whose length is len.

The len argument must be of integer type or an untyped constant.
A constant len argument must be non-negative and representable by a value of type int;
if it is an untyped constant it is given type int.
At run time, if len is negative, or if ptr is nil and len is not zero,
a run-time panic occurs.

Since Go strings are immutable, the bytes passed to String
must not be modified as long as the returned string value exists.</p>
            
            <pre><code>func String(ptr *byte, len IntegerType) string</code></pre>
         </article>
         
         <article class="function" data-name="StringData">
            <h2>StringData</h2>
            <hr />
            
            <p>StringData returns a pointer to the underlying bytes of str.
For an empty string the return value is unspecified, and may be nil.

Since Go strings are immutable, the bytes returned by StringData
must not be modified.</p>
            
            <pre><code>func StringData(str string) *byte</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
