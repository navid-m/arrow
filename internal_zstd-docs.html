<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zstd</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>zstd</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"encoding/binary"
"encoding/binary"
"math/bits"
"encoding/binary"
"errors"
"fmt"
"io"
"math/bits"
"io"
"math/bits"
"io"
"math/bits"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="debug" data-name="debug">
               <h3>
                  debug 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debug" class="anchor" title="Link to debug">#</a>
               </h3>
               
                  <p class="doc-comment">debug can be set in the source to print debug info using println.</p>
               
               <pre><code class="language-go">const debug = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fuzzing" data-name="fuzzing">
               <h3>
                  fuzzing 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fuzzing" class="anchor" title="Link to fuzzing">#</a>
               </h3>
               
                  <p class="doc-comment">fuzzing is a fuzzer hook set to true when fuzzing.
This is used to reject cases where we don't match zstd.</p>
               
               <pre><code class="language-go">var fuzzing = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="literalLengthBase" data-name="literalLengthBase">
               <h3>
                  literalLengthBase 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#literalLengthBase" class="anchor" title="Link to literalLengthBase">#</a>
               </h3>
               
               <pre><code class="language-go">var literalLengthBase = []uint32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="literalLengthOffset" data-name="literalLengthOffset">
               <h3>
                  literalLengthOffset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#literalLengthOffset" class="anchor" title="Link to literalLengthOffset">#</a>
               </h3>
               
               <pre><code class="language-go">const literalLengthOffset = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchLengthBase" data-name="matchLengthBase">
               <h3>
                  matchLengthBase 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#matchLengthBase" class="anchor" title="Link to matchLengthBase">#</a>
               </h3>
               
               <pre><code class="language-go">var matchLengthBase = []uint32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchLengthOffset" data-name="matchLengthOffset">
               <h3>
                  matchLengthOffset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#matchLengthOffset" class="anchor" title="Link to matchLengthOffset">#</a>
               </h3>
               
               <pre><code class="language-go">const matchLengthOffset = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxHuffmanBits" data-name="maxHuffmanBits">
               <h3>
                  maxHuffmanBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxHuffmanBits" class="anchor" title="Link to maxHuffmanBits">#</a>
               </h3>
               
                  <p class="doc-comment">maxHuffmanBits is the largest possible Huffman table bits.</p>
               
               <pre><code class="language-go">const maxHuffmanBits = 11</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predefinedLiteralTable" data-name="predefinedLiteralTable">
               <h3>
                  predefinedLiteralTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predefinedLiteralTable" class="anchor" title="Link to predefinedLiteralTable">#</a>
               </h3>
               
                  <p class="doc-comment">predefinedLiteralTable is the predefined table to use for literal lengths.
Generated from table in RFC 3.1.1.3.2.2.1.
Checked by TestPredefinedTables.</p>
               
               <pre><code class="language-go">var predefinedLiteralTable = [...]fseBaselineEntry{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predefinedMatchTable" data-name="predefinedMatchTable">
               <h3>
                  predefinedMatchTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predefinedMatchTable" class="anchor" title="Link to predefinedMatchTable">#</a>
               </h3>
               
                  <p class="doc-comment">predefinedMatchTable is the predefined table to use for match lengths.
Generated from table in RFC 3.1.1.3.2.2.2.
Checked by TestPredefinedTables.</p>
               
               <pre><code class="language-go">var predefinedMatchTable = [...]fseBaselineEntry{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predefinedOffsetTable" data-name="predefinedOffsetTable">
               <h3>
                  predefinedOffsetTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predefinedOffsetTable" class="anchor" title="Link to predefinedOffsetTable">#</a>
               </h3>
               
                  <p class="doc-comment">predefinedOffsetTable is the predefined table to use for offsets.
Generated from table in RFC 3.1.1.3.2.2.3.
Checked by TestPredefinedTables.</p>
               
               <pre><code class="language-go">var predefinedOffsetTable = [...]fseBaselineEntry{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seqCodeInfo" data-name="seqCodeInfo">
               <h3>
                  seqCodeInfo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#seqCodeInfo" class="anchor" title="Link to seqCodeInfo">#</a>
               </h3>
               
                  <p class="doc-comment">seqCodeInfo is the seqCodeInfoData for each kind of sequence code.</p>
               
               <pre><code class="language-go">var seqCodeInfo = [3]seqCodeInfoData{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seqLiteral" data-name="seqLiteral">
               <h3>
                  seqLiteral 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seqLiteral" class="anchor" title="Link to seqLiteral">#</a>
               </h3>
               
               <pre><code class="language-go">const seqLiteral seqCode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seqMatch" data-name="seqMatch">
               <h3>
                  seqMatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seqMatch" class="anchor" title="Link to seqMatch">#</a>
               </h3>
               
               <pre><code class="language-go">const seqMatch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seqOffset" data-name="seqOffset">
               <h3>
                  seqOffset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seqOffset" class="anchor" title="Link to seqOffset">#</a>
               </h3>
               
               <pre><code class="language-go">const seqOffset</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xxhPrime64c1" data-name="xxhPrime64c1">
               <h3>
                  xxhPrime64c1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xxhPrime64c1" class="anchor" title="Link to xxhPrime64c1">#</a>
               </h3>
               
               <pre><code class="language-go">const xxhPrime64c1 = 0x9e3779b185ebca87</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xxhPrime64c2" data-name="xxhPrime64c2">
               <h3>
                  xxhPrime64c2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xxhPrime64c2" class="anchor" title="Link to xxhPrime64c2">#</a>
               </h3>
               
               <pre><code class="language-go">const xxhPrime64c2 = 0xc2b2ae3d27d4eb4f</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xxhPrime64c3" data-name="xxhPrime64c3">
               <h3>
                  xxhPrime64c3 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xxhPrime64c3" class="anchor" title="Link to xxhPrime64c3">#</a>
               </h3>
               
               <pre><code class="language-go">const xxhPrime64c3 = 0x165667b19e3779f9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xxhPrime64c4" data-name="xxhPrime64c4">
               <h3>
                  xxhPrime64c4 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xxhPrime64c4" class="anchor" title="Link to xxhPrime64c4">#</a>
               </h3>
               
               <pre><code class="language-go">const xxhPrime64c4 = 0x85ebca77c2b2ae63</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xxhPrime64c5" data-name="xxhPrime64c5">
               <h3>
                  xxhPrime64c5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xxhPrime64c5" class="anchor" title="Link to xxhPrime64c5">#</a>
               </h3>
               
               <pre><code class="language-go">const xxhPrime64c5 = 0x27d4eb2f165667c5</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="block" data-name="block">
               <h3>
                  block
                  <span class="badge type-badge">type</span>
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block is the data for a single compressed block.
The data starts immediately after the 3 byte block header,
and is Block_Size bytes long.</p>
               
               <pre><code class="language-go">type block []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="seqCode" data-name="seqCode">
               <h3>
                  seqCode
                  <span class="badge type-badge">type</span>
                  <a href="#seqCode" class="anchor" title="Link to seqCode">#</a>
               </h3>
               
               <p>seqCode is the kind of sequence codes we have to handle.</p>
               
               <pre><code class="language-go">type seqCode int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>Reader implements [io.Reader] to read a zstd compressed stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Reader struct {
r io.Reader
sawFrameHeader bool
hasChecksum bool
readOneFrame bool
frameSizeUnknown bool
remainingFrameSize uint64
blockOffset int64
buffer []byte
off int
repeatedOffset1 uint32
repeatedOffset2 uint32
repeatedOffset3 uint32
huffmanTable []uint16
huffmanTableBits int
window window
compressedBuf []byte
literals []byte
seqTables [3][]fseBaselineEntry
seqTableBits [3]uint8
seqTableBuffers [3][]fseBaselineEntry
scratch [16]byte
fseScratch []fseEntry
checksum xxhash64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bitReader" data-name="bitReader">
               <h3>
                  bitReader
                  <span class="badge">struct</span>
                  <a href="#bitReader" class="anchor" title="Link to bitReader">#</a>
               </h3>
               
               <p>bitReader reads a bit stream going forward.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type bitReader struct {
r *Reader
data block
off uint32
bits uint32
cnt uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fseBaselineEntry" data-name="fseBaselineEntry">
               <h3>
                  fseBaselineEntry
                  <span class="badge">struct</span>
                  <a href="#fseBaselineEntry" class="anchor" title="Link to fseBaselineEntry">#</a>
               </h3>
               
               <p>fseBaselineEntry is an entry in an FSE baseline table.
We use these for literal/match/length values.
Those require mapping the symbol to a baseline value,
and then reading zero or more bits and adding the value to the baseline.
Rather than looking these up in separate tables,
we convert the FSE table to an FSE baseline table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fseBaselineEntry struct {
baseline uint32
basebits uint8
bits uint8
base uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fseEntry" data-name="fseEntry">
               <h3>
                  fseEntry
                  <span class="badge">struct</span>
                  <a href="#fseEntry" class="anchor" title="Link to fseEntry">#</a>
               </h3>
               
               <p>fseEntry is one entry in an FSE table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fseEntry struct {
sym uint8
bits uint8
base uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="reverseBitReader" data-name="reverseBitReader">
               <h3>
                  reverseBitReader
                  <span class="badge">struct</span>
                  <a href="#reverseBitReader" class="anchor" title="Link to reverseBitReader">#</a>
               </h3>
               
               <p>reverseBitReader reads a bit stream in reverse.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type reverseBitReader struct {
r *Reader
data block
off uint32
start uint32
bits uint32
cnt uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="seqCodeInfoData" data-name="seqCodeInfoData">
               <h3>
                  seqCodeInfoData
                  <span class="badge">struct</span>
                  <a href="#seqCodeInfoData" class="anchor" title="Link to seqCodeInfoData">#</a>
               </h3>
               
               <p>seqCodeInfoData is the information needed to set up seqTables and
seqTableBits for a particular kind of sequence code.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type seqCodeInfoData struct {
predefTable []fseBaselineEntry
predefTableBits int
maxSym int
maxBits int
toBaseline func(*Reader, int, []fseEntry, []fseBaselineEntry) error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="window" data-name="window">
               <h3>
                  window
                  <span class="badge">struct</span>
                  <a href="#window" class="anchor" title="Link to window">#</a>
               </h3>
               
               <p>window stores up to size bytes of data.
It is implemented as a circular buffer:
sequential save calls append to the data slice until
its length reaches configured size and after that,
save calls overwrite previously saved data at off
and update off such that it always points at
the byte stored before others.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type window struct {
size int
data []byte
off int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="xxhash64" data-name="xxhash64">
               <h3>
                  xxhash64
                  <span class="badge">struct</span>
                  <a href="#xxhash64" class="anchor" title="Link to xxhash64">#</a>
               </h3>
               
               <p>xxhash64 is the state of a xxHash-64 checksum.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type xxhash64 struct {
len uint64
v [4]uint64
buf [32]byte
cnt int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zstdError" data-name="zstdError">
               <h3>
                  zstdError
                  <span class="badge">struct</span>
                  <a href="#zstdError" class="anchor" title="Link to zstdError">#</a>
               </h3>
               
               <p>zstdError is an error while decompressing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type zstdError struct {
offset int64
err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (ze *zstdError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader creates a new Reader that decompresses data from the given reader.</p>
               
               <pre><code class="language-go">func NewReader(input io.Reader) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read implements [io.Reader].</p>
               
               <pre><code class="language-go">func (r *Reader) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadByte" data-name="ReadByte">
               <h3>
                  ReadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadByte" class="anchor" title="Link to ReadByte">#</a>
               </h3>
               
               <p>ReadByte implements [io.ByteReader].</p>
               
               <pre><code class="language-go">func (r *Reader) ReadByte() (byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset discards the current state and starts reading a new stream from r.
This permits reusing a Reader rather than allocating a new one.</p>
               
               <pre><code class="language-go">func (r *Reader) Reset(input io.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (ze *zstdError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTo" data-name="appendTo">
               <h3>
                  appendTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendTo" class="anchor" title="Link to appendTo">#</a>
               </h3>
               
               <p>appendTo appends stored bytes between from and to indices to the buf.
Index from must be less or equal to index to and to must be less or equal to w.len().</p>
               
               <pre><code class="language-go">func (w *window) appendTo(buf []byte, from uint32, to uint32) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="backup" data-name="backup">
               <h3>
                  backup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#backup" class="anchor" title="Link to backup">#</a>
               </h3>
               
               <p>backup steps back to the last byte we used.</p>
               
               <pre><code class="language-go">func (br *bitReader) backup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildFSE" data-name="buildFSE">
               <h3>
                  buildFSE 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#buildFSE" class="anchor" title="Link to buildFSE">#</a>
               </h3>
               
               <p>buildFSE builds an FSE decoding table from a list of probabilities.
The probabilities are in norm. next is scratch space. The number of bits
in the table is tableBits.</p>
               
               <pre><code class="language-go">func (r *Reader) buildFSE(off int, norm []int16, table []fseEntry, tableBits int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compressedBlock" data-name="compressedBlock">
               <h3>
                  compressedBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compressedBlock" class="anchor" title="Link to compressedBlock">#</a>
               </h3>
               
               <p>compressedBlock decompresses a compressed block, storing the decompressed
data in r.buffer. The blockSize argument is the compressed size.
RFC 3.1.1.3.</p>
               
               <pre><code class="language-go">func (r *Reader) compressedBlock(blockSize int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyFromWindow" data-name="copyFromWindow">
               <h3>
                  copyFromWindow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyFromWindow" class="anchor" title="Link to copyFromWindow">#</a>
               </h3>
               
               <p>Copy match bytes from the decoded output, or the window, at offset.</p>
               
               <pre><code class="language-go">func (r *Reader) copyFromWindow(rbr *reverseBitReader, offset uint32, match uint32) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="digest" data-name="digest">
               <h3>
                  digest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#digest" class="anchor" title="Link to digest">#</a>
               </h3>
               
               <p>digest returns the final hash value.</p>
               
               <pre><code class="language-go">func (xh *xxhash64) digest() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="execSeqs" data-name="execSeqs">
               <h3>
                  execSeqs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#execSeqs" class="anchor" title="Link to execSeqs">#</a>
               </h3>
               
               <p>execSeqs reads and executes the sequences. RFC 3.1.1.3.2.1.2.</p>
               
               <pre><code class="language-go">func (r *Reader) execSeqs(data block, off int, litbuf []byte, seqCount int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fetch" data-name="fetch">
               <h3>
                  fetch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fetch" class="anchor" title="Link to fetch">#</a>
               </h3>
               
               <p>fetch is called to ensure that at least b bits are available.
It reports false if this can't be done,
in which case only rbr.cnt bits are available.</p>
               
               <pre><code class="language-go">func (rbr *reverseBitReader) fetch(b uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initSeqs" data-name="initSeqs">
               <h3>
                  initSeqs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initSeqs" class="anchor" title="Link to initSeqs">#</a>
               </h3>
               
               <p>initSeqs reads the Sequences_Section_Header and sets up the FSE
tables used to read the sequence codes. It returns the number of
sequences and the new offset. RFC 3.1.1.3.2.1.</p>
               
               <pre><code class="language-go">func (r *Reader) initSeqs(data block, off int) (int, int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <p>len returns the number of stored bytes.</p>
               
               <pre><code class="language-go">func (w *window) len() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeBitReader" data-name="makeBitReader">
               <h3>
                  makeBitReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeBitReader" class="anchor" title="Link to makeBitReader">#</a>
               </h3>
               
               <p>makeBitReader makes a bit reader starting at off.</p>
               
               <pre><code class="language-go">func (r *Reader) makeBitReader(data block, off int) bitReader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeEOFError" data-name="makeEOFError">
               <h3>
                  makeEOFError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeEOFError" class="anchor" title="Link to makeEOFError">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Reader) makeEOFError(off int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeError" data-name="makeError">
               <h3>
                  makeError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeError" class="anchor" title="Link to makeError">#</a>
               </h3>
               
               <p>makeError returns an error at the current offset wrapping a string.</p>
               
               <pre><code class="language-go">func (rbr *reverseBitReader) makeError(msg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeError" data-name="makeError">
               <h3>
                  makeError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeError" class="anchor" title="Link to makeError">#</a>
               </h3>
               
               <p>makeError returns an error at the current offset wrapping a string.</p>
               
               <pre><code class="language-go">func (br *bitReader) makeError(msg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeError" data-name="makeError">
               <h3>
                  makeError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeError" class="anchor" title="Link to makeError">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Reader) makeError(off int, msg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeLiteralBaselineFSE" data-name="makeLiteralBaselineFSE">
               <h3>
                  makeLiteralBaselineFSE 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeLiteralBaselineFSE" class="anchor" title="Link to makeLiteralBaselineFSE">#</a>
               </h3>
               
               <p>makeLiteralBaselineFSE converts the literal length fseTable to baselineTable.</p>
               
               <pre><code class="language-go">func (r *Reader) makeLiteralBaselineFSE(off int, fseTable []fseEntry, baselineTable []fseBaselineEntry) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeMatchBaselineFSE" data-name="makeMatchBaselineFSE">
               <h3>
                  makeMatchBaselineFSE 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeMatchBaselineFSE" class="anchor" title="Link to makeMatchBaselineFSE">#</a>
               </h3>
               
               <p>makeMatchBaselineFSE converts the match length fseTable to baselineTable.</p>
               
               <pre><code class="language-go">func (r *Reader) makeMatchBaselineFSE(off int, fseTable []fseEntry, baselineTable []fseBaselineEntry) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeOffsetBaselineFSE" data-name="makeOffsetBaselineFSE">
               <h3>
                  makeOffsetBaselineFSE 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeOffsetBaselineFSE" class="anchor" title="Link to makeOffsetBaselineFSE">#</a>
               </h3>
               
               <p>makeOffsetBaselineFSE converts the offset length fseTable to baselineTable.</p>
               
               <pre><code class="language-go">func (r *Reader) makeOffsetBaselineFSE(off int, fseTable []fseEntry, baselineTable []fseBaselineEntry) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeReverseBitReader" data-name="makeReverseBitReader">
               <h3>
                  makeReverseBitReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeReverseBitReader" class="anchor" title="Link to makeReverseBitReader">#</a>
               </h3>
               
               <p>makeReverseBitReader makes a reverseBitReader reading backward
from off to start. The bitstream starts with a 1 bit in the last
byte, at off.</p>
               
               <pre><code class="language-go">func (r *Reader) makeReverseBitReader(data block, off int, start int) (reverseBitReader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeRound" data-name="mergeRound">
               <h3>
                  mergeRound 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mergeRound" class="anchor" title="Link to mergeRound">#</a>
               </h3>
               
               <p>mergeRound updates a value in the final round.</p>
               
               <pre><code class="language-go">func (xh *xxhash64) mergeRound(v uint64, n uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moreBits" data-name="moreBits">
               <h3>
                  moreBits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#moreBits" class="anchor" title="Link to moreBits">#</a>
               </h3>
               
               <p>moreBits is called to read more bits.
This ensures that at least 16 bits are available.</p>
               
               <pre><code class="language-go">func (br *bitReader) moreBits() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readBlock" data-name="readBlock">
               <h3>
                  readBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readBlock" class="anchor" title="Link to readBlock">#</a>
               </h3>
               
               <p>readBlock reads the next block from a frame.</p>
               
               <pre><code class="language-go">func (r *Reader) readBlock() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFSE" data-name="readFSE">
               <h3>
                  readFSE 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFSE" class="anchor" title="Link to readFSE">#</a>
               </h3>
               
               <p>readFSE reads an FSE table from data starting at off.
maxSym is the maximum symbol value.
maxBits is the maximum number of bits permitted for symbols in the table.
The FSE is written into table, which must be at least 1<<maxBits in size.
This returns the number of bits in the FSE table and the new offset.
RFC 4.1.1.</p>
               
               <pre><code class="language-go">func (r *Reader) readFSE(data block, off int, maxSym int, maxBits int, table []fseEntry) (tableBits int, roff int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrameHeader" data-name="readFrameHeader">
               <h3>
                  readFrameHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrameHeader" class="anchor" title="Link to readFrameHeader">#</a>
               </h3>
               
               <p>readFrameHeader reads the frame header and prepares to read a block.</p>
               
               <pre><code class="language-go">func (r *Reader) readFrameHeader() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readHuff" data-name="readHuff">
               <h3>
                  readHuff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readHuff" class="anchor" title="Link to readHuff">#</a>
               </h3>
               
               <p>readHuff reads Huffman table from data starting at off into table.
Each entry in a Huffman table is a pair of bytes.
The high byte is the encoded value. The low byte is the number
of bits used to encode that value. We index into the table
with a value of size tableBits. A value that requires fewer bits
appear in the table multiple times.
This returns the number of bits in the Huffman table and the new offset.
RFC 4.2.1.</p>
               
               <pre><code class="language-go">func (r *Reader) readHuff(data block, off int, table []uint16) (tableBits int, roff int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readHuffLiterals" data-name="readHuffLiterals">
               <h3>
                  readHuffLiterals 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readHuffLiterals" class="anchor" title="Link to readHuffLiterals">#</a>
               </h3>
               
               <p>readHuffLiterals reads and decompresses a Compressed_Literals_Block or
a Treeless_Literals_Block. RFC 3.1.1.3.1.4.</p>
               
               <pre><code class="language-go">func (r *Reader) readHuffLiterals(data block, off int, hdr byte, outbuf []byte) (int, []byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLiterals" data-name="readLiterals">
               <h3>
                  readLiterals 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLiterals" class="anchor" title="Link to readLiterals">#</a>
               </h3>
               
               <p>readLiterals reads and decompresses the literals from data at off.
The literals are appended to outbuf, which is returned.
Also returns the new input offset. RFC 3.1.1.3.1.</p>
               
               <pre><code class="language-go">func (r *Reader) readLiterals(data block, off int, outbuf []byte) (int, []byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLiteralsFourStreams" data-name="readLiteralsFourStreams">
               <h3>
                  readLiteralsFourStreams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLiteralsFourStreams" class="anchor" title="Link to readLiteralsFourStreams">#</a>
               </h3>
               
               <p>readLiteralsFourStreams reads four interleaved streams of
compressed literals.</p>
               
               <pre><code class="language-go">func (r *Reader) readLiteralsFourStreams(data block, off int, totalStreamsSize int, regeneratedSize int, outbuf []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLiteralsOneStream" data-name="readLiteralsOneStream">
               <h3>
                  readLiteralsOneStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLiteralsOneStream" class="anchor" title="Link to readLiteralsOneStream">#</a>
               </h3>
               
               <p>readLiteralsOneStream reads a single stream of compressed literals.</p>
               
               <pre><code class="language-go">func (r *Reader) readLiteralsOneStream(data block, off int, compressedSize int, regeneratedSize int, outbuf []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRawRLELiterals" data-name="readRawRLELiterals">
               <h3>
                  readRawRLELiterals 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readRawRLELiterals" class="anchor" title="Link to readRawRLELiterals">#</a>
               </h3>
               
               <p>readRawRLELiterals reads and decompresses a Raw_Literals_Block or
a RLE_Literals_Block. RFC 3.1.1.3.1.1.</p>
               
               <pre><code class="language-go">func (r *Reader) readRawRLELiterals(data block, off int, hdr byte, outbuf []byte) (int, []byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refill" data-name="refill">
               <h3>
                  refill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refill" class="anchor" title="Link to refill">#</a>
               </h3>
               
               <p>refill reads and decompresses the next block.</p>
               
               <pre><code class="language-go">func (r *Reader) refill() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refillIfNeeded" data-name="refillIfNeeded">
               <h3>
                  refillIfNeeded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refillIfNeeded" class="anchor" title="Link to refillIfNeeded">#</a>
               </h3>
               
               <p>refillIfNeeded reads the next block if necessary.</p>
               
               <pre><code class="language-go">func (r *Reader) refillIfNeeded() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <p>reset discards the current state and prepares to compute a new hash.
We assume a seed of 0 since that is what zstd uses.</p>
               
               <pre><code class="language-go">func (xh *xxhash64) reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <p>reset clears stored data and configures window size.</p>
               
               <pre><code class="language-go">func (w *window) reset(size int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="round" data-name="round">
               <h3>
                  round 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#round" class="anchor" title="Link to round">#</a>
               </h3>
               
               <p>round updates a value.</p>
               
               <pre><code class="language-go">func (xh *xxhash64) round(v uint64, n uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="save" data-name="save">
               <h3>
                  save 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#save" class="anchor" title="Link to save">#</a>
               </h3>
               
               <p>save stores up to size last bytes from the buf.</p>
               
               <pre><code class="language-go">func (w *window) save(buf []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBufferSize" data-name="setBufferSize">
               <h3>
                  setBufferSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBufferSize" class="anchor" title="Link to setBufferSize">#</a>
               </h3>
               
               <p>setBufferSize sets the decompressed buffer size.
When this is called the buffer is empty.</p>
               
               <pre><code class="language-go">func (r *Reader) setBufferSize(size int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setSeqTable" data-name="setSeqTable">
               <h3>
                  setSeqTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setSeqTable" class="anchor" title="Link to setSeqTable">#</a>
               </h3>
               
               <p>setSeqTable uses the Compression_Mode in mode to set up r.seqTables and
r.seqTableBits for kind. We store these in the Reader because one of
the modes simply reuses the value from the last block in the frame.</p>
               
               <pre><code class="language-go">func (r *Reader) setSeqTable(data block, off int, kind seqCode, mode byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipFrame" data-name="skipFrame">
               <h3>
                  skipFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#skipFrame" class="anchor" title="Link to skipFrame">#</a>
               </h3>
               
               <p>skipFrame skips a skippable frame. RFC 3.1.2.</p>
               
               <pre><code class="language-go">func (r *Reader) skipFrame() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <p>update adds a buffer to the has.</p>
               
               <pre><code class="language-go">func (xh *xxhash64) update(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="val" data-name="val">
               <h3>
                  val 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#val" class="anchor" title="Link to val">#</a>
               </h3>
               
               <p>val is called to fetch a value of b bits.</p>
               
               <pre><code class="language-go">func (rbr *reverseBitReader) val(b uint8) (uint32, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="val" data-name="val">
               <h3>
                  val 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#val" class="anchor" title="Link to val">#</a>
               </h3>
               
               <p>val is called to fetch a value of b bits.</p>
               
               <pre><code class="language-go">func (br *bitReader) val(b uint8) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapError" data-name="wrapError">
               <h3>
                  wrapError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wrapError" class="anchor" title="Link to wrapError">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Reader) wrapError(off int, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapNonEOFError" data-name="wrapNonEOFError">
               <h3>
                  wrapNonEOFError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wrapNonEOFError" class="anchor" title="Link to wrapNonEOFError">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Reader) wrapNonEOFError(off int, err error) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>