<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zstd</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>zstd</code>
         </h1>
         <hr />
         
         <article class="global" data-name="literalPredefinedDistribution">
            <h2>literalPredefinedDistribution</h2>
            <hr />
            
            <p>literalPredefinedDistribution is the predefined distribution table
for literal lengths. RFC 3.1.1.3.2.2.1.</p>
            
            <pre><code>literalPredefinedDistribution</code></pre>
         </article>
         
         <article class="global" data-name="offsetPredefinedDistribution">
            <h2>offsetPredefinedDistribution</h2>
            <hr />
            
            <p>offsetPredefinedDistribution is the predefined distribution table
for offsets. RFC 3.1.1.3.2.2.3.</p>
            
            <pre><code>offsetPredefinedDistribution</code></pre>
         </article>
         
         <article class="global" data-name="matchPredefinedDistribution">
            <h2>matchPredefinedDistribution</h2>
            <hr />
            
            <p>matchPredefinedDistribution is the predefined distribution table
for match lengths. RFC 3.1.1.3.2.2.2.</p>
            
            <pre><code>matchPredefinedDistribution</code></pre>
         </article>
         
         <article class="global" data-name="badStrings">
            <h2>badStrings</h2>
            <hr />
            
            <p>badStrings is some inputs that FuzzReader failed on earlier.</p>
            
            <pre><code>badStrings</code></pre>
         </article>
         
         <article class="global" data-name="maxHuffmanBits">
            <h2>maxHuffmanBits</h2>
            <hr />
            
            <p>maxHuffmanBits is the largest possible Huffman table bits.</p>
            
            <pre><code>maxHuffmanBits</code></pre>
         </article>
         
         <article class="global" data-name="xxhPrime64c1">
            <h2>xxhPrime64c1</h2>
            <hr />
            
            <pre><code>xxhPrime64c1</code></pre>
         </article>
         
         <article class="global" data-name="xxhPrime64c2">
            <h2>xxhPrime64c2</h2>
            <hr />
            
            <pre><code>xxhPrime64c2</code></pre>
         </article>
         
         <article class="global" data-name="xxhPrime64c3">
            <h2>xxhPrime64c3</h2>
            <hr />
            
            <pre><code>xxhPrime64c3</code></pre>
         </article>
         
         <article class="global" data-name="xxhPrime64c4">
            <h2>xxhPrime64c4</h2>
            <hr />
            
            <pre><code>xxhPrime64c4</code></pre>
         </article>
         
         <article class="global" data-name="xxhPrime64c5">
            <h2>xxhPrime64c5</h2>
            <hr />
            
            <pre><code>xxhPrime64c5</code></pre>
         </article>
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <p>debug can be set in the source to print debug info using println.</p>
            
            <pre><code>debug</code></pre>
         </article>
         
         <article class="global" data-name="seqLiteral">
            <h2>seqLiteral</h2>
            <hr />
            
            <pre><code>seqLiteral seqCode</code></pre>
         </article>
         
         <article class="global" data-name="seqOffset">
            <h2>seqOffset</h2>
            <hr />
            
            <pre><code>seqOffset</code></pre>
         </article>
         
         <article class="global" data-name="seqMatch">
            <h2>seqMatch</h2>
            <hr />
            
            <pre><code>seqMatch</code></pre>
         </article>
         
         <article class="global" data-name="seqCodeInfo">
            <h2>seqCodeInfo</h2>
            <hr />
            
            <p>seqCodeInfo is the seqCodeInfoData for each kind of sequence code.</p>
            
            <pre><code>seqCodeInfo</code></pre>
         </article>
         
         <article class="global" data-name="xxHashTests">
            <h2>xxHashTests</h2>
            <hr />
            
            <pre><code>xxHashTests</code></pre>
         </article>
         
         <article class="global" data-name="fuzzing">
            <h2>fuzzing</h2>
            <hr />
            
            <p>fuzzing is a fuzzer hook set to true when fuzzing.
This is used to reject cases where we don't match zstd.</p>
            
            <pre><code>fuzzing</code></pre>
         </article>
         
         <article class="global" data-name="tests">
            <h2>tests</h2>
            <hr />
            
            <p>tests holds some simple test cases, including some found by fuzzing.</p>
            
            <pre><code>tests</code></pre>
         </article>
         
         <article class="global" data-name="bigDataOnce">
            <h2>bigDataOnce</h2>
            <hr />
            
            <pre><code>bigDataOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="bigDataBytes">
            <h2>bigDataBytes</h2>
            <hr />
            
            <pre><code>bigDataBytes []byte</code></pre>
         </article>
         
         <article class="global" data-name="bigDataErr">
            <h2>bigDataErr</h2>
            <hr />
            
            <pre><code>bigDataErr error</code></pre>
         </article>
         
         <article class="global" data-name="zstdBigOnce">
            <h2>zstdBigOnce</h2>
            <hr />
            
            <pre><code>zstdBigOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="zstdBigBytes">
            <h2>zstdBigBytes</h2>
            <hr />
            
            <pre><code>zstdBigBytes []byte</code></pre>
         </article>
         
         <article class="global" data-name="zstdBigErr">
            <h2>zstdBigErr</h2>
            <hr />
            
            <pre><code>zstdBigErr error</code></pre>
         </article>
         
         <article class="global" data-name="literalLengthOffset">
            <h2>literalLengthOffset</h2>
            <hr />
            
            <pre><code>literalLengthOffset</code></pre>
         </article>
         
         <article class="global" data-name="literalLengthBase">
            <h2>literalLengthBase</h2>
            <hr />
            
            <pre><code>literalLengthBase</code></pre>
         </article>
         
         <article class="global" data-name="matchLengthOffset">
            <h2>matchLengthOffset</h2>
            <hr />
            
            <pre><code>matchLengthOffset</code></pre>
         </article>
         
         <article class="global" data-name="matchLengthBase">
            <h2>matchLengthBase</h2>
            <hr />
            
            <pre><code>matchLengthBase</code></pre>
         </article>
         
         <article class="global" data-name="predefinedLiteralTable">
            <h2>predefinedLiteralTable</h2>
            <hr />
            
            <p>predefinedLiteralTable is the predefined table to use for literal lengths.
Generated from table in RFC 3.1.1.3.2.2.1.
Checked by TestPredefinedTables.</p>
            
            <pre><code>predefinedLiteralTable</code></pre>
         </article>
         
         <article class="global" data-name="predefinedOffsetTable">
            <h2>predefinedOffsetTable</h2>
            <hr />
            
            <p>predefinedOffsetTable is the predefined table to use for offsets.
Generated from table in RFC 3.1.1.3.2.2.3.
Checked by TestPredefinedTables.</p>
            
            <pre><code>predefinedOffsetTable</code></pre>
         </article>
         
         <article class="global" data-name="predefinedMatchTable">
            <h2>predefinedMatchTable</h2>
            <hr />
            
            <p>predefinedMatchTable is the predefined table to use for match lengths.
Generated from table in RFC 3.1.1.3.2.2.2.
Checked by TestPredefinedTables.</p>
            
            <pre><code>predefinedMatchTable</code></pre>
         </article>
          
         <article class="struct" data-name="window">
            <h2>type window struct</h2>
            <hr />
            
            <p>window stores up to size bytes of data.
It is implemented as a circular buffer:
sequential save calls append to the data slice until
its length reaches configured size and after that,
save calls overwrite previously saved data at off
and update off such that it always points at
the byte stored before others.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">size int
data []byte
off int</code></pre>
         </article>
         
         <article class="struct" data-name="xxhash64">
            <h2>type xxhash64 struct</h2>
            <hr />
            
            <p>xxhash64 is the state of a xxHash-64 checksum.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">len uint64
v []uint64
buf []byte
cnt int</code></pre>
         </article>
         
         <article class="struct" data-name="seqCodeInfoData">
            <h2>type seqCodeInfoData struct</h2>
            <hr />
            
            <p>seqCodeInfoData is the information needed to set up seqTables and
seqTableBits for a particular kind of sequence code.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">predefTable []fseBaselineEntry
predefTableBits int
maxSym int
maxBits int
toBaseline func</code></pre>
         </article>
         
         <article class="struct" data-name="Reader">
            <h2>type Reader struct</h2>
            <hr />
            
            <p>Reader implements [io.Reader] to read a zstd compressed stream.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader
sawFrameHeader bool
hasChecksum bool
readOneFrame bool
frameSizeUnknown bool
remainingFrameSize uint64
blockOffset int64
buffer []byte
off int
repeatedOffset1 uint32
repeatedOffset2 uint32
repeatedOffset3 uint32
huffmanTable []uint16
huffmanTableBits int
window window
compressedBuf []byte
literals []byte
seqTables [][]fseBaselineEntry
seqTableBits []uint8
seqTableBuffers [][]fseBaselineEntry
scratch []byte
fseScratch []fseEntry
checksum xxhash64</code></pre>
         </article>
         
         <article class="struct" data-name="zstdError">
            <h2>type zstdError struct</h2>
            <hr />
            
            <p>zstdError is an error while decompressing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">offset int64
err error</code></pre>
         </article>
         
         <article class="struct" data-name="bitReader">
            <h2>type bitReader struct</h2>
            <hr />
            
            <p>bitReader reads a bit stream going forward.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r *Reader
data block
off uint32
bits uint32
cnt uint32</code></pre>
         </article>
         
         <article class="struct" data-name="reverseBitReader">
            <h2>type reverseBitReader struct</h2>
            <hr />
            
            <p>reverseBitReader reads a bit stream in reverse.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r *Reader
data block
off uint32
start uint32
bits uint32
cnt uint32</code></pre>
         </article>
         
         <article class="struct" data-name="fseEntry">
            <h2>type fseEntry struct</h2>
            <hr />
            
            <p>fseEntry is one entry in an FSE table.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sym uint8
bits uint8
base uint16</code></pre>
         </article>
         
         <article class="struct" data-name="fseBaselineEntry">
            <h2>type fseBaselineEntry struct</h2>
            <hr />
            
            <p>fseBaselineEntry is an entry in an FSE baseline table.
We use these for literal/match/length values.
Those require mapping the symbol to a baseline value,
and then reading zero or more bits and adding the value to the baseline.
Rather than looking these up in separate tables,
we convert the FSE table to an FSE baseline table.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">baseline uint32
basebits uint8
bits uint8
base uint16</code></pre>
         </article>
          
         <article class="function" data-name="TestPredefinedTables">
            <h2>TestPredefinedTables</h2>
            <hr />
            
            <p>TestPredefinedTables verifies that we can generate the predefined
literal/offset/match tables from the input data in RFC 8878.
This serves as a test of the predefined tables, and also of buildFSE
and the functions that make baseline FSE tables.</p>
            
            <pre><code>func TestPredefinedTables(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="FuzzReader">
            <h2>FuzzReader</h2>
            <hr />
            
            <p>This is a simple fuzzer to see if the decompressor panics.</p>
            
            <pre><code>func FuzzReader(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="FuzzDecompressor">
            <h2>FuzzDecompressor</h2>
            <hr />
            
            <p>Fuzz test to verify that what we decompress is what we compress.
This isn't a great fuzz test because the fuzzer can't efficiently
explore the space of decompressor behavior, since it can't see
what the compressor is doing. But it's better than nothing.</p>
            
            <pre><code>func FuzzDecompressor(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="FuzzReverse">
            <h2>FuzzReverse</h2>
            <hr />
            
            <p>Fuzz test to check that if we can decompress some data,
so can zstd, and that we get the same result.</p>
            
            <pre><code>func FuzzReverse(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="readHuff">
            <h2>readHuff</h2>
            <hr />
            
            <p>readHuff reads Huffman table from data starting at off into table.
Each entry in a Huffman table is a pair of bytes.
The high byte is the encoded value. The low byte is the number
of bits used to encode that value. We index into the table
with a value of size tableBits. A value that requires fewer bits
appear in the table multiple times.
This returns the number of bits in the Huffman table and the new offset.
RFC 4.2.1.</p>
            
            <pre><code>func readHuff(data block, off int, table []uint16) (tableBits int, roff int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <p>reset clears stored data and configures window size.</p>
            
            <pre><code>func reset(size int)</code></pre>
         </article>
         
         <article class="function" data-name="len">
            <h2>len</h2>
            <hr />
            
            <p>len returns the number of stored bytes.</p>
            
            <pre><code>func len() uint32</code></pre>
         </article>
         
         <article class="function" data-name="save">
            <h2>save</h2>
            <hr />
            
            <p>save stores up to size last bytes from the buf.</p>
            
            <pre><code>func save(buf []byte)</code></pre>
         </article>
         
         <article class="function" data-name="appendTo">
            <h2>appendTo</h2>
            <hr />
            
            <p>appendTo appends stored bytes between from and to indices to the buf.
Index from must be less or equal to index to and to must be less or equal to w.len().</p>
            
            <pre><code>func appendTo(buf []byte, from uint32, to uint32) []byte</code></pre>
         </article>
         
         <article class="function" data-name="makeSequence">
            <h2>makeSequence</h2>
            <hr />
            
            <pre><code>func makeSequence(start int, n int) seq []byte</code></pre>
         </article>
         
         <article class="function" data-name="TestWindow">
            <h2>TestWindow</h2>
            <hr />
            
            <pre><code>func TestWindow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testWindow">
            <h2>testWindow</h2>
            <hr />
            
            <p>testWindow tests window by saving three sequences of bytes to it.
Third sequence tests read offset that can become non-zero only after second save.</p>
            
            <pre><code>func testWindow(t *testing.T, size int, a []byte, b []byte, c []byte)</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <p>reset discards the current state and prepares to compute a new hash.
We assume a seed of 0 since that is what zstd uses.</p>
            
            <pre><code>func reset()</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <p>update adds a buffer to the has.</p>
            
            <pre><code>func update(b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="digest">
            <h2>digest</h2>
            <hr />
            
            <p>digest returns the final hash value.</p>
            
            <pre><code>func digest() uint64</code></pre>
         </article>
         
         <article class="function" data-name="round">
            <h2>round</h2>
            <hr />
            
            <p>round updates a value.</p>
            
            <pre><code>func round(v uint64, n uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="mergeRound">
            <h2>mergeRound</h2>
            <hr />
            
            <p>mergeRound updates a value in the final round.</p>
            
            <pre><code>func mergeRound(v uint64, n uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="compressedBlock">
            <h2>compressedBlock</h2>
            <hr />
            
            <p>compressedBlock decompresses a compressed block, storing the decompressed
data in r.buffer. The blockSize argument is the compressed size.
RFC 3.1.1.3.</p>
            
            <pre><code>func compressedBlock(blockSize int) error</code></pre>
         </article>
         
         <article class="function" data-name="initSeqs">
            <h2>initSeqs</h2>
            <hr />
            
            <p>initSeqs reads the Sequences_Section_Header and sets up the FSE
tables used to read the sequence codes. It returns the number of
sequences and the new offset. RFC 3.1.1.3.2.1.</p>
            
            <pre><code>func initSeqs(data block, off int) (int, int, error)</code></pre>
         </article>
         
         <article class="function" data-name="setSeqTable">
            <h2>setSeqTable</h2>
            <hr />
            
            <p>setSeqTable uses the Compression_Mode in mode to set up r.seqTables and
r.seqTableBits for kind. We store these in the Reader because one of
the modes simply reuses the value from the last block in the frame.</p>
            
            <pre><code>func setSeqTable(data block, off int, kind seqCode, mode byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="execSeqs">
            <h2>execSeqs</h2>
            <hr />
            
            <p>execSeqs reads and executes the sequences. RFC 3.1.1.3.2.1.2.</p>
            
            <pre><code>func execSeqs(data block, off int, litbuf []byte, seqCount int) error</code></pre>
         </article>
         
         <article class="function" data-name="copyFromWindow">
            <h2>copyFromWindow</h2>
            <hr />
            
            <p>Copy match bytes from the decoded output, or the window, at offset.</p>
            
            <pre><code>func copyFromWindow(rbr *reverseBitReader, offset uint32, match uint32) error</code></pre>
         </article>
         
         <article class="function" data-name="readLiterals">
            <h2>readLiterals</h2>
            <hr />
            
            <p>readLiterals reads and decompresses the literals from data at off.
The literals are appended to outbuf, which is returned.
Also returns the new input offset. RFC 3.1.1.3.1.</p>
            
            <pre><code>func readLiterals(data block, off int, outbuf []byte) (int, []byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readRawRLELiterals">
            <h2>readRawRLELiterals</h2>
            <hr />
            
            <p>readRawRLELiterals reads and decompresses a Raw_Literals_Block or
a RLE_Literals_Block. RFC 3.1.1.3.1.1.</p>
            
            <pre><code>func readRawRLELiterals(data block, off int, hdr byte, outbuf []byte) (int, []byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readHuffLiterals">
            <h2>readHuffLiterals</h2>
            <hr />
            
            <p>readHuffLiterals reads and decompresses a Compressed_Literals_Block or
a Treeless_Literals_Block. RFC 3.1.1.3.1.4.</p>
            
            <pre><code>func readHuffLiterals(data block, off int, hdr byte, outbuf []byte) (int, []byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readLiteralsOneStream">
            <h2>readLiteralsOneStream</h2>
            <hr />
            
            <p>readLiteralsOneStream reads a single stream of compressed literals.</p>
            
            <pre><code>func readLiteralsOneStream(data block, off int, compressedSize int, regeneratedSize int, outbuf []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readLiteralsFourStreams">
            <h2>readLiteralsFourStreams</h2>
            <hr />
            
            <p>readLiteralsFourStreams reads four interleaved streams of
compressed literals.</p>
            
            <pre><code>func readLiteralsFourStreams(data block, off int, totalStreamsSize int, regeneratedSize int, outbuf []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestXXHash">
            <h2>TestXXHash</h2>
            <hr />
            
            <pre><code>func TestXXHash(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeXXHash">
            <h2>TestLargeXXHash</h2>
            <hr />
            
            <pre><code>func TestLargeXXHash(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="findXxhsum">
            <h2>findXxhsum</h2>
            <hr />
            
            <pre><code>func findXxhsum(t testing.TB) string</code></pre>
         </article>
         
         <article class="function" data-name="FuzzXXHash">
            <h2>FuzzXXHash</h2>
            <hr />
            
            <pre><code>func FuzzXXHash(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="NewReader">
            <h2>NewReader</h2>
            <hr />
            
            <p>NewReader creates a new Reader that decompresses data from the given reader.</p>
            
            <pre><code>func NewReader(input io.Reader) *Reader</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset discards the current state and starts reading a new stream from r.
This permits reusing a Reader rather than allocating a new one.</p>
            
            <pre><code>func Reset(input io.Reader)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read implements [io.Reader].</p>
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadByte">
            <h2>ReadByte</h2>
            <hr />
            
            <p>ReadByte implements [io.ByteReader].</p>
            
            <pre><code>func ReadByte() (byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="refillIfNeeded">
            <h2>refillIfNeeded</h2>
            <hr />
            
            <p>refillIfNeeded reads the next block if necessary.</p>
            
            <pre><code>func refillIfNeeded() error</code></pre>
         </article>
         
         <article class="function" data-name="refill">
            <h2>refill</h2>
            <hr />
            
            <p>refill reads and decompresses the next block.</p>
            
            <pre><code>func refill() error</code></pre>
         </article>
         
         <article class="function" data-name="readFrameHeader">
            <h2>readFrameHeader</h2>
            <hr />
            
            <p>readFrameHeader reads the frame header and prepares to read a block.</p>
            
            <pre><code>func readFrameHeader() error</code></pre>
         </article>
         
         <article class="function" data-name="skipFrame">
            <h2>skipFrame</h2>
            <hr />
            
            <p>skipFrame skips a skippable frame. RFC 3.1.2.</p>
            
            <pre><code>func skipFrame() error</code></pre>
         </article>
         
         <article class="function" data-name="readBlock">
            <h2>readBlock</h2>
            <hr />
            
            <p>readBlock reads the next block from a frame.</p>
            
            <pre><code>func readBlock() error</code></pre>
         </article>
         
         <article class="function" data-name="setBufferSize">
            <h2>setBufferSize</h2>
            <hr />
            
            <p>setBufferSize sets the decompressed buffer size.
When this is called the buffer is empty.</p>
            
            <pre><code>func setBufferSize(size int)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="makeEOFError">
            <h2>makeEOFError</h2>
            <hr />
            
            <pre><code>func makeEOFError(off int) error</code></pre>
         </article>
         
         <article class="function" data-name="wrapNonEOFError">
            <h2>wrapNonEOFError</h2>
            <hr />
            
            <pre><code>func wrapNonEOFError(off int, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="makeError">
            <h2>makeError</h2>
            <hr />
            
            <pre><code>func makeError(off int, msg string) error</code></pre>
         </article>
         
         <article class="function" data-name="wrapError">
            <h2>wrapError</h2>
            <hr />
            
            <pre><code>func wrapError(off int, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="TestSamples">
            <h2>TestSamples</h2>
            <hr />
            
            <pre><code>func TestSamples(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReset">
            <h2>TestReset</h2>
            <hr />
            
            <pre><code>func TestReset(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="bigData">
            <h2>bigData</h2>
            <hr />
            
            <p>bigData returns the contents of our large test file repeated multiple times.</p>
            
            <pre><code>func bigData(t testing.TB) []byte</code></pre>
         </article>
         
         <article class="function" data-name="findZstd">
            <h2>findZstd</h2>
            <hr />
            
            <pre><code>func findZstd(t testing.TB) string</code></pre>
         </article>
         
         <article class="function" data-name="zstdBigData">
            <h2>zstdBigData</h2>
            <hr />
            
            <p>zstdBigData returns the compressed contents of our large test file.
This will only run on Unix systems with zstd installed.
That's OK as the package is GOOS-independent.</p>
            
            <pre><code>func zstdBigData(t testing.TB) []byte</code></pre>
         </article>
         
         <article class="function" data-name="TestLarge">
            <h2>TestLarge</h2>
            <hr />
            
            <p>Test decompressing a large file. We don't have a compressor,
so this test only runs on systems with zstd installed.</p>
            
            <pre><code>func TestLarge(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="showDiffs">
            <h2>showDiffs</h2>
            <hr />
            
            <p>showDiffs reports the first few differences in two []byte.</p>
            
            <pre><code>func showDiffs(t *testing.T, got []byte, want []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestAlloc">
            <h2>TestAlloc</h2>
            <hr />
            
            <pre><code>func TestAlloc(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFileSamples">
            <h2>TestFileSamples</h2>
            <hr />
            
            <pre><code>func TestFileSamples(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderBad">
            <h2>TestReaderBad</h2>
            <hr />
            
            <pre><code>func TestReaderBad(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkLarge">
            <h2>BenchmarkLarge</h2>
            <hr />
            
            <pre><code>func BenchmarkLarge(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="makeBitReader">
            <h2>makeBitReader</h2>
            <hr />
            
            <p>makeBitReader makes a bit reader starting at off.</p>
            
            <pre><code>func makeBitReader(data block, off int) bitReader</code></pre>
         </article>
         
         <article class="function" data-name="moreBits">
            <h2>moreBits</h2>
            <hr />
            
            <p>moreBits is called to read more bits.
This ensures that at least 16 bits are available.</p>
            
            <pre><code>func moreBits() error</code></pre>
         </article>
         
         <article class="function" data-name="val">
            <h2>val</h2>
            <hr />
            
            <p>val is called to fetch a value of b bits.</p>
            
            <pre><code>func val(b uint8) uint32</code></pre>
         </article>
         
         <article class="function" data-name="backup">
            <h2>backup</h2>
            <hr />
            
            <p>backup steps back to the last byte we used.</p>
            
            <pre><code>func backup()</code></pre>
         </article>
         
         <article class="function" data-name="makeError">
            <h2>makeError</h2>
            <hr />
            
            <p>makeError returns an error at the current offset wrapping a string.</p>
            
            <pre><code>func makeError(msg string) error</code></pre>
         </article>
         
         <article class="function" data-name="makeReverseBitReader">
            <h2>makeReverseBitReader</h2>
            <hr />
            
            <p>makeReverseBitReader makes a reverseBitReader reading backward
from off to start. The bitstream starts with a 1 bit in the last
byte, at off.</p>
            
            <pre><code>func makeReverseBitReader(data block, off int, start int) (reverseBitReader, error)</code></pre>
         </article>
         
         <article class="function" data-name="val">
            <h2>val</h2>
            <hr />
            
            <p>val is called to fetch a value of b bits.</p>
            
            <pre><code>func val(b uint8) (uint32, error)</code></pre>
         </article>
         
         <article class="function" data-name="fetch">
            <h2>fetch</h2>
            <hr />
            
            <p>fetch is called to ensure that at least b bits are available.
It reports false if this can't be done,
in which case only rbr.cnt bits are available.</p>
            
            <pre><code>func fetch(b uint8) bool</code></pre>
         </article>
         
         <article class="function" data-name="makeError">
            <h2>makeError</h2>
            <hr />
            
            <p>makeError returns an error at the current offset wrapping a string.</p>
            
            <pre><code>func makeError(msg string) error</code></pre>
         </article>
         
         <article class="function" data-name="readFSE">
            <h2>readFSE</h2>
            <hr />
            
            <p>readFSE reads an FSE table from data starting at off.
maxSym is the maximum symbol value.
maxBits is the maximum number of bits permitted for symbols in the table.
The FSE is written into table, which must be at least 1<<maxBits in size.
This returns the number of bits in the FSE table and the new offset.
RFC 4.1.1.</p>
            
            <pre><code>func readFSE(data block, off int, maxSym int, maxBits int, table []fseEntry) (tableBits int, roff int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="buildFSE">
            <h2>buildFSE</h2>
            <hr />
            
            <p>buildFSE builds an FSE decoding table from a list of probabilities.
The probabilities are in norm. next is scratch space. The number of bits
in the table is tableBits.</p>
            
            <pre><code>func buildFSE(off int, norm []int16, table []fseEntry, tableBits int) error</code></pre>
         </article>
         
         <article class="function" data-name="makeLiteralBaselineFSE">
            <h2>makeLiteralBaselineFSE</h2>
            <hr />
            
            <p>makeLiteralBaselineFSE converts the literal length fseTable to baselineTable.</p>
            
            <pre><code>func makeLiteralBaselineFSE(off int, fseTable []fseEntry, baselineTable []fseBaselineEntry) error</code></pre>
         </article>
         
         <article class="function" data-name="makeOffsetBaselineFSE">
            <h2>makeOffsetBaselineFSE</h2>
            <hr />
            
            <p>makeOffsetBaselineFSE converts the offset length fseTable to baselineTable.</p>
            
            <pre><code>func makeOffsetBaselineFSE(off int, fseTable []fseEntry, baselineTable []fseBaselineEntry) error</code></pre>
         </article>
         
         <article class="function" data-name="makeMatchBaselineFSE">
            <h2>makeMatchBaselineFSE</h2>
            <hr />
            
            <p>makeMatchBaselineFSE converts the match length fseTable to baselineTable.</p>
            
            <pre><code>func makeMatchBaselineFSE(off int, fseTable []fseEntry, baselineTable []fseBaselineEntry) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
