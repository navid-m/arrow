<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>graph - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>graph</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"io"
"math"
"path/filepath"
"strings"
"github.com/google/pprof/internal/measurement"
"fmt"
"math"
"path/filepath"
"regexp"
"sort"
"strconv"
"strings"
"github.com/google/pprof/profile"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AddressOrder" data-name="AddressOrder">
               <h3>
                  AddressOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AddressOrder" class="anchor" title="Link to AddressOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const AddressOrder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CumNameOrder" data-name="CumNameOrder">
               <h3>
                  CumNameOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CumNameOrder" class="anchor" title="Link to CumNameOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const CumNameOrder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EntropyOrder" data-name="EntropyOrder">
               <h3>
                  EntropyOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EntropyOrder" class="anchor" title="Link to EntropyOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const EntropyOrder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FileOrder" data-name="FileOrder">
               <h3>
                  FileOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FileOrder" class="anchor" title="Link to FileOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const FileOrder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FlatCumNameOrder" data-name="FlatCumNameOrder">
               <h3>
                  FlatCumNameOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FlatCumNameOrder" class="anchor" title="Link to FlatCumNameOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const FlatCumNameOrder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FlatNameOrder" data-name="FlatNameOrder">
               <h3>
                  FlatNameOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FlatNameOrder" class="anchor" title="Link to FlatNameOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const FlatNameOrder NodeOrder = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NameOrder" data-name="NameOrder">
               <h3>
                  NameOrder 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NameOrder" class="anchor" title="Link to NameOrder">#</a>
               </h3>
               
                  <p class="doc-comment">Sorting options for node sort.</p>
               
               <pre><code class="language-go">const NameOrder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cppAnonymousPrefixRegExp" data-name="cppAnonymousPrefixRegExp">
               <h3>
                  cppAnonymousPrefixRegExp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cppAnonymousPrefixRegExp" class="anchor" title="Link to cppAnonymousPrefixRegExp">#</a>
               </h3>
               
               <pre><code class="language-go">var cppAnonymousPrefixRegExp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cppRegExp" data-name="cppRegExp">
               <h3>
                  cppRegExp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cppRegExp" class="anchor" title="Link to cppRegExp">#</a>
               </h3>
               
                  <p class="doc-comment">Strips C++ namespace prefix from a C++ function / method name.
NOTE: Make sure to keep the template parameters in the name. Normally,
template parameters are stripped from the C++ names but when
-symbolize=demangle=templates flag is used, they will not be.
See tests for examples.</p>
               
               <pre><code class="language-go">var cppRegExp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goRegExp" data-name="goRegExp">
               <h3>
                  goRegExp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goRegExp" class="anchor" title="Link to goRegExp">#</a>
               </h3>
               
                  <p class="doc-comment">Removes package name and method arguments for Go function names.
See tests for examples.</p>
               
               <pre><code class="language-go">var goRegExp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goVerRegExp" data-name="goVerRegExp">
               <h3>
                  goVerRegExp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goVerRegExp" class="anchor" title="Link to goVerRegExp">#</a>
               </h3>
               
                  <p class="doc-comment">Removes potential module versions in a package path.</p>
               
               <pre><code class="language-go">var goVerRegExp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="javaRegExp" data-name="javaRegExp">
               <h3>
                  javaRegExp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#javaRegExp" class="anchor" title="Link to javaRegExp">#</a>
               </h3>
               
                  <p class="doc-comment">Removes package name and method arguments for Java method names.
See tests for examples.</p>
               
               <pre><code class="language-go">var javaRegExp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxNodelets" data-name="maxNodelets">
               <h3>
                  maxNodelets 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxNodelets" class="anchor" title="Link to maxNodelets">#</a>
               </h3>
               
               <pre><code class="language-go">const maxNodelets = 4</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="EdgeMap" data-name="EdgeMap">
               <h3>
                  EdgeMap
                  <span class="badge type-badge">type</span>
                  <a href="#EdgeMap" class="anchor" title="Link to EdgeMap">#</a>
               </h3>
               
               <p>EdgeMap is used to represent the incoming/outgoing edges from a node.</p>
               
               <pre><code class="language-go">type EdgeMap map[*Node]*Edge</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="NodeMap" data-name="NodeMap">
               <h3>
                  NodeMap
                  <span class="badge type-badge">type</span>
                  <a href="#NodeMap" class="anchor" title="Link to NodeMap">#</a>
               </h3>
               
               <p>NodeMap maps from a node info struct to a node. It is used to merge
report entries with the same info.</p>
               
               <pre><code class="language-go">type NodeMap map[NodeInfo]*Node</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="NodeOrder" data-name="NodeOrder">
               <h3>
                  NodeOrder
                  <span class="badge type-badge">type</span>
                  <a href="#NodeOrder" class="anchor" title="Link to NodeOrder">#</a>
               </h3>
               
               <p>NodeOrder sets the ordering for a Sort operation</p>
               
               <pre><code class="language-go">type NodeOrder int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="NodePtrSet" data-name="NodePtrSet">
               <h3>
                  NodePtrSet
                  <span class="badge type-badge">type</span>
                  <a href="#NodePtrSet" class="anchor" title="Link to NodePtrSet">#</a>
               </h3>
               
               <p>NodePtrSet is a collection of nodes. Trimming a graph or tree requires a set
of objects which uniquely identify the nodes to keep. In a graph, NodeInfo
works as a unique identifier; however, in a tree multiple nodes may share
identical NodeInfos. A *Node does uniquely identify a node so we can use that
instead. Though a *Node also uniquely identifies a node in a graph,
currently, during trimming, graphs are rebuilt from scratch using only the
NodeSet, so there would not be the required context of the initial graph to
allow for the use of *Node.</p>
               
               <pre><code class="language-go">type NodePtrSet map[*Node]bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="NodeSet" data-name="NodeSet">
               <h3>
                  NodeSet
                  <span class="badge type-badge">type</span>
                  <a href="#NodeSet" class="anchor" title="Link to NodeSet">#</a>
               </h3>
               
               <p>NodeSet is a collection of node info structs.</p>
               
               <pre><code class="language-go">type NodeSet map[NodeInfo]bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Nodes" data-name="Nodes">
               <h3>
                  Nodes
                  <span class="badge type-badge">type</span>
                  <a href="#Nodes" class="anchor" title="Link to Nodes">#</a>
               </h3>
               
               <p>Nodes is an ordered collection of graph nodes.</p>
               
               <pre><code class="language-go">type Nodes []*Node</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="TagMap" data-name="TagMap">
               <h3>
                  TagMap
                  <span class="badge type-badge">type</span>
                  <a href="#TagMap" class="anchor" title="Link to TagMap">#</a>
               </h3>
               
               <p>TagMap is a collection of tags, classified by their name.</p>
               
               <pre><code class="language-go">type TagMap map[string]*Tag</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="edgeList" data-name="edgeList">
               <h3>
                  edgeList
                  <span class="badge type-badge">type</span>
                  <a href="#edgeList" class="anchor" title="Link to edgeList">#</a>
               </h3>
               
               <pre><code class="language-go">type edgeList []*Edge</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="DotAttributes" data-name="DotAttributes">
               <h3>
                  DotAttributes
                  <span class="badge">struct</span>
                  <a href="#DotAttributes" class="anchor" title="Link to DotAttributes">#</a>
               </h3>
               
               <p>DotAttributes contains details about the graph itself, giving
insight into how its elements should be rendered.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DotAttributes struct {
Nodes map[*Node]*DotNodeAttributes
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DotConfig" data-name="DotConfig">
               <h3>
                  DotConfig
                  <span class="badge">struct</span>
                  <a href="#DotConfig" class="anchor" title="Link to DotConfig">#</a>
               </h3>
               
               <p>DotConfig contains attributes about how a graph should be
constructed and how it should look.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DotConfig struct {
Title string
LegendURL string
Labels []string
FormatValue func(int64) string
Total int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DotNodeAttributes" data-name="DotNodeAttributes">
               <h3>
                  DotNodeAttributes
                  <span class="badge">struct</span>
                  <a href="#DotNodeAttributes" class="anchor" title="Link to DotNodeAttributes">#</a>
               </h3>
               
               <p>DotNodeAttributes contains Node specific visualization options.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DotNodeAttributes struct {
Shape string
Bold bool
Peripheries int
URL string
Formatter func(*NodeInfo) string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Edge" data-name="Edge">
               <h3>
                  Edge
                  <span class="badge">struct</span>
                  <a href="#Edge" class="anchor" title="Link to Edge">#</a>
               </h3>
               
               <p>Edge contains any attributes to be represented about edges in a graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Edge struct {
Src *Node
Dest *Node
Weight int64
WeightDiv int64
Residual bool
Inline bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Graph" data-name="Graph">
               <h3>
                  Graph
                  <span class="badge">struct</span>
                  <a href="#Graph" class="anchor" title="Link to Graph">#</a>
               </h3>
               
               <p>Graph summarizes a performance profile into a format that is
suitable for visualization.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Graph struct {
Nodes Nodes
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Node" data-name="Node">
               <h3>
                  Node
                  <span class="badge">struct</span>
                  <a href="#Node" class="anchor" title="Link to Node">#</a>
               </h3>
               
               <p>Node is an entry on a profiling report. It represents a unique
program location.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Node struct {
Info NodeInfo
Function *Node
Flat int64
FlatDiv int64
Cum int64
CumDiv int64
In EdgeMap
Out EdgeMap
LabelTags TagMap
NumericTags map[string]TagMap
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NodeInfo" data-name="NodeInfo">
               <h3>
                  NodeInfo
                  <span class="badge">struct</span>
                  <a href="#NodeInfo" class="anchor" title="Link to NodeInfo">#</a>
               </h3>
               
               <p>NodeInfo contains the attributes for a node.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type NodeInfo struct {
Name string
OrigName string
Address uint64
File string
StartLine int
Lineno int
Columnno int
Objfile string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Options" data-name="Options">
               <h3>
                  Options
                  <span class="badge">struct</span>
                  <a href="#Options" class="anchor" title="Link to Options">#</a>
               </h3>
               
               <p>Options encodes the options for constructing a graph</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Options struct {
SampleValue func(s []int64) int64
SampleMeanDivisor func(s []int64) int64
FormatTag func(int64, string) string
ObjNames bool
OrigFnNames bool
CallTree bool
DropNegative bool
KeptNodes NodeSet
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Tag" data-name="Tag">
               <h3>
                  Tag
                  <span class="badge">struct</span>
                  <a href="#Tag" class="anchor" title="Link to Tag">#</a>
               </h3>
               
               <p>Tag represent sample annotations</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Tag struct {
Name string
Unit string
Value int64
Flat int64
FlatDiv int64
Cum int64
CumDiv int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="builder" data-name="builder">
               <h3>
                  builder
                  <span class="badge">struct</span>
                  <a href="#builder" class="anchor" title="Link to builder">#</a>
               </h3>
               
               <p>builder wraps an io.Writer and understands how to compose DOT formatted elements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type builder struct {
io.Writer
attributes *DotAttributes
config *DotConfig
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nodePair" data-name="nodePair">
               <h3>
                  nodePair
                  <span class="badge">struct</span>
                  <a href="#nodePair" class="anchor" title="Link to nodePair">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nodePair struct {
src *Node
dest *Node
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nodeSorter" data-name="nodeSorter">
               <h3>
                  nodeSorter
                  <span class="badge">struct</span>
                  <a href="#nodeSorter" class="anchor" title="Link to nodeSorter">#</a>
               </h3>
               
               <p>nodeSorter is a mechanism used to allow a report to be sorted
in different ways.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nodeSorter struct {
rs Nodes
less func(l *Node, r *Node) bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tags" data-name="tags">
               <h3>
                  tags
                  <span class="badge">struct</span>
                  <a href="#tags" class="anchor" title="Link to tags">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type tags struct {
t []*Tag
flat bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddToEdge" data-name="AddToEdge">
               <h3>
                  AddToEdge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddToEdge" class="anchor" title="Link to AddToEdge">#</a>
               </h3>
               
               <p>AddToEdge increases the weight of an edge between two nodes. If
there isn't such an edge one is created.</p>
               
               <pre><code class="language-go">func (n *Node) AddToEdge(to *Node, v int64, residual bool, inline bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddToEdgeDiv" data-name="AddToEdgeDiv">
               <h3>
                  AddToEdgeDiv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddToEdgeDiv" class="anchor" title="Link to AddToEdgeDiv">#</a>
               </h3>
               
               <p>AddToEdgeDiv increases the weight of an edge between two nodes. If
there isn't such an edge one is created.</p>
               
               <pre><code class="language-go">func (n *Node) AddToEdgeDiv(to *Node, dv int64, v int64, residual bool, inline bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ComposeDot" data-name="ComposeDot">
               <h3>
                  ComposeDot 
                  <span class="badge">function</span>
                  
                  <a href="#ComposeDot" class="anchor" title="Link to ComposeDot">#</a>
               </h3>
               
               <p>ComposeDot creates and writes a in the DOT format to the writer, using
the configurations given.</p>
               
               <pre><code class="language-go">func ComposeDot(w io.Writer, g *Graph, a *DotAttributes, c *DotConfig)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateNodes" data-name="CreateNodes">
               <h3>
                  CreateNodes 
                  <span class="badge">function</span>
                  
                  <a href="#CreateNodes" class="anchor" title="Link to CreateNodes">#</a>
               </h3>
               
               <p>CreateNodes creates graph nodes for all locations in a profile. It
returns set of all nodes, plus a mapping of each location to the
set of corresponding nodes (one per location.Line).</p>
               
               <pre><code class="language-go">func CreateNodes(prof *profile.Profile, o *Options) (Nodes, map[uint64]Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CumValue" data-name="CumValue">
               <h3>
                  CumValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CumValue" class="anchor" title="Link to CumValue">#</a>
               </h3>
               
               <p>CumValue returns the inclusive value for this tag, computing the
mean if a divisor is available.</p>
               
               <pre><code class="language-go">func (t *Tag) CumValue() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CumValue" data-name="CumValue">
               <h3>
                  CumValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CumValue" class="anchor" title="Link to CumValue">#</a>
               </h3>
               
               <p>CumValue returns the inclusive value for this node, computing the
mean if a divisor is available.</p>
               
               <pre><code class="language-go">func (n *Node) CumValue() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DiscardLowFrequencyNodePtrs" data-name="DiscardLowFrequencyNodePtrs">
               <h3>
                  DiscardLowFrequencyNodePtrs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DiscardLowFrequencyNodePtrs" class="anchor" title="Link to DiscardLowFrequencyNodePtrs">#</a>
               </h3>
               
               <p>DiscardLowFrequencyNodePtrs returns a NodePtrSet of nodes at or over a
specific cum value cutoff.</p>
               
               <pre><code class="language-go">func (g *Graph) DiscardLowFrequencyNodePtrs(nodeCutoff int64) NodePtrSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DiscardLowFrequencyNodes" data-name="DiscardLowFrequencyNodes">
               <h3>
                  DiscardLowFrequencyNodes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DiscardLowFrequencyNodes" class="anchor" title="Link to DiscardLowFrequencyNodes">#</a>
               </h3>
               
               <p>DiscardLowFrequencyNodes returns a set of the nodes at or over a
specific cum value cutoff.</p>
               
               <pre><code class="language-go">func (g *Graph) DiscardLowFrequencyNodes(nodeCutoff int64) NodeSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FindOrInsertNode" data-name="FindOrInsertNode">
               <h3>
                  FindOrInsertNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FindOrInsertNode" class="anchor" title="Link to FindOrInsertNode">#</a>
               </h3>
               
               <p>FindOrInsertNode takes the info for a node and either returns a matching node
from the node map if one exists, or adds one to the map if one does not.
If kept is non-nil, nodes are only added if they can be located on it.</p>
               
               <pre><code class="language-go">func (nm NodeMap) FindOrInsertNode(info NodeInfo, kept NodeSet) *Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FlatValue" data-name="FlatValue">
               <h3>
                  FlatValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FlatValue" class="anchor" title="Link to FlatValue">#</a>
               </h3>
               
               <p>FlatValue returns the exclusive value for this tag, computing the
mean if a divisor is available.</p>
               
               <pre><code class="language-go">func (t *Tag) FlatValue() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FlatValue" data-name="FlatValue">
               <h3>
                  FlatValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FlatValue" class="anchor" title="Link to FlatValue">#</a>
               </h3>
               
               <p>FlatValue returns the exclusive value for this node, computing the
mean if a divisor is available.</p>
               
               <pre><code class="language-go">func (n *Node) FlatValue() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (el edgeList) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (s nodeSorter) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (t tags) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (el edgeList) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (t tags) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (s nodeSorter) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NameComponents" data-name="NameComponents">
               <h3>
                  NameComponents 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NameComponents" class="anchor" title="Link to NameComponents">#</a>
               </h3>
               
               <p>NameComponents returns the components of the printable name to be used for a node.</p>
               
               <pre><code class="language-go">func (i *NodeInfo) NameComponents() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New summarizes performance data from a profile into a graph.</p>
               
               <pre><code class="language-go">func New(prof *profile.Profile, o *Options) *Graph</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PrintableName" data-name="PrintableName">
               <h3>
                  PrintableName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PrintableName" class="anchor" title="Link to PrintableName">#</a>
               </h3>
               
               <p>PrintableName calls the Node's Formatter function with a single space separator.</p>
               
               <pre><code class="language-go">func (i *NodeInfo) PrintableName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RemoveRedundantEdges" data-name="RemoveRedundantEdges">
               <h3>
                  RemoveRedundantEdges 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RemoveRedundantEdges" class="anchor" title="Link to RemoveRedundantEdges">#</a>
               </h3>
               
               <p>RemoveRedundantEdges removes residual edges if the destination can
be reached through another path. This is done to simplify the graph
while preserving connectivity.</p>
               
               <pre><code class="language-go">func (g *Graph) RemoveRedundantEdges()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SelectTopNodePtrs" data-name="SelectTopNodePtrs">
               <h3>
                  SelectTopNodePtrs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SelectTopNodePtrs" class="anchor" title="Link to SelectTopNodePtrs">#</a>
               </h3>
               
               <p>SelectTopNodePtrs returns a set of the top maxNodes *Node in a graph.</p>
               
               <pre><code class="language-go">func (g *Graph) SelectTopNodePtrs(maxNodes int, visualMode bool) NodePtrSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SelectTopNodes" data-name="SelectTopNodes">
               <h3>
                  SelectTopNodes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SelectTopNodes" class="anchor" title="Link to SelectTopNodes">#</a>
               </h3>
               
               <p>SelectTopNodes returns a set of the top maxNodes nodes in a graph.</p>
               
               <pre><code class="language-go">func (g *Graph) SelectTopNodes(maxNodes int, visualMode bool) NodeSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ShortenFunctionName" data-name="ShortenFunctionName">
               <h3>
                  ShortenFunctionName 
                  <span class="badge">function</span>
                  
                  <a href="#ShortenFunctionName" class="anchor" title="Link to ShortenFunctionName">#</a>
               </h3>
               
               <p>ShortenFunctionName returns a shortened version of a function's name.</p>
               
               <pre><code class="language-go">func ShortenFunctionName(f string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sort" data-name="Sort">
               <h3>
                  Sort 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sort" class="anchor" title="Link to Sort">#</a>
               </h3>
               
               <p>Sort returns a slice of the edges in the map, in a consistent
order. The sort order is first based on the edge weight
(higher-to-lower) and then by the node names to avoid flakiness.</p>
               
               <pre><code class="language-go">func (e EdgeMap) Sort() []*Edge</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sort" data-name="Sort">
               <h3>
                  Sort 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sort" class="anchor" title="Link to Sort">#</a>
               </h3>
               
               <p>Sort reorders a slice of nodes based on the specified ordering
criteria. The result is sorted in decreasing order for (absolute)
numeric quantities, alphabetically for text, and increasing for
addresses.</p>
               
               <pre><code class="language-go">func (ns Nodes) Sort(o NodeOrder) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortNodes" data-name="SortNodes">
               <h3>
                  SortNodes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SortNodes" class="anchor" title="Link to SortNodes">#</a>
               </h3>
               
               <p>SortNodes sorts the nodes in a graph based on a specific heuristic.</p>
               
               <pre><code class="language-go">func (g *Graph) SortNodes(cum bool, visualMode bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortTags" data-name="SortTags">
               <h3>
                  SortTags 
                  <span class="badge">function</span>
                  
                  <a href="#SortTags" class="anchor" title="Link to SortTags">#</a>
               </h3>
               
               <p>SortTags sorts a slice of tags based on their weight.</p>
               
               <pre><code class="language-go">func SortTags(t []*Tag, flat bool) []*Tag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a text representation of a graph, for debugging purposes.</p>
               
               <pre><code class="language-go">func (g *Graph) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum adds the flat and cum values of a set of nodes.</p>
               
               <pre><code class="language-go">func (ns Nodes) Sum() (flat int64, cum int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum returns the total weight for a set of nodes.</p>
               
               <pre><code class="language-go">func (e EdgeMap) Sum() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (el edgeList) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (t tags) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (s nodeSorter) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimLowFrequencyEdges" data-name="TrimLowFrequencyEdges">
               <h3>
                  TrimLowFrequencyEdges 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TrimLowFrequencyEdges" class="anchor" title="Link to TrimLowFrequencyEdges">#</a>
               </h3>
               
               <p>TrimLowFrequencyEdges removes edges that have less than
the specified weight. Returns the number of edges removed</p>
               
               <pre><code class="language-go">func (g *Graph) TrimLowFrequencyEdges(edgeCutoff int64) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimLowFrequencyTags" data-name="TrimLowFrequencyTags">
               <h3>
                  TrimLowFrequencyTags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TrimLowFrequencyTags" class="anchor" title="Link to TrimLowFrequencyTags">#</a>
               </h3>
               
               <p>TrimLowFrequencyTags removes tags that have less than
the specified weight.</p>
               
               <pre><code class="language-go">func (g *Graph) TrimLowFrequencyTags(tagCutoff int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimTree" data-name="TrimTree">
               <h3>
                  TrimTree 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TrimTree" class="anchor" title="Link to TrimTree">#</a>
               </h3>
               
               <p>TrimTree trims a Graph in forest form, keeping only the nodes in kept. This
will not work correctly if even a single node has multiple parents.</p>
               
               <pre><code class="language-go">func (g *Graph) TrimTree(kept NodePtrSet)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WeightValue" data-name="WeightValue">
               <h3>
                  WeightValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WeightValue" class="anchor" title="Link to WeightValue">#</a>
               </h3>
               
               <p>WeightValue returns the weight value for this edge, normalizing if a
divisor is available.</p>
               
               <pre><code class="language-go">func (e *Edge) WeightValue() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abs64" data-name="abs64">
               <h3>
                  abs64 
                  <span class="badge">function</span>
                  
                  <a href="#abs64" class="anchor" title="Link to abs64">#</a>
               </h3>
               
               <pre><code class="language-go">func abs64(i int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addEdge" data-name="addEdge">
               <h3>
                  addEdge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addEdge" class="anchor" title="Link to addEdge">#</a>
               </h3>
               
               <p>addEdge generates a graph edge in DOT format.</p>
               
               <pre><code class="language-go">func (b *builder) addEdge(edge *Edge, from int, to int, hasNodelets bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addLegend" data-name="addLegend">
               <h3>
                  addLegend 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addLegend" class="anchor" title="Link to addLegend">#</a>
               </h3>
               
               <p>addLegend generates a legend in DOT format.</p>
               
               <pre><code class="language-go">func (b *builder) addLegend()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addNode" data-name="addNode">
               <h3>
                  addNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addNode" class="anchor" title="Link to addNode">#</a>
               </h3>
               
               <p>addNode generates a graph node in DOT format.</p>
               
               <pre><code class="language-go">func (b *builder) addNode(node *Node, nodeID int, maxFlat float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addNodelets" data-name="addNodelets">
               <h3>
                  addNodelets 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addNodelets" class="anchor" title="Link to addNodelets">#</a>
               </h3>
               
               <p>addNodelets generates the DOT boxes for the node tags if they exist.</p>
               
               <pre><code class="language-go">func (b *builder) addNodelets(node *Node, nodeID int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addSample" data-name="addSample">
               <h3>
                  addSample 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addSample" class="anchor" title="Link to addSample">#</a>
               </h3>
               
               <pre><code class="language-go">func (n *Node) addSample(dw int64, w int64, labels string, numLabel map[string][]int64, numUnit map[string][]string, format func(int64, string) string, flat bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collapsedTags" data-name="collapsedTags">
               <h3>
                  collapsedTags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collapsedTags" class="anchor" title="Link to collapsedTags">#</a>
               </h3>
               
               <p>collapsedTags trims and sorts a slice of tags.</p>
               
               <pre><code class="language-go">func (b *builder) collapsedTags(ts []*Tag, count int, flatTags bool) []*Tag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compareNodes" data-name="compareNodes">
               <h3>
                  compareNodes 
                  <span class="badge">function</span>
                  
                  <a href="#compareNodes" class="anchor" title="Link to compareNodes">#</a>
               </h3>
               
               <p>compareNodes compares two nodes to provide a deterministic ordering
between them. Two nodes cannot have the same Node.Info value.</p>
               
               <pre><code class="language-go">func compareNodes(l *Node, r *Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="countTags" data-name="countTags">
               <h3>
                  countTags 
                  <span class="badge">function</span>
                  
                  <a href="#countTags" class="anchor" title="Link to countTags">#</a>
               </h3>
               
               <p>countTags counts the tags with flat count. This underestimates the
number of tags being displayed, but in practice is close enough.</p>
               
               <pre><code class="language-go">func countTags(n *Node) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultLabelFormat" data-name="defaultLabelFormat">
               <h3>
                  defaultLabelFormat 
                  <span class="badge">function</span>
                  
                  <a href="#defaultLabelFormat" class="anchor" title="Link to defaultLabelFormat">#</a>
               </h3>
               
               <pre><code class="language-go">func defaultLabelFormat(v int64, key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dotColor" data-name="dotColor">
               <h3>
                  dotColor 
                  <span class="badge">function</span>
                  
                  <a href="#dotColor" class="anchor" title="Link to dotColor">#</a>
               </h3>
               
               <p>dotColor returns a color for the given score (between -1.0 and
1.0), with -1.0 colored green, 0.0 colored grey, and 1.0 colored
red. If isBackground is true, then a light (low-saturation)
color is returned (suitable for use as a background color);
otherwise, a darker color is returned (suitable for use as a
foreground color).</p>
               
               <pre><code class="language-go">func dotColor(score float64, isBackground bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="edgeEntropyScore" data-name="edgeEntropyScore">
               <h3>
                  edgeEntropyScore 
                  <span class="badge">function</span>
                  
                  <a href="#edgeEntropyScore" class="anchor" title="Link to edgeEntropyScore">#</a>
               </h3>
               
               <p>edgeEntropyScore computes the entropy value for a set of edges
coming in or out of a node. Entropy (as defined in information
theory) refers to the amount of information encoded by the set of
edges. A set of edges that have a more interesting distribution of
samples gets a higher score.</p>
               
               <pre><code class="language-go">func edgeEntropyScore(n *Node, edges EdgeMap, self int64) float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entropyScore" data-name="entropyScore">
               <h3>
                  entropyScore 
                  <span class="badge">function</span>
                  
                  <a href="#entropyScore" class="anchor" title="Link to entropyScore">#</a>
               </h3>
               
               <p>entropyScore computes a score for a node representing how important
it is to include this node on a graph visualization. It is used to
sort the nodes and select which ones to display if we have more
nodes than desired in the graph. This number is computed by looking
at the flat and cum weights of the node and the incoming/outgoing
edges. The fundamental idea is to penalize nodes that have a simple
fallthrough from their incoming to the outgoing edge.</p>
               
               <pre><code class="language-go">func entropyScore(n *Node) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapeAllForDot" data-name="escapeAllForDot">
               <h3>
                  escapeAllForDot 
                  <span class="badge">function</span>
                  
                  <a href="#escapeAllForDot" class="anchor" title="Link to escapeAllForDot">#</a>
               </h3>
               
               <p>escapeAllForDot applies escapeForDot to all strings in the given slice.</p>
               
               <pre><code class="language-go">func escapeAllForDot(in []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapeForDot" data-name="escapeForDot">
               <h3>
                  escapeForDot 
                  <span class="badge">function</span>
                  
                  <a href="#escapeForDot" class="anchor" title="Link to escapeForDot">#</a>
               </h3>
               
               <p>escapeForDot escapes double quotes and backslashes, and replaces Graphviz's
"center" character (\n) with a left-justified character.
See https://graphviz.org/docs/attr-types/escString/ for more info.</p>
               
               <pre><code class="language-go">func escapeForDot(str string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findOrAddTag" data-name="findOrAddTag">
               <h3>
                  findOrAddTag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findOrAddTag" class="anchor" title="Link to findOrAddTag">#</a>
               </h3>
               
               <pre><code class="language-go">func (m TagMap) findOrAddTag(label string, unit string, value int64) *Tag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findOrInsertLine" data-name="findOrInsertLine">
               <h3>
                  findOrInsertLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findOrInsertLine" class="anchor" title="Link to findOrInsertLine">#</a>
               </h3>
               
               <pre><code class="language-go">func (nm NodeMap) findOrInsertLine(l *profile.Location, li profile.Line, o *Options) *Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finish" data-name="finish">
               <h3>
                  finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finish" class="anchor" title="Link to finish">#</a>
               </h3>
               
               <p>finish closes the opening curly bracket in the constructed DOT buffer.</p>
               
               <pre><code class="language-go">func (b *builder) finish()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getNodesAboveCumCutoff" data-name="getNodesAboveCumCutoff">
               <h3>
                  getNodesAboveCumCutoff 
                  <span class="badge">function</span>
                  
                  <a href="#getNodesAboveCumCutoff" class="anchor" title="Link to getNodesAboveCumCutoff">#</a>
               </h3>
               
               <p>getNodesAboveCumCutoff returns all the nodes which have a Cum value greater
than or equal to cutoff.</p>
               
               <pre><code class="language-go">func getNodesAboveCumCutoff(nodes Nodes, nodeCutoff int64) Nodes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNegative" data-name="isNegative">
               <h3>
                  isNegative 
                  <span class="badge">function</span>
                  
                  <a href="#isNegative" class="anchor" title="Link to isNegative">#</a>
               </h3>
               
               <p>isNegative returns true if the node is considered as "negative" for the
purposes of drop_negative.</p>
               
               <pre><code class="language-go">func isNegative(n *Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isRedundantEdge" data-name="isRedundantEdge">
               <h3>
                  isRedundantEdge 
                  <span class="badge">function</span>
                  
                  <a href="#isRedundantEdge" class="anchor" title="Link to isRedundantEdge">#</a>
               </h3>
               
               <p>isRedundantEdge determines if there is a path that allows e.Src
to reach e.Dest after removing e.</p>
               
               <pre><code class="language-go">func isRedundantEdge(e *Edge) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="joinLabels" data-name="joinLabels">
               <h3>
                  joinLabels 
                  <span class="badge">function</span>
                  
                  <a href="#joinLabels" class="anchor" title="Link to joinLabels">#</a>
               </h3>
               
               <pre><code class="language-go">func joinLabels(s *profile.Sample) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeNodeSet" data-name="makeNodeSet">
               <h3>
                  makeNodeSet 
                  <span class="badge">function</span>
                  
                  <a href="#makeNodeSet" class="anchor" title="Link to makeNodeSet">#</a>
               </h3>
               
               <pre><code class="language-go">func makeNodeSet(nodes Nodes, nodeCutoff int64) NodeSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="min64" data-name="min64">
               <h3>
                  min64 
                  <span class="badge">function</span>
                  
                  <a href="#min64" class="anchor" title="Link to min64">#</a>
               </h3>
               
               <pre><code class="language-go">func min64(a int64, b int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multilinePrintableName" data-name="multilinePrintableName">
               <h3>
                  multilinePrintableName 
                  <span class="badge">function</span>
                  
                  <a href="#multilinePrintableName" class="anchor" title="Link to multilinePrintableName">#</a>
               </h3>
               
               <pre><code class="language-go">func multilinePrintableName(info *NodeInfo) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newGraph" data-name="newGraph">
               <h3>
                  newGraph 
                  <span class="badge">function</span>
                  
                  <a href="#newGraph" class="anchor" title="Link to newGraph">#</a>
               </h3>
               
               <p>newGraph computes a graph from a profile. It returns the graph, and
a map from the profile location indices to the corresponding graph
nodes.</p>
               
               <pre><code class="language-go">func newGraph(prof *profile.Profile, o *Options) (*Graph, map[uint64]Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTree" data-name="newTree">
               <h3>
                  newTree 
                  <span class="badge">function</span>
                  
                  <a href="#newTree" class="anchor" title="Link to newTree">#</a>
               </h3>
               
               <pre><code class="language-go">func newTree(prof *profile.Profile, o *Options) (g *Graph)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeInfo" data-name="nodeInfo">
               <h3>
                  nodeInfo 
                  <span class="badge">function</span>
                  
                  <a href="#nodeInfo" class="anchor" title="Link to nodeInfo">#</a>
               </h3>
               
               <pre><code class="language-go">func nodeInfo(l *profile.Location, line profile.Line, objfile string, o *Options) *NodeInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodes" data-name="nodes">
               <h3>
                  nodes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodes" class="anchor" title="Link to nodes">#</a>
               </h3>
               
               <pre><code class="language-go">func (nm NodeMap) nodes() Nodes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="numericNodelets" data-name="numericNodelets">
               <h3>
                  numericNodelets 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#numericNodelets" class="anchor" title="Link to numericNodelets">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) numericNodelets(nts []*Tag, maxNumNodelets int, flatTags bool, source string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectNodesForGraph" data-name="selectNodesForGraph">
               <h3>
                  selectNodesForGraph 
                  <span class="badge">function</span>
                  
                  <a href="#selectNodesForGraph" class="anchor" title="Link to selectNodesForGraph">#</a>
               </h3>
               
               <pre><code class="language-go">func selectNodesForGraph(nodes Nodes, dropNegative bool) *Graph</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectTopNodes" data-name="selectTopNodes">
               <h3>
                  selectTopNodes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectTopNodes" class="anchor" title="Link to selectTopNodes">#</a>
               </h3>
               
               <p>selectTopNodes returns a slice of the top maxNodes nodes in a graph.</p>
               
               <pre><code class="language-go">func (g *Graph) selectTopNodes(maxNodes int, visualMode bool) Nodes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="start" data-name="start">
               <h3>
                  start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#start" class="anchor" title="Link to start">#</a>
               </h3>
               
               <p>start generates a title and initial node in DOT format.</p>
               
               <pre><code class="language-go">func (b *builder) start()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tagDistance" data-name="tagDistance">
               <h3>
                  tagDistance 
                  <span class="badge">function</span>
                  
                  <a href="#tagDistance" class="anchor" title="Link to tagDistance">#</a>
               </h3>
               
               <pre><code class="language-go">func tagDistance(t *Tag, u *Tag) float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tagGroupLabel" data-name="tagGroupLabel">
               <h3>
                  tagGroupLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tagGroupLabel" class="anchor" title="Link to tagGroupLabel">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) tagGroupLabel(g []*Tag) (label string, flat int64, cum int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimLowFreqTags" data-name="trimLowFreqTags">
               <h3>
                  trimLowFreqTags 
                  <span class="badge">function</span>
                  
                  <a href="#trimLowFreqTags" class="anchor" title="Link to trimLowFreqTags">#</a>
               </h3>
               
               <pre><code class="language-go">func trimLowFreqTags(tags TagMap, minValue int64) TagMap</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>