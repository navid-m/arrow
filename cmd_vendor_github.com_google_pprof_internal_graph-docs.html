<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - graph</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>graph</code>
         </h1>
         <hr />
         
         <article class="global" data-name="maxNodelets">
            <h2>maxNodelets</h2>
            <hr />
            
            <pre><code>maxNodelets</code></pre>
         </article>
         
         <article class="global" data-name="javaRegExp">
            <h2>javaRegExp</h2>
            <hr />
            
            <p>Removes package name and method arguments for Java method names.
See tests for examples.</p>
            
            <pre><code>javaRegExp</code></pre>
         </article>
         
         <article class="global" data-name="goRegExp">
            <h2>goRegExp</h2>
            <hr />
            
            <p>Removes package name and method arguments for Go function names.
See tests for examples.</p>
            
            <pre><code>goRegExp</code></pre>
         </article>
         
         <article class="global" data-name="goVerRegExp">
            <h2>goVerRegExp</h2>
            <hr />
            
            <p>Removes potential module versions in a package path.</p>
            
            <pre><code>goVerRegExp</code></pre>
         </article>
         
         <article class="global" data-name="cppRegExp">
            <h2>cppRegExp</h2>
            <hr />
            
            <p>Strips C++ namespace prefix from a C++ function / method name.
NOTE: Make sure to keep the template parameters in the name. Normally,
template parameters are stripped from the C++ names but when
-symbolize=demangle=templates flag is used, they will not be.
See tests for examples.</p>
            
            <pre><code>cppRegExp</code></pre>
         </article>
         
         <article class="global" data-name="cppAnonymousPrefixRegExp">
            <h2>cppAnonymousPrefixRegExp</h2>
            <hr />
            
            <pre><code>cppAnonymousPrefixRegExp</code></pre>
         </article>
         
         <article class="global" data-name="FlatNameOrder">
            <h2>FlatNameOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>FlatNameOrder NodeOrder</code></pre>
         </article>
         
         <article class="global" data-name="FlatCumNameOrder">
            <h2>FlatCumNameOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>FlatCumNameOrder</code></pre>
         </article>
         
         <article class="global" data-name="CumNameOrder">
            <h2>CumNameOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>CumNameOrder</code></pre>
         </article>
         
         <article class="global" data-name="NameOrder">
            <h2>NameOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>NameOrder</code></pre>
         </article>
         
         <article class="global" data-name="FileOrder">
            <h2>FileOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>FileOrder</code></pre>
         </article>
         
         <article class="global" data-name="AddressOrder">
            <h2>AddressOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>AddressOrder</code></pre>
         </article>
         
         <article class="global" data-name="EntropyOrder">
            <h2>EntropyOrder</h2>
            <hr />
            
            <p>Sorting options for node sort.</p>
            
            <pre><code>EntropyOrder</code></pre>
         </article>
          
         <article class="struct" data-name="DotAttributes">
            <h2>type DotAttributes struct</h2>
            <hr />
            
            <p>DotAttributes contains details about the graph itself, giving
insight into how its elements should be rendered.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Nodes *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="DotNodeAttributes">
            <h2>type DotNodeAttributes struct</h2>
            <hr />
            
            <p>DotNodeAttributes contains Node specific visualization options.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Shape string
Bold bool
Peripheries int
URL string
Formatter func</code></pre>
         </article>
         
         <article class="struct" data-name="DotConfig">
            <h2>type DotConfig struct</h2>
            <hr />
            
            <p>DotConfig contains attributes about how a graph should be
constructed and how it should look.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Title string
LegendURL string
Labels []string
FormatValue func
Total int64</code></pre>
         </article>
         
         <article class="struct" data-name="builder">
            <h2>type builder struct</h2>
            <hr />
            
            <p>builder wraps an io.Writer and understands how to compose DOT formatted elements.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">io.Writer
attributes *DotAttributes
config *DotConfig</code></pre>
         </article>
         
         <article class="struct" data-name="Graph">
            <h2>type Graph struct</h2>
            <hr />
            
            <p>Graph summarizes a performance profile into a format that is
suitable for visualization.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Nodes Nodes</code></pre>
         </article>
         
         <article class="struct" data-name="Options">
            <h2>type Options struct</h2>
            <hr />
            
            <p>Options encodes the options for constructing a graph</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">SampleValue func
SampleMeanDivisor func
FormatTag func
ObjNames bool
OrigFnNames bool
CallTree bool
DropNegative bool
KeptNodes NodeSet</code></pre>
         </article>
         
         <article class="struct" data-name="Node">
            <h2>type Node struct</h2>
            <hr />
            
            <p>Node is an entry on a profiling report. It represents a unique
program location.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Info NodeInfo
Function *Node
Flat int64
FlatDiv int64
Cum int64
CumDiv int64
In EdgeMap
Out EdgeMap
LabelTags TagMap
NumericTags *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="NodeInfo">
            <h2>type NodeInfo struct</h2>
            <hr />
            
            <p>NodeInfo contains the attributes for a node.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
OrigName string
Address uint64
File string
StartLine int
Lineno int
Columnno int
Objfile string</code></pre>
         </article>
         
         <article class="struct" data-name="Edge">
            <h2>type Edge struct</h2>
            <hr />
            
            <p>Edge contains any attributes to be represented about edges in a graph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Src *Node
Dest *Node
Weight int64
WeightDiv int64
Residual bool
Inline bool</code></pre>
         </article>
         
         <article class="struct" data-name="Tag">
            <h2>type Tag struct</h2>
            <hr />
            
            <p>Tag represent sample annotations</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
Unit string
Value int64
Flat int64
FlatDiv int64
Cum int64
CumDiv int64</code></pre>
         </article>
         
         <article class="struct" data-name="nodePair">
            <h2>type nodePair struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">src *Node
dest *Node</code></pre>
         </article>
         
         <article class="struct" data-name="tags">
            <h2>type tags struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">t []*Tag
flat bool</code></pre>
         </article>
         
         <article class="struct" data-name="nodeSorter">
            <h2>type nodeSorter struct</h2>
            <hr />
            
            <p>nodeSorter is a mechanism used to allow a report to be sorted
in different ways.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">rs Nodes
less func</code></pre>
         </article>
          
         <article class="function" data-name="ComposeDot">
            <h2>ComposeDot</h2>
            <hr />
            
            <p>ComposeDot creates and writes a in the DOT format to the writer, using
the configurations given.</p>
            
            <pre><code>func ComposeDot(w io.Writer, g *Graph, a *DotAttributes, c *DotConfig)</code></pre>
         </article>
         
         <article class="function" data-name="start">
            <h2>start</h2>
            <hr />
            
            <p>start generates a title and initial node in DOT format.</p>
            
            <pre><code>func start()</code></pre>
         </article>
         
         <article class="function" data-name="finish">
            <h2>finish</h2>
            <hr />
            
            <p>finish closes the opening curly bracket in the constructed DOT buffer.</p>
            
            <pre><code>func finish()</code></pre>
         </article>
         
         <article class="function" data-name="addLegend">
            <h2>addLegend</h2>
            <hr />
            
            <p>addLegend generates a legend in DOT format.</p>
            
            <pre><code>func addLegend()</code></pre>
         </article>
         
         <article class="function" data-name="addNode">
            <h2>addNode</h2>
            <hr />
            
            <p>addNode generates a graph node in DOT format.</p>
            
            <pre><code>func addNode(node *Node, nodeID int, maxFlat float64)</code></pre>
         </article>
         
         <article class="function" data-name="addNodelets">
            <h2>addNodelets</h2>
            <hr />
            
            <p>addNodelets generates the DOT boxes for the node tags if they exist.</p>
            
            <pre><code>func addNodelets(node *Node, nodeID int) bool</code></pre>
         </article>
         
         <article class="function" data-name="numericNodelets">
            <h2>numericNodelets</h2>
            <hr />
            
            <pre><code>func numericNodelets(nts []*Tag, maxNumNodelets int, flatTags bool, source string) string</code></pre>
         </article>
         
         <article class="function" data-name="addEdge">
            <h2>addEdge</h2>
            <hr />
            
            <p>addEdge generates a graph edge in DOT format.</p>
            
            <pre><code>func addEdge(edge *Edge, from int, to int, hasNodelets bool)</code></pre>
         </article>
         
         <article class="function" data-name="dotColor">
            <h2>dotColor</h2>
            <hr />
            
            <p>dotColor returns a color for the given score (between -1.0 and
1.0), with -1.0 colored green, 0.0 colored grey, and 1.0 colored
red. If isBackground is true, then a light (low-saturation)
color is returned (suitable for use as a background color);
otherwise, a darker color is returned (suitable for use as a
foreground color).</p>
            
            <pre><code>func dotColor(score float64, isBackground bool) string</code></pre>
         </article>
         
         <article class="function" data-name="multilinePrintableName">
            <h2>multilinePrintableName</h2>
            <hr />
            
            <pre><code>func multilinePrintableName(info *NodeInfo) string</code></pre>
         </article>
         
         <article class="function" data-name="collapsedTags">
            <h2>collapsedTags</h2>
            <hr />
            
            <p>collapsedTags trims and sorts a slice of tags.</p>
            
            <pre><code>func collapsedTags(ts []*Tag, count int, flatTags bool) []*Tag</code></pre>
         </article>
         
         <article class="function" data-name="tagDistance">
            <h2>tagDistance</h2>
            <hr />
            
            <pre><code>func tagDistance(t *Tag, u *Tag) float64</code></pre>
         </article>
         
         <article class="function" data-name="tagGroupLabel">
            <h2>tagGroupLabel</h2>
            <hr />
            
            <pre><code>func tagGroupLabel(g []*Tag) (label string, flat int64, cum int64)</code></pre>
         </article>
         
         <article class="function" data-name="min64">
            <h2>min64</h2>
            <hr />
            
            <pre><code>func min64(a int64, b int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="escapeAllForDot">
            <h2>escapeAllForDot</h2>
            <hr />
            
            <p>escapeAllForDot applies escapeForDot to all strings in the given slice.</p>
            
            <pre><code>func escapeAllForDot(in []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="escapeForDot">
            <h2>escapeForDot</h2>
            <hr />
            
            <p>escapeForDot escapes double quotes and backslashes, and replaces Graphviz's
"center" character (\n) with a left-justified character.
See https://graphviz.org/docs/attr-types/escString/ for more info.</p>
            
            <pre><code>func escapeForDot(str string) string</code></pre>
         </article>
         
         <article class="function" data-name="FlatValue">
            <h2>FlatValue</h2>
            <hr />
            
            <p>FlatValue returns the exclusive value for this node, computing the
mean if a divisor is available.</p>
            
            <pre><code>func FlatValue() int64</code></pre>
         </article>
         
         <article class="function" data-name="CumValue">
            <h2>CumValue</h2>
            <hr />
            
            <p>CumValue returns the inclusive value for this node, computing the
mean if a divisor is available.</p>
            
            <pre><code>func CumValue() int64</code></pre>
         </article>
         
         <article class="function" data-name="AddToEdge">
            <h2>AddToEdge</h2>
            <hr />
            
            <p>AddToEdge increases the weight of an edge between two nodes. If
there isn't such an edge one is created.</p>
            
            <pre><code>func AddToEdge(to *Node, v int64, residual bool, inline bool)</code></pre>
         </article>
         
         <article class="function" data-name="AddToEdgeDiv">
            <h2>AddToEdgeDiv</h2>
            <hr />
            
            <p>AddToEdgeDiv increases the weight of an edge between two nodes. If
there isn't such an edge one is created.</p>
            
            <pre><code>func AddToEdgeDiv(to *Node, dv int64, v int64, residual bool, inline bool)</code></pre>
         </article>
         
         <article class="function" data-name="PrintableName">
            <h2>PrintableName</h2>
            <hr />
            
            <p>PrintableName calls the Node's Formatter function with a single space separator.</p>
            
            <pre><code>func PrintableName() string</code></pre>
         </article>
         
         <article class="function" data-name="NameComponents">
            <h2>NameComponents</h2>
            <hr />
            
            <p>NameComponents returns the components of the printable name to be used for a node.</p>
            
            <pre><code>func NameComponents() []string</code></pre>
         </article>
         
         <article class="function" data-name="FindOrInsertNode">
            <h2>FindOrInsertNode</h2>
            <hr />
            
            <p>FindOrInsertNode takes the info for a node and either returns a matching node
from the node map if one exists, or adds one to the map if one does not.
If kept is non-nil, nodes are only added if they can be located on it.</p>
            
            <pre><code>func FindOrInsertNode(info NodeInfo, kept NodeSet) *Node</code></pre>
         </article>
         
         <article class="function" data-name="WeightValue">
            <h2>WeightValue</h2>
            <hr />
            
            <p>WeightValue returns the weight value for this edge, normalizing if a
divisor is available.</p>
            
            <pre><code>func WeightValue() int64</code></pre>
         </article>
         
         <article class="function" data-name="FlatValue">
            <h2>FlatValue</h2>
            <hr />
            
            <p>FlatValue returns the exclusive value for this tag, computing the
mean if a divisor is available.</p>
            
            <pre><code>func FlatValue() int64</code></pre>
         </article>
         
         <article class="function" data-name="CumValue">
            <h2>CumValue</h2>
            <hr />
            
            <p>CumValue returns the inclusive value for this tag, computing the
mean if a divisor is available.</p>
            
            <pre><code>func CumValue() int64</code></pre>
         </article>
         
         <article class="function" data-name="SortTags">
            <h2>SortTags</h2>
            <hr />
            
            <p>SortTags sorts a slice of tags based on their weight.</p>
            
            <pre><code>func SortTags(t []*Tag, flat bool) []*Tag</code></pre>
         </article>
         
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New summarizes performance data from a profile into a graph.</p>
            
            <pre><code>func New(prof *profile.Profile, o *Options) *Graph</code></pre>
         </article>
         
         <article class="function" data-name="newGraph">
            <h2>newGraph</h2>
            <hr />
            
            <p>newGraph computes a graph from a profile. It returns the graph, and
a map from the profile location indices to the corresponding graph
nodes.</p>
            
            <pre><code>func newGraph(prof *profile.Profile, o *Options) (*Graph, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="selectNodesForGraph">
            <h2>selectNodesForGraph</h2>
            <hr />
            
            <pre><code>func selectNodesForGraph(nodes Nodes, dropNegative bool) *Graph</code></pre>
         </article>
         
         <article class="function" data-name="newTree">
            <h2>newTree</h2>
            <hr />
            
            <pre><code>func newTree(prof *profile.Profile, o *Options) g *Graph</code></pre>
         </article>
         
         <article class="function" data-name="ShortenFunctionName">
            <h2>ShortenFunctionName</h2>
            <hr />
            
            <p>ShortenFunctionName returns a shortened version of a function's name.</p>
            
            <pre><code>func ShortenFunctionName(f string) string</code></pre>
         </article>
         
         <article class="function" data-name="TrimTree">
            <h2>TrimTree</h2>
            <hr />
            
            <p>TrimTree trims a Graph in forest form, keeping only the nodes in kept. This
will not work correctly if even a single node has multiple parents.</p>
            
            <pre><code>func TrimTree(kept NodePtrSet)</code></pre>
         </article>
         
         <article class="function" data-name="joinLabels">
            <h2>joinLabels</h2>
            <hr />
            
            <pre><code>func joinLabels(s *profile.Sample) string</code></pre>
         </article>
         
         <article class="function" data-name="isNegative">
            <h2>isNegative</h2>
            <hr />
            
            <p>isNegative returns true if the node is considered as "negative" for the
purposes of drop_negative.</p>
            
            <pre><code>func isNegative(n *Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="CreateNodes">
            <h2>CreateNodes</h2>
            <hr />
            
            <p>CreateNodes creates graph nodes for all locations in a profile. It
returns set of all nodes, plus a mapping of each location to the
set of corresponding nodes (one per location.Line).</p>
            
            <pre><code>func CreateNodes(prof *profile.Profile, o *Options) (Nodes, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="nodes">
            <h2>nodes</h2>
            <hr />
            
            <pre><code>func nodes() Nodes</code></pre>
         </article>
         
         <article class="function" data-name="findOrInsertLine">
            <h2>findOrInsertLine</h2>
            <hr />
            
            <pre><code>func findOrInsertLine(l *profile.Location, li profile.Line, o *Options) *Node</code></pre>
         </article>
         
         <article class="function" data-name="nodeInfo">
            <h2>nodeInfo</h2>
            <hr />
            
            <pre><code>func nodeInfo(l *profile.Location, line profile.Line, objfile string, o *Options) *NodeInfo</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum adds the flat and cum values of a set of nodes.</p>
            
            <pre><code>func Sum() (flat int64, cum int64)</code></pre>
         </article>
         
         <article class="function" data-name="addSample">
            <h2>addSample</h2>
            <hr />
            
            <pre><code>func addSample(dw int64, w int64, labels string, numLabel *ast.MapType, numUnit *ast.MapType, format func, flat bool)</code></pre>
         </article>
         
         <article class="function" data-name="defaultLabelFormat">
            <h2>defaultLabelFormat</h2>
            <hr />
            
            <pre><code>func defaultLabelFormat(v int64, key string) string</code></pre>
         </article>
         
         <article class="function" data-name="findOrAddTag">
            <h2>findOrAddTag</h2>
            <hr />
            
            <pre><code>func findOrAddTag(label string, unit string, value int64) *Tag</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a text representation of a graph, for debugging purposes.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="DiscardLowFrequencyNodes">
            <h2>DiscardLowFrequencyNodes</h2>
            <hr />
            
            <p>DiscardLowFrequencyNodes returns a set of the nodes at or over a
specific cum value cutoff.</p>
            
            <pre><code>func DiscardLowFrequencyNodes(nodeCutoff int64) NodeSet</code></pre>
         </article>
         
         <article class="function" data-name="DiscardLowFrequencyNodePtrs">
            <h2>DiscardLowFrequencyNodePtrs</h2>
            <hr />
            
            <p>DiscardLowFrequencyNodePtrs returns a NodePtrSet of nodes at or over a
specific cum value cutoff.</p>
            
            <pre><code>func DiscardLowFrequencyNodePtrs(nodeCutoff int64) NodePtrSet</code></pre>
         </article>
         
         <article class="function" data-name="makeNodeSet">
            <h2>makeNodeSet</h2>
            <hr />
            
            <pre><code>func makeNodeSet(nodes Nodes, nodeCutoff int64) NodeSet</code></pre>
         </article>
         
         <article class="function" data-name="getNodesAboveCumCutoff">
            <h2>getNodesAboveCumCutoff</h2>
            <hr />
            
            <p>getNodesAboveCumCutoff returns all the nodes which have a Cum value greater
than or equal to cutoff.</p>
            
            <pre><code>func getNodesAboveCumCutoff(nodes Nodes, nodeCutoff int64) Nodes</code></pre>
         </article>
         
         <article class="function" data-name="TrimLowFrequencyTags">
            <h2>TrimLowFrequencyTags</h2>
            <hr />
            
            <p>TrimLowFrequencyTags removes tags that have less than
the specified weight.</p>
            
            <pre><code>func TrimLowFrequencyTags(tagCutoff int64)</code></pre>
         </article>
         
         <article class="function" data-name="trimLowFreqTags">
            <h2>trimLowFreqTags</h2>
            <hr />
            
            <pre><code>func trimLowFreqTags(tags TagMap, minValue int64) TagMap</code></pre>
         </article>
         
         <article class="function" data-name="TrimLowFrequencyEdges">
            <h2>TrimLowFrequencyEdges</h2>
            <hr />
            
            <p>TrimLowFrequencyEdges removes edges that have less than
the specified weight. Returns the number of edges removed</p>
            
            <pre><code>func TrimLowFrequencyEdges(edgeCutoff int64) int</code></pre>
         </article>
         
         <article class="function" data-name="SortNodes">
            <h2>SortNodes</h2>
            <hr />
            
            <p>SortNodes sorts the nodes in a graph based on a specific heuristic.</p>
            
            <pre><code>func SortNodes(cum bool, visualMode bool)</code></pre>
         </article>
         
         <article class="function" data-name="SelectTopNodePtrs">
            <h2>SelectTopNodePtrs</h2>
            <hr />
            
            <p>SelectTopNodePtrs returns a set of the top maxNodes *Node in a graph.</p>
            
            <pre><code>func SelectTopNodePtrs(maxNodes int, visualMode bool) NodePtrSet</code></pre>
         </article>
         
         <article class="function" data-name="SelectTopNodes">
            <h2>SelectTopNodes</h2>
            <hr />
            
            <p>SelectTopNodes returns a set of the top maxNodes nodes in a graph.</p>
            
            <pre><code>func SelectTopNodes(maxNodes int, visualMode bool) NodeSet</code></pre>
         </article>
         
         <article class="function" data-name="selectTopNodes">
            <h2>selectTopNodes</h2>
            <hr />
            
            <p>selectTopNodes returns a slice of the top maxNodes nodes in a graph.</p>
            
            <pre><code>func selectTopNodes(maxNodes int, visualMode bool) Nodes</code></pre>
         </article>
         
         <article class="function" data-name="countTags">
            <h2>countTags</h2>
            <hr />
            
            <p>countTags counts the tags with flat count. This underestimates the
number of tags being displayed, but in practice is close enough.</p>
            
            <pre><code>func countTags(n *Node) int</code></pre>
         </article>
         
         <article class="function" data-name="RemoveRedundantEdges">
            <h2>RemoveRedundantEdges</h2>
            <hr />
            
            <p>RemoveRedundantEdges removes residual edges if the destination can
be reached through another path. This is done to simplify the graph
while preserving connectivity.</p>
            
            <pre><code>func RemoveRedundantEdges()</code></pre>
         </article>
         
         <article class="function" data-name="isRedundantEdge">
            <h2>isRedundantEdge</h2>
            <hr />
            
            <p>isRedundantEdge determines if there is a path that allows e.Src
to reach e.Dest after removing e.</p>
            
            <pre><code>func isRedundantEdge(e *Edge) bool</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Sort">
            <h2>Sort</h2>
            <hr />
            
            <p>Sort reorders a slice of nodes based on the specified ordering
criteria. The result is sorted in decreasing order for (absolute)
numeric quantities, alphabetically for text, and increasing for
addresses.</p>
            
            <pre><code>func Sort(o NodeOrder) error</code></pre>
         </article>
         
         <article class="function" data-name="compareNodes">
            <h2>compareNodes</h2>
            <hr />
            
            <p>compareNodes compares two nodes to provide a deterministic ordering
between them. Two nodes cannot have the same Node.Info value.</p>
            
            <pre><code>func compareNodes(l *Node, r *Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="entropyScore">
            <h2>entropyScore</h2>
            <hr />
            
            <p>entropyScore computes a score for a node representing how important
it is to include this node on a graph visualization. It is used to
sort the nodes and select which ones to display if we have more
nodes than desired in the graph. This number is computed by looking
at the flat and cum weights of the node and the incoming/outgoing
edges. The fundamental idea is to penalize nodes that have a simple
fallthrough from their incoming to the outgoing edge.</p>
            
            <pre><code>func entropyScore(n *Node) int64</code></pre>
         </article>
         
         <article class="function" data-name="edgeEntropyScore">
            <h2>edgeEntropyScore</h2>
            <hr />
            
            <p>edgeEntropyScore computes the entropy value for a set of edges
coming in or out of a node. Entropy (as defined in information
theory) refers to the amount of information encoded by the set of
edges. A set of edges that have a more interesting distribution of
samples gets a higher score.</p>
            
            <pre><code>func edgeEntropyScore(n *Node, edges EdgeMap, self int64) float64</code></pre>
         </article>
         
         <article class="function" data-name="Sort">
            <h2>Sort</h2>
            <hr />
            
            <p>Sort returns a slice of the edges in the map, in a consistent
order. The sort order is first based on the edge weight
(higher-to-lower) and then by the node names to avoid flakiness.</p>
            
            <pre><code>func Sort() []*Edge</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum returns the total weight for a set of nodes.</p>
            
            <pre><code>func Sum() int64</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="abs64">
            <h2>abs64</h2>
            <hr />
            
            <pre><code>func abs64(i int64) int64</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
