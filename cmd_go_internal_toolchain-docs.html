<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - toolchain</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>toolchain</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"cmd/go/internal/base"
"fmt"
"internal/godebug"
"os"
"os/exec"
"runtime"
"syscall"
"cmd/go/internal/base"
"io/fs"
"io/fs"
"os"
"path/filepath"
"strings"
"sync"
"cmd/go/internal/gover"
"context"
"fmt"
"os"
"path/filepath"
"sort"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/internal/telemetry/counter"
"io/fs"
"os"
"path/filepath"
"cmd/go/internal/gover"
"internal/syscall/unix"
"io/fs"
"os"
"path/filepath"
"syscall"
"cmd/go/internal/gover"
"bytes"
"context"
"errors"
"flag"
"fmt"
"go/build"
"internal/godebug"
"io"
"io/fs"
"log"
"os"
"path/filepath"
"runtime"
"strconv"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch"
"cmd/go/internal/modload"
"cmd/go/internal/run"
"cmd/go/internal/work"
"cmd/internal/pathcache"
"cmd/internal/telemetry/counter"
"golang.org/x/mod/module"
"io/fs"
"io/fs"
"syscall"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="TestVersionSwitch" data-name="TestVersionSwitch">
               <h3>
                  TestVersionSwitch 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#TestVersionSwitch" class="anchor" title="Link to TestVersionSwitch">#</a>
               </h3>
               
               <p>TestVersionSwitch is set in the test go binary to the value in $TESTGO_VERSION_SWITCH.
Valid settings are:
"switch" - simulate version switches by reinvoking the test go binary with a different TESTGO_VERSION.
"mismatch" - like "switch" but forget to set TESTGO_VERSION, so it looks like we invoked a mismatched toolchain
"loop" - like "mismatch" but forget the target check, causing a toolchain switching loop</p>
               
               <pre><code>var TestVersionSwitch string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="countEnv" data-name="countEnv">
               <h3>
                  countEnv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#countEnv" class="anchor" title="Link to countEnv">#</a>
               </h3>
               
               <p>countEnv is a special environment variable
that is incremented during each toolchain switch, to detect loops.
It is cleared before invoking programs in 'go run', 'go test', 'go generate', and 'go tool'
by invoking them in an environment filtered with FilterEnv,
so user programs should not see this in their environment.</p>
               
               <pre><code>const countEnv = "GOTOOLCHAIN_INTERNAL_SWITCH_COUNT"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterErrorsInvalidToolchainInFile" data-name="counterErrorsInvalidToolchainInFile">
               <h3>
                  counterErrorsInvalidToolchainInFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#counterErrorsInvalidToolchainInFile" class="anchor" title="Link to counterErrorsInvalidToolchainInFile">#</a>
               </h3>
               
               <pre><code>var counterErrorsInvalidToolchainInFile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterSelectExec" data-name="counterSelectExec">
               <h3>
                  counterSelectExec 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#counterSelectExec" class="anchor" title="Link to counterSelectExec">#</a>
               </h3>
               
               <pre><code>var counterSelectExec = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterSwitchExec" data-name="counterSwitchExec">
               <h3>
                  counterSwitchExec 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#counterSwitchExec" class="anchor" title="Link to counterSwitchExec">#</a>
               </h3>
               
               <pre><code>var counterSwitchExec = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gotoolchainModule" data-name="gotoolchainModule">
               <h3>
                  gotoolchainModule 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gotoolchainModule" class="anchor" title="Link to gotoolchainModule">#</a>
               </h3>
               
               <p>We download golang.org/toolchain version v0.0.1-<gotoolchain>.<goos>-<goarch>.
If the 0.0.1 indicates anything at all, its the version of the toolchain packaging:
if for some reason we needed to change the way toolchains are packaged into
module zip files in a future version of Go, we could switch to v0.0.2 and then
older versions expecting the old format could use v0.0.1 and newer versions
would use v0.0.2. Of course, then we'd also have to publish two of each
module zip file. It's not likely we'll ever need to change this.</p>
               
               <pre><code>const gotoolchainModule = "golang.org/toolchain"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gotoolchainVersion" data-name="gotoolchainVersion">
               <h3>
                  gotoolchainVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gotoolchainVersion" class="anchor" title="Link to gotoolchainVersion">#</a>
               </h3>
               
               <pre><code>const gotoolchainVersion = "v0.0.1"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxSwitch" data-name="maxSwitch">
               <h3>
                  maxSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxSwitch" class="anchor" title="Link to maxSwitch">#</a>
               </h3>
               
               <p>maxSwitch is the maximum toolchain switching depth.
Most uses should never see more than three.
(Perhaps one for the initial GOTOOLCHAIN dispatch,
a second for go get doing an upgrade, and a third if
for some reason the chosen upgrade version is too small
by a little.)
When the count reaches maxSwitch - 10, we start logging
the switched versions for debugging before crashing with
a fatal error upon reaching maxSwitch.
That should be enough to see the repetition.</p>
               
               <pre><code>const maxSwitch = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pathExts" data-name="pathExts">
               <h3>
                  pathExts 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pathExts" class="anchor" title="Link to pathExts">#</a>
               </h3>
               
               <pre><code>var pathExts = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="targetEnv" data-name="targetEnv">
               <h3>
                  targetEnv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#targetEnv" class="anchor" title="Link to targetEnv">#</a>
               </h3>
               
               <p>targetEnv is a special environment variable set to the expected
toolchain version during the toolchain switch by the parent
process and cleared in the child process. When set, that indicates
to the child to confirm that it provides the expected toolchain version.</p>
               
               <pre><code>const targetEnv = "GOTOOLCHAIN_INTERNAL_SWITCH_VERSION"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="toolchainTrace" data-name="toolchainTrace">
               <h3>
                  toolchainTrace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#toolchainTrace" class="anchor" title="Link to toolchainTrace">#</a>
               </h3>
               
               <pre><code>var toolchainTrace = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="writeBits" data-name="writeBits">
               <h3>
                  writeBits 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#writeBits" class="anchor" title="Link to writeBits">#</a>
               </h3>
               
               <pre><code>var writeBits fs.FileMode</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Switcher" data-name="Switcher">
               <h3>
                  Switcher
                  <span class="badge">struct</span>
                  <a href="#Switcher" class="anchor" title="Link to Switcher">#</a>
               </h3>
               
               <p>A Switcher collects errors to be reported and then decides
between reporting the errors or switching to a new toolchain
to resolve them.
The client calls [Switcher.Error] repeatedly with errors encountered
and then calls [Switcher.Switch]. If the errors included any
*gover.TooNewErrors (potentially wrapped) and switching is
permitted by GOTOOLCHAIN, Switch switches to a new toolchain.
Otherwise Switch prints all the errors using base.Error.
See https://go.dev/doc/toolchain#switch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Switcher struct {
TooNew *gover.TooNewError
Errors []error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error reports the error to the Switcher,
which saves it for processing during Switch.</p>
               
               <pre><code>func (s *Switcher) Error(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exec" data-name="Exec">
               <h3>
                  Exec 
                  <span class="badge">function</span>
                  
                  <a href="#Exec" class="anchor" title="Link to Exec">#</a>
               </h3>
               
               <p>Exec invokes the specified Go toolchain or else prints an error and exits the process.
If $GOTOOLCHAIN is set to path or min+path, Exec only considers the PATH
as a source of Go toolchains. Otherwise Exec tries the PATH but then downloads
a toolchain if necessary.</p>
               
               <pre><code>func Exec(gotoolchain string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FilterEnv" data-name="FilterEnv">
               <h3>
                  FilterEnv 
                  <span class="badge">function</span>
                  
                  <a href="#FilterEnv" class="anchor" title="Link to FilterEnv">#</a>
               </h3>
               
               <p>FilterEnv returns a copy of env with internal GOTOOLCHAIN environment
variables filtered out.</p>
               
               <pre><code>func FilterEnv(env []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasAuto" data-name="HasAuto">
               <h3>
                  HasAuto 
                  <span class="badge">function</span>
                  
                  <a href="#HasAuto" class="anchor" title="Link to HasAuto">#</a>
               </h3>
               
               <p>HasAuto reports whether the GOTOOLCHAIN setting allows "auto" upgrades.</p>
               
               <pre><code>func HasAuto() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPath" data-name="HasPath">
               <h3>
                  HasPath 
                  <span class="badge">function</span>
                  
                  <a href="#HasPath" class="anchor" title="Link to HasPath">#</a>
               </h3>
               
               <p>HasPath reports whether the GOTOOLCHAIN setting allows "path" upgrades.</p>
               
               <pre><code>func HasPath() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NeedSwitch" data-name="NeedSwitch">
               <h3>
                  NeedSwitch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NeedSwitch" class="anchor" title="Link to NeedSwitch">#</a>
               </h3>
               
               <p>NeedSwitch reports whether Switch would attempt to switch toolchains.</p>
               
               <pre><code>func (s *Switcher) NeedSwitch() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewerToolchain" data-name="NewerToolchain">
               <h3>
                  NewerToolchain 
                  <span class="badge">function</span>
                  
                  <a href="#NewerToolchain" class="anchor" title="Link to NewerToolchain">#</a>
               </h3>
               
               <p>NewerToolchain returns the name of the toolchain to use when we need
to switch to a newer toolchain that must support at least the given Go version.
See https://go.dev/doc/toolchain#switch.
If the latest major release is 1.N.0, we use the latest patch release of 1.(N-1) if that's >= version.
Otherwise we use the latest 1.N if that's allowed.
Otherwise we use the latest release.</p>
               
               <pre><code>func NewerToolchain(ctx context.Context, version string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge">function</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select invokes a different Go toolchain if directed by
the GOTOOLCHAIN environment variable or the user's configuration
or go.mod file.
It must be called early in startup.
See https://go.dev/doc/toolchain#select.</p>
               
               <pre><code>func Select()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Switch" data-name="Switch">
               <h3>
                  Switch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Switch" class="anchor" title="Link to Switch">#</a>
               </h3>
               
               <p>Switch decides whether to switch to a newer toolchain
to resolve any of the saved errors.
It switches if toolchain switches are permitted and there is at least one TooNewError.
If Switch decides not to switch toolchains, it prints the errors using base.Error and returns.
If Switch decides to switch toolchains but cannot identify a toolchain to use.
it prints the errors along with one more about not being able to find the toolchain
and returns.
Otherwise, Switch prints an informational message giving a reason for the
switch and the toolchain being invoked and then switches toolchains.
This operation never returns.</p>
               
               <pre><code>func (s *Switcher) Switch(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SwitchOrFatal" data-name="SwitchOrFatal">
               <h3>
                  SwitchOrFatal 
                  <span class="badge">function</span>
                  
                  <a href="#SwitchOrFatal" class="anchor" title="Link to SwitchOrFatal">#</a>
               </h3>
               
               <p>SwitchOrFatal attempts a toolchain switch based on the information in err
and otherwise falls back to base.Fatal(err).</p>
               
               <pre><code>func SwitchOrFatal(ctx context.Context, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addTooNew" data-name="addTooNew">
               <h3>
                  addTooNew 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addTooNew" class="anchor" title="Link to addTooNew">#</a>
               </h3>
               
               <p>addTooNew adds any TooNew errors that can be found in err.</p>
               
               <pre><code>func (s *Switcher) addTooNew(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="autoToolchains" data-name="autoToolchains">
               <h3>
                  autoToolchains 
                  <span class="badge">function</span>
                  
                  <a href="#autoToolchains" class="anchor" title="Link to autoToolchains">#</a>
               </h3>
               
               <p>autoToolchains returns the list of toolchain versions available to GOTOOLCHAIN=auto or =min+auto mode.</p>
               
               <pre><code>func autoToolchains(ctx context.Context) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cutExt" data-name="cutExt">
               <h3>
                  cutExt 
                  <span class="badge">function</span>
                  
                  <a href="#cutExt" class="anchor" title="Link to cutExt">#</a>
               </h3>
               
               <p>cutExt looks for any of the known extensions at the end of file.
If one is found, cutExt returns the file name with the extension trimmed,
the extension itself, and true to signal that an extension was found.
Otherwise cutExt returns file, "", false.</p>
               
               <pre><code>func cutExt(file string, exts []string) (name string, ext string, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="execGoToolchain" data-name="execGoToolchain">
               <h3>
                  execGoToolchain 
                  <span class="badge">function</span>
                  
                  <a href="#execGoToolchain" class="anchor" title="Link to execGoToolchain">#</a>
               </h3>
               
               <p>execGoToolchain execs the Go toolchain with the given name (gotoolchain),
GOROOT directory, and go command executable.
The GOROOT directory is empty if we are invoking a command named
gotoolchain found in $PATH.</p>
               
               <pre><code>func execGoToolchain(gotoolchain string, dir string, exe string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="execGoToolchain" data-name="execGoToolchain">
               <h3>
                  execGoToolchain 
                  <span class="badge">function</span>
                  
                  <a href="#execGoToolchain" class="anchor" title="Link to execGoToolchain">#</a>
               </h3>
               
               <pre><code>func execGoToolchain(gotoolchain string, dir string, exe string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goInstallVersion" data-name="goInstallVersion">
               <h3>
                  goInstallVersion 
                  <span class="badge">function</span>
                  
                  <a href="#goInstallVersion" class="anchor" title="Link to goInstallVersion">#</a>
               </h3>
               
               <p>goInstallVersion reports whether the command line is go install m@v or go run m@v.
If so, Select must not read the go.mod or go.work file in "auto" or "path" mode.</p>
               
               <pre><code>func goInstallVersion(minVers string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modGoToolchain" data-name="modGoToolchain">
               <h3>
                  modGoToolchain 
                  <span class="badge">function</span>
                  
                  <a href="#modGoToolchain" class="anchor" title="Link to modGoToolchain">#</a>
               </h3>
               
               <p>modGoToolchain finds the enclosing go.work or go.mod file
and returns the go version and toolchain lines from the file.
The toolchain line overrides the version line</p>
               
               <pre><code>func modGoToolchain() (file string, goVers string, toolchain string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newerToolchain" data-name="newerToolchain">
               <h3>
                  newerToolchain 
                  <span class="badge">function</span>
                  
                  <a href="#newerToolchain" class="anchor" title="Link to newerToolchain">#</a>
               </h3>
               
               <p>newerToolchain implements NewerToolchain where the list of choices is known.
It is separated out for easier testing of this logic.</p>
               
               <pre><code>func newerToolchain(need string, list []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathDirs" data-name="pathDirs">
               <h3>
                  pathDirs 
                  <span class="badge">function</span>
                  
                  <a href="#pathDirs" class="anchor" title="Link to pathDirs">#</a>
               </h3>
               
               <p>pathDirs returns the directories in the system search path.</p>
               
               <pre><code>func pathDirs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathDirs" data-name="pathDirs">
               <h3>
                  pathDirs 
                  <span class="badge">function</span>
                  
                  <a href="#pathDirs" class="anchor" title="Link to pathDirs">#</a>
               </h3>
               
               <p>pathDirs returns the directories in the system search path.</p>
               
               <pre><code>func pathDirs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathDirs" data-name="pathDirs">
               <h3>
                  pathDirs 
                  <span class="badge">function</span>
                  
                  <a href="#pathDirs" class="anchor" title="Link to pathDirs">#</a>
               </h3>
               
               <p>pathDirs returns the directories in the system search path.</p>
               
               <pre><code>func pathDirs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathDirs" data-name="pathDirs">
               <h3>
                  pathDirs 
                  <span class="badge">function</span>
                  
                  <a href="#pathDirs" class="anchor" title="Link to pathDirs">#</a>
               </h3>
               
               <p>pathDirs returns the directories in the system search path.</p>
               
               <pre><code>func pathDirs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathToolchains" data-name="pathToolchains">
               <h3>
                  pathToolchains 
                  <span class="badge">function</span>
                  
                  <a href="#pathToolchains" class="anchor" title="Link to pathToolchains">#</a>
               </h3>
               
               <p>pathToolchains returns the list of toolchain versions available to GOTOOLCHAIN=path or =min+path mode.</p>
               
               <pre><code>func pathToolchains(ctx context.Context) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathVersion" data-name="pathVersion">
               <h3>
                  pathVersion 
                  <span class="badge">function</span>
                  
                  <a href="#pathVersion" class="anchor" title="Link to pathVersion">#</a>
               </h3>
               
               <p>pathVersion returns the Go version implemented by the file
described by de and info in directory dir.
The analysis only uses the name itself; it does not run the program.</p>
               
               <pre><code>func pathVersion(dir string, de fs.DirEntry, info fs.FileInfo) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathVersion" data-name="pathVersion">
               <h3>
                  pathVersion 
                  <span class="badge">function</span>
                  
                  <a href="#pathVersion" class="anchor" title="Link to pathVersion">#</a>
               </h3>
               
               <p>pathVersion returns the Go version implemented by the file
described by de and info in directory dir.
The analysis only uses the name itself; it does not run the program.</p>
               
               <pre><code>func pathVersion(dir string, de fs.DirEntry, info fs.FileInfo) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathVersion" data-name="pathVersion">
               <h3>
                  pathVersion 
                  <span class="badge">function</span>
                  
                  <a href="#pathVersion" class="anchor" title="Link to pathVersion">#</a>
               </h3>
               
               <p>pathVersion returns the Go version implemented by the file
described by de and info in directory dir.
The analysis only uses the name itself; it does not run the program.</p>
               
               <pre><code>func pathVersion(dir string, de fs.DirEntry, info fs.FileInfo) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathVersion" data-name="pathVersion">
               <h3>
                  pathVersion 
                  <span class="badge">function</span>
                  
                  <a href="#pathVersion" class="anchor" title="Link to pathVersion">#</a>
               </h3>
               
               <p>pathVersion returns the Go version implemented by the file
described by de and info in directory dir.
The analysis only uses the name itself; it does not run the program.</p>
               
               <pre><code>func pathVersion(dir string, de fs.DirEntry, info fs.FileInfo) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="raceSafeCopy" data-name="raceSafeCopy">
               <h3>
                  raceSafeCopy 
                  <span class="badge">function</span>
                  
                  <a href="#raceSafeCopy" class="anchor" title="Link to raceSafeCopy">#</a>
               </h3>
               
               <p>raceSafeCopy copies the file old to the file new, being careful to ensure
that if multiple go commands call raceSafeCopy(old, new) at the same time,
they don't interfere with each other: both will succeed and return and
later observe the correct content in new. Like in the build cache, we arrange
this by opening new without truncation and then writing the content.
Both go commands can do this simultaneously and will write the same thing
(old never changes content).</p>
               
               <pre><code>func raceSafeCopy(old string, new string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="size" data-name="size">
               <h3>
                  size 
                  <span class="badge">function</span>
                  
                  <a href="#size" class="anchor" title="Link to size">#</a>
               </h3>
               
               <pre><code>func size(path string) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sysWriteBits" data-name="sysWriteBits">
               <h3>
                  sysWriteBits 
                  <span class="badge">function</span>
                  
                  <a href="#sysWriteBits" class="anchor" title="Link to sysWriteBits">#</a>
               </h3>
               
               <pre><code>func sysWriteBits() fs.FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sysWriteBits" data-name="sysWriteBits">
               <h3>
                  sysWriteBits 
                  <span class="badge">function</span>
                  
                  <a href="#sysWriteBits" class="anchor" title="Link to sysWriteBits">#</a>
               </h3>
               
               <p>sysWriteBits determines which bits to OR into the mode to make a directory writable.
It must be called when there are no other file system operations happening.</p>
               
               <pre><code>func sysWriteBits() fs.FileMode</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>