<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ecdsa</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>ecdsa</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"crypto/internal/boring"
"crypto/internal/boring/bbig"
"crypto/internal/boring/bcache"
"math/big"
"crypto"
"crypto/ecdh"
"crypto/elliptic"
"crypto/internal/boring"
"crypto/internal/boring/bbig"
"crypto/internal/fips140/ecdsa"
"crypto/internal/fips140hash"
"crypto/internal/fips140only"
"crypto/internal/randutil"
"crypto/sha512"
"crypto/subtle"
"errors"
"io"
"math/big"
"golang.org/x/crypto/cryptobyte"
"golang.org/x/crypto/cryptobyte/asn1"
"crypto/elliptic"
"crypto/internal/fips140only"
"errors"
"io"
"math/big"
"math/rand/v2"
"golang.org/x/crypto/cryptobyte"
"golang.org/x/crypto/cryptobyte/asn1"
"crypto/internal/boring"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="errNoAsm">
               <h3>
                  errNoAsm 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errNoAsm is returned by signAsm and verifyAsm when the assembly
implementation is not available.</p>
               
               <pre><code>var errNoAsm = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errZeroParam">
               <h3>
                  errZeroParam 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errZeroParam = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="one">
               <h3>
                  one 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var one = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="privCache">
               <h3>
                  privCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var privCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="pubCache">
               <h3>
                  pubCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pubCache *ast.IndexListExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="PrivateKey">
               <h3>
                  PrivateKey
                  <span class="badge">struct</span>
               </h3>
               
               <p>PrivateKey represents an ECDSA private key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PrivateKey struct {
PublicKey
D *big.Int
}</code></pre>
            </article>
            
            <article class="struct" data-name="PublicKey">
               <h3>
                  PublicKey
                  <span class="badge">struct</span>
               </h3>
               
               <p>PublicKey represents an ECDSA public key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PublicKey struct {
elliptic.Curve
X *big.Int
Y *big.Int
}</code></pre>
            </article>
            
            <article class="struct" data-name="boringPriv">
               <h3>
                  boringPriv
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type boringPriv struct {
key *boring.PrivateKeyECDSA
orig PrivateKey
}</code></pre>
            </article>
            
            <article class="struct" data-name="boringPub">
               <h3>
                  boringPub
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type boringPub struct {
key *boring.PublicKeyECDSA
orig PublicKey
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="ECDH">
               <h3>
                  ECDH 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ECDH returns k as a [ecdh.PrivateKey]. It returns an error if the key is
invalid according to the definition of [ecdh.Curve.NewPrivateKey], or if the
Curve is not supported by [crypto/ecdh].</p>
               
               <pre><code>func (k *PrivateKey) ECDH() (*ecdh.PrivateKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="ECDH">
               <h3>
                  ECDH 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is
invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the
Curve is not supported by crypto/ecdh.</p>
               
               <pre><code>func (k *PublicKey) ECDH() (*ecdh.PublicKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether priv and x have the same value.
See [PublicKey.Equal] for details on how Curve is compared.</p>
               
               <pre><code>func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether pub and x have the same value.
Two keys are only considered to have the same value if they have the same Curve value.
Note that for example [elliptic.P256] and elliptic.P256().Params() are different
values, as the latter is a generic not constant time implementation.</p>
               
               <pre><code>func (pub *PublicKey) Equal(x crypto.PublicKey) bool</code></pre>
            </article>
            
            <article class="function" data-name="GenerateKey">
               <h3>
                  GenerateKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GenerateKey generates a new ECDSA private key for the specified curve.
Most applications should use [crypto/rand.Reader] as rand. Note that the
returned key does not depend deterministically on the bytes read from rand,
and may change between calls and/or between versions.</p>
               
               <pre><code>func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="Public">
               <h3>
                  Public 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Public returns the public key corresponding to priv.</p>
               
               <pre><code>func (priv *PrivateKey) Public() crypto.PublicKey</code></pre>
            </article>
            
            <article class="function" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sign signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key's curve order, the hash will be truncated to that length. It
returns the signature as a pair of integers. Most applications should use
[SignASN1] instead of dealing directly with r, s.</p>
               
               <pre><code>func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r *big.Int, s *big.Int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sign signs a hash (which should be the result of hashing a larger message
with opts.HashFunc()) using the private key, priv. If the hash is longer than
the bit-length of the private key's curve order, the hash will be truncated
to that length. It returns the ASN.1 encoded signature, like [SignASN1].
If rand is not nil, the signature is randomized. Most applications should use
[crypto/rand.Reader] as rand. Note that the returned signature does not
depend deterministically on the bytes read from rand, and may change between
calls and/or between versions.
If rand is nil, Sign will produce a deterministic signature according to RFC
6979. When producing a deterministic signature, opts.HashFunc() must be the
function used to produce digest and priv.Curve must be one of
[elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521].</p>
               
               <pre><code>func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="SignASN1">
               <h3>
                  SignASN1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SignASN1 signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key's curve order, the hash will be truncated to that length. It
returns the ASN.1 encoded signature.
The signature is randomized. Most applications should use [crypto/rand.Reader]
as rand. Note that the returned signature does not depend deterministically on
the bytes read from rand, and may change between calls and/or between versions.</p>
               
               <pre><code>func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Verify">
               <h3>
                  Verify 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Verify verifies the signature in r, s of hash using the public key, pub. Its
return value records whether the signature is valid. Most applications should
use VerifyASN1 instead of dealing directly with r, s.
The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
               
               <pre><code>func Verify(pub *PublicKey, hash []byte, r *big.Int, s *big.Int) bool</code></pre>
            </article>
            
            <article class="function" data-name="VerifyASN1">
               <h3>
                  VerifyASN1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
public key, pub. Its return value records whether the signature is valid.
The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
               
               <pre><code>func VerifyASN1(pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="addASN1IntBytes">
               <h3>
                  addASN1IntBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addASN1IntBytes encodes in ASN.1 a positive integer represented as
a big-endian byte slice with zero or more leading zeroes.</p>
               
               <pre><code>func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte)</code></pre>
            </article>
            
            <article class="function" data-name="bigIntEqual">
               <h3>
                  bigIntEqual 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>bigIntEqual reports whether a and b are equal leaking only their bit length
through timing side-channels.</p>
               
               <pre><code>func bigIntEqual(a *big.Int, b *big.Int) bool</code></pre>
            </article>
            
            <article class="function" data-name="boringPrivateKey">
               <h3>
                  boringPrivateKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function" data-name="boringPrivateKey">
               <h3>
                  boringPrivateKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function" data-name="boringPublicKey">
               <h3>
                  boringPublicKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function" data-name="boringPublicKey">
               <h3>
                  boringPublicKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boringPublicKey(pub *PublicKey) (*boring.PublicKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function" data-name="copyPrivateKey">
               <h3>
                  copyPrivateKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyPrivateKey(k *PrivateKey) PrivateKey</code></pre>
            </article>
            
            <article class="function" data-name="copyPublicKey">
               <h3>
                  copyPublicKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyPublicKey(k *PublicKey) PublicKey</code></pre>
            </article>
            
            <article class="function" data-name="curveToECDH">
               <h3>
                  curveToECDH 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func curveToECDH(c elliptic.Curve) ecdh.Curve</code></pre>
            </article>
            
            <article class="function" data-name="encodeSignature">
               <h3>
                  encodeSignature 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeSignature(r []byte, s []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="generateFIPS">
               <h3>
                  generateFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func generateFIPS(curve elliptic.Curve, c **ast.IndexExpr, rand io.Reader) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="generateLegacy">
               <h3>
                  generateLegacy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func generateLegacy(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="hashToInt">
               <h3>
                  hashToInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hashToInt converts a hash value to an integer. Per FIPS 186-4, Section 6.4,
we use the left-most bits of the hash to match the bit-length of the order of
the curve. This also performs Step 5 of SEC 1, Version 2.0, Section 4.1.3.</p>
               
               <pre><code>func hashToInt(hash []byte, c elliptic.Curve) *big.Int</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="parseSignature">
               <h3>
                  parseSignature 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseSignature(sig []byte) (r []byte, s []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="pointFromAffine">
               <h3>
                  pointFromAffine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pointFromAffine is used to convert the PublicKey to a nistec SetBytes input.</p>
               
               <pre><code>func pointFromAffine(curve elliptic.Curve, x *big.Int, y *big.Int) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="pointToAffine">
               <h3>
                  pointToAffine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pointToAffine is used to convert a nistec Bytes encoding to a PublicKey.</p>
               
               <pre><code>func pointToAffine(curve elliptic.Curve, p []byte) (x *big.Int, y *big.Int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="privateKeyEqual">
               <h3>
                  privateKeyEqual 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func privateKeyEqual(k1 *PrivateKey, k2 *PrivateKey) bool</code></pre>
            </article>
            
            <article class="function" data-name="privateKeyFromFIPS">
               <h3>
                  privateKeyFromFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func privateKeyFromFIPS(curve elliptic.Curve, priv *ecdsa.PrivateKey) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="privateKeyToFIPS">
               <h3>
                  privateKeyToFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func privateKeyToFIPS(c **ast.IndexExpr, priv *PrivateKey) (*ecdsa.PrivateKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="publicKeyEqual">
               <h3>
                  publicKeyEqual 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func publicKeyEqual(k1 *PublicKey, k2 *PublicKey) bool</code></pre>
            </article>
            
            <article class="function" data-name="publicKeyFromFIPS">
               <h3>
                  publicKeyFromFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func publicKeyFromFIPS(curve elliptic.Curve, pub *ecdsa.PublicKey) (*PublicKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="publicKeyToFIPS">
               <h3>
                  publicKeyToFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func publicKeyToFIPS(c **ast.IndexExpr, pub *PublicKey) (*ecdsa.PublicKey, error)</code></pre>
            </article>
            
            <article class="function" data-name="randFieldElement">
               <h3>
                  randFieldElement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>randFieldElement returns a random element of the order of the given
curve using the procedure given in FIPS 186-4, Appendix B.5.2.</p>
               
               <pre><code>func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="signFIPS">
               <h3>
                  signFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func signFIPS(c **ast.IndexExpr, priv *PrivateKey, rand io.Reader, hash []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="signFIPSDeterministic">
               <h3>
                  signFIPSDeterministic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func signFIPSDeterministic(c **ast.IndexExpr, hashFunc crypto.Hash, priv *PrivateKey, hash []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="signLegacy">
               <h3>
                  signLegacy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func signLegacy(priv *PrivateKey, csprng io.Reader, hash []byte) (sig []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="signRFC6979">
               <h3>
                  signRFC6979 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func signRFC6979(priv *PrivateKey, hash []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="verifyFIPS">
               <h3>
                  verifyFIPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func verifyFIPS(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="verifyLegacy">
               <h3>
                  verifyLegacy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func verifyLegacy(pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
