<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ecdsa</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>ecdsa</code>
         </h1>
         <hr />
         
         <article class="global" data-name="errNoAsm">
            <h2>errNoAsm</h2>
            <hr />
            
            <p>errNoAsm is returned by signAsm and verifyAsm when the assembly
implementation is not available.</p>
            
            <pre><code>errNoAsm</code></pre>
         </article>
         
         <article class="global" data-name="errZeroParam">
            <h2>errZeroParam</h2>
            <hr />
            
            <pre><code>errZeroParam</code></pre>
         </article>
         
         <article class="global" data-name="one">
            <h2>one</h2>
            <hr />
            
            <pre><code>one</code></pre>
         </article>
         
         <article class="global" data-name="zeroReader">
            <h2>zeroReader</h2>
            <hr />
            
            <pre><code>zeroReader</code></pre>
         </article>
         
         <article class="global" data-name="pubCache">
            <h2>pubCache</h2>
            <hr />
            
            <pre><code>pubCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="privCache">
            <h2>privCache</h2>
            <hr />
            
            <pre><code>privCache *ast.IndexListExpr</code></pre>
         </article>
          
         <article class="struct" data-name="PublicKey">
            <h2>type PublicKey struct</h2>
            <hr />
            
            <p>PublicKey represents an ECDSA public key.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">elliptic.Curve
X *big.Int
Y *big.Int</code></pre>
         </article>
         
         <article class="struct" data-name="PrivateKey">
            <h2>type PrivateKey struct</h2>
            <hr />
            
            <p>PrivateKey represents an ECDSA private key.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">PublicKey
D *big.Int</code></pre>
         </article>
         
         <article class="struct" data-name="boringPub">
            <h2>type boringPub struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">key *boring.PublicKeyECDSA
orig PublicKey</code></pre>
         </article>
         
         <article class="struct" data-name="boringPriv">
            <h2>type boringPriv struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">key *boring.PrivateKeyECDSA
orig PrivateKey</code></pre>
         </article>
          
         <article class="function" data-name="ECDH">
            <h2>ECDH</h2>
            <hr />
            
            <p>ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is
invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the
Curve is not supported by crypto/ecdh.</p>
            
            <pre><code>func ECDH() (*ecdh.PublicKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal reports whether pub and x have the same value.

Two keys are only considered to have the same value if they have the same Curve value.
Note that for example [elliptic.P256] and elliptic.P256().Params() are different
values, as the latter is a generic not constant time implementation.</p>
            
            <pre><code>func Equal(x crypto.PublicKey) bool</code></pre>
         </article>
         
         <article class="function" data-name="ECDH">
            <h2>ECDH</h2>
            <hr />
            
            <p>ECDH returns k as a [ecdh.PrivateKey]. It returns an error if the key is
invalid according to the definition of [ecdh.Curve.NewPrivateKey], or if the
Curve is not supported by [crypto/ecdh].</p>
            
            <pre><code>func ECDH() (*ecdh.PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="curveToECDH">
            <h2>curveToECDH</h2>
            <hr />
            
            <pre><code>func curveToECDH(c elliptic.Curve) ecdh.Curve</code></pre>
         </article>
         
         <article class="function" data-name="Public">
            <h2>Public</h2>
            <hr />
            
            <p>Public returns the public key corresponding to priv.</p>
            
            <pre><code>func Public() crypto.PublicKey</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal reports whether priv and x have the same value.

See [PublicKey.Equal] for details on how Curve is compared.</p>
            
            <pre><code>func Equal(x crypto.PrivateKey) bool</code></pre>
         </article>
         
         <article class="function" data-name="bigIntEqual">
            <h2>bigIntEqual</h2>
            <hr />
            
            <p>bigIntEqual reports whether a and b are equal leaking only their bit length
through timing side-channels.</p>
            
            <pre><code>func bigIntEqual(a *big.Int, b *big.Int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Sign">
            <h2>Sign</h2>
            <hr />
            
            <p>Sign signs a hash (which should be the result of hashing a larger message
with opts.HashFunc()) using the private key, priv. If the hash is longer than
the bit-length of the private key's curve order, the hash will be truncated
to that length. It returns the ASN.1 encoded signature, like [SignASN1].

If rand is not nil, the signature is randomized. Most applications should use
[crypto/rand.Reader] as rand. Note that the returned signature does not
depend deterministically on the bytes read from rand, and may change between
calls and/or between versions.

If rand is nil, Sign will produce a deterministic signature according to RFC
6979. When producing a deterministic signature, opts.HashFunc() must be the
function used to produce digest and priv.Curve must be one of
[elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521].</p>
            
            <pre><code>func Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="GenerateKey">
            <h2>GenerateKey</h2>
            <hr />
            
            <p>GenerateKey generates a new ECDSA private key for the specified curve.

Most applications should use [crypto/rand.Reader] as rand. Note that the
returned key does not depend deterministically on the bytes read from rand,
and may change between calls and/or between versions.</p>
            
            <pre><code>func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="generateFIPS">
            <h2>generateFIPS</h2>
            <hr />
            
            <pre><code>func generateFIPS(curve elliptic.Curve, c **ast.IndexExpr, rand io.Reader) (*PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="SignASN1">
            <h2>SignASN1</h2>
            <hr />
            
            <p>SignASN1 signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key's curve order, the hash will be truncated to that length. It
returns the ASN.1 encoded signature.

The signature is randomized. Most applications should use [crypto/rand.Reader]
as rand. Note that the returned signature does not depend deterministically on
the bytes read from rand, and may change between calls and/or between versions.</p>
            
            <pre><code>func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="signFIPS">
            <h2>signFIPS</h2>
            <hr />
            
            <pre><code>func signFIPS(c **ast.IndexExpr, priv *PrivateKey, rand io.Reader, hash []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="signRFC6979">
            <h2>signRFC6979</h2>
            <hr />
            
            <pre><code>func signRFC6979(priv *PrivateKey, hash []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="signFIPSDeterministic">
            <h2>signFIPSDeterministic</h2>
            <hr />
            
            <pre><code>func signFIPSDeterministic(c **ast.IndexExpr, hashFunc crypto.Hash, priv *PrivateKey, hash []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="encodeSignature">
            <h2>encodeSignature</h2>
            <hr />
            
            <pre><code>func encodeSignature(r []byte, s []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="addASN1IntBytes">
            <h2>addASN1IntBytes</h2>
            <hr />
            
            <p>addASN1IntBytes encodes in ASN.1 a positive integer represented as
a big-endian byte slice with zero or more leading zeroes.</p>
            
            <pre><code>func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte)</code></pre>
         </article>
         
         <article class="function" data-name="VerifyASN1">
            <h2>VerifyASN1</h2>
            <hr />
            
            <p>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
public key, pub. Its return value records whether the signature is valid.

The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
            
            <pre><code>func VerifyASN1(pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="verifyFIPS">
            <h2>verifyFIPS</h2>
            <hr />
            
            <pre><code>func verifyFIPS(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseSignature">
            <h2>parseSignature</h2>
            <hr />
            
            <pre><code>func parseSignature(sig []byte) (r []byte, s []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="publicKeyFromFIPS">
            <h2>publicKeyFromFIPS</h2>
            <hr />
            
            <pre><code>func publicKeyFromFIPS(curve elliptic.Curve, pub *ecdsa.PublicKey) (*PublicKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="privateKeyFromFIPS">
            <h2>privateKeyFromFIPS</h2>
            <hr />
            
            <pre><code>func privateKeyFromFIPS(curve elliptic.Curve, priv *ecdsa.PrivateKey) (*PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="publicKeyToFIPS">
            <h2>publicKeyToFIPS</h2>
            <hr />
            
            <pre><code>func publicKeyToFIPS(c **ast.IndexExpr, pub *PublicKey) (*ecdsa.PublicKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="privateKeyToFIPS">
            <h2>privateKeyToFIPS</h2>
            <hr />
            
            <pre><code>func privateKeyToFIPS(c **ast.IndexExpr, priv *PrivateKey) (*ecdsa.PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="pointFromAffine">
            <h2>pointFromAffine</h2>
            <hr />
            
            <p>pointFromAffine is used to convert the PublicKey to a nistec SetBytes input.</p>
            
            <pre><code>func pointFromAffine(curve elliptic.Curve, x *big.Int, y *big.Int) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="pointToAffine">
            <h2>pointToAffine</h2>
            <hr />
            
            <p>pointToAffine is used to convert a nistec Bytes encoding to a PublicKey.</p>
            
            <pre><code>func pointToAffine(curve elliptic.Curve, p []byte) (x *big.Int, y *big.Int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="generateLegacy">
            <h2>generateLegacy</h2>
            <hr />
            
            <pre><code>func generateLegacy(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="hashToInt">
            <h2>hashToInt</h2>
            <hr />
            
            <p>hashToInt converts a hash value to an integer. Per FIPS 186-4, Section 6.4,
we use the left-most bits of the hash to match the bit-length of the order of
the curve. This also performs Step 5 of SEC 1, Version 2.0, Section 4.1.3.</p>
            
            <pre><code>func hashToInt(hash []byte, c elliptic.Curve) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="Sign">
            <h2>Sign</h2>
            <hr />
            
            <p>Sign signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key's curve order, the hash will be truncated to that length. It
returns the signature as a pair of integers. Most applications should use
[SignASN1] instead of dealing directly with r, s.</p>
            
            <pre><code>func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r *big.Int, s *big.Int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="signLegacy">
            <h2>signLegacy</h2>
            <hr />
            
            <pre><code>func signLegacy(priv *PrivateKey, csprng io.Reader, hash []byte) (sig []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Verify">
            <h2>Verify</h2>
            <hr />
            
            <p>Verify verifies the signature in r, s of hash using the public key, pub. Its
return value records whether the signature is valid. Most applications should
use VerifyASN1 instead of dealing directly with r, s.

The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
            
            <pre><code>func Verify(pub *PublicKey, hash []byte, r *big.Int, s *big.Int) bool</code></pre>
         </article>
         
         <article class="function" data-name="verifyLegacy">
            <h2>verifyLegacy</h2>
            <hr />
            
            <pre><code>func verifyLegacy(pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="randFieldElement">
            <h2>randFieldElement</h2>
            <hr />
            
            <p>randFieldElement returns a random element of the order of the given
curve using the procedure given in FIPS 186-4, Appendix B.5.2.</p>
            
            <pre><code>func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="testAllCurves">
            <h2>testAllCurves</h2>
            <hr />
            
            <pre><code>func testAllCurves(t *testing.T, f func)</code></pre>
         </article>
         
         <article class="function" data-name="genericParamsForCurve">
            <h2>genericParamsForCurve</h2>
            <hr />
            
            <p>genericParamsForCurve returns the dereferenced CurveParams for
the specified curve. This is used to avoid the logic for
upgrading a curve to its specific implementation, forcing
usage of the generic implementation.</p>
            
            <pre><code>func genericParamsForCurve(c elliptic.Curve) *elliptic.CurveParams</code></pre>
         </article>
         
         <article class="function" data-name="TestKeyGeneration">
            <h2>TestKeyGeneration</h2>
            <hr />
            
            <pre><code>func TestKeyGeneration(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testKeyGeneration">
            <h2>testKeyGeneration</h2>
            <hr />
            
            <pre><code>func testKeyGeneration(t *testing.T, c elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestSignAndVerify">
            <h2>TestSignAndVerify</h2>
            <hr />
            
            <pre><code>func TestSignAndVerify(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testSignAndVerify">
            <h2>testSignAndVerify</h2>
            <hr />
            
            <pre><code>func testSignAndVerify(t *testing.T, c elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestSignAndVerifyASN1">
            <h2>TestSignAndVerifyASN1</h2>
            <hr />
            
            <pre><code>func TestSignAndVerifyASN1(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testSignAndVerifyASN1">
            <h2>testSignAndVerifyASN1</h2>
            <hr />
            
            <pre><code>func testSignAndVerifyASN1(t *testing.T, c elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestNonceSafety">
            <h2>TestNonceSafety</h2>
            <hr />
            
            <pre><code>func TestNonceSafety(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testNonceSafety">
            <h2>testNonceSafety</h2>
            <hr />
            
            <pre><code>func testNonceSafety(t *testing.T, c elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestINDCCA">
            <h2>TestINDCCA</h2>
            <hr />
            
            <pre><code>func TestINDCCA(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testINDCCA">
            <h2>testINDCCA</h2>
            <hr />
            
            <pre><code>func testINDCCA(t *testing.T, c elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="fromHex">
            <h2>fromHex</h2>
            <hr />
            
            <pre><code>func fromHex(s string) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="TestVectors">
            <h2>TestVectors</h2>
            <hr />
            
            <pre><code>func TestVectors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testVectors">
            <h2>testVectors</h2>
            <hr />
            
            <pre><code>func testVectors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNegativeInputs">
            <h2>TestNegativeInputs</h2>
            <hr />
            
            <pre><code>func TestNegativeInputs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testNegativeInputs">
            <h2>testNegativeInputs</h2>
            <hr />
            
            <pre><code>func testNegativeInputs(t *testing.T, curve elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestZeroHashSignature">
            <h2>TestZeroHashSignature</h2>
            <hr />
            
            <pre><code>func TestZeroHashSignature(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testZeroHashSignature">
            <h2>testZeroHashSignature</h2>
            <hr />
            
            <pre><code>func testZeroHashSignature(t *testing.T, curve elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestZeroSignature">
            <h2>TestZeroSignature</h2>
            <hr />
            
            <pre><code>func TestZeroSignature(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testZeroSignature">
            <h2>testZeroSignature</h2>
            <hr />
            
            <pre><code>func testZeroSignature(t *testing.T, curve elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestNegativeSignature">
            <h2>TestNegativeSignature</h2>
            <hr />
            
            <pre><code>func TestNegativeSignature(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testNegativeSignature">
            <h2>testNegativeSignature</h2>
            <hr />
            
            <pre><code>func testNegativeSignature(t *testing.T, curve elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestRPlusNSignature">
            <h2>TestRPlusNSignature</h2>
            <hr />
            
            <pre><code>func TestRPlusNSignature(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRPlusNSignature">
            <h2>testRPlusNSignature</h2>
            <hr />
            
            <pre><code>func testRPlusNSignature(t *testing.T, curve elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestRMinusNSignature">
            <h2>TestRMinusNSignature</h2>
            <hr />
            
            <pre><code>func TestRMinusNSignature(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRMinusNSignature">
            <h2>testRMinusNSignature</h2>
            <hr />
            
            <pre><code>func testRMinusNSignature(t *testing.T, curve elliptic.Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestRFC6979">
            <h2>TestRFC6979</h2>
            <hr />
            
            <pre><code>func TestRFC6979(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRFC6979">
            <h2>testRFC6979</h2>
            <hr />
            
            <pre><code>func testRFC6979(t *testing.T, curve elliptic.Curve, D string, X string, Y string, msg string, r string, s string)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkAllCurves">
            <h2>benchmarkAllCurves</h2>
            <hr />
            
            <pre><code>func benchmarkAllCurves(b *testing.B, f func)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkSign">
            <h2>BenchmarkSign</h2>
            <hr />
            
            <pre><code>func BenchmarkSign(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkVerify">
            <h2>BenchmarkVerify</h2>
            <hr />
            
            <pre><code>func BenchmarkVerify(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkGenerateKey">
            <h2>BenchmarkGenerateKey</h2>
            <hr />
            
            <pre><code>func BenchmarkGenerateKey(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="boringPublicKey">
            <h2>boringPublicKey</h2>
            <hr />
            
            <pre><code>func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error)</code></pre>
         </article>
         
         <article class="function" data-name="boringPrivateKey">
            <h2>boringPrivateKey</h2>
            <hr />
            
            <pre><code>func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyECDSA, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="boringPublicKey">
            <h2>boringPublicKey</h2>
            <hr />
            
            <pre><code>func boringPublicKey(pub *PublicKey) (*boring.PublicKeyECDSA, error)</code></pre>
         </article>
         
         <article class="function" data-name="boringPrivateKey">
            <h2>boringPrivateKey</h2>
            <hr />
            
            <pre><code>func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyECDSA, error)</code></pre>
         </article>
         
         <article class="function" data-name="publicKeyEqual">
            <h2>publicKeyEqual</h2>
            <hr />
            
            <pre><code>func publicKeyEqual(k1 *PublicKey, k2 *PublicKey) bool</code></pre>
         </article>
         
         <article class="function" data-name="privateKeyEqual">
            <h2>privateKeyEqual</h2>
            <hr />
            
            <pre><code>func privateKeyEqual(k1 *PrivateKey, k2 *PrivateKey) bool</code></pre>
         </article>
         
         <article class="function" data-name="copyPublicKey">
            <h2>copyPublicKey</h2>
            <hr />
            
            <pre><code>func copyPublicKey(k *PublicKey) PublicKey</code></pre>
         </article>
         
         <article class="function" data-name="copyPrivateKey">
            <h2>copyPrivateKey</h2>
            <hr />
            
            <pre><code>func copyPrivateKey(k *PrivateKey) PrivateKey</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
