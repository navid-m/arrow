<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>ecdsa - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>ecdsa</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"crypto/internal/boring"
"crypto/internal/boring/bbig"
"crypto/internal/boring/bcache"
"math/big"
"crypto"
"crypto/ecdh"
"crypto/elliptic"
"crypto/internal/boring"
"crypto/internal/boring/bbig"
"crypto/internal/fips140/ecdsa"
"crypto/internal/fips140hash"
"crypto/internal/fips140only"
"crypto/internal/randutil"
"crypto/sha512"
"crypto/subtle"
"errors"
"io"
"math/big"
"golang.org/x/crypto/cryptobyte"
"golang.org/x/crypto/cryptobyte/asn1"
"crypto/elliptic"
"crypto/internal/fips140only"
"errors"
"io"
"math/big"
"math/rand/v2"
"golang.org/x/crypto/cryptobyte"
"golang.org/x/crypto/cryptobyte/asn1"
"crypto/internal/boring"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="errNoAsm" data-name="errNoAsm">
               <h3>
                  errNoAsm 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoAsm" class="anchor" title="Link to errNoAsm">#</a>
               </h3>
               
                  <p class="doc-comment">errNoAsm is returned by signAsm and verifyAsm when the assembly
implementation is not available.</p>
               
               <pre><code class="language-go">var errNoAsm = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errZeroParam" data-name="errZeroParam">
               <h3>
                  errZeroParam 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errZeroParam" class="anchor" title="Link to errZeroParam">#</a>
               </h3>
               
               <pre><code class="language-go">var errZeroParam = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="one" data-name="one">
               <h3>
                  one 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#one" class="anchor" title="Link to one">#</a>
               </h3>
               
               <pre><code class="language-go">var one = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="privCache" data-name="privCache">
               <h3>
                  privCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#privCache" class="anchor" title="Link to privCache">#</a>
               </h3>
               
               <pre><code class="language-go">var privCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pubCache" data-name="pubCache">
               <h3>
                  pubCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pubCache" class="anchor" title="Link to pubCache">#</a>
               </h3>
               
               <pre><code class="language-go">var pubCache *ast.IndexListExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="PrivateKey" data-name="PrivateKey">
               <h3>
                  PrivateKey
                  <span class="badge">struct</span>
                  <a href="#PrivateKey" class="anchor" title="Link to PrivateKey">#</a>
               </h3>
               
               <p>PrivateKey represents an ECDSA private key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PrivateKey struct {
PublicKey
D *big.Int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PublicKey" data-name="PublicKey">
               <h3>
                  PublicKey
                  <span class="badge">struct</span>
                  <a href="#PublicKey" class="anchor" title="Link to PublicKey">#</a>
               </h3>
               
               <p>PublicKey represents an ECDSA public key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PublicKey struct {
elliptic.Curve
X *big.Int
Y *big.Int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="boringPriv" data-name="boringPriv">
               <h3>
                  boringPriv
                  <span class="badge">struct</span>
                  <a href="#boringPriv" class="anchor" title="Link to boringPriv">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type boringPriv struct {
key *boring.PrivateKeyECDSA
orig PrivateKey
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="boringPub" data-name="boringPub">
               <h3>
                  boringPub
                  <span class="badge">struct</span>
                  <a href="#boringPub" class="anchor" title="Link to boringPub">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type boringPub struct {
key *boring.PublicKeyECDSA
orig PublicKey
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ECDH" data-name="ECDH">
               <h3>
                  ECDH 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ECDH" class="anchor" title="Link to ECDH">#</a>
               </h3>
               
               <p>ECDH returns k as a [ecdh.PrivateKey]. It returns an error if the key is
invalid according to the definition of [ecdh.Curve.NewPrivateKey], or if the
Curve is not supported by [crypto/ecdh].</p>
               
               <pre><code class="language-go">func (k *PrivateKey) ECDH() (*ecdh.PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ECDH" data-name="ECDH">
               <h3>
                  ECDH 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ECDH" class="anchor" title="Link to ECDH">#</a>
               </h3>
               
               <p>ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is
invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the
Curve is not supported by crypto/ecdh.</p>
               
               <pre><code class="language-go">func (k *PublicKey) ECDH() (*ecdh.PublicKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether priv and x have the same value.
See [PublicKey.Equal] for details on how Curve is compared.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether pub and x have the same value.
Two keys are only considered to have the same value if they have the same Curve value.
Note that for example [elliptic.P256] and elliptic.P256().Params() are different
values, as the latter is a generic not constant time implementation.</p>
               
               <pre><code class="language-go">func (pub *PublicKey) Equal(x crypto.PublicKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GenerateKey" data-name="GenerateKey">
               <h3>
                  GenerateKey 
                  <span class="badge">function</span>
                  
                  <a href="#GenerateKey" class="anchor" title="Link to GenerateKey">#</a>
               </h3>
               
               <p>GenerateKey generates a new ECDSA private key for the specified curve.
Most applications should use [crypto/rand.Reader] as rand. Note that the
returned key does not depend deterministically on the bytes read from rand,
and may change between calls and/or between versions.</p>
               
               <pre><code class="language-go">func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Public" data-name="Public">
               <h3>
                  Public 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Public" class="anchor" title="Link to Public">#</a>
               </h3>
               
               <p>Public returns the public key corresponding to priv.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Public() crypto.PublicKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sign" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge">function</span>
                  
                  <a href="#Sign" class="anchor" title="Link to Sign">#</a>
               </h3>
               
               <p>Sign signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key's curve order, the hash will be truncated to that length. It
returns the signature as a pair of integers. Most applications should use
[SignASN1] instead of dealing directly with r, s.</p>
               
               <pre><code class="language-go">func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r *big.Int, s *big.Int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sign" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sign" class="anchor" title="Link to Sign">#</a>
               </h3>
               
               <p>Sign signs a hash (which should be the result of hashing a larger message
with opts.HashFunc()) using the private key, priv. If the hash is longer than
the bit-length of the private key's curve order, the hash will be truncated
to that length. It returns the ASN.1 encoded signature, like [SignASN1].
If rand is not nil, the signature is randomized. Most applications should use
[crypto/rand.Reader] as rand. Note that the returned signature does not
depend deterministically on the bytes read from rand, and may change between
calls and/or between versions.
If rand is nil, Sign will produce a deterministic signature according to RFC
6979. When producing a deterministic signature, opts.HashFunc() must be the
function used to produce digest and priv.Curve must be one of
[elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521].</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SignASN1" data-name="SignASN1">
               <h3>
                  SignASN1 
                  <span class="badge">function</span>
                  
                  <a href="#SignASN1" class="anchor" title="Link to SignASN1">#</a>
               </h3>
               
               <p>SignASN1 signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key's curve order, the hash will be truncated to that length. It
returns the ASN.1 encoded signature.
The signature is randomized. Most applications should use [crypto/rand.Reader]
as rand. Note that the returned signature does not depend deterministically on
the bytes read from rand, and may change between calls and/or between versions.</p>
               
               <pre><code class="language-go">func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Verify" data-name="Verify">
               <h3>
                  Verify 
                  <span class="badge">function</span>
                  
                  <a href="#Verify" class="anchor" title="Link to Verify">#</a>
               </h3>
               
               <p>Verify verifies the signature in r, s of hash using the public key, pub. Its
return value records whether the signature is valid. Most applications should
use VerifyASN1 instead of dealing directly with r, s.
The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
               
               <pre><code class="language-go">func Verify(pub *PublicKey, hash []byte, r *big.Int, s *big.Int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VerifyASN1" data-name="VerifyASN1">
               <h3>
                  VerifyASN1 
                  <span class="badge">function</span>
                  
                  <a href="#VerifyASN1" class="anchor" title="Link to VerifyASN1">#</a>
               </h3>
               
               <p>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
public key, pub. Its return value records whether the signature is valid.
The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
               
               <pre><code class="language-go">func VerifyASN1(pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addASN1IntBytes" data-name="addASN1IntBytes">
               <h3>
                  addASN1IntBytes 
                  <span class="badge">function</span>
                  
                  <a href="#addASN1IntBytes" class="anchor" title="Link to addASN1IntBytes">#</a>
               </h3>
               
               <p>addASN1IntBytes encodes in ASN.1 a positive integer represented as
a big-endian byte slice with zero or more leading zeroes.</p>
               
               <pre><code class="language-go">func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bigIntEqual" data-name="bigIntEqual">
               <h3>
                  bigIntEqual 
                  <span class="badge">function</span>
                  
                  <a href="#bigIntEqual" class="anchor" title="Link to bigIntEqual">#</a>
               </h3>
               
               <p>bigIntEqual reports whether a and b are equal leaking only their bit length
through timing side-channels.</p>
               
               <pre><code class="language-go">func bigIntEqual(a *big.Int, b *big.Int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPrivateKey" data-name="boringPrivateKey">
               <h3>
                  boringPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPrivateKey" class="anchor" title="Link to boringPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPrivateKey" data-name="boringPrivateKey">
               <h3>
                  boringPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPrivateKey" class="anchor" title="Link to boringPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPublicKey" data-name="boringPublicKey">
               <h3>
                  boringPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPublicKey" class="anchor" title="Link to boringPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPublicKey" data-name="boringPublicKey">
               <h3>
                  boringPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPublicKey" class="anchor" title="Link to boringPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPublicKey(pub *PublicKey) (*boring.PublicKeyECDSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyPrivateKey" data-name="copyPrivateKey">
               <h3>
                  copyPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#copyPrivateKey" class="anchor" title="Link to copyPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func copyPrivateKey(k *PrivateKey) PrivateKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyPublicKey" data-name="copyPublicKey">
               <h3>
                  copyPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#copyPublicKey" class="anchor" title="Link to copyPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func copyPublicKey(k *PublicKey) PublicKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="curveToECDH" data-name="curveToECDH">
               <h3>
                  curveToECDH 
                  <span class="badge">function</span>
                  
                  <a href="#curveToECDH" class="anchor" title="Link to curveToECDH">#</a>
               </h3>
               
               <pre><code class="language-go">func curveToECDH(c elliptic.Curve) ecdh.Curve</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeSignature" data-name="encodeSignature">
               <h3>
                  encodeSignature 
                  <span class="badge">function</span>
                  
                  <a href="#encodeSignature" class="anchor" title="Link to encodeSignature">#</a>
               </h3>
               
               <pre><code class="language-go">func encodeSignature(r []byte, s []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generateFIPS" data-name="generateFIPS">
               <h3>
                  generateFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#generateFIPS" class="anchor" title="Link to generateFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func generateFIPS(curve elliptic.Curve, c **ast.IndexExpr, rand io.Reader) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generateLegacy" data-name="generateLegacy">
               <h3>
                  generateLegacy 
                  <span class="badge">function</span>
                  
                  <a href="#generateLegacy" class="anchor" title="Link to generateLegacy">#</a>
               </h3>
               
               <pre><code class="language-go">func generateLegacy(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashToInt" data-name="hashToInt">
               <h3>
                  hashToInt 
                  <span class="badge">function</span>
                  
                  <a href="#hashToInt" class="anchor" title="Link to hashToInt">#</a>
               </h3>
               
               <p>hashToInt converts a hash value to an integer. Per FIPS 186-4, Section 6.4,
we use the left-most bits of the hash to match the bit-length of the order of
the curve. This also performs Step 5 of SEC 1, Version 2.0, Section 4.1.3.</p>
               
               <pre><code class="language-go">func hashToInt(hash []byte, c elliptic.Curve) *big.Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSignature" data-name="parseSignature">
               <h3>
                  parseSignature 
                  <span class="badge">function</span>
                  
                  <a href="#parseSignature" class="anchor" title="Link to parseSignature">#</a>
               </h3>
               
               <pre><code class="language-go">func parseSignature(sig []byte) (r []byte, s []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointFromAffine" data-name="pointFromAffine">
               <h3>
                  pointFromAffine 
                  <span class="badge">function</span>
                  
                  <a href="#pointFromAffine" class="anchor" title="Link to pointFromAffine">#</a>
               </h3>
               
               <p>pointFromAffine is used to convert the PublicKey to a nistec SetBytes input.</p>
               
               <pre><code class="language-go">func pointFromAffine(curve elliptic.Curve, x *big.Int, y *big.Int) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointToAffine" data-name="pointToAffine">
               <h3>
                  pointToAffine 
                  <span class="badge">function</span>
                  
                  <a href="#pointToAffine" class="anchor" title="Link to pointToAffine">#</a>
               </h3>
               
               <p>pointToAffine is used to convert a nistec Bytes encoding to a PublicKey.</p>
               
               <pre><code class="language-go">func pointToAffine(curve elliptic.Curve, p []byte) (x *big.Int, y *big.Int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="privateKeyEqual" data-name="privateKeyEqual">
               <h3>
                  privateKeyEqual 
                  <span class="badge">function</span>
                  
                  <a href="#privateKeyEqual" class="anchor" title="Link to privateKeyEqual">#</a>
               </h3>
               
               <pre><code class="language-go">func privateKeyEqual(k1 *PrivateKey, k2 *PrivateKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="privateKeyFromFIPS" data-name="privateKeyFromFIPS">
               <h3>
                  privateKeyFromFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#privateKeyFromFIPS" class="anchor" title="Link to privateKeyFromFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func privateKeyFromFIPS(curve elliptic.Curve, priv *ecdsa.PrivateKey) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="privateKeyToFIPS" data-name="privateKeyToFIPS">
               <h3>
                  privateKeyToFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#privateKeyToFIPS" class="anchor" title="Link to privateKeyToFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func privateKeyToFIPS(c **ast.IndexExpr, priv *PrivateKey) (*ecdsa.PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="publicKeyEqual" data-name="publicKeyEqual">
               <h3>
                  publicKeyEqual 
                  <span class="badge">function</span>
                  
                  <a href="#publicKeyEqual" class="anchor" title="Link to publicKeyEqual">#</a>
               </h3>
               
               <pre><code class="language-go">func publicKeyEqual(k1 *PublicKey, k2 *PublicKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="publicKeyFromFIPS" data-name="publicKeyFromFIPS">
               <h3>
                  publicKeyFromFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#publicKeyFromFIPS" class="anchor" title="Link to publicKeyFromFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func publicKeyFromFIPS(curve elliptic.Curve, pub *ecdsa.PublicKey) (*PublicKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="publicKeyToFIPS" data-name="publicKeyToFIPS">
               <h3>
                  publicKeyToFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#publicKeyToFIPS" class="anchor" title="Link to publicKeyToFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func publicKeyToFIPS(c **ast.IndexExpr, pub *PublicKey) (*ecdsa.PublicKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="randFieldElement" data-name="randFieldElement">
               <h3>
                  randFieldElement 
                  <span class="badge">function</span>
                  
                  <a href="#randFieldElement" class="anchor" title="Link to randFieldElement">#</a>
               </h3>
               
               <p>randFieldElement returns a random element of the order of the given
curve using the procedure given in FIPS 186-4, Appendix B.5.2.</p>
               
               <pre><code class="language-go">func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signFIPS" data-name="signFIPS">
               <h3>
                  signFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#signFIPS" class="anchor" title="Link to signFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func signFIPS(c **ast.IndexExpr, priv *PrivateKey, rand io.Reader, hash []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signFIPSDeterministic" data-name="signFIPSDeterministic">
               <h3>
                  signFIPSDeterministic 
                  <span class="badge">function</span>
                  
                  <a href="#signFIPSDeterministic" class="anchor" title="Link to signFIPSDeterministic">#</a>
               </h3>
               
               <pre><code class="language-go">func signFIPSDeterministic(c **ast.IndexExpr, hashFunc crypto.Hash, priv *PrivateKey, hash []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signLegacy" data-name="signLegacy">
               <h3>
                  signLegacy 
                  <span class="badge">function</span>
                  
                  <a href="#signLegacy" class="anchor" title="Link to signLegacy">#</a>
               </h3>
               
               <pre><code class="language-go">func signLegacy(priv *PrivateKey, csprng io.Reader, hash []byte) (sig []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signRFC6979" data-name="signRFC6979">
               <h3>
                  signRFC6979 
                  <span class="badge">function</span>
                  
                  <a href="#signRFC6979" class="anchor" title="Link to signRFC6979">#</a>
               </h3>
               
               <pre><code class="language-go">func signRFC6979(priv *PrivateKey, hash []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verifyFIPS" data-name="verifyFIPS">
               <h3>
                  verifyFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#verifyFIPS" class="anchor" title="Link to verifyFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">func verifyFIPS(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verifyLegacy" data-name="verifyLegacy">
               <h3>
                  verifyLegacy 
                  <span class="badge">function</span>
                  
                  <a href="#verifyLegacy" class="anchor" title="Link to verifyLegacy">#</a>
               </h3>
               
               <pre><code class="language-go">func verifyLegacy(pub *PublicKey, hash []byte, sig []byte) bool</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>