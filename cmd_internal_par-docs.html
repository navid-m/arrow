<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - par</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>par</code>
         </h1>
         <hr />
         
         <article class="global" data-name="ErrCacheEntryNotFound">
            <h2>ErrCacheEntryNotFound</h2>
            <hr />
            
            <pre><code>ErrCacheEntryNotFound</code></pre>
         </article>
          
         <article class="struct" data-name="Queue">
            <h2>type Queue struct</h2>
            <hr />
            
            <p>Queue manages a set of work items to be executed in parallel. The number of
active work items is limited, and excess items are queued sequentially.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">maxActive int
st *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="queueState">
            <h2>type queueState struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">active int
backlog []func
idle *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="Work">
            <h2>type Work struct</h2>
            <hr />
            
            <p>Work manages a set of work items to be executed in parallel, at most once each.
The items in the set must all be valid map keys.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">f func
running int
mu sync.Mutex
added *ast.MapType
todo []T
wait sync.Cond
waiting int</code></pre>
         </article>
         
         <article class="struct" data-name="ErrCache">
            <h2>type ErrCache struct</h2>
            <hr />
            
            <p>ErrCache is like Cache except that it also stores
an error value alongside the cached value V.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*ast.IndexListExpr</code></pre>
         </article>
         
         <article class="struct" data-name="errValue">
            <h2>type errValue struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">v V
err error</code></pre>
         </article>
         
         <article class="struct" data-name="Cache">
            <h2>type Cache struct</h2>
            <hr />
            
            <p>Cache runs an action once per key and caches the result.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">m sync.Map</code></pre>
         </article>
         
         <article class="struct" data-name="cacheEntry">
            <h2>type cacheEntry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">done atomic.Bool
mu sync.Mutex
result V</code></pre>
         </article>
          
         <article class="function" data-name="TestWork">
            <h2>TestWork</h2>
            <hr />
            
            <pre><code>func TestWork(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWorkParallel">
            <h2>TestWorkParallel</h2>
            <hr />
            
            <pre><code>func TestWorkParallel(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCache">
            <h2>TestCache</h2>
            <hr />
            
            <pre><code>func TestCache(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="NewQueue">
            <h2>NewQueue</h2>
            <hr />
            
            <p>NewQueue returns a Queue that executes up to maxActive items in parallel.

maxActive must be positive.</p>
            
            <pre><code>func NewQueue(maxActive int) *Queue</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds f as a work item in the queue.

Add returns immediately, but the queue will be marked as non-idle until after
f (and any subsequently-added work) has completed.</p>
            
            <pre><code>func Add(f func)</code></pre>
         </article>
         
         <article class="function" data-name="Idle">
            <h2>Idle</h2>
            <hr />
            
            <p>Idle returns a channel that will be closed when q has no (active or enqueued)
work outstanding.</p>
            
            <pre><code>func Idle() *ast.ChanType</code></pre>
         </article>
         
         <article class="function" data-name="TestQueueIdle">
            <h2>TestQueueIdle</h2>
            <hr />
            
            <pre><code>func TestQueueIdle(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestQueueBacklog">
            <h2>TestQueueBacklog</h2>
            <hr />
            
            <pre><code>func TestQueueBacklog(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds item to the work set, if it hasn't already been added.</p>
            
            <pre><code>func Add(item T)</code></pre>
         </article>
         
         <article class="function" data-name="Do">
            <h2>Do</h2>
            <hr />
            
            <p>Do runs f in parallel on items from the work set,
with at most n invocations of f running at a time.
It returns when everything added to the work set has been processed.
At least one item should have been added to the work set
before calling Do (or else Do returns immediately),
but it is allowed for f(item) to add new items to the set.
Do should only be used once on a given Work.</p>
            
            <pre><code>func Do(n int, f func)</code></pre>
         </article>
         
         <article class="function" data-name="runner">
            <h2>runner</h2>
            <hr />
            
            <p>runner executes work in w until both nothing is left to do
and all the runners are waiting for work.
(Then all the runners return.)</p>
            
            <pre><code>func runner()</code></pre>
         </article>
         
         <article class="function" data-name="Do">
            <h2>Do</h2>
            <hr />
            
            <pre><code>func Do(key K, f func) (V, error)</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <p>Get returns the cached result associated with key.
It returns ErrCacheEntryNotFound if there is no such result.</p>
            
            <pre><code>func Get(key K) (V, error)</code></pre>
         </article>
         
         <article class="function" data-name="Do">
            <h2>Do</h2>
            <hr />
            
            <p>Do calls the function f if and only if Do is being called for the first time with this key.
No call to Do with a given key returns until the one call to f returns.
Do returns the value returned by the one call to f.</p>
            
            <pre><code>func Do(key K, f func) V</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <p>Get returns the cached result associated with key
and reports whether there is such a result.

If the result for key is being computed, Get does not wait for the computation to finish.</p>
            
            <pre><code>func Get(key K) (V, bool)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
