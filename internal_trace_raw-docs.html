<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - raw</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>raw</code>
         </h1>
         <hr />
         
         <article class="global" data-name="frameFields">
            <h2>frameFields</h2>
            <hr />
            
            <pre><code>frameFields</code></pre>
         </article>
          
         <article class="struct" data-name="TextReader">
            <h2>type TextReader struct</h2>
            <hr />
            
            <p>TextReader parses a text format trace with only very basic validation
into an event stream.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">v version.Version
specs []event.Spec
names *ast.MapType
s *bufio.Scanner</code></pre>
         </article>
         
         <article class="struct" data-name="TextWriter">
            <h2>type TextWriter struct</h2>
            <hr />
            
            <p>TextWriter emits the text format of a trace.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer
v version.Version</code></pre>
         </article>
         
         <article class="struct" data-name="Writer">
            <h2>type Writer struct</h2>
            <hr />
            
            <p>Writer emits the wire format of a trace.

It may not produce a byte-for-byte compatible trace from what is
produced by the runtime, because it may be missing extra padding
in the LEB128 encoding that the runtime adds but isn't necessary
when you know the data up-front.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer
buf []byte
v version.Version
specs []event.Spec</code></pre>
         </article>
         
         <article class="struct" data-name="Event">
            <h2>type Event struct</h2>
            <hr />
            
            <p>Event is a simple representation of a trace event.

Note that this typically includes much more than just
timestamped events, and it also represents parts of the
trace format's framing. (But not interpreted.)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Version version.Version
Ev event.Type
Args []uint64
Data []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Reader">
            <h2>type Reader struct</h2>
            <hr />
            
            <p>Reader parses trace bytes with only very basic validation
into an event stream.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r *bufio.Reader
v version.Version
specs []event.Spec</code></pre>
         </article>
          
         <article class="function" data-name="NewTextReader">
            <h2>NewTextReader</h2>
            <hr />
            
            <p>NewTextReader creates a new reader for the trace text format.</p>
            
            <pre><code>func NewTextReader(r io.Reader) (*TextReader, error)</code></pre>
         </article>
         
         <article class="function" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version returns the version of the trace that we're reading.</p>
            
            <pre><code>func Version() version.Version</code></pre>
         </article>
         
         <article class="function" data-name="ReadEvent">
            <h2>ReadEvent</h2>
            <hr />
            
            <p>ReadEvent reads and returns the next trace event in the text stream.</p>
            
            <pre><code>func ReadEvent() (Event, error)</code></pre>
         </article>
         
         <article class="function" data-name="nextLine">
            <h2>nextLine</h2>
            <hr />
            
            <pre><code>func nextLine() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readArgs">
            <h2>readArgs</h2>
            <hr />
            
            <pre><code>func readArgs(s string, names []string) ([]uint64, error)</code></pre>
         </article>
         
         <article class="function" data-name="readArg">
            <h2>readArg</h2>
            <hr />
            
            <pre><code>func readArg(s string) (arg string, value uint64, rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readToken">
            <h2>readToken</h2>
            <hr />
            
            <pre><code>func readToken(s string) (token string, rest string)</code></pre>
         </article>
         
         <article class="function" data-name="readData">
            <h2>readData</h2>
            <hr />
            
            <pre><code>func readData(line string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewTextWriter">
            <h2>NewTextWriter</h2>
            <hr />
            
            <p>NewTextWriter creates a new write for the trace text format.</p>
            
            <pre><code>func NewTextWriter(w io.Writer, v version.Version) (*TextWriter, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteEvent">
            <h2>WriteEvent</h2>
            <hr />
            
            <p>WriteEvent writes a single event to the stream.</p>
            
            <pre><code>func WriteEvent(e Event) error</code></pre>
         </article>
         
         <article class="function" data-name="NewWriter">
            <h2>NewWriter</h2>
            <hr />
            
            <p>NewWriter creates a new byte format writer.</p>
            
            <pre><code>func NewWriter(w io.Writer, v version.Version) (*Writer, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteEvent">
            <h2>WriteEvent</h2>
            <hr />
            
            <p>WriteEvent writes a single event to the trace wire format stream.</p>
            
            <pre><code>func WriteEvent(e Event) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the canonical string representation of the event.

This format is the same format that is parsed by the TextReader
and emitted by the TextWriter.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="EncodedSize">
            <h2>EncodedSize</h2>
            <hr />
            
            <p>EncodedSize returns the canonical encoded size of an event.</p>
            
            <pre><code>func EncodedSize() int</code></pre>
         </article>
         
         <article class="function" data-name="NewReader">
            <h2>NewReader</h2>
            <hr />
            
            <p>NewReader creates a new reader for the trace wire format.</p>
            
            <pre><code>func NewReader(r io.Reader) (*Reader, error)</code></pre>
         </article>
         
         <article class="function" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <p>Version returns the version of the trace that we're reading.</p>
            
            <pre><code>func Version() version.Version</code></pre>
         </article>
         
         <article class="function" data-name="ReadEvent">
            <h2>ReadEvent</h2>
            <hr />
            
            <p>ReadEvent reads and returns the next trace event in the byte stream.</p>
            
            <pre><code>func ReadEvent() (Event, error)</code></pre>
         </article>
         
         <article class="function" data-name="readArgs">
            <h2>readArgs</h2>
            <hr />
            
            <pre><code>func readArgs(n int) ([]uint64, error)</code></pre>
         </article>
         
         <article class="function" data-name="readData">
            <h2>readData</h2>
            <hr />
            
            <pre><code>func readData() ([]byte, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
