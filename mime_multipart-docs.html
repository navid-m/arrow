<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - multipart</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>multipart</code>
         </h1>
         <hr />
         
         <article class="global" data-name="quoteEscaper">
            <h2>quoteEscaper</h2>
            <hr />
            
            <pre><code>quoteEscaper</code></pre>
         </article>
         
         <article class="global" data-name="ErrMessageTooLarge">
            <h2>ErrMessageTooLarge</h2>
            <hr />
            
            <p>ErrMessageTooLarge is returned by ReadForm if the message form
data is too large to be processed.</p>
            
            <pre><code>ErrMessageTooLarge</code></pre>
         </article>
         
         <article class="global" data-name="multipartfiles">
            <h2>multipartfiles</h2>
            <hr />
            
            <pre><code>multipartfiles</code></pre>
         </article>
         
         <article class="global" data-name="multipartmaxparts">
            <h2>multipartmaxparts</h2>
            <hr />
            
            <pre><code>multipartmaxparts</code></pre>
         </article>
         
         <article class="global" data-name="fileaContents">
            <h2>fileaContents</h2>
            <hr />
            
            <pre><code>fileaContents</code></pre>
         </article>
         
         <article class="global" data-name="filebContents">
            <h2>filebContents</h2>
            <hr />
            
            <pre><code>filebContents</code></pre>
         </article>
         
         <article class="global" data-name="textaValue">
            <h2>textaValue</h2>
            <hr />
            
            <pre><code>textaValue</code></pre>
         </article>
         
         <article class="global" data-name="textbValue">
            <h2>textbValue</h2>
            <hr />
            
            <pre><code>textbValue</code></pre>
         </article>
         
         <article class="global" data-name="boundary">
            <h2>boundary</h2>
            <hr />
            
            <pre><code>boundary</code></pre>
         </article>
         
         <article class="global" data-name="messageWithFileWithoutName">
            <h2>messageWithFileWithoutName</h2>
            <hr />
            
            <pre><code>messageWithFileWithoutName</code></pre>
         </article>
         
         <article class="global" data-name="messageWithFileName">
            <h2>messageWithFileName</h2>
            <hr />
            
            <pre><code>messageWithFileName</code></pre>
         </article>
         
         <article class="global" data-name="messageWithTextContentType">
            <h2>messageWithTextContentType</h2>
            <hr />
            
            <pre><code>messageWithTextContentType</code></pre>
         </article>
         
         <article class="global" data-name="message">
            <h2>message</h2>
            <hr />
            
            <pre><code>message</code></pre>
         </article>
         
         <article class="global" data-name="emptyParams">
            <h2>emptyParams</h2>
            <hr />
            
            <pre><code>emptyParams</code></pre>
         </article>
         
         <article class="global" data-name="peekBufferSize">
            <h2>peekBufferSize</h2>
            <hr />
            
            <p>This constant needs to be at least 76 for this package to work correctly.
This is because \r\n--separator_of_len_70- would fill the buffer and it
wouldn't be safe to consume a single byte from it.</p>
            
            <pre><code>peekBufferSize</code></pre>
         </article>
         
         <article class="global" data-name="maxMIMEHeaderSize">
            <h2>maxMIMEHeaderSize</h2>
            <hr />
            
            <p>maxMIMEHeaderSize is the maximum size of a MIME header we will parse,
including header keys, values, and map overhead.</p>
            
            <pre><code>maxMIMEHeaderSize</code></pre>
         </article>
         
         <article class="global" data-name="multipartmaxheaders">
            <h2>multipartmaxheaders</h2>
            <hr />
            
            <p>multipartmaxheaders is the maximum number of header entries NextPart will return,
as well as the maximum combined total of header entries Reader.ReadForm will return
in FileHeaders.</p>
            
            <pre><code>multipartmaxheaders</code></pre>
         </article>
         
         <article class="global" data-name="longLine">
            <h2>longLine</h2>
            <hr />
            
            <pre><code>longLine</code></pre>
         </article>
         
         <article class="global" data-name="maxReadThreshold">
            <h2>maxReadThreshold</h2>
            <hr />
            
            <pre><code>maxReadThreshold</code></pre>
         </article>
         
         <article class="global" data-name="parseTests">
            <h2>parseTests</h2>
            <hr />
            
            <pre><code>parseTests</code></pre>
         </article>
          
         <article class="struct" data-name="Writer">
            <h2>type Writer struct</h2>
            <hr />
            
            <p>A Writer generates multipart messages.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer
boundary string
lastpart *part</code></pre>
         </article>
         
         <article class="struct" data-name="part">
            <h2>type part struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mw *Writer
closed bool
we error</code></pre>
         </article>
         
         <article class="struct" data-name="Form">
            <h2>type Form struct</h2>
            <hr />
            
            <p>Form is a parsed multipart form.
Its File parts are stored either in memory or on disk,
and are accessible via the [*FileHeader]'s Open method.
Its Value parts are stored as strings.
Both are keyed by field name.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Value *ast.MapType
File *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="FileHeader">
            <h2>type FileHeader struct</h2>
            <hr />
            
            <p>A FileHeader describes a file part of a multipart request.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Filename string
Header textproto.MIMEHeader
Size int64
content []byte
tmpfile string
tmpoff int64
tmpshared bool</code></pre>
         </article>
         
         <article class="struct" data-name="sectionReadCloser">
            <h2>type sectionReadCloser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*io.SectionReader
io.Closer</code></pre>
         </article>
         
         <article class="struct" data-name="failOnReadAfterErrorReader">
            <h2>type failOnReadAfterErrorReader struct</h2>
            <hr />
            
            <p>failOnReadAfterErrorReader is an io.Reader wrapping r.
It fails t if any Read is called after a failing Read.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">t *testing.T
r io.Reader
sawErr error</code></pre>
         </article>
         
         <article class="struct" data-name="Part">
            <h2>type Part struct</h2>
            <hr />
            
            <p>A Part represents a single part in a multipart body.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Header textproto.MIMEHeader
mr *Reader
disposition string
dispositionParams *ast.MapType
r io.Reader
n int
total int64
err error
readErr error</code></pre>
         </article>
         
         <article class="struct" data-name="stickyErrorReader">
            <h2>type stickyErrorReader struct</h2>
            <hr />
            
            <p>stickyErrorReader is an io.Reader which never calls Read on its
underlying Reader once an error has been seen. (the io.Reader
interface's contract promises nothing about the return values of
Read calls after an error, yet this package does do multiple Reads
after error)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader
err error</code></pre>
         </article>
         
         <article class="struct" data-name="partReader">
            <h2>type partReader struct</h2>
            <hr />
            
            <p>partReader implements io.Reader by reading raw bytes directly from the
wrapped *Part, without doing any Transfer-Encoding decoding.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *Part</code></pre>
         </article>
         
         <article class="struct" data-name="Reader">
            <h2>type Reader struct</h2>
            <hr />
            
            <p>Reader is an iterator over parts in a MIME multipart body.
Reader's underlying parser consumes its input as needed. Seeking
isn't supported.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">bufReader *bufio.Reader
tempDir string
currentPart *Part
partsRead int
nl []byte
nlDashBoundary []byte
dashBoundaryDash []byte
dashBoundary []byte</code></pre>
         </article>
         
         <article class="struct" data-name="maliciousReader">
            <h2>type maliciousReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">t *testing.T
n int</code></pre>
         </article>
         
         <article class="struct" data-name="slowReader">
            <h2>type slowReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="sentinelReader">
            <h2>type sentinelReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">done *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="headerBody">
            <h2>type headerBody struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">header textproto.MIMEHeader
body string</code></pre>
         </article>
         
         <article class="struct" data-name="parseTest">
            <h2>type parseTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
in string
sep string
want []headerBody</code></pre>
         </article>
          
         <article class="function" data-name="readMIMEHeader">
            <h2>readMIMEHeader</h2>
            <hr />
            
            <p>readMIMEHeader is defined in package [net/textproto].</p>
            
            <pre><code>func readMIMEHeader(r *textproto.Reader, maxMemory int64, maxHeaders int64) (textproto.MIMEHeader, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewWriter">
            <h2>NewWriter</h2>
            <hr />
            
            <p>NewWriter returns a new multipart [Writer] with a random boundary,
writing to w.</p>
            
            <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
         </article>
         
         <article class="function" data-name="Boundary">
            <h2>Boundary</h2>
            <hr />
            
            <p>Boundary returns the [Writer]'s boundary.</p>
            
            <pre><code>func Boundary() string</code></pre>
         </article>
         
         <article class="function" data-name="SetBoundary">
            <h2>SetBoundary</h2>
            <hr />
            
            <p>SetBoundary overrides the [Writer]'s default randomly-generated
boundary separator with an explicit value.

SetBoundary must be called before any parts are created, may only
contain certain ASCII characters, and must be non-empty and
at most 70 bytes long.</p>
            
            <pre><code>func SetBoundary(boundary string) error</code></pre>
         </article>
         
         <article class="function" data-name="FormDataContentType">
            <h2>FormDataContentType</h2>
            <hr />
            
            <p>FormDataContentType returns the Content-Type for an HTTP
multipart/form-data with this [Writer]'s Boundary.</p>
            
            <pre><code>func FormDataContentType() string</code></pre>
         </article>
         
         <article class="function" data-name="randomBoundary">
            <h2>randomBoundary</h2>
            <hr />
            
            <pre><code>func randomBoundary() string</code></pre>
         </article>
         
         <article class="function" data-name="CreatePart">
            <h2>CreatePart</h2>
            <hr />
            
            <p>CreatePart creates a new multipart section with the provided
header. The body of the part should be written to the returned
[Writer]. After calling CreatePart, any previous part may no longer
be written to.</p>
            
            <pre><code>func CreatePart(header textproto.MIMEHeader) (io.Writer, error)</code></pre>
         </article>
         
         <article class="function" data-name="escapeQuotes">
            <h2>escapeQuotes</h2>
            <hr />
            
            <pre><code>func escapeQuotes(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="CreateFormFile">
            <h2>CreateFormFile</h2>
            <hr />
            
            <p>CreateFormFile is a convenience wrapper around [Writer.CreatePart]. It creates
a new form-data header with the provided field name and file name.</p>
            
            <pre><code>func CreateFormFile(fieldname string, filename string) (io.Writer, error)</code></pre>
         </article>
         
         <article class="function" data-name="CreateFormField">
            <h2>CreateFormField</h2>
            <hr />
            
            <p>CreateFormField calls [Writer.CreatePart] with a header using the
given field name.</p>
            
            <pre><code>func CreateFormField(fieldname string) (io.Writer, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteField">
            <h2>WriteField</h2>
            <hr />
            
            <p>WriteField calls [Writer.CreateFormField] and then writes the given value.</p>
            
            <pre><code>func WriteField(fieldname string, value string) error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close finishes the multipart message and writes the trailing
boundary end line to the output.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close() error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(d []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriter">
            <h2>TestWriter</h2>
            <hr />
            
            <pre><code>func TestWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterSetBoundary">
            <h2>TestWriterSetBoundary</h2>
            <hr />
            
            <pre><code>func TestWriterSetBoundary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterBoundaryGoroutines">
            <h2>TestWriterBoundaryGoroutines</h2>
            <hr />
            
            <pre><code>func TestWriterBoundaryGoroutines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSortedHeader">
            <h2>TestSortedHeader</h2>
            <hr />
            
            <pre><code>func TestSortedHeader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="ReadForm">
            <h2>ReadForm</h2>
            <hr />
            
            <p>ReadForm parses an entire multipart message whose parts have
a Content-Disposition of "form-data".
It stores up to maxMemory bytes + 10MB (reserved for non-file parts)
in memory. File parts which can't be stored in memory will be stored on
disk in temporary files.
It returns [ErrMessageTooLarge] if all non-file parts can't be stored in
memory.</p>
            
            <pre><code>func ReadForm(maxMemory int64) (*Form, error)</code></pre>
         </article>
         
         <article class="function" data-name="readForm">
            <h2>readForm</h2>
            <hr />
            
            <pre><code>func readForm(maxMemory int64) (_ *Form, err error)</code></pre>
         </article>
         
         <article class="function" data-name="mimeHeaderSize">
            <h2>mimeHeaderSize</h2>
            <hr />
            
            <pre><code>func mimeHeaderSize(h textproto.MIMEHeader) size int64</code></pre>
         </article>
         
         <article class="function" data-name="RemoveAll">
            <h2>RemoveAll</h2>
            <hr />
            
            <p>RemoveAll removes any temporary files associated with a [Form].</p>
            
            <pre><code>func RemoveAll() error</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <p>Open opens and returns the [FileHeader]'s associated File.</p>
            
            <pre><code>func Open() (File, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="TestReadForm">
            <h2>TestReadForm</h2>
            <hr />
            
            <pre><code>func TestReadForm(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFormWithNamelessFile">
            <h2>TestReadFormWithNamelessFile</h2>
            <hr />
            
            <pre><code>func TestReadFormWithNamelessFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFormWitFileNameMaxMemoryOverflow">
            <h2>TestReadFormWitFileNameMaxMemoryOverflow</h2>
            <hr />
            
            <p>Issue 58384: Handle ReadForm(math.MaxInt64)</p>
            
            <pre><code>func TestReadFormWitFileNameMaxMemoryOverflow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFormMaxMemoryOverflow">
            <h2>TestReadFormMaxMemoryOverflow</h2>
            <hr />
            
            <p>Issue 40430: Handle ReadForm(math.MaxInt64)</p>
            
            <pre><code>func TestReadFormMaxMemoryOverflow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFormWithTextContentType">
            <h2>TestReadFormWithTextContentType</h2>
            <hr />
            
            <pre><code>func TestReadFormWithTextContentType(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testFile">
            <h2>testFile</h2>
            <hr />
            
            <pre><code>func testFile(t *testing.T, fh *FileHeader, efn string, econtent string) File</code></pre>
         </article>
         
         <article class="function" data-name="TestReadForm_NoReadAfterEOF">
            <h2>TestReadForm_NoReadAfterEOF</h2>
            <hr />
            
            <pre><code>func TestReadForm_NoReadAfterEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadForm_NonFileMaxMemory">
            <h2>TestReadForm_NonFileMaxMemory</h2>
            <hr />
            
            <p>TestReadForm_NonFileMaxMemory asserts that the ReadForm maxMemory limit is applied
while processing non-file form data as well as file form data.</p>
            
            <pre><code>func TestReadForm_NonFileMaxMemory(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadForm_MetadataTooLarge">
            <h2>TestReadForm_MetadataTooLarge</h2>
            <hr />
            
            <p>TestReadForm_MetadataTooLarge verifies that we account for the size of field names,
MIME headers, and map entry overhead while limiting the memory consumption of parsed forms.</p>
            
            <pre><code>func TestReadForm_MetadataTooLarge(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadForm_ManyFiles_Combined">
            <h2>TestReadForm_ManyFiles_Combined</h2>
            <hr />
            
            <p>TestReadForm_ManyFiles_Combined tests that a multipart form containing many files only
results in a single on-disk file.</p>
            
            <pre><code>func TestReadForm_ManyFiles_Combined(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadForm_ManyFiles_Distinct">
            <h2>TestReadForm_ManyFiles_Distinct</h2>
            <hr />
            
            <p>TestReadForm_ManyFiles_Distinct tests that setting GODEBUG=multipartfiles=distinct
results in every file in a multipart form being placed in a distinct on-disk file.</p>
            
            <pre><code>func TestReadForm_ManyFiles_Distinct(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testReadFormManyFiles">
            <h2>testReadFormManyFiles</h2>
            <hr />
            
            <pre><code>func testReadFormManyFiles(t *testing.T, distinct bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFormLimits">
            <h2>TestReadFormLimits</h2>
            <hr />
            
            <pre><code>func TestReadFormLimits(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFormEndlessHeaderLine">
            <h2>TestReadFormEndlessHeaderLine</h2>
            <hr />
            
            <pre><code>func TestReadFormEndlessHeaderLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkReadForm">
            <h2>BenchmarkReadForm</h2>
            <hr />
            
            <pre><code>func BenchmarkReadForm(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="FormName">
            <h2>FormName</h2>
            <hr />
            
            <p>FormName returns the name parameter if p has a Content-Disposition
of type "form-data".  Otherwise it returns the empty string.</p>
            
            <pre><code>func FormName() string</code></pre>
         </article>
         
         <article class="function" data-name="FileName">
            <h2>FileName</h2>
            <hr />
            
            <p>FileName returns the filename parameter of the [Part]'s Content-Disposition
header. If not empty, the filename is passed through filepath.Base (which is
platform dependent) before being returned.</p>
            
            <pre><code>func FileName() string</code></pre>
         </article>
         
         <article class="function" data-name="parseContentDisposition">
            <h2>parseContentDisposition</h2>
            <hr />
            
            <pre><code>func parseContentDisposition()</code></pre>
         </article>
         
         <article class="function" data-name="NewReader">
            <h2>NewReader</h2>
            <hr />
            
            <p>NewReader creates a new multipart [Reader] reading from r using the
given MIME boundary.

The boundary is usually obtained from the "boundary" parameter of
the message's "Content-Type" header. Use [mime.ParseMediaType] to
parse such headers.</p>
            
            <pre><code>func NewReader(r io.Reader, boundary string) *Reader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, _ error)</code></pre>
         </article>
         
         <article class="function" data-name="newPart">
            <h2>newPart</h2>
            <hr />
            
            <pre><code>func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize int64, maxMIMEHeaders int64) (*Part, error)</code></pre>
         </article>
         
         <article class="function" data-name="populateHeaders">
            <h2>populateHeaders</h2>
            <hr />
            
            <pre><code>func populateHeaders(maxMIMEHeaderSize int64, maxMIMEHeaders int64) error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read reads the body of a part, after its headers and before the
next part (if any) begins.</p>
            
            <pre><code>func Read(d []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(d []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="scanUntilBoundary">
            <h2>scanUntilBoundary</h2>
            <hr />
            
            <p>scanUntilBoundary scans buf to identify how much of it can be safely
returned as part of the Part body.
dashBoundary is "--boundary".
nlDashBoundary is "\r\n--boundary" or "\n--boundary", depending on what mode we are in.
The comments below (and the name) assume "\n--boundary", but either is accepted.
total is the number of bytes read out so far. If total == 0, then a leading "--boundary" is recognized.
readErr is the read error, if any, that followed reading the bytes in buf.
scanUntilBoundary returns the number of data bytes from buf that can be
returned as part of the Part body and also the error to return (if any)
once those data bytes are done.</p>
            
            <pre><code>func scanUntilBoundary(buf []byte, dashBoundary []byte, nlDashBoundary []byte, total int64, readErr error) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="matchAfterPrefix">
            <h2>matchAfterPrefix</h2>
            <hr />
            
            <p>matchAfterPrefix checks whether buf should be considered to match the boundary.
The prefix is "--boundary" or "\r\n--boundary" or "\n--boundary",
and the caller has verified already that bytes.HasPrefix(buf, prefix) is true.

matchAfterPrefix returns +1 if the buffer does match the boundary,
meaning the prefix is followed by a double dash, space, tab, cr, nl,
or end of input.
It returns -1 if the buffer definitely does NOT match the boundary,
meaning the prefix is followed by some other character.
For example, "--foobar" does not match "--foo".
It returns 0 more input needs to be read to make the decision,
meaning that len(buf) == len(prefix) and readErr == nil.</p>
            
            <pre><code>func matchAfterPrefix(buf []byte, prefix []byte, readErr error) int</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="maxMIMEHeaders">
            <h2>maxMIMEHeaders</h2>
            <hr />
            
            <pre><code>func maxMIMEHeaders() int64</code></pre>
         </article>
         
         <article class="function" data-name="NextPart">
            <h2>NextPart</h2>
            <hr />
            
            <p>NextPart returns the next part in the multipart or an error.
When there are no more parts, the error [io.EOF] is returned.

As a special case, if the "Content-Transfer-Encoding" header
has a value of "quoted-printable", that header is instead
hidden and the body is transparently decoded during Read calls.</p>
            
            <pre><code>func NextPart() (*Part, error)</code></pre>
         </article>
         
         <article class="function" data-name="NextRawPart">
            <h2>NextRawPart</h2>
            <hr />
            
            <p>NextRawPart returns the next part in the multipart or an error.
When there are no more parts, the error [io.EOF] is returned.

Unlike [Reader.NextPart], it does not have special handling for
"Content-Transfer-Encoding: quoted-printable".</p>
            
            <pre><code>func NextRawPart() (*Part, error)</code></pre>
         </article>
         
         <article class="function" data-name="nextPart">
            <h2>nextPart</h2>
            <hr />
            
            <pre><code>func nextPart(rawPart bool, maxMIMEHeaderSize int64, maxMIMEHeaders int64) (*Part, error)</code></pre>
         </article>
         
         <article class="function" data-name="isFinalBoundary">
            <h2>isFinalBoundary</h2>
            <hr />
            
            <p>isFinalBoundary reports whether line is the final boundary line
indicating that all parts are over.
It matches `^--boundary--[ \t]*(\r\n)?$`</p>
            
            <pre><code>func isFinalBoundary(line []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isBoundaryDelimiterLine">
            <h2>isBoundaryDelimiterLine</h2>
            <hr />
            
            <pre><code>func isBoundaryDelimiterLine(line []byte) ret bool</code></pre>
         </article>
         
         <article class="function" data-name="skipLWSPChar">
            <h2>skipLWSPChar</h2>
            <hr />
            
            <p>skipLWSPChar returns b with leading spaces and tabs removed.
RFC 822 defines:

	LWSP-char = SPACE / HTAB</p>
            
            <pre><code>func skipLWSPChar(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="TestBoundaryLine">
            <h2>TestBoundaryLine</h2>
            <hr />
            
            <pre><code>func TestBoundaryLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="escapeString">
            <h2>escapeString</h2>
            <hr />
            
            <pre><code>func escapeString(v string) string</code></pre>
         </article>
         
         <article class="function" data-name="expectEq">
            <h2>expectEq</h2>
            <hr />
            
            <pre><code>func expectEq(t *testing.T, expected string, actual string, what string)</code></pre>
         </article>
         
         <article class="function" data-name="TestNameAccessors">
            <h2>TestNameAccessors</h2>
            <hr />
            
            <pre><code>func TestNameAccessors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testMultipartBody">
            <h2>testMultipartBody</h2>
            <hr />
            
            <pre><code>func testMultipartBody(sep string) string</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipart">
            <h2>TestMultipart</h2>
            <hr />
            
            <pre><code>func TestMultipart(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipartOnlyNewlines">
            <h2>TestMultipartOnlyNewlines</h2>
            <hr />
            
            <pre><code>func TestMultipartOnlyNewlines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipartSlowInput">
            <h2>TestMultipartSlowInput</h2>
            <hr />
            
            <pre><code>func TestMultipartSlowInput(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testMultipart">
            <h2>testMultipart</h2>
            <hr />
            
            <pre><code>func testMultipart(t *testing.T, r io.Reader, onlyNewlines bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestVariousTextLineEndings">
            <h2>TestVariousTextLineEndings</h2>
            <hr />
            
            <pre><code>func TestVariousTextLineEndings(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineLimit">
            <h2>TestLineLimit</h2>
            <hr />
            
            <pre><code>func TestLineLimit(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipartTruncated">
            <h2>TestMultipartTruncated</h2>
            <hr />
            
            <pre><code>func TestMultipartTruncated(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read([]byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipartStreamReadahead">
            <h2>TestMultipartStreamReadahead</h2>
            <hr />
            
            <p>TestMultipartStreamReadahead tests that PartReader does not block
on reading past the end of a part, ensuring that it can be used on
a stream like multipart/x-mixed-replace. See golang.org/issue/15431</p>
            
            <pre><code>func TestMultipartStreamReadahead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineContinuation">
            <h2>TestLineContinuation</h2>
            <hr />
            
            <pre><code>func TestLineContinuation(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestQuotedPrintableEncoding">
            <h2>TestQuotedPrintableEncoding</h2>
            <hr />
            
            <pre><code>func TestQuotedPrintableEncoding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testQuotedPrintableEncoding">
            <h2>testQuotedPrintableEncoding</h2>
            <hr />
            
            <pre><code>func testQuotedPrintableEncoding(t *testing.T, cte string)</code></pre>
         </article>
         
         <article class="function" data-name="TestRawPart">
            <h2>TestRawPart</h2>
            <hr />
            
            <pre><code>func TestRawPart(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNested">
            <h2>TestNested</h2>
            <hr />
            
            <p>Test parsing an image attachment from gmail, which previously failed.</p>
            
            <pre><code>func TestNested(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="formData">
            <h2>formData</h2>
            <hr />
            
            <pre><code>func formData(key string, value string) headerBody</code></pre>
         </article>
         
         <article class="function" data-name="TestParse">
            <h2>TestParse</h2>
            <hr />
            
            <pre><code>func TestParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="partsFromReader">
            <h2>partsFromReader</h2>
            <hr />
            
            <pre><code>func partsFromReader(r *Reader) ([]headerBody, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseAllSizes">
            <h2>TestParseAllSizes</h2>
            <hr />
            
            <pre><code>func TestParseAllSizes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="roundTripParseTest">
            <h2>roundTripParseTest</h2>
            <hr />
            
            <pre><code>func roundTripParseTest() parseTest</code></pre>
         </article>
         
         <article class="function" data-name="TestNoBoundary">
            <h2>TestNoBoundary</h2>
            <hr />
            
            <pre><code>func TestNoBoundary(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
