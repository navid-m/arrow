<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - multipart</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>multipart</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"bytes"
"errors"
"internal/godebug"
"io"
"math"
"net/textproto"
"os"
"strconv"
"bufio"
"bytes"
"fmt"
"internal/godebug"
"io"
"mime"
"mime/quotedprintable"
"net/textproto"
"path/filepath"
"strconv"
"strings"
"net/textproto"
_ "unsafe"
"bytes"
"crypto/rand"
"errors"
"fmt"
"io"
"maps"
"net/textproto"
"slices"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrMessageTooLarge" data-name="ErrMessageTooLarge">
               <h3>
                  ErrMessageTooLarge 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrMessageTooLarge" class="anchor" title="Link to ErrMessageTooLarge">#</a>
               </h3>
               
               <p>ErrMessageTooLarge is returned by ReadForm if the message form
data is too large to be processed.</p>
               
               <pre><code>var ErrMessageTooLarge = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="emptyParams" data-name="emptyParams">
               <h3>
                  emptyParams 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#emptyParams" class="anchor" title="Link to emptyParams">#</a>
               </h3>
               
               <pre><code>var emptyParams = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxMIMEHeaderSize" data-name="maxMIMEHeaderSize">
               <h3>
                  maxMIMEHeaderSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxMIMEHeaderSize" class="anchor" title="Link to maxMIMEHeaderSize">#</a>
               </h3>
               
               <p>maxMIMEHeaderSize is the maximum size of a MIME header we will parse,
including header keys, values, and map overhead.</p>
               
               <pre><code>const maxMIMEHeaderSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="multipartfiles" data-name="multipartfiles">
               <h3>
                  multipartfiles 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#multipartfiles" class="anchor" title="Link to multipartfiles">#</a>
               </h3>
               
               <pre><code>var multipartfiles = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="multipartmaxheaders" data-name="multipartmaxheaders">
               <h3>
                  multipartmaxheaders 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#multipartmaxheaders" class="anchor" title="Link to multipartmaxheaders">#</a>
               </h3>
               
               <p>multipartmaxheaders is the maximum number of header entries NextPart will return,
as well as the maximum combined total of header entries Reader.ReadForm will return
in FileHeaders.</p>
               
               <pre><code>var multipartmaxheaders = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="multipartmaxparts" data-name="multipartmaxparts">
               <h3>
                  multipartmaxparts 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#multipartmaxparts" class="anchor" title="Link to multipartmaxparts">#</a>
               </h3>
               
               <pre><code>var multipartmaxparts = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="peekBufferSize" data-name="peekBufferSize">
               <h3>
                  peekBufferSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#peekBufferSize" class="anchor" title="Link to peekBufferSize">#</a>
               </h3>
               
               <p>This constant needs to be at least 76 for this package to work correctly.
This is because \r\n--separator_of_len_70- would fill the buffer and it
wouldn't be safe to consume a single byte from it.</p>
               
               <pre><code>const peekBufferSize = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="quoteEscaper" data-name="quoteEscaper">
               <h3>
                  quoteEscaper 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#quoteEscaper" class="anchor" title="Link to quoteEscaper">#</a>
               </h3>
               
               <pre><code>var quoteEscaper = *ast.CallExpr</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge interface-badge">interface</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>File is an interface to access the file part of a multipart message.
Its contents may be either stored in memory or on disk.
If stored on disk, the File's underlying concrete type will be an *os.File.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type File interface {
io.Reader
io.ReaderAt
io.Seeker
io.Closer
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="FileHeader" data-name="FileHeader">
               <h3>
                  FileHeader
                  <span class="badge">struct</span>
                  <a href="#FileHeader" class="anchor" title="Link to FileHeader">#</a>
               </h3>
               
               <p>A FileHeader describes a file part of a multipart request.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FileHeader struct {
Filename string
Header textproto.MIMEHeader
Size int64
content []byte
tmpfile string
tmpoff int64
tmpshared bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Form" data-name="Form">
               <h3>
                  Form
                  <span class="badge">struct</span>
                  <a href="#Form" class="anchor" title="Link to Form">#</a>
               </h3>
               
               <p>Form is a parsed multipart form.
Its File parts are stored either in memory or on disk,
and are accessible via the [*FileHeader]'s Open method.
Its Value parts are stored as strings.
Both are keyed by field name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Form struct {
Value map[string][]string
File map[string][]*FileHeader
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Part" data-name="Part">
               <h3>
                  Part
                  <span class="badge">struct</span>
                  <a href="#Part" class="anchor" title="Link to Part">#</a>
               </h3>
               
               <p>A Part represents a single part in a multipart body.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Part struct {
Header textproto.MIMEHeader
mr *Reader
disposition string
dispositionParams map[string]string
r io.Reader
n int
total int64
err error
readErr error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>Reader is an iterator over parts in a MIME multipart body.
Reader's underlying parser consumes its input as needed. Seeking
isn't supported.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
bufReader *bufio.Reader
tempDir string
currentPart *Part
partsRead int
nl []byte
nlDashBoundary []byte
dashBoundaryDash []byte
dashBoundary []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>A Writer generates multipart messages.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
w io.Writer
boundary string
lastpart *part
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="part" data-name="part">
               <h3>
                  part
                  <span class="badge">struct</span>
                  <a href="#part" class="anchor" title="Link to part">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type part struct {
mw *Writer
closed bool
we error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="partReader" data-name="partReader">
               <h3>
                  partReader
                  <span class="badge">struct</span>
                  <a href="#partReader" class="anchor" title="Link to partReader">#</a>
               </h3>
               
               <p>partReader implements io.Reader by reading raw bytes directly from the
wrapped *Part, without doing any Transfer-Encoding decoding.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type partReader struct {
p *Part
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sectionReadCloser" data-name="sectionReadCloser">
               <h3>
                  sectionReadCloser
                  <span class="badge">struct</span>
                  <a href="#sectionReadCloser" class="anchor" title="Link to sectionReadCloser">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sectionReadCloser struct {
*io.SectionReader
io.Closer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stickyErrorReader" data-name="stickyErrorReader">
               <h3>
                  stickyErrorReader
                  <span class="badge">struct</span>
                  <a href="#stickyErrorReader" class="anchor" title="Link to stickyErrorReader">#</a>
               </h3>
               
               <p>stickyErrorReader is an io.Reader which never calls Read on its
underlying Reader once an error has been seen. (the io.Reader
interface's contract promises nothing about the return values of
Read calls after an error, yet this package does do multiple Reads
after error)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stickyErrorReader struct {
r io.Reader
err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Boundary" data-name="Boundary">
               <h3>
                  Boundary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Boundary" class="anchor" title="Link to Boundary">#</a>
               </h3>
               
               <p>Boundary returns the [Writer]'s boundary.</p>
               
               <pre><code>func (w *Writer) Boundary() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (p *Part) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close finishes the multipart message and writes the trailing
boundary end line to the output.</p>
               
               <pre><code>func (w *Writer) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (rc sectionReadCloser) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateFormField" data-name="CreateFormField">
               <h3>
                  CreateFormField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CreateFormField" class="anchor" title="Link to CreateFormField">#</a>
               </h3>
               
               <p>CreateFormField calls [Writer.CreatePart] with a header using the
given field name.</p>
               
               <pre><code>func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateFormFile" data-name="CreateFormFile">
               <h3>
                  CreateFormFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CreateFormFile" class="anchor" title="Link to CreateFormFile">#</a>
               </h3>
               
               <p>CreateFormFile is a convenience wrapper around [Writer.CreatePart]. It creates
a new form-data header with the provided field name and file name.</p>
               
               <pre><code>func (w *Writer) CreateFormFile(fieldname string, filename string) (io.Writer, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreatePart" data-name="CreatePart">
               <h3>
                  CreatePart 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CreatePart" class="anchor" title="Link to CreatePart">#</a>
               </h3>
               
               <p>CreatePart creates a new multipart section with the provided
header. The body of the part should be written to the returned
[Writer]. After calling CreatePart, any previous part may no longer
be written to.</p>
               
               <pre><code>func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileName" data-name="FileName">
               <h3>
                  FileName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FileName" class="anchor" title="Link to FileName">#</a>
               </h3>
               
               <p>FileName returns the filename parameter of the [Part]'s Content-Disposition
header. If not empty, the filename is passed through filepath.Base (which is
platform dependent) before being returned.</p>
               
               <pre><code>func (p *Part) FileName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormDataContentType" data-name="FormDataContentType">
               <h3>
                  FormDataContentType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FormDataContentType" class="anchor" title="Link to FormDataContentType">#</a>
               </h3>
               
               <p>FormDataContentType returns the Content-Type for an HTTP
multipart/form-data with this [Writer]'s Boundary.</p>
               
               <pre><code>func (w *Writer) FormDataContentType() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormName" data-name="FormName">
               <h3>
                  FormName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FormName" class="anchor" title="Link to FormName">#</a>
               </h3>
               
               <p>FormName returns the name parameter if p has a Content-Disposition
of type "form-data".  Otherwise it returns the empty string.</p>
               
               <pre><code>func (p *Part) FormName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader creates a new multipart [Reader] reading from r using the
given MIME boundary.
The boundary is usually obtained from the "boundary" parameter of
the message's "Content-Type" header. Use [mime.ParseMediaType] to
parse such headers.</p>
               
               <pre><code>func NewReader(r io.Reader, boundary string) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter returns a new multipart [Writer] with a random boundary,
writing to w.</p>
               
               <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NextPart" data-name="NextPart">
               <h3>
                  NextPart 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NextPart" class="anchor" title="Link to NextPart">#</a>
               </h3>
               
               <p>NextPart returns the next part in the multipart or an error.
When there are no more parts, the error [io.EOF] is returned.
As a special case, if the "Content-Transfer-Encoding" header
has a value of "quoted-printable", that header is instead
hidden and the body is transparently decoded during Read calls.</p>
               
               <pre><code>func (r *Reader) NextPart() (*Part, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NextRawPart" data-name="NextRawPart">
               <h3>
                  NextRawPart 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NextRawPart" class="anchor" title="Link to NextRawPart">#</a>
               </h3>
               
               <p>NextRawPart returns the next part in the multipart or an error.
When there are no more parts, the error [io.EOF] is returned.
Unlike [Reader.NextPart], it does not have special handling for
"Content-Transfer-Encoding: quoted-printable".</p>
               
               <pre><code>func (r *Reader) NextRawPart() (*Part, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open opens and returns the [FileHeader]'s associated File.</p>
               
               <pre><code>func (fh *FileHeader) Open() (File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads the body of a part, after its headers and before the
next part (if any) begins.</p>
               
               <pre><code>func (p *Part) Read(d []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (pr partReader) Read(d []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r *stickyErrorReader) Read(p []byte) (n int, _ error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadForm" data-name="ReadForm">
               <h3>
                  ReadForm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadForm" class="anchor" title="Link to ReadForm">#</a>
               </h3>
               
               <p>ReadForm parses an entire multipart message whose parts have
a Content-Disposition of "form-data".
It stores up to maxMemory bytes + 10MB (reserved for non-file parts)
in memory. File parts which can't be stored in memory will be stored on
disk in temporary files.
It returns [ErrMessageTooLarge] if all non-file parts can't be stored in
memory.</p>
               
               <pre><code>func (r *Reader) ReadForm(maxMemory int64) (*Form, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RemoveAll" data-name="RemoveAll">
               <h3>
                  RemoveAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RemoveAll" class="anchor" title="Link to RemoveAll">#</a>
               </h3>
               
               <p>RemoveAll removes any temporary files associated with a [Form].</p>
               
               <pre><code>func (f *Form) RemoveAll() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBoundary" data-name="SetBoundary">
               <h3>
                  SetBoundary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBoundary" class="anchor" title="Link to SetBoundary">#</a>
               </h3>
               
               <p>SetBoundary overrides the [Writer]'s default randomly-generated
boundary separator with an explicit value.
SetBoundary must be called before any parts are created, may only
contain certain ASCII characters, and must be non-empty and
at most 70 bytes long.</p>
               
               <pre><code>func (w *Writer) SetBoundary(boundary string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (p *part) Write(d []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteField" data-name="WriteField">
               <h3>
                  WriteField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteField" class="anchor" title="Link to WriteField">#</a>
               </h3>
               
               <p>WriteField calls [Writer.CreateFormField] and then writes the given value.</p>
               
               <pre><code>func (w *Writer) WriteField(fieldname string, value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (p *part) close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapeQuotes" data-name="escapeQuotes">
               <h3>
                  escapeQuotes 
                  <span class="badge">function</span>
                  
                  <a href="#escapeQuotes" class="anchor" title="Link to escapeQuotes">#</a>
               </h3>
               
               <pre><code>func escapeQuotes(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBoundaryDelimiterLine" data-name="isBoundaryDelimiterLine">
               <h3>
                  isBoundaryDelimiterLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isBoundaryDelimiterLine" class="anchor" title="Link to isBoundaryDelimiterLine">#</a>
               </h3>
               
               <pre><code>func (r *Reader) isBoundaryDelimiterLine(line []byte) (ret bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isFinalBoundary" data-name="isFinalBoundary">
               <h3>
                  isFinalBoundary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isFinalBoundary" class="anchor" title="Link to isFinalBoundary">#</a>
               </h3>
               
               <p>isFinalBoundary reports whether line is the final boundary line
indicating that all parts are over.
It matches `^--boundary--[ \t]*(\r\n)?$`</p>
               
               <pre><code>func (r *Reader) isFinalBoundary(line []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchAfterPrefix" data-name="matchAfterPrefix">
               <h3>
                  matchAfterPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#matchAfterPrefix" class="anchor" title="Link to matchAfterPrefix">#</a>
               </h3>
               
               <p>matchAfterPrefix checks whether buf should be considered to match the boundary.
The prefix is "--boundary" or "\r\n--boundary" or "\n--boundary",
and the caller has verified already that bytes.HasPrefix(buf, prefix) is true.
matchAfterPrefix returns +1 if the buffer does match the boundary,
meaning the prefix is followed by a double dash, space, tab, cr, nl,
or end of input.
It returns -1 if the buffer definitely does NOT match the boundary,
meaning the prefix is followed by some other character.
For example, "--foobar" does not match "--foo".
It returns 0 more input needs to be read to make the decision,
meaning that len(buf) == len(prefix) and readErr == nil.</p>
               
               <pre><code>func matchAfterPrefix(buf []byte, prefix []byte, readErr error) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxMIMEHeaders" data-name="maxMIMEHeaders">
               <h3>
                  maxMIMEHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#maxMIMEHeaders" class="anchor" title="Link to maxMIMEHeaders">#</a>
               </h3>
               
               <pre><code>func maxMIMEHeaders() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mimeHeaderSize" data-name="mimeHeaderSize">
               <h3>
                  mimeHeaderSize 
                  <span class="badge">function</span>
                  
                  <a href="#mimeHeaderSize" class="anchor" title="Link to mimeHeaderSize">#</a>
               </h3>
               
               <pre><code>func mimeHeaderSize(h textproto.MIMEHeader) (size int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPart" data-name="newPart">
               <h3>
                  newPart 
                  <span class="badge">function</span>
                  
                  <a href="#newPart" class="anchor" title="Link to newPart">#</a>
               </h3>
               
               <pre><code>func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize int64, maxMIMEHeaders int64) (*Part, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextPart" data-name="nextPart">
               <h3>
                  nextPart 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nextPart" class="anchor" title="Link to nextPart">#</a>
               </h3>
               
               <pre><code>func (r *Reader) nextPart(rawPart bool, maxMIMEHeaderSize int64, maxMIMEHeaders int64) (*Part, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseContentDisposition" data-name="parseContentDisposition">
               <h3>
                  parseContentDisposition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseContentDisposition" class="anchor" title="Link to parseContentDisposition">#</a>
               </h3>
               
               <pre><code>func (p *Part) parseContentDisposition()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="populateHeaders" data-name="populateHeaders">
               <h3>
                  populateHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#populateHeaders" class="anchor" title="Link to populateHeaders">#</a>
               </h3>
               
               <pre><code>func (p *Part) populateHeaders(maxMIMEHeaderSize int64, maxMIMEHeaders int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="randomBoundary" data-name="randomBoundary">
               <h3>
                  randomBoundary 
                  <span class="badge">function</span>
                  
                  <a href="#randomBoundary" class="anchor" title="Link to randomBoundary">#</a>
               </h3>
               
               <pre><code>func randomBoundary() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readForm" data-name="readForm">
               <h3>
                  readForm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readForm" class="anchor" title="Link to readForm">#</a>
               </h3>
               
               <pre><code>func (r *Reader) readForm(maxMemory int64) (_ *Form, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readMIMEHeader" data-name="readMIMEHeader">
               <h3>
                  readMIMEHeader 
                  <span class="badge">function</span>
                  
                  <a href="#readMIMEHeader" class="anchor" title="Link to readMIMEHeader">#</a>
               </h3>
               
               <p>readMIMEHeader is defined in package [net/textproto].
go:linkname readMIMEHeader net/textproto.readMIMEHeader</p>
               
               <pre><code>func readMIMEHeader(r *textproto.Reader, maxMemory int64, maxHeaders int64) (textproto.MIMEHeader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanUntilBoundary" data-name="scanUntilBoundary">
               <h3>
                  scanUntilBoundary 
                  <span class="badge">function</span>
                  
                  <a href="#scanUntilBoundary" class="anchor" title="Link to scanUntilBoundary">#</a>
               </h3>
               
               <p>scanUntilBoundary scans buf to identify how much of it can be safely
returned as part of the Part body.
dashBoundary is "--boundary".
nlDashBoundary is "\r\n--boundary" or "\n--boundary", depending on what mode we are in.
The comments below (and the name) assume "\n--boundary", but either is accepted.
total is the number of bytes read out so far. If total == 0, then a leading "--boundary" is recognized.
readErr is the read error, if any, that followed reading the bytes in buf.
scanUntilBoundary returns the number of data bytes from buf that can be
returned as part of the Part body and also the error to return (if any)
once those data bytes are done.</p>
               
               <pre><code>func scanUntilBoundary(buf []byte, dashBoundary []byte, nlDashBoundary []byte, total int64, readErr error) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipLWSPChar" data-name="skipLWSPChar">
               <h3>
                  skipLWSPChar 
                  <span class="badge">function</span>
                  
                  <a href="#skipLWSPChar" class="anchor" title="Link to skipLWSPChar">#</a>
               </h3>
               
               <p>skipLWSPChar returns b with leading spaces and tabs removed.
RFC 822 defines:
LWSP-char = SPACE / HTAB</p>
               
               <pre><code>func skipLWSPChar(b []byte) []byte</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>