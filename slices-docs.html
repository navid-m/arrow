<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - slices</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>slices</code>
         </h1>
         <hr />
         
         <article class="global" data-name="unknownHint">
            <h2>unknownHint</h2>
            <hr />
            
            <pre><code>unknownHint sortedHint</code></pre>
         </article>
         
         <article class="global" data-name="increasingHint">
            <h2>increasingHint</h2>
            <hr />
            
            <pre><code>increasingHint</code></pre>
         </article>
         
         <article class="global" data-name="decreasingHint">
            <h2>decreasingHint</h2>
            <hr />
            
            <pre><code>decreasingHint</code></pre>
         </article>
           
         <article class="function" data-name="All">
            <h2>All</h2>
            <hr />
            
            <p>All returns an iterator over index-value pairs in the slice
in the usual order.</p>
            
            <pre><code>func All(s Slice) *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="function" data-name="Backward">
            <h2>Backward</h2>
            <hr />
            
            <p>Backward returns an iterator over index-value pairs in the slice,
traversing it backward with descending indices.</p>
            
            <pre><code>func Backward(s Slice) *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="function" data-name="Values">
            <h2>Values</h2>
            <hr />
            
            <p>Values returns an iterator that yields the slice elements in order.</p>
            
            <pre><code>func Values(s Slice) *ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="AppendSeq">
            <h2>AppendSeq</h2>
            <hr />
            
            <p>AppendSeq appends the values from seq to the slice and
returns the extended slice.</p>
            
            <pre><code>func AppendSeq(s Slice, seq *ast.IndexExpr) Slice</code></pre>
         </article>
         
         <article class="function" data-name="Collect">
            <h2>Collect</h2>
            <hr />
            
            <p>Collect collects values from seq into a new slice and returns it.</p>
            
            <pre><code>func Collect(seq *ast.IndexExpr) []E</code></pre>
         </article>
         
         <article class="function" data-name="Sorted">
            <h2>Sorted</h2>
            <hr />
            
            <p>Sorted collects values from seq into a new slice, sorts the slice,
and returns it.</p>
            
            <pre><code>func Sorted(seq *ast.IndexExpr) []E</code></pre>
         </article>
         
         <article class="function" data-name="SortedFunc">
            <h2>SortedFunc</h2>
            <hr />
            
            <p>SortedFunc collects values from seq into a new slice, sorts the slice
using the comparison function, and returns it.</p>
            
            <pre><code>func SortedFunc(seq *ast.IndexExpr, cmp func) []E</code></pre>
         </article>
         
         <article class="function" data-name="SortedStableFunc">
            <h2>SortedStableFunc</h2>
            <hr />
            
            <p>SortedStableFunc collects values from seq into a new slice.
It then sorts the slice while keeping the original order of equal elements,
using the comparison function to compare elements.
It returns the new slice.</p>
            
            <pre><code>func SortedStableFunc(seq *ast.IndexExpr, cmp func) []E</code></pre>
         </article>
         
         <article class="function" data-name="Chunk">
            <h2>Chunk</h2>
            <hr />
            
            <p>Chunk returns an iterator over consecutive sub-slices of up to n elements of s.
All but the last sub-slice will have size n.
All sub-slices are clipped to have no capacity beyond the length.
If s is empty, the sequence is empty: there is no empty slice in the sequence.
Chunk panics if n is less than 1.</p>
            
            <pre><code>func Chunk(s Slice, n int) *ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal reports whether two slices are equal: the same length and all
elements equal. If the lengths are different, Equal returns false.
Otherwise, the elements are compared in increasing index order, and the
comparison stops at the first unequal pair.
Empty and nil slices are considered equal.
Floating point NaNs are not considered equal.</p>
            
            <pre><code>func Equal(s1 S, s2 S) bool</code></pre>
         </article>
         
         <article class="function" data-name="EqualFunc">
            <h2>EqualFunc</h2>
            <hr />
            
            <p>EqualFunc reports whether two slices are equal using an equality
function on each pair of elements. If the lengths are different,
EqualFunc returns false. Otherwise, the elements are compared in
increasing index order, and the comparison stops at the first index
for which eq returns false.</p>
            
            <pre><code>func EqualFunc(s1 S1, s2 S2, eq func) bool</code></pre>
         </article>
         
         <article class="function" data-name="Compare">
            <h2>Compare</h2>
            <hr />
            
            <p>Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
of elements. The elements are compared sequentially, starting at index 0,
until one element is not equal to the other.
The result of comparing the first non-matching elements is returned.
If both slices are equal until one of them ends, the shorter slice is
considered less than the longer one.
The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.</p>
            
            <pre><code>func Compare(s1 S, s2 S) int</code></pre>
         </article>
         
         <article class="function" data-name="CompareFunc">
            <h2>CompareFunc</h2>
            <hr />
            
            <p>CompareFunc is like [Compare] but uses a custom comparison function on each
pair of elements.
The result is the first non-zero result of cmp; if cmp always
returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
and +1 if len(s1) > len(s2).</p>
            
            <pre><code>func CompareFunc(s1 S1, s2 S2, cmp func) int</code></pre>
         </article>
         
         <article class="function" data-name="Index">
            <h2>Index</h2>
            <hr />
            
            <p>Index returns the index of the first occurrence of v in s,
or -1 if not present.</p>
            
            <pre><code>func Index(s S, v E) int</code></pre>
         </article>
         
         <article class="function" data-name="IndexFunc">
            <h2>IndexFunc</h2>
            <hr />
            
            <p>IndexFunc returns the first index i satisfying f(s[i]),
or -1 if none do.</p>
            
            <pre><code>func IndexFunc(s S, f func) int</code></pre>
         </article>
         
         <article class="function" data-name="Contains">
            <h2>Contains</h2>
            <hr />
            
            <p>Contains reports whether v is present in s.</p>
            
            <pre><code>func Contains(s S, v E) bool</code></pre>
         </article>
         
         <article class="function" data-name="ContainsFunc">
            <h2>ContainsFunc</h2>
            <hr />
            
            <p>ContainsFunc reports whether at least one
element e of s satisfies f(e).</p>
            
            <pre><code>func ContainsFunc(s S, f func) bool</code></pre>
         </article>
         
         <article class="function" data-name="Insert">
            <h2>Insert</h2>
            <hr />
            
            <p>Insert inserts the values v... into s at index i,
returning the modified slice.
The elements at s[i:] are shifted up to make room.
In the returned slice r, r[i] == v[0],
and, if i < len(s), r[i+len(v)] == value originally at r[i].
Insert panics if i > len(s).
This function is O(len(s) + len(v)).</p>
            
            <pre><code>func Insert(s S, i int, v ...E) S</code></pre>
         </article>
         
         <article class="function" data-name="Delete">
            <h2>Delete</h2>
            <hr />
            
            <p>Delete removes the elements s[i:j] from s, returning the modified slice.
Delete panics if j > len(s) or s[i:j] is not a valid slice of s.
Delete is O(len(s)-i), so if many items must be deleted, it is better to
make a single call deleting them all together than to delete one at a time.
Delete zeroes the elements s[len(s)-(j-i):len(s)].</p>
            
            <pre><code>func Delete(s S, i int, j int) S</code></pre>
         </article>
         
         <article class="function" data-name="DeleteFunc">
            <h2>DeleteFunc</h2>
            <hr />
            
            <p>DeleteFunc removes any elements from s for which del returns true,
returning the modified slice.
DeleteFunc zeroes the elements between the new length and the original length.</p>
            
            <pre><code>func DeleteFunc(s S, del func) S</code></pre>
         </article>
         
         <article class="function" data-name="Replace">
            <h2>Replace</h2>
            <hr />
            
            <p>Replace replaces the elements s[i:j] by the given v, and returns the
modified slice.
Replace panics if j > len(s) or s[i:j] is not a valid slice of s.
When len(v) < (j-i), Replace zeroes the elements between the new length and the original length.</p>
            
            <pre><code>func Replace(s S, i int, j int, v ...E) S</code></pre>
         </article>
         
         <article class="function" data-name="Clone">
            <h2>Clone</h2>
            <hr />
            
            <p>Clone returns a copy of the slice.
The elements are copied using assignment, so this is a shallow clone.
The result may have additional unused capacity.</p>
            
            <pre><code>func Clone(s S) S</code></pre>
         </article>
         
         <article class="function" data-name="Compact">
            <h2>Compact</h2>
            <hr />
            
            <p>Compact replaces consecutive runs of equal elements with a single copy.
This is like the uniq command found on Unix.
Compact modifies the contents of the slice s and returns the modified slice,
which may have a smaller length.
Compact zeroes the elements between the new length and the original length.</p>
            
            <pre><code>func Compact(s S) S</code></pre>
         </article>
         
         <article class="function" data-name="CompactFunc">
            <h2>CompactFunc</h2>
            <hr />
            
            <p>CompactFunc is like [Compact] but uses an equality function to compare elements.
For runs of elements that compare equal, CompactFunc keeps the first one.
CompactFunc zeroes the elements between the new length and the original length.</p>
            
            <pre><code>func CompactFunc(s S, eq func) S</code></pre>
         </article>
         
         <article class="function" data-name="Grow">
            <h2>Grow</h2>
            <hr />
            
            <p>Grow increases the slice's capacity, if necessary, to guarantee space for
another n elements. After Grow(n), at least n elements can be appended
to the slice without another allocation. If n is negative or too large to
allocate the memory, Grow panics.</p>
            
            <pre><code>func Grow(s S, n int) S</code></pre>
         </article>
         
         <article class="function" data-name="Clip">
            <h2>Clip</h2>
            <hr />
            
            <p>Clip removes unused capacity from the slice, returning s[:len(s):len(s)].</p>
            
            <pre><code>func Clip(s S) S</code></pre>
         </article>
         
         <article class="function" data-name="rotateLeft">
            <h2>rotateLeft</h2>
            <hr />
            
            <p>rotateLeft rotates s left by r spaces.
s_final[i] = s_orig[i+r], wrapping around.</p>
            
            <pre><code>func rotateLeft(s []E, r int)</code></pre>
         </article>
         
         <article class="function" data-name="rotateRight">
            <h2>rotateRight</h2>
            <hr />
            
            <pre><code>func rotateRight(s []E, r int)</code></pre>
         </article>
         
         <article class="function" data-name="overlaps">
            <h2>overlaps</h2>
            <hr />
            
            <p>overlaps reports whether the memory ranges a[:len(a)] and b[:len(b)] overlap.</p>
            
            <pre><code>func overlaps(a []E, b []E) bool</code></pre>
         </article>
         
         <article class="function" data-name="startIdx">
            <h2>startIdx</h2>
            <hr />
            
            <p>startIdx returns the index in haystack where the needle starts.
prerequisite: the needle must be aliased entirely inside the haystack.</p>
            
            <pre><code>func startIdx(haystack []E, needle []E) int</code></pre>
         </article>
         
         <article class="function" data-name="Reverse">
            <h2>Reverse</h2>
            <hr />
            
            <p>Reverse reverses the elements of the slice in place.</p>
            
            <pre><code>func Reverse(s S)</code></pre>
         </article>
         
         <article class="function" data-name="Concat">
            <h2>Concat</h2>
            <hr />
            
            <p>Concat returns a new slice concatenating the passed in slices.</p>
            
            <pre><code>func Concat(slices ...S) S</code></pre>
         </article>
         
         <article class="function" data-name="Repeat">
            <h2>Repeat</h2>
            <hr />
            
            <p>Repeat returns a new slice that repeats the provided slice the given number of times.
The result has length and capacity (len(x) * count).
The result is never nil.
Repeat panics if count is negative or if the result of (len(x) * count)
overflows.</p>
            
            <pre><code>func Repeat(x S, count int) S</code></pre>
         </article>
         
         <article class="function" data-name="Sort">
            <h2>Sort</h2>
            <hr />
            
            <p>Sort sorts a slice of any ordered type in ascending order.
When sorting floating-point numbers, NaNs are ordered before other values.</p>
            
            <pre><code>func Sort(x S)</code></pre>
         </article>
         
         <article class="function" data-name="SortFunc">
            <h2>SortFunc</h2>
            <hr />
            
            <p>SortFunc sorts the slice x in ascending order as determined by the cmp
function. This sort is not guaranteed to be stable.
cmp(a, b) should return a negative number when a < b, a positive number when
a > b and zero when a == b or a and b are incomparable in the sense of
a strict weak ordering.

SortFunc requires that cmp is a strict weak ordering.
See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.
The function should return 0 for incomparable items.</p>
            
            <pre><code>func SortFunc(x S, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="SortStableFunc">
            <h2>SortStableFunc</h2>
            <hr />
            
            <p>SortStableFunc sorts the slice x while keeping the original order of equal
elements, using cmp to compare elements in the same way as [SortFunc].</p>
            
            <pre><code>func SortStableFunc(x S, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="IsSorted">
            <h2>IsSorted</h2>
            <hr />
            
            <p>IsSorted reports whether x is sorted in ascending order.</p>
            
            <pre><code>func IsSorted(x S) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsSortedFunc">
            <h2>IsSortedFunc</h2>
            <hr />
            
            <p>IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
comparison function as defined by [SortFunc].</p>
            
            <pre><code>func IsSortedFunc(x S, cmp func) bool</code></pre>
         </article>
         
         <article class="function" data-name="Min">
            <h2>Min</h2>
            <hr />
            
            <p>Min returns the minimal value in x. It panics if x is empty.
For floating-point numbers, Min propagates NaNs (any NaN value in x
forces the output to be NaN).</p>
            
            <pre><code>func Min(x S) E</code></pre>
         </article>
         
         <article class="function" data-name="MinFunc">
            <h2>MinFunc</h2>
            <hr />
            
            <p>MinFunc returns the minimal value in x, using cmp to compare elements.
It panics if x is empty. If there is more than one minimal element
according to the cmp function, MinFunc returns the first one.</p>
            
            <pre><code>func MinFunc(x S, cmp func) E</code></pre>
         </article>
         
         <article class="function" data-name="Max">
            <h2>Max</h2>
            <hr />
            
            <p>Max returns the maximal value in x. It panics if x is empty.
For floating-point E, Max propagates NaNs (any NaN value in x
forces the output to be NaN).</p>
            
            <pre><code>func Max(x S) E</code></pre>
         </article>
         
         <article class="function" data-name="MaxFunc">
            <h2>MaxFunc</h2>
            <hr />
            
            <p>MaxFunc returns the maximal value in x, using cmp to compare elements.
It panics if x is empty. If there is more than one maximal element
according to the cmp function, MaxFunc returns the first one.</p>
            
            <pre><code>func MaxFunc(x S, cmp func) E</code></pre>
         </article>
         
         <article class="function" data-name="BinarySearch">
            <h2>BinarySearch</h2>
            <hr />
            
            <p>BinarySearch searches for target in a sorted slice and returns the earliest
position where target is found, or the position where target would appear
in the sort order; it also returns a bool saying whether the target is
really found in the slice. The slice must be sorted in increasing order.</p>
            
            <pre><code>func BinarySearch(x S, target E) (int, bool)</code></pre>
         </article>
         
         <article class="function" data-name="BinarySearchFunc">
            <h2>BinarySearchFunc</h2>
            <hr />
            
            <p>BinarySearchFunc works like [BinarySearch], but uses a custom comparison
function. The slice must be sorted in increasing order, where "increasing"
is defined by cmp. cmp should return 0 if the slice element matches
the target, a negative number if the slice element precedes the target,
or a positive number if the slice element follows the target.
cmp must implement the same ordering as the slice, such that if
cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.</p>
            
            <pre><code>func BinarySearchFunc(x S, target T, cmp func) (int, bool)</code></pre>
         </article>
         
         <article class="function" data-name="Next">
            <h2>Next</h2>
            <hr />
            
            <pre><code>func Next() uint64</code></pre>
         </article>
         
         <article class="function" data-name="nextPowerOfTwo">
            <h2>nextPowerOfTwo</h2>
            <hr />
            
            <pre><code>func nextPowerOfTwo(length int) uint</code></pre>
         </article>
         
         <article class="function" data-name="isNaN">
            <h2>isNaN</h2>
            <hr />
            
            <p>isNaN reports whether x is a NaN without requiring the math package.
This will always return false if T is not floating-point.</p>
            
            <pre><code>func isNaN(x T) bool</code></pre>
         </article>
         
         <article class="function" data-name="insertionSortCmpFunc">
            <h2>insertionSortCmpFunc</h2>
            <hr />
            
            <p>insertionSortCmpFunc sorts data[a:b] using insertion sort.</p>
            
            <pre><code>func insertionSortCmpFunc(data []E, a int, b int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="siftDownCmpFunc">
            <h2>siftDownCmpFunc</h2>
            <hr />
            
            <p>siftDownCmpFunc implements the heap property on data[lo:hi].
first is an offset into the array where the root of the heap lies.</p>
            
            <pre><code>func siftDownCmpFunc(data []E, lo int, hi int, first int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="heapSortCmpFunc">
            <h2>heapSortCmpFunc</h2>
            <hr />
            
            <pre><code>func heapSortCmpFunc(data []E, a int, b int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="pdqsortCmpFunc">
            <h2>pdqsortCmpFunc</h2>
            <hr />
            
            <p>pdqsortCmpFunc sorts data[a:b].
The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
C++ implementation: https://github.com/orlp/pdqsort
Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</p>
            
            <pre><code>func pdqsortCmpFunc(data []E, a int, b int, limit int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="partitionCmpFunc">
            <h2>partitionCmpFunc</h2>
            <hr />
            
            <p>partitionCmpFunc does one quicksort partition.
Let p = data[pivot]
Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
On return, data[newpivot] = p</p>
            
            <pre><code>func partitionCmpFunc(data []E, a int, b int, pivot int, cmp func) (newpivot int, alreadyPartitioned bool)</code></pre>
         </article>
         
         <article class="function" data-name="partitionEqualCmpFunc">
            <h2>partitionEqualCmpFunc</h2>
            <hr />
            
            <p>partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
It assumed that data[a:b] does not contain elements smaller than the data[pivot].</p>
            
            <pre><code>func partitionEqualCmpFunc(data []E, a int, b int, pivot int, cmp func) newpivot int</code></pre>
         </article>
         
         <article class="function" data-name="partialInsertionSortCmpFunc">
            <h2>partialInsertionSortCmpFunc</h2>
            <hr />
            
            <p>partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.</p>
            
            <pre><code>func partialInsertionSortCmpFunc(data []E, a int, b int, cmp func) bool</code></pre>
         </article>
         
         <article class="function" data-name="breakPatternsCmpFunc">
            <h2>breakPatternsCmpFunc</h2>
            <hr />
            
            <p>breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
that might cause imbalanced partitions in quicksort.</p>
            
            <pre><code>func breakPatternsCmpFunc(data []E, a int, b int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="choosePivotCmpFunc">
            <h2>choosePivotCmpFunc</h2>
            <hr />
            
            <p>choosePivotCmpFunc chooses a pivot in data[a:b].

[0,8): chooses a static pivot.
[8,shortestNinther): uses the simple median-of-three method.
[shortestNinther,∞): uses the Tukey ninther method.</p>
            
            <pre><code>func choosePivotCmpFunc(data []E, a int, b int, cmp func) (pivot int, hint sortedHint)</code></pre>
         </article>
         
         <article class="function" data-name="order2CmpFunc">
            <h2>order2CmpFunc</h2>
            <hr />
            
            <p>order2CmpFunc returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.</p>
            
            <pre><code>func order2CmpFunc(data []E, a int, b int, swaps *int, cmp func) (int, int)</code></pre>
         </article>
         
         <article class="function" data-name="medianCmpFunc">
            <h2>medianCmpFunc</h2>
            <hr />
            
            <p>medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</p>
            
            <pre><code>func medianCmpFunc(data []E, a int, b int, c int, swaps *int, cmp func) int</code></pre>
         </article>
         
         <article class="function" data-name="medianAdjacentCmpFunc">
            <h2>medianAdjacentCmpFunc</h2>
            <hr />
            
            <p>medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</p>
            
            <pre><code>func medianAdjacentCmpFunc(data []E, a int, swaps *int, cmp func) int</code></pre>
         </article>
         
         <article class="function" data-name="reverseRangeCmpFunc">
            <h2>reverseRangeCmpFunc</h2>
            <hr />
            
            <pre><code>func reverseRangeCmpFunc(data []E, a int, b int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="swapRangeCmpFunc">
            <h2>swapRangeCmpFunc</h2>
            <hr />
            
            <pre><code>func swapRangeCmpFunc(data []E, a int, b int, n int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="stableCmpFunc">
            <h2>stableCmpFunc</h2>
            <hr />
            
            <pre><code>func stableCmpFunc(data []E, n int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="symMergeCmpFunc">
            <h2>symMergeCmpFunc</h2>
            <hr />
            
            <p>symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
Computer Science, pages 714-723. Springer, 2004.

Let M = m-a and N = b-n. Wolog M < N.
The recursion depth is bound by ceil(log(N+M)).
The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
The algorithm needs O((M+N)*log(M)) calls to data.Swap.

The paper gives O((M+N)*log(M)) as the number of assignments assuming a
rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
in the paper carries through for Swap operations, especially as the block
swapping rotate uses only O(M+N) Swaps.

symMerge assumes non-degenerate arguments: a < m && m < b.
Having the caller check this condition eliminates many leaf recursion calls,
which improves performance.</p>
            
            <pre><code>func symMergeCmpFunc(data []E, a int, m int, b int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="rotateCmpFunc">
            <h2>rotateCmpFunc</h2>
            <hr />
            
            <p>rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
Data of the form 'x u v y' is changed to 'x v u y'.
rotate performs at most b-a many calls to data.Swap,
and it assumes non-degenerate arguments: a < m && m < b.</p>
            
            <pre><code>func rotateCmpFunc(data []E, a int, m int, b int, cmp func)</code></pre>
         </article>
         
         <article class="function" data-name="insertionSortOrdered">
            <h2>insertionSortOrdered</h2>
            <hr />
            
            <p>insertionSortOrdered sorts data[a:b] using insertion sort.</p>
            
            <pre><code>func insertionSortOrdered(data []E, a int, b int)</code></pre>
         </article>
         
         <article class="function" data-name="siftDownOrdered">
            <h2>siftDownOrdered</h2>
            <hr />
            
            <p>siftDownOrdered implements the heap property on data[lo:hi].
first is an offset into the array where the root of the heap lies.</p>
            
            <pre><code>func siftDownOrdered(data []E, lo int, hi int, first int)</code></pre>
         </article>
         
         <article class="function" data-name="heapSortOrdered">
            <h2>heapSortOrdered</h2>
            <hr />
            
            <pre><code>func heapSortOrdered(data []E, a int, b int)</code></pre>
         </article>
         
         <article class="function" data-name="pdqsortOrdered">
            <h2>pdqsortOrdered</h2>
            <hr />
            
            <p>pdqsortOrdered sorts data[a:b].
The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
C++ implementation: https://github.com/orlp/pdqsort
Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</p>
            
            <pre><code>func pdqsortOrdered(data []E, a int, b int, limit int)</code></pre>
         </article>
         
         <article class="function" data-name="partitionOrdered">
            <h2>partitionOrdered</h2>
            <hr />
            
            <p>partitionOrdered does one quicksort partition.
Let p = data[pivot]
Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
On return, data[newpivot] = p</p>
            
            <pre><code>func partitionOrdered(data []E, a int, b int, pivot int) (newpivot int, alreadyPartitioned bool)</code></pre>
         </article>
         
         <article class="function" data-name="partitionEqualOrdered">
            <h2>partitionEqualOrdered</h2>
            <hr />
            
            <p>partitionEqualOrdered partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
It assumed that data[a:b] does not contain elements smaller than the data[pivot].</p>
            
            <pre><code>func partitionEqualOrdered(data []E, a int, b int, pivot int) newpivot int</code></pre>
         </article>
         
         <article class="function" data-name="partialInsertionSortOrdered">
            <h2>partialInsertionSortOrdered</h2>
            <hr />
            
            <p>partialInsertionSortOrdered partially sorts a slice, returns true if the slice is sorted at the end.</p>
            
            <pre><code>func partialInsertionSortOrdered(data []E, a int, b int) bool</code></pre>
         </article>
         
         <article class="function" data-name="breakPatternsOrdered">
            <h2>breakPatternsOrdered</h2>
            <hr />
            
            <p>breakPatternsOrdered scatters some elements around in an attempt to break some patterns
that might cause imbalanced partitions in quicksort.</p>
            
            <pre><code>func breakPatternsOrdered(data []E, a int, b int)</code></pre>
         </article>
         
         <article class="function" data-name="choosePivotOrdered">
            <h2>choosePivotOrdered</h2>
            <hr />
            
            <p>choosePivotOrdered chooses a pivot in data[a:b].

[0,8): chooses a static pivot.
[8,shortestNinther): uses the simple median-of-three method.
[shortestNinther,∞): uses the Tukey ninther method.</p>
            
            <pre><code>func choosePivotOrdered(data []E, a int, b int) (pivot int, hint sortedHint)</code></pre>
         </article>
         
         <article class="function" data-name="order2Ordered">
            <h2>order2Ordered</h2>
            <hr />
            
            <p>order2Ordered returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.</p>
            
            <pre><code>func order2Ordered(data []E, a int, b int, swaps *int) (int, int)</code></pre>
         </article>
         
         <article class="function" data-name="medianOrdered">
            <h2>medianOrdered</h2>
            <hr />
            
            <p>medianOrdered returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</p>
            
            <pre><code>func medianOrdered(data []E, a int, b int, c int, swaps *int) int</code></pre>
         </article>
         
         <article class="function" data-name="medianAdjacentOrdered">
            <h2>medianAdjacentOrdered</h2>
            <hr />
            
            <p>medianAdjacentOrdered finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</p>
            
            <pre><code>func medianAdjacentOrdered(data []E, a int, swaps *int) int</code></pre>
         </article>
         
         <article class="function" data-name="reverseRangeOrdered">
            <h2>reverseRangeOrdered</h2>
            <hr />
            
            <pre><code>func reverseRangeOrdered(data []E, a int, b int)</code></pre>
         </article>
         
         <article class="function" data-name="swapRangeOrdered">
            <h2>swapRangeOrdered</h2>
            <hr />
            
            <pre><code>func swapRangeOrdered(data []E, a int, b int, n int)</code></pre>
         </article>
         
         <article class="function" data-name="stableOrdered">
            <h2>stableOrdered</h2>
            <hr />
            
            <pre><code>func stableOrdered(data []E, n int)</code></pre>
         </article>
         
         <article class="function" data-name="symMergeOrdered">
            <h2>symMergeOrdered</h2>
            <hr />
            
            <p>symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
Computer Science, pages 714-723. Springer, 2004.

Let M = m-a and N = b-n. Wolog M < N.
The recursion depth is bound by ceil(log(N+M)).
The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
The algorithm needs O((M+N)*log(M)) calls to data.Swap.

The paper gives O((M+N)*log(M)) as the number of assignments assuming a
rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
in the paper carries through for Swap operations, especially as the block
swapping rotate uses only O(M+N) Swaps.

symMerge assumes non-degenerate arguments: a < m && m < b.
Having the caller check this condition eliminates many leaf recursion calls,
which improves performance.</p>
            
            <pre><code>func symMergeOrdered(data []E, a int, m int, b int)</code></pre>
         </article>
         
         <article class="function" data-name="rotateOrdered">
            <h2>rotateOrdered</h2>
            <hr />
            
            <p>rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
Data of the form 'x u v y' is changed to 'x v u y'.
rotate performs at most b-a many calls to data.Swap,
and it assumes non-degenerate arguments: a < m && m < b.</p>
            
            <pre><code>func rotateOrdered(data []E, a int, m int, b int)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
