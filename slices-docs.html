<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>slices - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                  
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>slices</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmp"
"cmp"
"iter"
"cmp"
"math/bits"
"unsafe"
"cmp"
"math/bits"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="decreasingHint" data-name="decreasingHint">
               <h3>
                  decreasingHint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#decreasingHint" class="anchor" title="Link to decreasingHint">#</a>
               </h3>
               
               <pre><code class="language-go">const decreasingHint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="increasingHint" data-name="increasingHint">
               <h3>
                  increasingHint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#increasingHint" class="anchor" title="Link to increasingHint">#</a>
               </h3>
               
               <pre><code class="language-go">const increasingHint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unknownHint" data-name="unknownHint">
               <h3>
                  unknownHint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unknownHint" class="anchor" title="Link to unknownHint">#</a>
               </h3>
               
               <pre><code class="language-go">const unknownHint sortedHint = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="sortedHint" data-name="sortedHint">
               <h3>
                  sortedHint
                  <span class="badge type-badge">type</span>
                  <a href="#sortedHint" class="anchor" title="Link to sortedHint">#</a>
               </h3>
               
               <pre><code class="language-go">type sortedHint int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="xorshift" data-name="xorshift">
               <h3>
                  xorshift
                  <span class="badge type-badge">type</span>
                  <a href="#xorshift" class="anchor" title="Link to xorshift">#</a>
               </h3>
               
               <p>xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf</p>
               
               <pre><code class="language-go">type xorshift uint64</code></pre>
            </article>
            
         </section>
            
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="All" data-name="All">
               <h3>
                  All 
                  <span class="badge">function</span>
                  
                  <a href="#All" class="anchor" title="Link to All">#</a>
               </h3>
               
               <p>All returns an iterator over index-value pairs in the slice
in the usual order.</p>
               
               <pre><code class="language-go">func All(s Slice) *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendSeq" data-name="AppendSeq">
               <h3>
                  AppendSeq 
                  <span class="badge">function</span>
                  
                  <a href="#AppendSeq" class="anchor" title="Link to AppendSeq">#</a>
               </h3>
               
               <p>AppendSeq appends the values from seq to the slice and
returns the extended slice.</p>
               
               <pre><code class="language-go">func AppendSeq(s Slice, seq *ast.IndexExpr) Slice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Backward" data-name="Backward">
               <h3>
                  Backward 
                  <span class="badge">function</span>
                  
                  <a href="#Backward" class="anchor" title="Link to Backward">#</a>
               </h3>
               
               <p>Backward returns an iterator over index-value pairs in the slice,
traversing it backward with descending indices.</p>
               
               <pre><code class="language-go">func Backward(s Slice) *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BinarySearch" data-name="BinarySearch">
               <h3>
                  BinarySearch 
                  <span class="badge">function</span>
                  
                  <a href="#BinarySearch" class="anchor" title="Link to BinarySearch">#</a>
               </h3>
               
               <p>BinarySearch searches for target in a sorted slice and returns the earliest
position where target is found, or the position where target would appear
in the sort order; it also returns a bool saying whether the target is
really found in the slice. The slice must be sorted in increasing order.</p>
               
               <pre><code class="language-go">func BinarySearch(x S, target E) (int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BinarySearchFunc" data-name="BinarySearchFunc">
               <h3>
                  BinarySearchFunc 
                  <span class="badge">function</span>
                  
                  <a href="#BinarySearchFunc" class="anchor" title="Link to BinarySearchFunc">#</a>
               </h3>
               
               <p>BinarySearchFunc works like [BinarySearch], but uses a custom comparison
function. The slice must be sorted in increasing order, where "increasing"
is defined by cmp. cmp should return 0 if the slice element matches
the target, a negative number if the slice element precedes the target,
or a positive number if the slice element follows the target.
cmp must implement the same ordering as the slice, such that if
cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.</p>
               
               <pre><code class="language-go">func BinarySearchFunc(x S, target T, cmp func(E, T) int) (int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chunk" data-name="Chunk">
               <h3>
                  Chunk 
                  <span class="badge">function</span>
                  
                  <a href="#Chunk" class="anchor" title="Link to Chunk">#</a>
               </h3>
               
               <p>Chunk returns an iterator over consecutive sub-slices of up to n elements of s.
All but the last sub-slice will have size n.
All sub-slices are clipped to have no capacity beyond the length.
If s is empty, the sequence is empty: there is no empty slice in the sequence.
Chunk panics if n is less than 1.</p>
               
               <pre><code class="language-go">func Chunk(s Slice, n int) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clip" data-name="Clip">
               <h3>
                  Clip 
                  <span class="badge">function</span>
                  
                  <a href="#Clip" class="anchor" title="Link to Clip">#</a>
               </h3>
               
               <p>Clip removes unused capacity from the slice, returning s[:len(s):len(s)].</p>
               
               <pre><code class="language-go">func Clip(s S) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clone" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge">function</span>
                  
                  <a href="#Clone" class="anchor" title="Link to Clone">#</a>
               </h3>
               
               <p>Clone returns a copy of the slice.
The elements are copied using assignment, so this is a shallow clone.
The result may have additional unused capacity.</p>
               
               <pre><code class="language-go">func Clone(s S) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Collect" data-name="Collect">
               <h3>
                  Collect 
                  <span class="badge">function</span>
                  
                  <a href="#Collect" class="anchor" title="Link to Collect">#</a>
               </h3>
               
               <p>Collect collects values from seq into a new slice and returns it.</p>
               
               <pre><code class="language-go">func Collect(seq *ast.IndexExpr) []E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compact" data-name="Compact">
               <h3>
                  Compact 
                  <span class="badge">function</span>
                  
                  <a href="#Compact" class="anchor" title="Link to Compact">#</a>
               </h3>
               
               <p>Compact replaces consecutive runs of equal elements with a single copy.
This is like the uniq command found on Unix.
Compact modifies the contents of the slice s and returns the modified slice,
which may have a smaller length.
Compact zeroes the elements between the new length and the original length.</p>
               
               <pre><code class="language-go">func Compact(s S) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompactFunc" data-name="CompactFunc">
               <h3>
                  CompactFunc 
                  <span class="badge">function</span>
                  
                  <a href="#CompactFunc" class="anchor" title="Link to CompactFunc">#</a>
               </h3>
               
               <p>CompactFunc is like [Compact] but uses an equality function to compare elements.
For runs of elements that compare equal, CompactFunc keeps the first one.
CompactFunc zeroes the elements between the new length and the original length.</p>
               
               <pre><code class="language-go">func CompactFunc(s S, eq func(E, E) bool) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compare" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge">function</span>
                  
                  <a href="#Compare" class="anchor" title="Link to Compare">#</a>
               </h3>
               
               <p>Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
of elements. The elements are compared sequentially, starting at index 0,
until one element is not equal to the other.
The result of comparing the first non-matching elements is returned.
If both slices are equal until one of them ends, the shorter slice is
considered less than the longer one.
The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.</p>
               
               <pre><code class="language-go">func Compare(s1 S, s2 S) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareFunc" data-name="CompareFunc">
               <h3>
                  CompareFunc 
                  <span class="badge">function</span>
                  
                  <a href="#CompareFunc" class="anchor" title="Link to CompareFunc">#</a>
               </h3>
               
               <p>CompareFunc is like [Compare] but uses a custom comparison function on each
pair of elements.
The result is the first non-zero result of cmp; if cmp always
returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
and +1 if len(s1) > len(s2).</p>
               
               <pre><code class="language-go">func CompareFunc(s1 S1, s2 S2, cmp func(E1, E2) int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Concat" data-name="Concat">
               <h3>
                  Concat 
                  <span class="badge">function</span>
                  
                  <a href="#Concat" class="anchor" title="Link to Concat">#</a>
               </h3>
               
               <p>Concat returns a new slice concatenating the passed in slices.</p>
               
               <pre><code class="language-go">func Concat(slices ...S) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Contains" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge">function</span>
                  
                  <a href="#Contains" class="anchor" title="Link to Contains">#</a>
               </h3>
               
               <p>Contains reports whether v is present in s.</p>
               
               <pre><code class="language-go">func Contains(s S, v E) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ContainsFunc" data-name="ContainsFunc">
               <h3>
                  ContainsFunc 
                  <span class="badge">function</span>
                  
                  <a href="#ContainsFunc" class="anchor" title="Link to ContainsFunc">#</a>
               </h3>
               
               <p>ContainsFunc reports whether at least one
element e of s satisfies f(e).</p>
               
               <pre><code class="language-go">func ContainsFunc(s S, f func(E) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge">function</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <p>Delete removes the elements s[i:j] from s, returning the modified slice.
Delete panics if j > len(s) or s[i:j] is not a valid slice of s.
Delete is O(len(s)-i), so if many items must be deleted, it is better to
make a single call deleting them all together than to delete one at a time.
Delete zeroes the elements s[len(s)-(j-i):len(s)].</p>
               
               <pre><code class="language-go">func Delete(s S, i int, j int) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DeleteFunc" data-name="DeleteFunc">
               <h3>
                  DeleteFunc 
                  <span class="badge">function</span>
                  
                  <a href="#DeleteFunc" class="anchor" title="Link to DeleteFunc">#</a>
               </h3>
               
               <p>DeleteFunc removes any elements from s for which del returns true,
returning the modified slice.
DeleteFunc zeroes the elements between the new length and the original length.</p>
               
               <pre><code class="language-go">func DeleteFunc(s S, del func(E) bool) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge">function</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether two slices are equal: the same length and all
elements equal. If the lengths are different, Equal returns false.
Otherwise, the elements are compared in increasing index order, and the
comparison stops at the first unequal pair.
Empty and nil slices are considered equal.
Floating point NaNs are not considered equal.</p>
               
               <pre><code class="language-go">func Equal(s1 S, s2 S) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EqualFunc" data-name="EqualFunc">
               <h3>
                  EqualFunc 
                  <span class="badge">function</span>
                  
                  <a href="#EqualFunc" class="anchor" title="Link to EqualFunc">#</a>
               </h3>
               
               <p>EqualFunc reports whether two slices are equal using an equality
function on each pair of elements. If the lengths are different,
EqualFunc returns false. Otherwise, the elements are compared in
increasing index order, and the comparison stops at the first index
for which eq returns false.</p>
               
               <pre><code class="language-go">func EqualFunc(s1 S1, s2 S2, eq func(E1, E2) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Grow" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge">function</span>
                  
                  <a href="#Grow" class="anchor" title="Link to Grow">#</a>
               </h3>
               
               <p>Grow increases the slice's capacity, if necessary, to guarantee space for
another n elements. After Grow(n), at least n elements can be appended
to the slice without another allocation. If n is negative or too large to
allocate the memory, Grow panics.</p>
               
               <pre><code class="language-go">func Grow(s S, n int) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Index" data-name="Index">
               <h3>
                  Index 
                  <span class="badge">function</span>
                  
                  <a href="#Index" class="anchor" title="Link to Index">#</a>
               </h3>
               
               <p>Index returns the index of the first occurrence of v in s,
or -1 if not present.</p>
               
               <pre><code class="language-go">func Index(s S, v E) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexFunc" data-name="IndexFunc">
               <h3>
                  IndexFunc 
                  <span class="badge">function</span>
                  
                  <a href="#IndexFunc" class="anchor" title="Link to IndexFunc">#</a>
               </h3>
               
               <p>IndexFunc returns the first index i satisfying f(s[i]),
or -1 if none do.</p>
               
               <pre><code class="language-go">func IndexFunc(s S, f func(E) bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Insert" data-name="Insert">
               <h3>
                  Insert 
                  <span class="badge">function</span>
                  
                  <a href="#Insert" class="anchor" title="Link to Insert">#</a>
               </h3>
               
               <p>Insert inserts the values v... into s at index i,
returning the modified slice.
The elements at s[i:] are shifted up to make room.
In the returned slice r, r[i] == v[0],
and, if i < len(s), r[i+len(v)] == value originally at r[i].
Insert panics if i > len(s).
This function is O(len(s) + len(v)).</p>
               
               <pre><code class="language-go">func Insert(s S, i int, v ...E) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsSorted" data-name="IsSorted">
               <h3>
                  IsSorted 
                  <span class="badge">function</span>
                  
                  <a href="#IsSorted" class="anchor" title="Link to IsSorted">#</a>
               </h3>
               
               <p>IsSorted reports whether x is sorted in ascending order.</p>
               
               <pre><code class="language-go">func IsSorted(x S) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsSortedFunc" data-name="IsSortedFunc">
               <h3>
                  IsSortedFunc 
                  <span class="badge">function</span>
                  
                  <a href="#IsSortedFunc" class="anchor" title="Link to IsSortedFunc">#</a>
               </h3>
               
               <p>IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
comparison function as defined by [SortFunc].</p>
               
               <pre><code class="language-go">func IsSortedFunc(x S, cmp func(a E, b E) int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Max" data-name="Max">
               <h3>
                  Max 
                  <span class="badge">function</span>
                  
                  <a href="#Max" class="anchor" title="Link to Max">#</a>
               </h3>
               
               <p>Max returns the maximal value in x. It panics if x is empty.
For floating-point E, Max propagates NaNs (any NaN value in x
forces the output to be NaN).</p>
               
               <pre><code class="language-go">func Max(x S) E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MaxFunc" data-name="MaxFunc">
               <h3>
                  MaxFunc 
                  <span class="badge">function</span>
                  
                  <a href="#MaxFunc" class="anchor" title="Link to MaxFunc">#</a>
               </h3>
               
               <p>MaxFunc returns the maximal value in x, using cmp to compare elements.
It panics if x is empty. If there is more than one maximal element
according to the cmp function, MaxFunc returns the first one.</p>
               
               <pre><code class="language-go">func MaxFunc(x S, cmp func(a E, b E) int) E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Min" data-name="Min">
               <h3>
                  Min 
                  <span class="badge">function</span>
                  
                  <a href="#Min" class="anchor" title="Link to Min">#</a>
               </h3>
               
               <p>Min returns the minimal value in x. It panics if x is empty.
For floating-point numbers, Min propagates NaNs (any NaN value in x
forces the output to be NaN).</p>
               
               <pre><code class="language-go">func Min(x S) E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MinFunc" data-name="MinFunc">
               <h3>
                  MinFunc 
                  <span class="badge">function</span>
                  
                  <a href="#MinFunc" class="anchor" title="Link to MinFunc">#</a>
               </h3>
               
               <p>MinFunc returns the minimal value in x, using cmp to compare elements.
It panics if x is empty. If there is more than one minimal element
according to the cmp function, MinFunc returns the first one.</p>
               
               <pre><code class="language-go">func MinFunc(x S, cmp func(a E, b E) int) E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *xorshift) Next() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Repeat" data-name="Repeat">
               <h3>
                  Repeat 
                  <span class="badge">function</span>
                  
                  <a href="#Repeat" class="anchor" title="Link to Repeat">#</a>
               </h3>
               
               <p>Repeat returns a new slice that repeats the provided slice the given number of times.
The result has length and capacity (len(x) * count).
The result is never nil.
Repeat panics if count is negative or if the result of (len(x) * count)
overflows.</p>
               
               <pre><code class="language-go">func Repeat(x S, count int) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Replace" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge">function</span>
                  
                  <a href="#Replace" class="anchor" title="Link to Replace">#</a>
               </h3>
               
               <p>Replace replaces the elements s[i:j] by the given v, and returns the
modified slice.
Replace panics if j > len(s) or s[i:j] is not a valid slice of s.
When len(v) < (j-i), Replace zeroes the elements between the new length and the original length.</p>
               
               <pre><code class="language-go">func Replace(s S, i int, j int, v ...E) S</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reverse" data-name="Reverse">
               <h3>
                  Reverse 
                  <span class="badge">function</span>
                  
                  <a href="#Reverse" class="anchor" title="Link to Reverse">#</a>
               </h3>
               
               <p>Reverse reverses the elements of the slice in place.</p>
               
               <pre><code class="language-go">func Reverse(s S)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sort" data-name="Sort">
               <h3>
                  Sort 
                  <span class="badge">function</span>
                  
                  <a href="#Sort" class="anchor" title="Link to Sort">#</a>
               </h3>
               
               <p>Sort sorts a slice of any ordered type in ascending order.
When sorting floating-point numbers, NaNs are ordered before other values.</p>
               
               <pre><code class="language-go">func Sort(x S)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortFunc" data-name="SortFunc">
               <h3>
                  SortFunc 
                  <span class="badge">function</span>
                  
                  <a href="#SortFunc" class="anchor" title="Link to SortFunc">#</a>
               </h3>
               
               <p>SortFunc sorts the slice x in ascending order as determined by the cmp
function. This sort is not guaranteed to be stable.
cmp(a, b) should return a negative number when a < b, a positive number when
a > b and zero when a == b or a and b are incomparable in the sense of
a strict weak ordering.
SortFunc requires that cmp is a strict weak ordering.
See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.
The function should return 0 for incomparable items.</p>
               
               <pre><code class="language-go">func SortFunc(x S, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortStableFunc" data-name="SortStableFunc">
               <h3>
                  SortStableFunc 
                  <span class="badge">function</span>
                  
                  <a href="#SortStableFunc" class="anchor" title="Link to SortStableFunc">#</a>
               </h3>
               
               <p>SortStableFunc sorts the slice x while keeping the original order of equal
elements, using cmp to compare elements in the same way as [SortFunc].</p>
               
               <pre><code class="language-go">func SortStableFunc(x S, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sorted" data-name="Sorted">
               <h3>
                  Sorted 
                  <span class="badge">function</span>
                  
                  <a href="#Sorted" class="anchor" title="Link to Sorted">#</a>
               </h3>
               
               <p>Sorted collects values from seq into a new slice, sorts the slice,
and returns it.</p>
               
               <pre><code class="language-go">func Sorted(seq *ast.IndexExpr) []E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortedFunc" data-name="SortedFunc">
               <h3>
                  SortedFunc 
                  <span class="badge">function</span>
                  
                  <a href="#SortedFunc" class="anchor" title="Link to SortedFunc">#</a>
               </h3>
               
               <p>SortedFunc collects values from seq into a new slice, sorts the slice
using the comparison function, and returns it.</p>
               
               <pre><code class="language-go">func SortedFunc(seq *ast.IndexExpr, cmp func(E, E) int) []E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortedStableFunc" data-name="SortedStableFunc">
               <h3>
                  SortedStableFunc 
                  <span class="badge">function</span>
                  
                  <a href="#SortedStableFunc" class="anchor" title="Link to SortedStableFunc">#</a>
               </h3>
               
               <p>SortedStableFunc collects values from seq into a new slice.
It then sorts the slice while keeping the original order of equal elements,
using the comparison function to compare elements.
It returns the new slice.</p>
               
               <pre><code class="language-go">func SortedStableFunc(seq *ast.IndexExpr, cmp func(E, E) int) []E</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Values" data-name="Values">
               <h3>
                  Values 
                  <span class="badge">function</span>
                  
                  <a href="#Values" class="anchor" title="Link to Values">#</a>
               </h3>
               
               <p>Values returns an iterator that yields the slice elements in order.</p>
               
               <pre><code class="language-go">func Values(s Slice) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="breakPatternsCmpFunc" data-name="breakPatternsCmpFunc">
               <h3>
                  breakPatternsCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#breakPatternsCmpFunc" class="anchor" title="Link to breakPatternsCmpFunc">#</a>
               </h3>
               
               <p>breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
that might cause imbalanced partitions in quicksort.</p>
               
               <pre><code class="language-go">func breakPatternsCmpFunc(data []E, a int, b int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="breakPatternsOrdered" data-name="breakPatternsOrdered">
               <h3>
                  breakPatternsOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#breakPatternsOrdered" class="anchor" title="Link to breakPatternsOrdered">#</a>
               </h3>
               
               <p>breakPatternsOrdered scatters some elements around in an attempt to break some patterns
that might cause imbalanced partitions in quicksort.</p>
               
               <pre><code class="language-go">func breakPatternsOrdered(data []E, a int, b int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="choosePivotCmpFunc" data-name="choosePivotCmpFunc">
               <h3>
                  choosePivotCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#choosePivotCmpFunc" class="anchor" title="Link to choosePivotCmpFunc">#</a>
               </h3>
               
               <p>choosePivotCmpFunc chooses a pivot in data[a:b].
[0,8): chooses a static pivot.
[8,shortestNinther): uses the simple median-of-three method.
[shortestNinther,∞): uses the Tukey ninther method.</p>
               
               <pre><code class="language-go">func choosePivotCmpFunc(data []E, a int, b int, cmp func(a E, b E) int) (pivot int, hint sortedHint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="choosePivotOrdered" data-name="choosePivotOrdered">
               <h3>
                  choosePivotOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#choosePivotOrdered" class="anchor" title="Link to choosePivotOrdered">#</a>
               </h3>
               
               <p>choosePivotOrdered chooses a pivot in data[a:b].
[0,8): chooses a static pivot.
[8,shortestNinther): uses the simple median-of-three method.
[shortestNinther,∞): uses the Tukey ninther method.</p>
               
               <pre><code class="language-go">func choosePivotOrdered(data []E, a int, b int) (pivot int, hint sortedHint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="heapSortCmpFunc" data-name="heapSortCmpFunc">
               <h3>
                  heapSortCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#heapSortCmpFunc" class="anchor" title="Link to heapSortCmpFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func heapSortCmpFunc(data []E, a int, b int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="heapSortOrdered" data-name="heapSortOrdered">
               <h3>
                  heapSortOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#heapSortOrdered" class="anchor" title="Link to heapSortOrdered">#</a>
               </h3>
               
               <pre><code class="language-go">func heapSortOrdered(data []E, a int, b int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insertionSortCmpFunc" data-name="insertionSortCmpFunc">
               <h3>
                  insertionSortCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#insertionSortCmpFunc" class="anchor" title="Link to insertionSortCmpFunc">#</a>
               </h3>
               
               <p>insertionSortCmpFunc sorts data[a:b] using insertion sort.</p>
               
               <pre><code class="language-go">func insertionSortCmpFunc(data []E, a int, b int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insertionSortOrdered" data-name="insertionSortOrdered">
               <h3>
                  insertionSortOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#insertionSortOrdered" class="anchor" title="Link to insertionSortOrdered">#</a>
               </h3>
               
               <p>insertionSortOrdered sorts data[a:b] using insertion sort.</p>
               
               <pre><code class="language-go">func insertionSortOrdered(data []E, a int, b int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNaN" data-name="isNaN">
               <h3>
                  isNaN 
                  <span class="badge">function</span>
                  
                  <a href="#isNaN" class="anchor" title="Link to isNaN">#</a>
               </h3>
               
               <p>isNaN reports whether x is a NaN without requiring the math package.
This will always return false if T is not floating-point.</p>
               
               <pre><code class="language-go">func isNaN(x T) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="medianAdjacentCmpFunc" data-name="medianAdjacentCmpFunc">
               <h3>
                  medianAdjacentCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#medianAdjacentCmpFunc" class="anchor" title="Link to medianAdjacentCmpFunc">#</a>
               </h3>
               
               <p>medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</p>
               
               <pre><code class="language-go">func medianAdjacentCmpFunc(data []E, a int, swaps *int, cmp func(a E, b E) int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="medianAdjacentOrdered" data-name="medianAdjacentOrdered">
               <h3>
                  medianAdjacentOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#medianAdjacentOrdered" class="anchor" title="Link to medianAdjacentOrdered">#</a>
               </h3>
               
               <p>medianAdjacentOrdered finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</p>
               
               <pre><code class="language-go">func medianAdjacentOrdered(data []E, a int, swaps *int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="medianCmpFunc" data-name="medianCmpFunc">
               <h3>
                  medianCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#medianCmpFunc" class="anchor" title="Link to medianCmpFunc">#</a>
               </h3>
               
               <p>medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</p>
               
               <pre><code class="language-go">func medianCmpFunc(data []E, a int, b int, c int, swaps *int, cmp func(a E, b E) int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="medianOrdered" data-name="medianOrdered">
               <h3>
                  medianOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#medianOrdered" class="anchor" title="Link to medianOrdered">#</a>
               </h3>
               
               <p>medianOrdered returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</p>
               
               <pre><code class="language-go">func medianOrdered(data []E, a int, b int, c int, swaps *int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextPowerOfTwo" data-name="nextPowerOfTwo">
               <h3>
                  nextPowerOfTwo 
                  <span class="badge">function</span>
                  
                  <a href="#nextPowerOfTwo" class="anchor" title="Link to nextPowerOfTwo">#</a>
               </h3>
               
               <pre><code class="language-go">func nextPowerOfTwo(length int) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="order2CmpFunc" data-name="order2CmpFunc">
               <h3>
                  order2CmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#order2CmpFunc" class="anchor" title="Link to order2CmpFunc">#</a>
               </h3>
               
               <p>order2CmpFunc returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.</p>
               
               <pre><code class="language-go">func order2CmpFunc(data []E, a int, b int, swaps *int, cmp func(a E, b E) int) (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="order2Ordered" data-name="order2Ordered">
               <h3>
                  order2Ordered 
                  <span class="badge">function</span>
                  
                  <a href="#order2Ordered" class="anchor" title="Link to order2Ordered">#</a>
               </h3>
               
               <p>order2Ordered returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.</p>
               
               <pre><code class="language-go">func order2Ordered(data []E, a int, b int, swaps *int) (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="overlaps" data-name="overlaps">
               <h3>
                  overlaps 
                  <span class="badge">function</span>
                  
                  <a href="#overlaps" class="anchor" title="Link to overlaps">#</a>
               </h3>
               
               <p>overlaps reports whether the memory ranges a[:len(a)] and b[:len(b)] overlap.</p>
               
               <pre><code class="language-go">func overlaps(a []E, b []E) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="partialInsertionSortCmpFunc" data-name="partialInsertionSortCmpFunc">
               <h3>
                  partialInsertionSortCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#partialInsertionSortCmpFunc" class="anchor" title="Link to partialInsertionSortCmpFunc">#</a>
               </h3>
               
               <p>partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.</p>
               
               <pre><code class="language-go">func partialInsertionSortCmpFunc(data []E, a int, b int, cmp func(a E, b E) int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="partialInsertionSortOrdered" data-name="partialInsertionSortOrdered">
               <h3>
                  partialInsertionSortOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#partialInsertionSortOrdered" class="anchor" title="Link to partialInsertionSortOrdered">#</a>
               </h3>
               
               <p>partialInsertionSortOrdered partially sorts a slice, returns true if the slice is sorted at the end.</p>
               
               <pre><code class="language-go">func partialInsertionSortOrdered(data []E, a int, b int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="partitionCmpFunc" data-name="partitionCmpFunc">
               <h3>
                  partitionCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#partitionCmpFunc" class="anchor" title="Link to partitionCmpFunc">#</a>
               </h3>
               
               <p>partitionCmpFunc does one quicksort partition.
Let p = data[pivot]
Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
On return, data[newpivot] = p</p>
               
               <pre><code class="language-go">func partitionCmpFunc(data []E, a int, b int, pivot int, cmp func(a E, b E) int) (newpivot int, alreadyPartitioned bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="partitionEqualCmpFunc" data-name="partitionEqualCmpFunc">
               <h3>
                  partitionEqualCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#partitionEqualCmpFunc" class="anchor" title="Link to partitionEqualCmpFunc">#</a>
               </h3>
               
               <p>partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
It assumed that data[a:b] does not contain elements smaller than the data[pivot].</p>
               
               <pre><code class="language-go">func partitionEqualCmpFunc(data []E, a int, b int, pivot int, cmp func(a E, b E) int) (newpivot int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="partitionEqualOrdered" data-name="partitionEqualOrdered">
               <h3>
                  partitionEqualOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#partitionEqualOrdered" class="anchor" title="Link to partitionEqualOrdered">#</a>
               </h3>
               
               <p>partitionEqualOrdered partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
It assumed that data[a:b] does not contain elements smaller than the data[pivot].</p>
               
               <pre><code class="language-go">func partitionEqualOrdered(data []E, a int, b int, pivot int) (newpivot int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="partitionOrdered" data-name="partitionOrdered">
               <h3>
                  partitionOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#partitionOrdered" class="anchor" title="Link to partitionOrdered">#</a>
               </h3>
               
               <p>partitionOrdered does one quicksort partition.
Let p = data[pivot]
Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
On return, data[newpivot] = p</p>
               
               <pre><code class="language-go">func partitionOrdered(data []E, a int, b int, pivot int) (newpivot int, alreadyPartitioned bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pdqsortCmpFunc" data-name="pdqsortCmpFunc">
               <h3>
                  pdqsortCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#pdqsortCmpFunc" class="anchor" title="Link to pdqsortCmpFunc">#</a>
               </h3>
               
               <p>pdqsortCmpFunc sorts data[a:b].
The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
C++ implementation: https://github.com/orlp/pdqsort
Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</p>
               
               <pre><code class="language-go">func pdqsortCmpFunc(data []E, a int, b int, limit int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pdqsortOrdered" data-name="pdqsortOrdered">
               <h3>
                  pdqsortOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#pdqsortOrdered" class="anchor" title="Link to pdqsortOrdered">#</a>
               </h3>
               
               <p>pdqsortOrdered sorts data[a:b].
The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
C++ implementation: https://github.com/orlp/pdqsort
Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</p>
               
               <pre><code class="language-go">func pdqsortOrdered(data []E, a int, b int, limit int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reverseRangeCmpFunc" data-name="reverseRangeCmpFunc">
               <h3>
                  reverseRangeCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#reverseRangeCmpFunc" class="anchor" title="Link to reverseRangeCmpFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func reverseRangeCmpFunc(data []E, a int, b int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reverseRangeOrdered" data-name="reverseRangeOrdered">
               <h3>
                  reverseRangeOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#reverseRangeOrdered" class="anchor" title="Link to reverseRangeOrdered">#</a>
               </h3>
               
               <pre><code class="language-go">func reverseRangeOrdered(data []E, a int, b int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rotateCmpFunc" data-name="rotateCmpFunc">
               <h3>
                  rotateCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#rotateCmpFunc" class="anchor" title="Link to rotateCmpFunc">#</a>
               </h3>
               
               <p>rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
Data of the form 'x u v y' is changed to 'x v u y'.
rotate performs at most b-a many calls to data.Swap,
and it assumes non-degenerate arguments: a < m && m < b.</p>
               
               <pre><code class="language-go">func rotateCmpFunc(data []E, a int, m int, b int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rotateLeft" data-name="rotateLeft">
               <h3>
                  rotateLeft 
                  <span class="badge">function</span>
                  
                  <a href="#rotateLeft" class="anchor" title="Link to rotateLeft">#</a>
               </h3>
               
               <p>rotateLeft rotates s left by r spaces.
s_final[i] = s_orig[i+r], wrapping around.</p>
               
               <pre><code class="language-go">func rotateLeft(s []E, r int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rotateOrdered" data-name="rotateOrdered">
               <h3>
                  rotateOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#rotateOrdered" class="anchor" title="Link to rotateOrdered">#</a>
               </h3>
               
               <p>rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
Data of the form 'x u v y' is changed to 'x v u y'.
rotate performs at most b-a many calls to data.Swap,
and it assumes non-degenerate arguments: a < m && m < b.</p>
               
               <pre><code class="language-go">func rotateOrdered(data []E, a int, m int, b int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rotateRight" data-name="rotateRight">
               <h3>
                  rotateRight 
                  <span class="badge">function</span>
                  
                  <a href="#rotateRight" class="anchor" title="Link to rotateRight">#</a>
               </h3>
               
               <pre><code class="language-go">func rotateRight(s []E, r int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="siftDownCmpFunc" data-name="siftDownCmpFunc">
               <h3>
                  siftDownCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#siftDownCmpFunc" class="anchor" title="Link to siftDownCmpFunc">#</a>
               </h3>
               
               <p>siftDownCmpFunc implements the heap property on data[lo:hi].
first is an offset into the array where the root of the heap lies.</p>
               
               <pre><code class="language-go">func siftDownCmpFunc(data []E, lo int, hi int, first int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="siftDownOrdered" data-name="siftDownOrdered">
               <h3>
                  siftDownOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#siftDownOrdered" class="anchor" title="Link to siftDownOrdered">#</a>
               </h3>
               
               <p>siftDownOrdered implements the heap property on data[lo:hi].
first is an offset into the array where the root of the heap lies.</p>
               
               <pre><code class="language-go">func siftDownOrdered(data []E, lo int, hi int, first int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stableCmpFunc" data-name="stableCmpFunc">
               <h3>
                  stableCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#stableCmpFunc" class="anchor" title="Link to stableCmpFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func stableCmpFunc(data []E, n int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stableOrdered" data-name="stableOrdered">
               <h3>
                  stableOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#stableOrdered" class="anchor" title="Link to stableOrdered">#</a>
               </h3>
               
               <pre><code class="language-go">func stableOrdered(data []E, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startIdx" data-name="startIdx">
               <h3>
                  startIdx 
                  <span class="badge">function</span>
                  
                  <a href="#startIdx" class="anchor" title="Link to startIdx">#</a>
               </h3>
               
               <p>startIdx returns the index in haystack where the needle starts.
prerequisite: the needle must be aliased entirely inside the haystack.</p>
               
               <pre><code class="language-go">func startIdx(haystack []E, needle []E) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swapRangeCmpFunc" data-name="swapRangeCmpFunc">
               <h3>
                  swapRangeCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#swapRangeCmpFunc" class="anchor" title="Link to swapRangeCmpFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func swapRangeCmpFunc(data []E, a int, b int, n int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swapRangeOrdered" data-name="swapRangeOrdered">
               <h3>
                  swapRangeOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#swapRangeOrdered" class="anchor" title="Link to swapRangeOrdered">#</a>
               </h3>
               
               <pre><code class="language-go">func swapRangeOrdered(data []E, a int, b int, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="symMergeCmpFunc" data-name="symMergeCmpFunc">
               <h3>
                  symMergeCmpFunc 
                  <span class="badge">function</span>
                  
                  <a href="#symMergeCmpFunc" class="anchor" title="Link to symMergeCmpFunc">#</a>
               </h3>
               
               <p>symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
Computer Science, pages 714-723. Springer, 2004.
Let M = m-a and N = b-n. Wolog M < N.
The recursion depth is bound by ceil(log(N+M)).
The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
The algorithm needs O((M+N)*log(M)) calls to data.Swap.
The paper gives O((M+N)*log(M)) as the number of assignments assuming a
rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
in the paper carries through for Swap operations, especially as the block
swapping rotate uses only O(M+N) Swaps.
symMerge assumes non-degenerate arguments: a < m && m < b.
Having the caller check this condition eliminates many leaf recursion calls,
which improves performance.</p>
               
               <pre><code class="language-go">func symMergeCmpFunc(data []E, a int, m int, b int, cmp func(a E, b E) int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="symMergeOrdered" data-name="symMergeOrdered">
               <h3>
                  symMergeOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#symMergeOrdered" class="anchor" title="Link to symMergeOrdered">#</a>
               </h3>
               
               <p>symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
Computer Science, pages 714-723. Springer, 2004.
Let M = m-a and N = b-n. Wolog M < N.
The recursion depth is bound by ceil(log(N+M)).
The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
The algorithm needs O((M+N)*log(M)) calls to data.Swap.
The paper gives O((M+N)*log(M)) as the number of assignments assuming a
rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
in the paper carries through for Swap operations, especially as the block
swapping rotate uses only O(M+N) Swaps.
symMerge assumes non-degenerate arguments: a < m && m < b.
Having the caller check this condition eliminates many leaf recursion calls,
which improves performance.</p>
               
               <pre><code class="language-go">func symMergeOrdered(data []E, a int, m int, b int)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>