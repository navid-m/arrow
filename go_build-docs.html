<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - build</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="go_build_constraint-docs.html">constraint</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>build</code>
         </h1>
         <hr />
         
         <article class="global" data-name="thisOS">
            <h2>thisOS</h2>
            <hr />
            
            <pre><code>thisOS</code></pre>
         </article>
         
         <article class="global" data-name="thisArch">
            <h2>thisArch</h2>
            <hr />
            
            <pre><code>thisArch</code></pre>
         </article>
         
         <article class="global" data-name="otherOS">
            <h2>otherOS</h2>
            <hr />
            
            <pre><code>otherOS</code></pre>
         </article>
         
         <article class="global" data-name="otherArch">
            <h2>otherArch</h2>
            <hr />
            
            <pre><code>otherArch</code></pre>
         </article>
         
         <article class="global" data-name="tests">
            <h2>tests</h2>
            <hr />
            
            <pre><code>tests</code></pre>
         </article>
         
         <article class="global" data-name="allowedPackagePrefixes">
            <h2>allowedPackagePrefixes</h2>
            <hr />
            
            <p>Prefixes for packages that can be vendored into the go repo.
The prefixes are component-wise; for example, "golang.org/x"
matches "golang.org/x/build" but not "golang.org/xyz".

DO NOT ADD TO THIS LIST TO FIX BUILDS.
Vendoring a new package requires prior discussion.</p>
            
            <pre><code>allowedPackagePrefixes</code></pre>
         </article>
         
         <article class="global" data-name="quote">
            <h2>quote</h2>
            <hr />
            
            <pre><code>quote</code></pre>
         </article>
         
         <article class="global" data-name="readGoInfoTests">
            <h2>readGoInfoTests</h2>
            <hr />
            
            <pre><code>readGoInfoTests</code></pre>
         </article>
         
         <article class="global" data-name="readCommentsTests">
            <h2>readCommentsTests</h2>
            <hr />
            
            <pre><code>readCommentsTests</code></pre>
         </article>
         
         <article class="global" data-name="readFailuresTests">
            <h2>readFailuresTests</h2>
            <hr />
            
            <pre><code>readFailuresTests</code></pre>
         </article>
         
         <article class="global" data-name="readEmbedTests">
            <h2>readEmbedTests</h2>
            <hr />
            
            <pre><code>readEmbedTests</code></pre>
         </article>
         
         <article class="global" data-name="defaultCGO_ENABLED">
            <h2>defaultCGO_ENABLED</h2>
            <hr />
            
            <pre><code>defaultCGO_ENABLED</code></pre>
         </article>
         
         <article class="global" data-name="Default">
            <h2>Default</h2>
            <hr />
            
            <p>Default is the default Context for builds.
It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables
if set, or else the compiled code's GOARCH, GOOS, and GOROOT.</p>
            
            <pre><code>Default Context</code></pre>
         </article>
         
         <article class="global" data-name="defaultToolTags">
            <h2>defaultToolTags</h2>
            <hr />
            
            <p>defaultToolTags should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
  - github.com/gopherjs/gopherjs

Do not remove or change the type signature.
See go.dev/issue/67401.</p>
            
            <pre><code>defaultToolTags []string</code></pre>
         </article>
         
         <article class="global" data-name="defaultReleaseTags">
            <h2>defaultReleaseTags</h2>
            <hr />
            
            <p>defaultReleaseTags should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
  - github.com/gopherjs/gopherjs

Do not remove or change the type signature.
See go.dev/issue/67401.</p>
            
            <pre><code>defaultReleaseTags []string</code></pre>
         </article>
         
         <article class="global" data-name="FindOnly">
            <h2>FindOnly</h2>
            <hr />
            
            <p>If FindOnly is set, Import stops after locating the directory
that should contain the sources for a package. It does not
read any files in the directory.</p>
            
            <pre><code>FindOnly ImportMode</code></pre>
         </article>
         
         <article class="global" data-name="AllowBinary">
            <h2>AllowBinary</h2>
            <hr />
            
            <p>If AllowBinary is set, Import can be satisfied by a compiled
package object without corresponding sources.

Deprecated:
The supported way to create a compiled-only package is to
write source code containing a //go:binary-only-package comment at
the top of the file. Such a package will be recognized
regardless of this flag setting (because it has source code)
and will have BinaryOnly set to true in the returned Package.</p>
            
            <pre><code>AllowBinary</code></pre>
         </article>
         
         <article class="global" data-name="ImportComment">
            <h2>ImportComment</h2>
            <hr />
            
            <p>If ImportComment is set, parse import comments on package statements.
Import returns an error if it finds a comment it cannot understand
or finds conflicting comments in multiple source files.
See golang.org/s/go14customimport for more information.</p>
            
            <pre><code>ImportComment</code></pre>
         </article>
         
         <article class="global" data-name="IgnoreVendor">
            <h2>IgnoreVendor</h2>
            <hr />
            
            <p>By default, Import searches vendor directories
that apply in the given source directory before searching
the GOROOT and GOPATH roots.
If an Import finds and returns a package using a vendor
directory, the resulting ImportPath is the complete path
to the package, including the path elements leading up
to and including "vendor".
For example, if Import("y", "x/subdir", 0) finds
"x/vendor/y", the returned package's ImportPath is "x/vendor/y",
not plain "y".
See golang.org/s/go15vendor for more information.

Setting IgnoreVendor ignores vendor directories.

In contrast to the package's ImportPath,
the returned package's Imports, TestImports, and XTestImports
are always the exact import paths from the source files:
Import makes no attempt to resolve or check those paths.</p>
            
            <pre><code>IgnoreVendor</code></pre>
         </article>
         
         <article class="global" data-name="installgoroot">
            <h2>installgoroot</h2>
            <hr />
            
            <pre><code>installgoroot</code></pre>
         </article>
         
         <article class="global" data-name="errNoModules">
            <h2>errNoModules</h2>
            <hr />
            
            <pre><code>errNoModules</code></pre>
         </article>
         
         <article class="global" data-name="slashSlash">
            <h2>slashSlash</h2>
            <hr />
            
            <pre><code>slashSlash</code></pre>
         </article>
         
         <article class="global" data-name="slashStar">
            <h2>slashStar</h2>
            <hr />
            
            <pre><code>slashStar</code></pre>
         </article>
         
         <article class="global" data-name="starSlash">
            <h2>starSlash</h2>
            <hr />
            
            <pre><code>starSlash</code></pre>
         </article>
         
         <article class="global" data-name="newline">
            <h2>newline</h2>
            <hr />
            
            <pre><code>newline</code></pre>
         </article>
         
         <article class="global" data-name="dummyPkg">
            <h2>dummyPkg</h2>
            <hr />
            
            <pre><code>dummyPkg Package</code></pre>
         </article>
         
         <article class="global" data-name="plusBuild">
            <h2>plusBuild</h2>
            <hr />
            
            <pre><code>plusBuild</code></pre>
         </article>
         
         <article class="global" data-name="goBuildComment">
            <h2>goBuildComment</h2>
            <hr />
            
            <pre><code>goBuildComment</code></pre>
         </article>
         
         <article class="global" data-name="errMultipleGoBuild">
            <h2>errMultipleGoBuild</h2>
            <hr />
            
            <pre><code>errMultipleGoBuild</code></pre>
         </article>
         
         <article class="global" data-name="binaryOnlyComment">
            <h2>binaryOnlyComment</h2>
            <hr />
            
            <p>Special comment denoting a binary-only package.
See https://golang.org/design/2775-binary-only-packages
for more about the design of binary-only packages.</p>
            
            <pre><code>binaryOnlyComment</code></pre>
         </article>
         
         <article class="global" data-name="safeString">
            <h2>safeString</h2>
            <hr />
            
            <p>NOTE: $ is not safe for the shell, but it is allowed here because of linker options like -Wl,$ORIGIN.
We never pass these arguments to a shell (just to programs we construct argv for), so this should be okay.
See golang.org/issue/6038.
The @ is for OS X. See golang.org/issue/13720.
The % is for Jenkins. See golang.org/issue/16959.
The ! is because module paths may use them. See golang.org/issue/26716.
The ~ and ^ are for sr.ht. See golang.org/issue/32260.</p>
            
            <pre><code>safeString</code></pre>
         </article>
         
         <article class="global" data-name="ToolDir">
            <h2>ToolDir</h2>
            <hr />
            
            <p>ToolDir is the directory containing build tools.</p>
            
            <pre><code>ToolDir</code></pre>
         </article>
         
         <article class="global" data-name="shouldBuildTests">
            <h2>shouldBuildTests</h2>
            <hr />
            
            <pre><code>shouldBuildTests</code></pre>
         </article>
         
         <article class="global" data-name="ctxtP9">
            <h2>ctxtP9</h2>
            <hr />
            
            <pre><code>ctxtP9</code></pre>
         </article>
         
         <article class="global" data-name="ctxtAndroid">
            <h2>ctxtAndroid</h2>
            <hr />
            
            <pre><code>ctxtAndroid</code></pre>
         </article>
         
         <article class="global" data-name="matchFileTests">
            <h2>matchFileTests</h2>
            <hr />
            
            <pre><code>matchFileTests</code></pre>
         </article>
         
         <article class="global" data-name="expandSrcDirPath">
            <h2>expandSrcDirPath</h2>
            <hr />
            
            <pre><code>expandSrcDirPath</code></pre>
         </article>
         
         <article class="global" data-name="expandSrcDirTests">
            <h2>expandSrcDirTests</h2>
            <hr />
            
            <pre><code>expandSrcDirTests</code></pre>
         </article>
         
         <article class="global" data-name="depsRules">
            <h2>depsRules</h2>
            <hr />
            
            <p>depsRules defines the expected dependencies between packages in
the Go source tree. It is a statement of policy.

DO NOT CHANGE THIS DATA TO FIX BUILDS.
Existing packages should not have their constraints relaxed
without prior discussion.
Negative assertions should almost never be removed.

"a < b" means package b can import package a.

See `go doc internal/dag` for the full syntax.

All-caps names are pseudo-names for specific points
in the dependency lattice.</p>
            
            <pre><code>depsRules</code></pre>
         </article>
         
         <article class="global" data-name="buildIgnore">
            <h2>buildIgnore</h2>
            <hr />
            
            <pre><code>buildIgnore</code></pre>
         </article>
         
         <article class="global" data-name="bom">
            <h2>bom</h2>
            <hr />
            
            <pre><code>bom</code></pre>
         </article>
         
         <article class="global" data-name="errSyntax">
            <h2>errSyntax</h2>
            <hr />
            
            <pre><code>errSyntax</code></pre>
         </article>
         
         <article class="global" data-name="errNUL">
            <h2>errNUL</h2>
            <hr />
            
            <pre><code>errNUL</code></pre>
         </article>
         
         <article class="global" data-name="goEmbed">
            <h2>goEmbed</h2>
            <hr />
            
            <pre><code>goEmbed</code></pre>
         </article>
          
         <article class="struct" data-name="GoodFileTest">
            <h2>type GoodFileTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
result bool</code></pre>
         </article>
         
         <article class="struct" data-name="readTest">
            <h2>type readTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">in string
err string</code></pre>
         </article>
         
         <article class="struct" data-name="Context">
            <h2>type Context struct</h2>
            <hr />
            
            <p>A Context specifies the supporting context for a build.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">GOARCH string
GOOS string
GOROOT string
GOPATH string
Dir string
CgoEnabled bool
UseAllFiles bool
Compiler string
BuildTags []string
ToolTags []string
ReleaseTags []string
InstallSuffix string
JoinPath func
SplitPathList func
IsAbsPath func
IsDir func
HasSubdir func
ReadDir func
OpenFile func</code></pre>
         </article>
         
         <article class="struct" data-name="Package">
            <h2>type Package struct</h2>
            <hr />
            
            <p>A Package describes the Go package found in a directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string
Name string
ImportComment string
Doc string
ImportPath string
Root string
SrcRoot string
PkgRoot string
PkgTargetRoot string
BinDir string
Goroot bool
PkgObj string
AllTags []string
ConflictDir string
BinaryOnly bool
GoFiles []string
CgoFiles []string
IgnoredGoFiles []string
InvalidGoFiles []string
IgnoredOtherFiles []string
CFiles []string
CXXFiles []string
MFiles []string
HFiles []string
FFiles []string
SFiles []string
SwigFiles []string
SwigCXXFiles []string
SysoFiles []string
CgoCFLAGS []string
CgoCPPFLAGS []string
CgoCXXFLAGS []string
CgoFFLAGS []string
CgoLDFLAGS []string
CgoPkgConfig []string
TestGoFiles []string
XTestGoFiles []string
Directives []Directive
TestDirectives []Directive
XTestDirectives []Directive
Imports []string
ImportPos *ast.MapType
TestImports []string
TestImportPos *ast.MapType
XTestImports []string
XTestImportPos *ast.MapType
EmbedPatterns []string
EmbedPatternPos *ast.MapType
TestEmbedPatterns []string
TestEmbedPatternPos *ast.MapType
XTestEmbedPatterns []string
XTestEmbedPatternPos *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="Directive">
            <h2>type Directive struct</h2>
            <hr />
            
            <p>A Directive is a Go directive comment (//go:zzz...) found in a source file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Text string
Pos token.Position</code></pre>
         </article>
         
         <article class="struct" data-name="NoGoError">
            <h2>type NoGoError struct</h2>
            <hr />
            
            <p>NoGoError is the error used by [Import] to describe a directory
containing no buildable Go source files. (It may still contain
test files, files hidden by build tags, and so on.)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string</code></pre>
         </article>
         
         <article class="struct" data-name="MultiplePackageError">
            <h2>type MultiplePackageError struct</h2>
            <hr />
            
            <p>MultiplePackageError describes a directory containing
multiple buildable Go source files for multiple packages.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string
Packages []string
Files []string</code></pre>
         </article>
         
         <article class="struct" data-name="fileInfo">
            <h2>type fileInfo struct</h2>
            <hr />
            
            <p>fileInfo records information learned about a file included in a build.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
header []byte
fset *token.FileSet
parsed *ast.File
parseErr error
imports []fileImport
embeds []fileEmbed
directives []Directive</code></pre>
         </article>
         
         <article class="struct" data-name="fileImport">
            <h2>type fileImport struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
pos token.Pos
doc *ast.CommentGroup</code></pre>
         </article>
         
         <article class="struct" data-name="fileEmbed">
            <h2>type fileEmbed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pattern string
pos token.Position</code></pre>
         </article>
         
         <article class="struct" data-name="readNopCloser">
            <h2>type readNopCloser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="importReader">
            <h2>type importReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b *bufio.Reader
buf []byte
peek byte
err error
eof bool
nerr int
pos token.Position</code></pre>
         </article>
          
         <article class="function" data-name="anotherOS">
            <h2>anotherOS</h2>
            <hr />
            
            <pre><code>func anotherOS() string</code></pre>
         </article>
         
         <article class="function" data-name="anotherArch">
            <h2>anotherArch</h2>
            <hr />
            
            <pre><code>func anotherArch() string</code></pre>
         </article>
         
         <article class="function" data-name="TestGoodOSArch">
            <h2>TestGoodOSArch</h2>
            <hr />
            
            <pre><code>func TestGoodOSArch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVendorPackages">
            <h2>TestVendorPackages</h2>
            <hr />
            
            <p>Verify that the vendor directories contain only packages matching the list above.</p>
            
            <pre><code>func TestVendorPackages(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="isAllowed">
            <h2>isAllowed</h2>
            <hr />
            
            <pre><code>func isAllowed(pkg string) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestIsAllowed">
            <h2>TestIsAllowed</h2>
            <hr />
            
            <pre><code>func TestIsAllowed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRead">
            <h2>testRead</h2>
            <hr />
            
            <pre><code>func testRead(t *testing.T, tests []readTest, read func)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadGoInfo">
            <h2>TestReadGoInfo</h2>
            <hr />
            
            <pre><code>func TestReadGoInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadComments">
            <h2>TestReadComments</h2>
            <hr />
            
            <pre><code>func TestReadComments(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadFailuresIgnored">
            <h2>TestReadFailuresIgnored</h2>
            <hr />
            
            <pre><code>func TestReadFailuresIgnored(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadEmbed">
            <h2>TestReadEmbed</h2>
            <hr />
            
            <pre><code>func TestReadEmbed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="joinPath">
            <h2>joinPath</h2>
            <hr />
            
            <p>joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join.</p>
            
            <pre><code>func joinPath(elem ...string) string</code></pre>
         </article>
         
         <article class="function" data-name="splitPathList">
            <h2>splitPathList</h2>
            <hr />
            
            <p>splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList.</p>
            
            <pre><code>func splitPathList(s string) []string</code></pre>
         </article>
         
         <article class="function" data-name="isAbsPath">
            <h2>isAbsPath</h2>
            <hr />
            
            <p>isAbsPath calls ctxt.IsAbsPath (if not nil) or else filepath.IsAbs.</p>
            
            <pre><code>func isAbsPath(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isDir">
            <h2>isDir</h2>
            <hr />
            
            <p>isDir calls ctxt.IsDir (if not nil) or else uses os.Stat.</p>
            
            <pre><code>func isDir(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasSubdir">
            <h2>hasSubdir</h2>
            <hr />
            
            <p>hasSubdir calls ctxt.HasSubdir (if not nil) or else uses
the local file system to answer the question.</p>
            
            <pre><code>func hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="hasSubdir">
            <h2>hasSubdir</h2>
            <hr />
            
            <p>hasSubdir reports if dir is within root by performing lexical analysis only.</p>
            
            <pre><code>func hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="readDir">
            <h2>readDir</h2>
            <hr />
            
            <p>readDir calls ctxt.ReadDir (if not nil) or else os.ReadDir.</p>
            
            <pre><code>func readDir(path string) ([]fs.DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="openFile">
            <h2>openFile</h2>
            <hr />
            
            <p>openFile calls ctxt.OpenFile (if not nil) or else os.Open.</p>
            
            <pre><code>func openFile(path string) (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="isFile">
            <h2>isFile</h2>
            <hr />
            
            <p>isFile determines whether path is a file by trying to open it.
It reuses openFile instead of adding another function to the
list in Context.</p>
            
            <pre><code>func isFile(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="gopath">
            <h2>gopath</h2>
            <hr />
            
            <p>gopath returns the list of Go path directories.</p>
            
            <pre><code>func gopath() []string</code></pre>
         </article>
         
         <article class="function" data-name="SrcDirs">
            <h2>SrcDirs</h2>
            <hr />
            
            <p>SrcDirs returns a list of package source root directories.
It draws from the current Go root and Go path but omits directories
that do not exist.</p>
            
            <pre><code>func SrcDirs() []string</code></pre>
         </article>
         
         <article class="function" data-name="defaultGOPATH">
            <h2>defaultGOPATH</h2>
            <hr />
            
            <p>Keep consistent with cmd/go/internal/cfg.defaultGOPATH.</p>
            
            <pre><code>func defaultGOPATH() string</code></pre>
         </article>
         
         <article class="function" data-name="defaultContext">
            <h2>defaultContext</h2>
            <hr />
            
            <pre><code>func defaultContext() Context</code></pre>
         </article>
         
         <article class="function" data-name="envOr">
            <h2>envOr</h2>
            <hr />
            
            <pre><code>func envOr(name string, def string) string</code></pre>
         </article>
         
         <article class="function" data-name="IsCommand">
            <h2>IsCommand</h2>
            <hr />
            
            <p>IsCommand reports whether the package is considered a
command to be installed (not just a library).
Packages named "main" are treated as commands.</p>
            
            <pre><code>func IsCommand() bool</code></pre>
         </article>
         
         <article class="function" data-name="ImportDir">
            <h2>ImportDir</h2>
            <hr />
            
            <p>ImportDir is like [Import] but processes the Go package found in
the named directory.</p>
            
            <pre><code>func ImportDir(dir string, mode ImportMode) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="nameExt">
            <h2>nameExt</h2>
            <hr />
            
            <pre><code>func nameExt(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <p>Import returns details about the Go package named by the import path,
interpreting local import paths relative to the srcDir directory.
If the path is a local import path naming a package that can be imported
using a standard import path, the returned package will set p.ImportPath
to that path.

In the directory containing the package, .go, .c, .h, and .s files are
considered part of the package except for:

  - .go files in package documentation
  - files starting with _ or . (likely editor temporary files)
  - files with build constraints not satisfied by the context

If an error occurs, Import returns a non-nil error and a non-nil
*[Package] containing partial information.</p>
            
            <pre><code>func Import(path string, srcDir string, mode ImportMode) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="fileListForExt">
            <h2>fileListForExt</h2>
            <hr />
            
            <pre><code>func fileListForExt(p *Package, ext string) *[]string</code></pre>
         </article>
         
         <article class="function" data-name="uniq">
            <h2>uniq</h2>
            <hr />
            
            <pre><code>func uniq(list []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="importGo">
            <h2>importGo</h2>
            <hr />
            
            <p>importGo checks whether it can use the go command to find the directory for path.
If using the go command is not appropriate, importGo returns errNoModules.
Otherwise, importGo tries using the go command and reports whether that succeeded.
Using the go command lets build.Import and build.Context.Import find code
in Go modules. In the long term we want tools to use go/packages (currently golang.org/x/tools/go/packages),
which will also use the go command.
Invoking the go command here is not very efficient in that it computes information
about the requested package and all dependencies and then only reports about the requested package.
Then we reinvoke it for every dependency. But this is still better than not working at all.
See golang.org/issue/26504.</p>
            
            <pre><code>func importGo(p *Package, path string, srcDir string, mode ImportMode) error</code></pre>
         </article>
         
         <article class="function" data-name="equal">
            <h2>equal</h2>
            <hr />
            
            <pre><code>func equal(x []string, y []string) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasGoFiles">
            <h2>hasGoFiles</h2>
            <hr />
            
            <p>hasGoFiles reports whether dir contains any files with names ending in .go.
For a vendor check we must exclude directories that contain no .go files.
Otherwise it is not possible to vendor just a/b/c and still import the
non-vendored a/b. See golang.org/issue/13832.</p>
            
            <pre><code>func hasGoFiles(ctxt *Context, dir string) bool</code></pre>
         </article>
         
         <article class="function" data-name="findImportComment">
            <h2>findImportComment</h2>
            <hr />
            
            <pre><code>func findImportComment(data []byte) (s string, line int)</code></pre>
         </article>
         
         <article class="function" data-name="skipSpaceOrComment">
            <h2>skipSpaceOrComment</h2>
            <hr />
            
            <p>skipSpaceOrComment returns data with any leading spaces or comments removed.</p>
            
            <pre><code>func skipSpaceOrComment(data []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="parseWord">
            <h2>parseWord</h2>
            <hr />
            
            <p>parseWord skips any leading spaces or comments in data
and then parses the beginning of data as an identifier or keyword,
returning that word and what remains after the word.</p>
            
            <pre><code>func parseWord(data []byte) (word []byte, rest []byte)</code></pre>
         </article>
         
         <article class="function" data-name="MatchFile">
            <h2>MatchFile</h2>
            <hr />
            
            <p>MatchFile reports whether the file with the given name in the given directory
matches the context and would be included in a [Package] created by [ImportDir]
of that directory.

MatchFile considers the name of the file and may use ctxt.OpenFile to
read some or all of the file's content.</p>
            
            <pre><code>func MatchFile(dir string, name string) (match bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="matchFile">
            <h2>matchFile</h2>
            <hr />
            
            <p>matchFile determines whether the file with the given name in the given directory
should be included in the package being constructed.
If the file should be included, matchFile returns a non-nil *fileInfo (and a nil error).
Non-nil errors are reserved for unexpected problems.

If name denotes a Go program, matchFile reads until the end of the
imports and returns that section of the file in the fileInfo's header field,
even though it only considers text until the first non-comment
for go:build lines.

If allTags is non-nil, matchFile records any encountered build tag
by setting allTags[tag] = true.</p>
            
            <pre><code>func matchFile(dir string, name string, allTags *ast.MapType, binaryOnly *bool, fset *token.FileSet) (*fileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanDecls">
            <h2>cleanDecls</h2>
            <hr />
            
            <pre><code>func cleanDecls(m *ast.MapType) ([]string, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <p>Import is shorthand for Default.Import.</p>
            
            <pre><code>func Import(path string, srcDir string, mode ImportMode) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="ImportDir">
            <h2>ImportDir</h2>
            <hr />
            
            <p>ImportDir is shorthand for Default.ImportDir.</p>
            
            <pre><code>func ImportDir(dir string, mode ImportMode) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="isGoBuildComment">
            <h2>isGoBuildComment</h2>
            <hr />
            
            <pre><code>func isGoBuildComment(line []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="shouldBuild">
            <h2>shouldBuild</h2>
            <hr />
            
            <p>shouldBuild reports whether it is okay to use this file,
The rule is that in the file's leading run of // comments
and blank lines, which must be followed by a blank line
(to avoid including a Go package clause doc comment),
lines beginning with '//go:build' are taken as build directives.

The file is accepted only if each such line lists something
matching the file. For example:

	//go:build windows linux

marks the file as applicable only on Windows and Linux.

For each build tag it consults, shouldBuild sets allTags[tag] = true.

shouldBuild reports whether the file should be built
and whether a //go:binary-only-package comment was found.</p>
            
            <pre><code>func shouldBuild(content []byte, allTags *ast.MapType) (shouldBuild bool, binaryOnly bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseFileHeader">
            <h2>parseFileHeader</h2>
            <hr />
            
            <p>parseFileHeader should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
  - github.com/bazelbuild/bazel-gazelle

Do not remove or change the type signature.
See go.dev/issue/67401.</p>
            
            <pre><code>func parseFileHeader(content []byte) (trimmed []byte, goBuild []byte, sawBinaryOnly bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="saveCgo">
            <h2>saveCgo</h2>
            <hr />
            
            <p>saveCgo saves the information from the #cgo lines in the import "C" comment.
These lines set CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS and pkg-config directives
that affect the way cgo's C code is built.</p>
            
            <pre><code>func saveCgo(filename string, di *Package, cg *ast.CommentGroup) error</code></pre>
         </article>
         
         <article class="function" data-name="expandSrcDir">
            <h2>expandSrcDir</h2>
            <hr />
            
            <p>expandSrcDir expands any occurrence of ${SRCDIR}, making sure
the result is safe for the shell.</p>
            
            <pre><code>func expandSrcDir(str string, srcdir string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="makePathsAbsolute">
            <h2>makePathsAbsolute</h2>
            <hr />
            
            <p>makePathsAbsolute looks for compiler options that take paths and
makes them absolute. We do this because through the 1.8 release we
ran the compiler in the package directory, so any relative -I or -L
options would be relative to that directory. In 1.9 we changed to
running the compiler in the build directory, to get consistent
build results (issue #19964). To keep builds working, we change any
relative -I or -L options to be absolute.

Using filepath.IsAbs and filepath.Join here means the results will be
different on different systems, but that's OK: -I and -L options are
inherently system-dependent.</p>
            
            <pre><code>func makePathsAbsolute(args []string, srcDir string)</code></pre>
         </article>
         
         <article class="function" data-name="safeCgoName">
            <h2>safeCgoName</h2>
            <hr />
            
            <pre><code>func safeCgoName(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitQuoted">
            <h2>splitQuoted</h2>
            <hr />
            
            <p>splitQuoted splits the string s around each instance of one or more consecutive
white space characters while taking into account quotes and escaping, and
returns an array of substrings of s or an empty list if s contains only white space.
Single quotes and double quotes are recognized to prevent splitting within the
quoted region, and are removed from the resulting substrings. If a quote in s
isn't closed err will be set and r will have the unclosed argument as the
last element. The backslash is used for escaping.

For example, the following string:

	a b:"c d" 'e''f'  "g\""

Would be parsed as:

	[]string{"a", "b:c d", "ef", `g"`}</p>
            
            <pre><code>func splitQuoted(s string) (r []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="matchAuto">
            <h2>matchAuto</h2>
            <hr />
            
            <p>matchAuto interprets text as either a +build or //go:build expression (whichever works),
reporting whether the expression matches the build context.

matchAuto is only used for testing of tag evaluation
and in #cgo lines, which accept either syntax.</p>
            
            <pre><code>func matchAuto(text string, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="eval">
            <h2>eval</h2>
            <hr />
            
            <pre><code>func eval(x constraint.Expr, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchTag">
            <h2>matchTag</h2>
            <hr />
            
            <p>matchTag reports whether the name is one of:

	cgo (if cgo is enabled)
	$GOOS
	$GOARCH
	ctxt.Compiler
	linux (if GOOS = android)
	solaris (if GOOS = illumos)
	darwin (if GOOS = ios)
	unix (if this is a Unix GOOS)
	boringcrypto (if GOEXPERIMENT=boringcrypto is enabled)
	tag (if tag is listed in ctxt.BuildTags, ctxt.ToolTags, or ctxt.ReleaseTags)

It records all consulted tags in allTags.</p>
            
            <pre><code>func matchTag(name string, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="goodOSArchFile">
            <h2>goodOSArchFile</h2>
            <hr />
            
            <p>goodOSArchFile returns false if the name contains a $GOOS or $GOARCH
suffix which does not match the current system.
The recognized name formats are:

	name_$(GOOS).*
	name_$(GOARCH).*
	name_$(GOOS)_$(GOARCH).*
	name_$(GOOS)_test.*
	name_$(GOARCH)_test.*
	name_$(GOOS)_$(GOARCH)_test.*

Exceptions:
if GOOS=android, then files with GOOS=linux are also matched.
if GOOS=illumos, then files with GOOS=solaris are also matched.
if GOOS=ios, then files with GOOS=darwin are also matched.</p>
            
            <pre><code>func goodOSArchFile(name string, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsLocalImport">
            <h2>IsLocalImport</h2>
            <hr />
            
            <p>IsLocalImport reports whether the import path is
a local import path, like ".", "..", "./foo", or "../foo".</p>
            
            <pre><code>func IsLocalImport(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="ArchChar">
            <h2>ArchChar</h2>
            <hr />
            
            <p>ArchChar returns "?" and an error.
In earlier versions of Go, the returned string was used to derive
the compiler and linker tool names, the default object file suffix,
and the default linker output name. As of Go 1.5, those strings
no longer vary by architecture; they are compile, link, .o, and a.out, respectively.</p>
            
            <pre><code>func ArchChar(goarch string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="TestMatch">
            <h2>TestMatch</h2>
            <hr />
            
            <pre><code>func TestMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDotSlashImport">
            <h2>TestDotSlashImport</h2>
            <hr />
            
            <pre><code>func TestDotSlashImport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyImport">
            <h2>TestEmptyImport</h2>
            <hr />
            
            <pre><code>func TestEmptyImport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyFolderImport">
            <h2>TestEmptyFolderImport</h2>
            <hr />
            
            <pre><code>func TestEmptyFolderImport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultiplePackageImport">
            <h2>TestMultiplePackageImport</h2>
            <hr />
            
            <pre><code>func TestMultiplePackageImport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLocalDirectory">
            <h2>TestLocalDirectory</h2>
            <hr />
            
            <pre><code>func TestLocalDirectory(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestShouldBuild">
            <h2>TestShouldBuild</h2>
            <hr />
            
            <pre><code>func TestShouldBuild(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoodOSArchFile">
            <h2>TestGoodOSArchFile</h2>
            <hr />
            
            <pre><code>func TestGoodOSArchFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="TestMatchFile">
            <h2>TestMatchFile</h2>
            <hr />
            
            <pre><code>func TestMatchFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportCmd">
            <h2>TestImportCmd</h2>
            <hr />
            
            <pre><code>func TestImportCmd(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExpandSrcDir">
            <h2>TestExpandSrcDir</h2>
            <hr />
            
            <pre><code>func TestExpandSrcDir(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestShellSafety">
            <h2>TestShellSafety</h2>
            <hr />
            
            <pre><code>func TestShellSafety(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportDirNotExist">
            <h2>TestImportDirNotExist</h2>
            <hr />
            
            <p>Want to get a "cannot find package" error when directory for package does not exist.
There should be valid partial information in the returned non-nil *Package.</p>
            
            <pre><code>func TestImportDirNotExist(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportVendor">
            <h2>TestImportVendor</h2>
            <hr />
            
            <pre><code>func TestImportVendor(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkImportVendor">
            <h2>BenchmarkImportVendor</h2>
            <hr />
            
            <pre><code>func BenchmarkImportVendor(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportVendorFailure">
            <h2>TestImportVendorFailure</h2>
            <hr />
            
            <pre><code>func TestImportVendorFailure(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportVendorParentFailure">
            <h2>TestImportVendorParentFailure</h2>
            <hr />
            
            <pre><code>func TestImportVendorParentFailure(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportPackageOutsideModule">
            <h2>TestImportPackageOutsideModule</h2>
            <hr />
            
            <p>Check that a package is loaded in module mode if GO111MODULE=on, even when
no go.mod file is present. It should fail to resolve packages outside std.
Verifies golang.org/issue/34669.</p>
            
            <pre><code>func TestImportPackageOutsideModule(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue23594">
            <h2>TestIssue23594</h2>
            <hr />
            
            <p>TestIssue23594 prevents go/build from regressing and populating Package.Doc
from comments in test files.</p>
            
            <pre><code>func TestIssue23594(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue56509">
            <h2>TestIssue56509</h2>
            <hr />
            
            <p>TestIssue56509 tests that go/build does not add non-go files to InvalidGoFiles
when they have unparsable comments.</p>
            
            <pre><code>func TestIssue56509(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMissingImportErrorRepetition">
            <h2>TestMissingImportErrorRepetition</h2>
            <hr />
            
            <p>TestMissingImportErrorRepetition checks that when an unknown package is
imported, the package path is only shown once in the error.
Verifies golang.org/issue/34752.</p>
            
            <pre><code>func TestMissingImportErrorRepetition(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCgoImportsIgnored">
            <h2>TestCgoImportsIgnored</h2>
            <hr />
            
            <p>TestCgoImportsIgnored checks that imports in cgo files are not included
in the imports list when cgo is disabled.
Verifies golang.org/issue/35946.</p>
            
            <pre><code>func TestCgoImportsIgnored(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAllTags">
            <h2>TestAllTags</h2>
            <hr />
            
            <p>Issue #52053. Check that if there is a file x_GOOS_GOARCH.go that both
GOOS and GOARCH show up in the Package.AllTags field. We test both the
case where the file matches and where the file does not match.
The latter case used to fail, incorrectly omitting GOOS.</p>
            
            <pre><code>func TestAllTags(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAllTagsNonSourceFile">
            <h2>TestAllTagsNonSourceFile</h2>
            <hr />
            
            <pre><code>func TestAllTagsNonSourceFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDirectives">
            <h2>TestDirectives</h2>
            <hr />
            
            <pre><code>func TestDirectives(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="listStdPkgs">
            <h2>listStdPkgs</h2>
            <hr />
            
            <p>listStdPkgs returns the same list of packages as "go list std".</p>
            
            <pre><code>func listStdPkgs(goroot string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestDependencies">
            <h2>TestDependencies</h2>
            <hr />
            
            <pre><code>func TestDependencies(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="findImports">
            <h2>findImports</h2>
            <hr />
            
            <pre><code>func findImports(pkg string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="depsPolicy">
            <h2>depsPolicy</h2>
            <hr />
            
            <p>depsPolicy returns a map m such that m[p][d] == true when p can import d.</p>
            
            <pre><code>func depsPolicy(t *testing.T) *dag.Graph</code></pre>
         </article>
         
         <article class="function" data-name="TestStdlibLowercase">
            <h2>TestStdlibLowercase</h2>
            <hr />
            
            <p>TestStdlibLowercase tests that all standard library package names are
lowercase. See Issue 40065.</p>
            
            <pre><code>func TestStdlibLowercase(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFindImports">
            <h2>TestFindImports</h2>
            <hr />
            
            <p>TestFindImports tests that findImports works.  See #43249.</p>
            
            <pre><code>func TestFindImports(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="getToolDir">
            <h2>getToolDir</h2>
            <hr />
            
            <p>getToolDir returns the default value of ToolDir.</p>
            
            <pre><code>func getToolDir() string</code></pre>
         </article>
         
         <article class="function" data-name="getToolDir">
            <h2>getToolDir</h2>
            <hr />
            
            <p>getToolDir returns the default value of ToolDir.</p>
            
            <pre><code>func getToolDir() string</code></pre>
         </article>
         
         <article class="function" data-name="newImportReader">
            <h2>newImportReader</h2>
            <hr />
            
            <pre><code>func newImportReader(name string, r io.Reader) *importReader</code></pre>
         </article>
         
         <article class="function" data-name="isIdent">
            <h2>isIdent</h2>
            <hr />
            
            <pre><code>func isIdent(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="syntaxError">
            <h2>syntaxError</h2>
            <hr />
            
            <p>syntaxError records a syntax error, but only if an I/O error has not already been recorded.</p>
            
            <pre><code>func syntaxError()</code></pre>
         </article>
         
         <article class="function" data-name="readByte">
            <h2>readByte</h2>
            <hr />
            
            <p>readByte reads the next byte from the input, saves it in buf, and returns it.
If an error occurs, readByte records the error in r.err and returns 0.</p>
            
            <pre><code>func readByte() byte</code></pre>
         </article>
         
         <article class="function" data-name="readByteNoBuf">
            <h2>readByteNoBuf</h2>
            <hr />
            
            <p>readByteNoBuf is like readByte but doesn't buffer the byte.
It exhausts r.buf before reading from r.b.</p>
            
            <pre><code>func readByteNoBuf() byte</code></pre>
         </article>
         
         <article class="function" data-name="peekByte">
            <h2>peekByte</h2>
            <hr />
            
            <p>peekByte returns the next byte from the input reader but does not advance beyond it.
If skipSpace is set, peekByte skips leading spaces and comments.</p>
            
            <pre><code>func peekByte(skipSpace bool) byte</code></pre>
         </article>
         
         <article class="function" data-name="nextByte">
            <h2>nextByte</h2>
            <hr />
            
            <p>nextByte is like peekByte but advances beyond the returned byte.</p>
            
            <pre><code>func nextByte(skipSpace bool) byte</code></pre>
         </article>
         
         <article class="function" data-name="findEmbed">
            <h2>findEmbed</h2>
            <hr />
            
            <p>findEmbed advances the input reader to the next //go:embed comment.
It reports whether it found a comment.
(Otherwise it found an error or EOF.)</p>
            
            <pre><code>func findEmbed(first bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="readKeyword">
            <h2>readKeyword</h2>
            <hr />
            
            <p>readKeyword reads the given keyword from the input.
If the keyword is not present, readKeyword records a syntax error.</p>
            
            <pre><code>func readKeyword(kw string)</code></pre>
         </article>
         
         <article class="function" data-name="readIdent">
            <h2>readIdent</h2>
            <hr />
            
            <p>readIdent reads an identifier from the input.
If an identifier is not present, readIdent records a syntax error.</p>
            
            <pre><code>func readIdent()</code></pre>
         </article>
         
         <article class="function" data-name="readString">
            <h2>readString</h2>
            <hr />
            
            <p>readString reads a quoted string literal from the input.
If an identifier is not present, readString records a syntax error.</p>
            
            <pre><code>func readString()</code></pre>
         </article>
         
         <article class="function" data-name="readImport">
            <h2>readImport</h2>
            <hr />
            
            <p>readImport reads an import clause - optional identifier followed by quoted string -
from the input.</p>
            
            <pre><code>func readImport()</code></pre>
         </article>
         
         <article class="function" data-name="readComments">
            <h2>readComments</h2>
            <hr />
            
            <p>readComments is like io.ReadAll, except that it only reads the leading
block of comments in the file.

readComments should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
  - github.com/bazelbuild/bazel-gazelle

Do not remove or change the type signature.
See go.dev/issue/67401.</p>
            
            <pre><code>func readComments(f io.Reader) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readGoInfo">
            <h2>readGoInfo</h2>
            <hr />
            
            <p>readGoInfo expects a Go file as input and reads the file up to and including the import section.
It records what it learned in *info.
If info.fset is non-nil, readGoInfo parses the file and sets info.parsed, info.parseErr,
info.imports and info.embeds.

It only returns an error if there are problems reading the file,
not for syntax errors in the file itself.</p>
            
            <pre><code>func readGoInfo(f io.Reader, info *fileInfo) error</code></pre>
         </article>
         
         <article class="function" data-name="isValidImport">
            <h2>isValidImport</h2>
            <hr />
            
            <p>isValidImport checks if the import is a valid import using the more strict
checks allowed by the implementation restriction in https://go.dev/ref/spec#Import_declarations.
It was ported from the function of the same name that was removed from the
parser in CL 424855, when the parser stopped doing these checks.</p>
            
            <pre><code>func isValidImport(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseGoEmbed">
            <h2>parseGoEmbed</h2>
            <hr />
            
            <p>parseGoEmbed parses the text following "//go:embed" to extract the glob patterns.
It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.
This is based on a similar function in cmd/compile/internal/gc/noder.go;
this version calculates position information as well.</p>
            
            <pre><code>func parseGoEmbed(args string, pos token.Position) ([]fileEmbed, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
