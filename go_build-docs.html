<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - build</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="go_build_constraint-docs.html">constraint</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>build</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"bytes"
"errors"
"fmt"
"go/ast"
"go/build/constraint"
"go/doc"
"go/token"
"internal/buildcfg"
"internal/godebug"
"internal/goroot"
"internal/goversion"
"internal/platform"
"internal/syslist"
"io"
"io/fs"
"os"
"os/exec"
pathpkg "path"
"path/filepath"
"runtime"
"slices"
"strconv"
"strings"
"unicode"
"unicode/utf8"
_ "unsafe"
"path/filepath"
"runtime"
"runtime"
"bufio"
"bytes"
"errors"
"fmt"
"go/ast"
"go/parser"
"go/scanner"
"go/token"
"io"
"strconv"
"strings"
"unicode"
"unicode/utf8"
_ "unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AllowBinary" data-name="AllowBinary">
               <h3>
                  AllowBinary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AllowBinary" class="anchor" title="Link to AllowBinary">#</a>
               </h3>
               
               <p>If AllowBinary is set, Import can be satisfied by a compiled
package object without corresponding sources.
Deprecated:
The supported way to create a compiled-only package is to
write source code containing a //go:binary-only-package comment at
the top of the file. Such a package will be recognized
regardless of this flag setting (because it has source code)
and will have BinaryOnly set to true in the returned Package.</p>
               
               <pre><code>const AllowBinary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Default" data-name="Default">
               <h3>
                  Default 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Default" class="anchor" title="Link to Default">#</a>
               </h3>
               
               <p>Default is the default Context for builds.
It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables
if set, or else the compiled code's GOARCH, GOOS, and GOROOT.</p>
               
               <pre><code>var Default Context = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FindOnly" data-name="FindOnly">
               <h3>
                  FindOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FindOnly" class="anchor" title="Link to FindOnly">#</a>
               </h3>
               
               <p>If FindOnly is set, Import stops after locating the directory
that should contain the sources for a package. It does not
read any files in the directory.</p>
               
               <pre><code>const FindOnly ImportMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IgnoreVendor" data-name="IgnoreVendor">
               <h3>
                  IgnoreVendor 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IgnoreVendor" class="anchor" title="Link to IgnoreVendor">#</a>
               </h3>
               
               <p>By default, Import searches vendor directories
that apply in the given source directory before searching
the GOROOT and GOPATH roots.
If an Import finds and returns a package using a vendor
directory, the resulting ImportPath is the complete path
to the package, including the path elements leading up
to and including "vendor".
For example, if Import("y", "x/subdir", 0) finds
"x/vendor/y", the returned package's ImportPath is "x/vendor/y",
not plain "y".
See golang.org/s/go15vendor for more information.
Setting IgnoreVendor ignores vendor directories.
In contrast to the package's ImportPath,
the returned package's Imports, TestImports, and XTestImports
are always the exact import paths from the source files:
Import makes no attempt to resolve or check those paths.</p>
               
               <pre><code>const IgnoreVendor</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ImportComment" data-name="ImportComment">
               <h3>
                  ImportComment 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ImportComment" class="anchor" title="Link to ImportComment">#</a>
               </h3>
               
               <p>If ImportComment is set, parse import comments on package statements.
Import returns an error if it finds a comment it cannot understand
or finds conflicting comments in multiple source files.
See golang.org/s/go14customimport for more information.</p>
               
               <pre><code>const ImportComment</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToolDir" data-name="ToolDir">
               <h3>
                  ToolDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ToolDir" class="anchor" title="Link to ToolDir">#</a>
               </h3>
               
               <p>ToolDir is the directory containing build tools.</p>
               
               <pre><code>var ToolDir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="binaryOnlyComment" data-name="binaryOnlyComment">
               <h3>
                  binaryOnlyComment 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#binaryOnlyComment" class="anchor" title="Link to binaryOnlyComment">#</a>
               </h3>
               
               <p>Special comment denoting a binary-only package.
See https://golang.org/design/2775-binary-only-packages
for more about the design of binary-only packages.</p>
               
               <pre><code>var binaryOnlyComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bom" data-name="bom">
               <h3>
                  bom 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bom" class="anchor" title="Link to bom">#</a>
               </h3>
               
               <pre><code>var bom = []byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultCGO_ENABLED" data-name="defaultCGO_ENABLED">
               <h3>
                  defaultCGO_ENABLED 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#defaultCGO_ENABLED" class="anchor" title="Link to defaultCGO_ENABLED">#</a>
               </h3>
               
               <pre><code>const defaultCGO_ENABLED = ""</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultReleaseTags" data-name="defaultReleaseTags">
               <h3>
                  defaultReleaseTags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultReleaseTags" class="anchor" title="Link to defaultReleaseTags">#</a>
               </h3>
               
               <p>defaultReleaseTags should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/gopherjs/gopherjs
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname defaultReleaseTags</p>
               
               <pre><code>var defaultReleaseTags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultToolTags" data-name="defaultToolTags">
               <h3>
                  defaultToolTags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultToolTags" class="anchor" title="Link to defaultToolTags">#</a>
               </h3>
               
               <p>defaultToolTags should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/gopherjs/gopherjs
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname defaultToolTags</p>
               
               <pre><code>var defaultToolTags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dummyPkg" data-name="dummyPkg">
               <h3>
                  dummyPkg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dummyPkg" class="anchor" title="Link to dummyPkg">#</a>
               </h3>
               
               <pre><code>var dummyPkg Package</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMultipleGoBuild" data-name="errMultipleGoBuild">
               <h3>
                  errMultipleGoBuild 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMultipleGoBuild" class="anchor" title="Link to errMultipleGoBuild">#</a>
               </h3>
               
               <pre><code>var errMultipleGoBuild = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNUL" data-name="errNUL">
               <h3>
                  errNUL 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNUL" class="anchor" title="Link to errNUL">#</a>
               </h3>
               
               <pre><code>var errNUL = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoModules" data-name="errNoModules">
               <h3>
                  errNoModules 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoModules" class="anchor" title="Link to errNoModules">#</a>
               </h3>
               
               <pre><code>var errNoModules = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSyntax" data-name="errSyntax">
               <h3>
                  errSyntax 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSyntax" class="anchor" title="Link to errSyntax">#</a>
               </h3>
               
               <pre><code>var errSyntax = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goBuildComment" data-name="goBuildComment">
               <h3>
                  goBuildComment 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goBuildComment" class="anchor" title="Link to goBuildComment">#</a>
               </h3>
               
               <pre><code>var goBuildComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goEmbed" data-name="goEmbed">
               <h3>
                  goEmbed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goEmbed" class="anchor" title="Link to goEmbed">#</a>
               </h3>
               
               <pre><code>var goEmbed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="installgoroot" data-name="installgoroot">
               <h3>
                  installgoroot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#installgoroot" class="anchor" title="Link to installgoroot">#</a>
               </h3>
               
               <pre><code>var installgoroot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="newline" data-name="newline">
               <h3>
                  newline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#newline" class="anchor" title="Link to newline">#</a>
               </h3>
               
               <pre><code>var newline = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="plusBuild" data-name="plusBuild">
               <h3>
                  plusBuild 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#plusBuild" class="anchor" title="Link to plusBuild">#</a>
               </h3>
               
               <pre><code>var plusBuild = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="safeString" data-name="safeString">
               <h3>
                  safeString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#safeString" class="anchor" title="Link to safeString">#</a>
               </h3>
               
               <p>NOTE: $ is not safe for the shell, but it is allowed here because of linker options like -Wl,$ORIGIN.
We never pass these arguments to a shell (just to programs we construct argv for), so this should be okay.
See golang.org/issue/6038.
The @ is for OS X. See golang.org/issue/13720.
The % is for Jenkins. See golang.org/issue/16959.
The ! is because module paths may use them. See golang.org/issue/26716.
The ~ and ^ are for sr.ht. See golang.org/issue/32260.</p>
               
               <pre><code>const safeString = "+-.,/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz:$@%! ~^"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slashSlash" data-name="slashSlash">
               <h3>
                  slashSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slashSlash" class="anchor" title="Link to slashSlash">#</a>
               </h3>
               
               <pre><code>var slashSlash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slashStar" data-name="slashStar">
               <h3>
                  slashStar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slashStar" class="anchor" title="Link to slashStar">#</a>
               </h3>
               
               <pre><code>var slashStar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="starSlash" data-name="starSlash">
               <h3>
                  starSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#starSlash" class="anchor" title="Link to starSlash">#</a>
               </h3>
               
               <pre><code>var starSlash = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ImportMode" data-name="ImportMode">
               <h3>
                  ImportMode
                  <span class="badge type-badge">type</span>
                  <a href="#ImportMode" class="anchor" title="Link to ImportMode">#</a>
               </h3>
               
               <p>An ImportMode controls the behavior of the Import method.</p>
               
               <pre><code>type ImportMode uint</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Context" data-name="Context">
               <h3>
                  Context
                  <span class="badge">struct</span>
                  <a href="#Context" class="anchor" title="Link to Context">#</a>
               </h3>
               
               <p>A Context specifies the supporting context for a build.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Context struct {
GOARCH string
GOOS string
GOROOT string
GOPATH string
Dir string
CgoEnabled bool
UseAllFiles bool
Compiler string
BuildTags []string
ToolTags []string
ReleaseTags []string
InstallSuffix string
JoinPath func(elem ...string) string
SplitPathList func(list string) []string
IsAbsPath func(path string) bool
IsDir func(path string) bool
HasSubdir func(root string, dir string) (rel string, ok bool)
ReadDir func(dir string) ([]fs.FileInfo, error)
OpenFile func(path string) (io.ReadCloser, error)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Directive" data-name="Directive">
               <h3>
                  Directive
                  <span class="badge">struct</span>
                  <a href="#Directive" class="anchor" title="Link to Directive">#</a>
               </h3>
               
               <p>A Directive is a Go directive comment (//go:zzz...) found in a source file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Directive struct {
Text string
Pos token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MultiplePackageError" data-name="MultiplePackageError">
               <h3>
                  MultiplePackageError
                  <span class="badge">struct</span>
                  <a href="#MultiplePackageError" class="anchor" title="Link to MultiplePackageError">#</a>
               </h3>
               
               <p>MultiplePackageError describes a directory containing
multiple buildable Go source files for multiple packages.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MultiplePackageError struct {
Dir string
Packages []string
Files []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NoGoError" data-name="NoGoError">
               <h3>
                  NoGoError
                  <span class="badge">struct</span>
                  <a href="#NoGoError" class="anchor" title="Link to NoGoError">#</a>
               </h3>
               
               <p>NoGoError is the error used by [Import] to describe a directory
containing no buildable Go source files. (It may still contain
test files, files hidden by build tags, and so on.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NoGoError struct {
Dir string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <p>A Package describes the Go package found in a directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Package struct {
Dir string
Name string
ImportComment string
Doc string
ImportPath string
Root string
SrcRoot string
PkgRoot string
PkgTargetRoot string
BinDir string
Goroot bool
PkgObj string
AllTags []string
ConflictDir string
BinaryOnly bool
GoFiles []string
CgoFiles []string
IgnoredGoFiles []string
InvalidGoFiles []string
IgnoredOtherFiles []string
CFiles []string
CXXFiles []string
MFiles []string
HFiles []string
FFiles []string
SFiles []string
SwigFiles []string
SwigCXXFiles []string
SysoFiles []string
CgoCFLAGS []string
CgoCPPFLAGS []string
CgoCXXFLAGS []string
CgoFFLAGS []string
CgoLDFLAGS []string
CgoPkgConfig []string
TestGoFiles []string
XTestGoFiles []string
Directives []Directive
TestDirectives []Directive
XTestDirectives []Directive
Imports []string
ImportPos map[string][]token.Position
TestImports []string
TestImportPos map[string][]token.Position
XTestImports []string
XTestImportPos map[string][]token.Position
EmbedPatterns []string
EmbedPatternPos map[string][]token.Position
TestEmbedPatterns []string
TestEmbedPatternPos map[string][]token.Position
XTestEmbedPatterns []string
XTestEmbedPatternPos map[string][]token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileEmbed" data-name="fileEmbed">
               <h3>
                  fileEmbed
                  <span class="badge">struct</span>
                  <a href="#fileEmbed" class="anchor" title="Link to fileEmbed">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileEmbed struct {
pattern string
pos token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileImport" data-name="fileImport">
               <h3>
                  fileImport
                  <span class="badge">struct</span>
                  <a href="#fileImport" class="anchor" title="Link to fileImport">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileImport struct {
path string
pos token.Pos
doc *ast.CommentGroup
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileInfo" data-name="fileInfo">
               <h3>
                  fileInfo
                  <span class="badge">struct</span>
                  <a href="#fileInfo" class="anchor" title="Link to fileInfo">#</a>
               </h3>
               
               <p>fileInfo records information learned about a file included in a build.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileInfo struct {
name string
header []byte
fset *token.FileSet
parsed *ast.File
parseErr error
imports []fileImport
embeds []fileEmbed
directives []Directive
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importReader" data-name="importReader">
               <h3>
                  importReader
                  <span class="badge">struct</span>
                  <a href="#importReader" class="anchor" title="Link to importReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type importReader struct {
b *bufio.Reader
buf []byte
peek byte
err error
eof bool
nerr int
pos token.Position
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ArchChar" data-name="ArchChar">
               <h3>
                  ArchChar 
                  <span class="badge">function</span>
                  
                  <a href="#ArchChar" class="anchor" title="Link to ArchChar">#</a>
               </h3>
               
               <p>ArchChar returns "?" and an error.
In earlier versions of Go, the returned string was used to derive
the compiler and linker tool names, the default object file suffix,
and the default linker output name. As of Go 1.5, those strings
no longer vary by architecture; they are compile, link, .o, and a.out, respectively.</p>
               
               <pre><code>func ArchChar(goarch string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *NoGoError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *MultiplePackageError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Import" data-name="Import">
               <h3>
                  Import 
                  <span class="badge">function</span>
                  
                  <a href="#Import" class="anchor" title="Link to Import">#</a>
               </h3>
               
               <p>Import is shorthand for Default.Import.</p>
               
               <pre><code>func Import(path string, srcDir string, mode ImportMode) (*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Import" data-name="Import">
               <h3>
                  Import 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Import" class="anchor" title="Link to Import">#</a>
               </h3>
               
               <p>Import returns details about the Go package named by the import path,
interpreting local import paths relative to the srcDir directory.
If the path is a local import path naming a package that can be imported
using a standard import path, the returned package will set p.ImportPath
to that path.
In the directory containing the package, .go, .c, .h, and .s files are
considered part of the package except for:
- .go files in package documentation
- files starting with _ or . (likely editor temporary files)
- files with build constraints not satisfied by the context
If an error occurs, Import returns a non-nil error and a non-nil
*[Package] containing partial information.</p>
               
               <pre><code>func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportDir" data-name="ImportDir">
               <h3>
                  ImportDir 
                  <span class="badge">function</span>
                  
                  <a href="#ImportDir" class="anchor" title="Link to ImportDir">#</a>
               </h3>
               
               <p>ImportDir is shorthand for Default.ImportDir.</p>
               
               <pre><code>func ImportDir(dir string, mode ImportMode) (*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportDir" data-name="ImportDir">
               <h3>
                  ImportDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportDir" class="anchor" title="Link to ImportDir">#</a>
               </h3>
               
               <p>ImportDir is like [Import] but processes the Go package found in
the named directory.</p>
               
               <pre><code>func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsCommand" data-name="IsCommand">
               <h3>
                  IsCommand 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsCommand" class="anchor" title="Link to IsCommand">#</a>
               </h3>
               
               <p>IsCommand reports whether the package is considered a
command to be installed (not just a library).
Packages named "main" are treated as commands.</p>
               
               <pre><code>func (p *Package) IsCommand() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLocalImport" data-name="IsLocalImport">
               <h3>
                  IsLocalImport 
                  <span class="badge">function</span>
                  
                  <a href="#IsLocalImport" class="anchor" title="Link to IsLocalImport">#</a>
               </h3>
               
               <p>IsLocalImport reports whether the import path is
a local import path, like ".", "..", "./foo", or "../foo".</p>
               
               <pre><code>func IsLocalImport(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchFile" data-name="MatchFile">
               <h3>
                  MatchFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchFile" class="anchor" title="Link to MatchFile">#</a>
               </h3>
               
               <p>MatchFile reports whether the file with the given name in the given directory
matches the context and would be included in a [Package] created by [ImportDir]
of that directory.
MatchFile considers the name of the file and may use ctxt.OpenFile to
read some or all of the file's content.</p>
               
               <pre><code>func (ctxt *Context) MatchFile(dir string, name string) (match bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SrcDirs" data-name="SrcDirs">
               <h3>
                  SrcDirs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SrcDirs" class="anchor" title="Link to SrcDirs">#</a>
               </h3>
               
               <p>SrcDirs returns a list of package source root directories.
It draws from the current Go root and Go path but omits directories
that do not exist.</p>
               
               <pre><code>func (ctxt *Context) SrcDirs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanDecls" data-name="cleanDecls">
               <h3>
                  cleanDecls 
                  <span class="badge">function</span>
                  
                  <a href="#cleanDecls" class="anchor" title="Link to cleanDecls">#</a>
               </h3>
               
               <pre><code>func cleanDecls(m map[string][]token.Position) ([]string, map[string][]token.Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultContext" data-name="defaultContext">
               <h3>
                  defaultContext 
                  <span class="badge">function</span>
                  
                  <a href="#defaultContext" class="anchor" title="Link to defaultContext">#</a>
               </h3>
               
               <pre><code>func defaultContext() Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultGOPATH" data-name="defaultGOPATH">
               <h3>
                  defaultGOPATH 
                  <span class="badge">function</span>
                  
                  <a href="#defaultGOPATH" class="anchor" title="Link to defaultGOPATH">#</a>
               </h3>
               
               <p>Keep consistent with cmd/go/internal/cfg.defaultGOPATH.</p>
               
               <pre><code>func defaultGOPATH() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="envOr" data-name="envOr">
               <h3>
                  envOr 
                  <span class="badge">function</span>
                  
                  <a href="#envOr" class="anchor" title="Link to envOr">#</a>
               </h3>
               
               <pre><code>func envOr(name string, def string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="equal" data-name="equal">
               <h3>
                  equal 
                  <span class="badge">function</span>
                  
                  <a href="#equal" class="anchor" title="Link to equal">#</a>
               </h3>
               
               <pre><code>func equal(x []string, y []string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eval" data-name="eval">
               <h3>
                  eval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#eval" class="anchor" title="Link to eval">#</a>
               </h3>
               
               <pre><code>func (ctxt *Context) eval(x constraint.Expr, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandSrcDir" data-name="expandSrcDir">
               <h3>
                  expandSrcDir 
                  <span class="badge">function</span>
                  
                  <a href="#expandSrcDir" class="anchor" title="Link to expandSrcDir">#</a>
               </h3>
               
               <p>expandSrcDir expands any occurrence of ${SRCDIR}, making sure
the result is safe for the shell.</p>
               
               <pre><code>func expandSrcDir(str string, srcdir string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileListForExt" data-name="fileListForExt">
               <h3>
                  fileListForExt 
                  <span class="badge">function</span>
                  
                  <a href="#fileListForExt" class="anchor" title="Link to fileListForExt">#</a>
               </h3>
               
               <pre><code>func fileListForExt(p *Package, ext string) *[]string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findEmbed" data-name="findEmbed">
               <h3>
                  findEmbed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findEmbed" class="anchor" title="Link to findEmbed">#</a>
               </h3>
               
               <p>findEmbed advances the input reader to the next //go:embed comment.
It reports whether it found a comment.
(Otherwise it found an error or EOF.)</p>
               
               <pre><code>func (r *importReader) findEmbed(first bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findImportComment" data-name="findImportComment">
               <h3>
                  findImportComment 
                  <span class="badge">function</span>
                  
                  <a href="#findImportComment" class="anchor" title="Link to findImportComment">#</a>
               </h3>
               
               <pre><code>func findImportComment(data []byte) (s string, line int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getToolDir" data-name="getToolDir">
               <h3>
                  getToolDir 
                  <span class="badge">function</span>
                  
                  <a href="#getToolDir" class="anchor" title="Link to getToolDir">#</a>
               </h3>
               
               <p>getToolDir returns the default value of ToolDir.</p>
               
               <pre><code>func getToolDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getToolDir" data-name="getToolDir">
               <h3>
                  getToolDir 
                  <span class="badge">function</span>
                  
                  <a href="#getToolDir" class="anchor" title="Link to getToolDir">#</a>
               </h3>
               
               <p>getToolDir returns the default value of ToolDir.</p>
               
               <pre><code>func getToolDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goodOSArchFile" data-name="goodOSArchFile">
               <h3>
                  goodOSArchFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#goodOSArchFile" class="anchor" title="Link to goodOSArchFile">#</a>
               </h3>
               
               <p>goodOSArchFile returns false if the name contains a $GOOS or $GOARCH
suffix which does not match the current system.
The recognized name formats are:
name_$(GOOS).*
name_$(GOARCH).*
name_$(GOOS)_$(GOARCH).*
name_$(GOOS)_test.*
name_$(GOARCH)_test.*
name_$(GOOS)_$(GOARCH)_test.*
Exceptions:
if GOOS=android, then files with GOOS=linux are also matched.
if GOOS=illumos, then files with GOOS=solaris are also matched.
if GOOS=ios, then files with GOOS=darwin are also matched.</p>
               
               <pre><code>func (ctxt *Context) goodOSArchFile(name string, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gopath" data-name="gopath">
               <h3>
                  gopath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gopath" class="anchor" title="Link to gopath">#</a>
               </h3>
               
               <p>gopath returns the list of Go path directories.</p>
               
               <pre><code>func (ctxt *Context) gopath() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasGoFiles" data-name="hasGoFiles">
               <h3>
                  hasGoFiles 
                  <span class="badge">function</span>
                  
                  <a href="#hasGoFiles" class="anchor" title="Link to hasGoFiles">#</a>
               </h3>
               
               <p>hasGoFiles reports whether dir contains any files with names ending in .go.
For a vendor check we must exclude directories that contain no .go files.
Otherwise it is not possible to vendor just a/b/c and still import the
non-vendored a/b. See golang.org/issue/13832.</p>
               
               <pre><code>func hasGoFiles(ctxt *Context, dir string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasSubdir" data-name="hasSubdir">
               <h3>
                  hasSubdir 
                  <span class="badge">function</span>
                  
                  <a href="#hasSubdir" class="anchor" title="Link to hasSubdir">#</a>
               </h3>
               
               <p>hasSubdir reports if dir is within root by performing lexical analysis only.</p>
               
               <pre><code>func hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasSubdir" data-name="hasSubdir">
               <h3>
                  hasSubdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasSubdir" class="anchor" title="Link to hasSubdir">#</a>
               </h3>
               
               <p>hasSubdir calls ctxt.HasSubdir (if not nil) or else uses
the local file system to answer the question.</p>
               
               <pre><code>func (ctxt *Context) hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importGo" data-name="importGo">
               <h3>
                  importGo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#importGo" class="anchor" title="Link to importGo">#</a>
               </h3>
               
               <p>importGo checks whether it can use the go command to find the directory for path.
If using the go command is not appropriate, importGo returns errNoModules.
Otherwise, importGo tries using the go command and reports whether that succeeded.
Using the go command lets build.Import and build.Context.Import find code
in Go modules. In the long term we want tools to use go/packages (currently golang.org/x/tools/go/packages),
which will also use the go command.
Invoking the go command here is not very efficient in that it computes information
about the requested package and all dependencies and then only reports about the requested package.
Then we reinvoke it for every dependency. But this is still better than not working at all.
See golang.org/issue/26504.</p>
               
               <pre><code>func (ctxt *Context) importGo(p *Package, path string, srcDir string, mode ImportMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAbsPath" data-name="isAbsPath">
               <h3>
                  isAbsPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isAbsPath" class="anchor" title="Link to isAbsPath">#</a>
               </h3>
               
               <p>isAbsPath calls ctxt.IsAbsPath (if not nil) or else filepath.IsAbs.</p>
               
               <pre><code>func (ctxt *Context) isAbsPath(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDir" data-name="isDir">
               <h3>
                  isDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDir" class="anchor" title="Link to isDir">#</a>
               </h3>
               
               <p>isDir calls ctxt.IsDir (if not nil) or else uses os.Stat.</p>
               
               <pre><code>func (ctxt *Context) isDir(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isFile" data-name="isFile">
               <h3>
                  isFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isFile" class="anchor" title="Link to isFile">#</a>
               </h3>
               
               <p>isFile determines whether path is a file by trying to open it.
It reuses openFile instead of adding another function to the
list in Context.</p>
               
               <pre><code>func (ctxt *Context) isFile(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isGoBuildComment" data-name="isGoBuildComment">
               <h3>
                  isGoBuildComment 
                  <span class="badge">function</span>
                  
                  <a href="#isGoBuildComment" class="anchor" title="Link to isGoBuildComment">#</a>
               </h3>
               
               <pre><code>func isGoBuildComment(line []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIdent" data-name="isIdent">
               <h3>
                  isIdent 
                  <span class="badge">function</span>
                  
                  <a href="#isIdent" class="anchor" title="Link to isIdent">#</a>
               </h3>
               
               <pre><code>func isIdent(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidImport" data-name="isValidImport">
               <h3>
                  isValidImport 
                  <span class="badge">function</span>
                  
                  <a href="#isValidImport" class="anchor" title="Link to isValidImport">#</a>
               </h3>
               
               <p>isValidImport checks if the import is a valid import using the more strict
checks allowed by the implementation restriction in https://go.dev/ref/spec#Import_declarations.
It was ported from the function of the same name that was removed from the
parser in CL 424855, when the parser stopped doing these checks.</p>
               
               <pre><code>func isValidImport(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="joinPath" data-name="joinPath">
               <h3>
                  joinPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#joinPath" class="anchor" title="Link to joinPath">#</a>
               </h3>
               
               <p>joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join.</p>
               
               <pre><code>func (ctxt *Context) joinPath(elem ...string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makePathsAbsolute" data-name="makePathsAbsolute">
               <h3>
                  makePathsAbsolute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makePathsAbsolute" class="anchor" title="Link to makePathsAbsolute">#</a>
               </h3>
               
               <p>makePathsAbsolute looks for compiler options that take paths and
makes them absolute. We do this because through the 1.8 release we
ran the compiler in the package directory, so any relative -I or -L
options would be relative to that directory. In 1.9 we changed to
running the compiler in the build directory, to get consistent
build results (issue #19964). To keep builds working, we change any
relative -I or -L options to be absolute.
Using filepath.IsAbs and filepath.Join here means the results will be
different on different systems, but that's OK: -I and -L options are
inherently system-dependent.</p>
               
               <pre><code>func (ctxt *Context) makePathsAbsolute(args []string, srcDir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchAuto" data-name="matchAuto">
               <h3>
                  matchAuto 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchAuto" class="anchor" title="Link to matchAuto">#</a>
               </h3>
               
               <p>matchAuto interprets text as either a +build or //go:build expression (whichever works),
reporting whether the expression matches the build context.
matchAuto is only used for testing of tag evaluation
and in #cgo lines, which accept either syntax.</p>
               
               <pre><code>func (ctxt *Context) matchAuto(text string, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchFile" data-name="matchFile">
               <h3>
                  matchFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchFile" class="anchor" title="Link to matchFile">#</a>
               </h3>
               
               <p>matchFile determines whether the file with the given name in the given directory
should be included in the package being constructed.
If the file should be included, matchFile returns a non-nil *fileInfo (and a nil error).
Non-nil errors are reserved for unexpected problems.
If name denotes a Go program, matchFile reads until the end of the
imports and returns that section of the file in the fileInfo's header field,
even though it only considers text until the first non-comment
for go:build lines.
If allTags is non-nil, matchFile records any encountered build tag
by setting allTags[tag] = true.</p>
               
               <pre><code>func (ctxt *Context) matchFile(dir string, name string, allTags map[string]bool, binaryOnly *bool, fset *token.FileSet) (*fileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchTag" data-name="matchTag">
               <h3>
                  matchTag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchTag" class="anchor" title="Link to matchTag">#</a>
               </h3>
               
               <p>matchTag reports whether the name is one of:
cgo (if cgo is enabled)
$GOOS
$GOARCH
ctxt.Compiler
linux (if GOOS = android)
solaris (if GOOS = illumos)
darwin (if GOOS = ios)
unix (if this is a Unix GOOS)
boringcrypto (if GOEXPERIMENT=boringcrypto is enabled)
tag (if tag is listed in ctxt.BuildTags, ctxt.ToolTags, or ctxt.ReleaseTags)
It records all consulted tags in allTags.</p>
               
               <pre><code>func (ctxt *Context) matchTag(name string, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameExt" data-name="nameExt">
               <h3>
                  nameExt 
                  <span class="badge">function</span>
                  
                  <a href="#nameExt" class="anchor" title="Link to nameExt">#</a>
               </h3>
               
               <pre><code>func nameExt(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newImportReader" data-name="newImportReader">
               <h3>
                  newImportReader 
                  <span class="badge">function</span>
                  
                  <a href="#newImportReader" class="anchor" title="Link to newImportReader">#</a>
               </h3>
               
               <pre><code>func newImportReader(name string, r io.Reader) *importReader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextByte" data-name="nextByte">
               <h3>
                  nextByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nextByte" class="anchor" title="Link to nextByte">#</a>
               </h3>
               
               <p>nextByte is like peekByte but advances beyond the returned byte.</p>
               
               <pre><code>func (r *importReader) nextByte(skipSpace bool) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openFile" data-name="openFile">
               <h3>
                  openFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openFile" class="anchor" title="Link to openFile">#</a>
               </h3>
               
               <p>openFile calls ctxt.OpenFile (if not nil) or else os.Open.</p>
               
               <pre><code>func (ctxt *Context) openFile(path string) (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFileHeader" data-name="parseFileHeader">
               <h3>
                  parseFileHeader 
                  <span class="badge">function</span>
                  
                  <a href="#parseFileHeader" class="anchor" title="Link to parseFileHeader">#</a>
               </h3>
               
               <p>parseFileHeader should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/bazelbuild/bazel-gazelle
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname parseFileHeader</p>
               
               <pre><code>func parseFileHeader(content []byte) (trimmed []byte, goBuild []byte, sawBinaryOnly bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGoEmbed" data-name="parseGoEmbed">
               <h3>
                  parseGoEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#parseGoEmbed" class="anchor" title="Link to parseGoEmbed">#</a>
               </h3>
               
               <p>parseGoEmbed parses the text following "//go:embed" to extract the glob patterns.
It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.
This is based on a similar function in cmd/compile/internal/gc/noder.go;
this version calculates position information as well.</p>
               
               <pre><code>func parseGoEmbed(args string, pos token.Position) ([]fileEmbed, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseWord" data-name="parseWord">
               <h3>
                  parseWord 
                  <span class="badge">function</span>
                  
                  <a href="#parseWord" class="anchor" title="Link to parseWord">#</a>
               </h3>
               
               <p>parseWord skips any leading spaces or comments in data
and then parses the beginning of data as an identifier or keyword,
returning that word and what remains after the word.</p>
               
               <pre><code>func parseWord(data []byte) (word []byte, rest []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekByte" data-name="peekByte">
               <h3>
                  peekByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekByte" class="anchor" title="Link to peekByte">#</a>
               </h3>
               
               <p>peekByte returns the next byte from the input reader but does not advance beyond it.
If skipSpace is set, peekByte skips leading spaces and comments.</p>
               
               <pre><code>func (r *importReader) peekByte(skipSpace bool) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readByte" data-name="readByte">
               <h3>
                  readByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readByte" class="anchor" title="Link to readByte">#</a>
               </h3>
               
               <p>readByte reads the next byte from the input, saves it in buf, and returns it.
If an error occurs, readByte records the error in r.err and returns 0.</p>
               
               <pre><code>func (r *importReader) readByte() byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readByteNoBuf" data-name="readByteNoBuf">
               <h3>
                  readByteNoBuf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readByteNoBuf" class="anchor" title="Link to readByteNoBuf">#</a>
               </h3>
               
               <p>readByteNoBuf is like readByte but doesn't buffer the byte.
It exhausts r.buf before reading from r.b.</p>
               
               <pre><code>func (r *importReader) readByteNoBuf() byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readComments" data-name="readComments">
               <h3>
                  readComments 
                  <span class="badge">function</span>
                  
                  <a href="#readComments" class="anchor" title="Link to readComments">#</a>
               </h3>
               
               <p>readComments is like io.ReadAll, except that it only reads the leading
block of comments in the file.
readComments should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/bazelbuild/bazel-gazelle
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname readComments</p>
               
               <pre><code>func readComments(f io.Reader) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDir" data-name="readDir">
               <h3>
                  readDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readDir" class="anchor" title="Link to readDir">#</a>
               </h3>
               
               <p>readDir calls ctxt.ReadDir (if not nil) or else os.ReadDir.</p>
               
               <pre><code>func (ctxt *Context) readDir(path string) ([]fs.DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGoInfo" data-name="readGoInfo">
               <h3>
                  readGoInfo 
                  <span class="badge">function</span>
                  
                  <a href="#readGoInfo" class="anchor" title="Link to readGoInfo">#</a>
               </h3>
               
               <p>readGoInfo expects a Go file as input and reads the file up to and including the import section.
It records what it learned in *info.
If info.fset is non-nil, readGoInfo parses the file and sets info.parsed, info.parseErr,
info.imports and info.embeds.
It only returns an error if there are problems reading the file,
not for syntax errors in the file itself.</p>
               
               <pre><code>func readGoInfo(f io.Reader, info *fileInfo) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readIdent" data-name="readIdent">
               <h3>
                  readIdent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readIdent" class="anchor" title="Link to readIdent">#</a>
               </h3>
               
               <p>readIdent reads an identifier from the input.
If an identifier is not present, readIdent records a syntax error.</p>
               
               <pre><code>func (r *importReader) readIdent()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readImport" data-name="readImport">
               <h3>
                  readImport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readImport" class="anchor" title="Link to readImport">#</a>
               </h3>
               
               <p>readImport reads an import clause - optional identifier followed by quoted string -
from the input.</p>
               
               <pre><code>func (r *importReader) readImport()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readKeyword" data-name="readKeyword">
               <h3>
                  readKeyword 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readKeyword" class="anchor" title="Link to readKeyword">#</a>
               </h3>
               
               <p>readKeyword reads the given keyword from the input.
If the keyword is not present, readKeyword records a syntax error.</p>
               
               <pre><code>func (r *importReader) readKeyword(kw string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readString" data-name="readString">
               <h3>
                  readString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readString" class="anchor" title="Link to readString">#</a>
               </h3>
               
               <p>readString reads a quoted string literal from the input.
If an identifier is not present, readString records a syntax error.</p>
               
               <pre><code>func (r *importReader) readString()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeCgoName" data-name="safeCgoName">
               <h3>
                  safeCgoName 
                  <span class="badge">function</span>
                  
                  <a href="#safeCgoName" class="anchor" title="Link to safeCgoName">#</a>
               </h3>
               
               <pre><code>func safeCgoName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveCgo" data-name="saveCgo">
               <h3>
                  saveCgo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveCgo" class="anchor" title="Link to saveCgo">#</a>
               </h3>
               
               <p>saveCgo saves the information from the #cgo lines in the import "C" comment.
These lines set CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS and pkg-config directives
that affect the way cgo's C code is built.</p>
               
               <pre><code>func (ctxt *Context) saveCgo(filename string, di *Package, cg *ast.CommentGroup) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldBuild" data-name="shouldBuild">
               <h3>
                  shouldBuild 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldBuild" class="anchor" title="Link to shouldBuild">#</a>
               </h3>
               
               <p>shouldBuild reports whether it is okay to use this file,
The rule is that in the file's leading run of // comments
and blank lines, which must be followed by a blank line
(to avoid including a Go package clause doc comment),
lines beginning with '//go:build' are taken as build directives.
The file is accepted only if each such line lists something
matching the file. For example:
//go:build windows linux
marks the file as applicable only on Windows and Linux.
For each build tag it consults, shouldBuild sets allTags[tag] = true.
shouldBuild reports whether the file should be built
and whether a //go:binary-only-package comment was found.</p>
               
               <pre><code>func (ctxt *Context) shouldBuild(content []byte, allTags map[string]bool) (shouldBuild bool, binaryOnly bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipSpaceOrComment" data-name="skipSpaceOrComment">
               <h3>
                  skipSpaceOrComment 
                  <span class="badge">function</span>
                  
                  <a href="#skipSpaceOrComment" class="anchor" title="Link to skipSpaceOrComment">#</a>
               </h3>
               
               <p>skipSpaceOrComment returns data with any leading spaces or comments removed.</p>
               
               <pre><code>func skipSpaceOrComment(data []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPathList" data-name="splitPathList">
               <h3>
                  splitPathList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#splitPathList" class="anchor" title="Link to splitPathList">#</a>
               </h3>
               
               <p>splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList.</p>
               
               <pre><code>func (ctxt *Context) splitPathList(s string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitQuoted" data-name="splitQuoted">
               <h3>
                  splitQuoted 
                  <span class="badge">function</span>
                  
                  <a href="#splitQuoted" class="anchor" title="Link to splitQuoted">#</a>
               </h3>
               
               <p>splitQuoted splits the string s around each instance of one or more consecutive
white space characters while taking into account quotes and escaping, and
returns an array of substrings of s or an empty list if s contains only white space.
Single quotes and double quotes are recognized to prevent splitting within the
quoted region, and are removed from the resulting substrings. If a quote in s
isn't closed err will be set and r will have the unclosed argument as the
last element. The backslash is used for escaping.
For example, the following string:
a b:"c d" 'e''f'  "g\""
Would be parsed as:
[]string{"a", "b:c d", "ef", `g"`}</p>
               
               <pre><code>func splitQuoted(s string) (r []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntaxError" data-name="syntaxError">
               <h3>
                  syntaxError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntaxError" class="anchor" title="Link to syntaxError">#</a>
               </h3>
               
               <p>syntaxError records a syntax error, but only if an I/O error has not already been recorded.</p>
               
               <pre><code>func (r *importReader) syntaxError()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uniq" data-name="uniq">
               <h3>
                  uniq 
                  <span class="badge">function</span>
                  
                  <a href="#uniq" class="anchor" title="Link to uniq">#</a>
               </h3>
               
               <pre><code>func uniq(list []string) []string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>