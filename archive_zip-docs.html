<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zip</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>zip</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bufio"
"encoding/binary"
"errors"
"hash"
"hash/crc32"
"internal/godebug"
"io"
"io/fs"
"os"
"path"
"path/filepath"
"slices"
"strings"
"sync"
"time"
"compress/flate"
"errors"
"io"
"sync"
"io/fs"
"path"
"time"
"bufio"
"encoding/binary"
"errors"
"hash"
"hash/crc32"
"io"
"io/fs"
"strings"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Deflate">
               <h3>
                  Deflate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Compression methods.</p>
               
               <pre><code>const Deflate uint16 = 8</code></pre>
            </article>
            
            <article class="global" data-name="ErrAlgorithm">
               <h3>
                  ErrAlgorithm 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrAlgorithm = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrChecksum">
               <h3>
                  ErrChecksum 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrChecksum = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrFormat">
               <h3>
                  ErrFormat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrFormat = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrInsecurePath">
               <h3>
                  ErrInsecurePath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrInsecurePath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Store">
               <h3>
                  Store 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Compression methods.</p>
               
               <pre><code>const Store uint16 = 0</code></pre>
            </article>
            
            <article class="global" data-name="compressors">
               <h3>
                  compressors 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var compressors sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="creatorFAT">
               <h3>
                  creatorFAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Constants for the first byte in CreatorVersion.</p>
               
               <pre><code>const creatorFAT = 0</code></pre>
            </article>
            
            <article class="global" data-name="creatorMacOSX">
               <h3>
                  creatorMacOSX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const creatorMacOSX = 19</code></pre>
            </article>
            
            <article class="global" data-name="creatorNTFS">
               <h3>
                  creatorNTFS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const creatorNTFS = 11</code></pre>
            </article>
            
            <article class="global" data-name="creatorUnix">
               <h3>
                  creatorUnix 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const creatorUnix = 3</code></pre>
            </article>
            
            <article class="global" data-name="creatorVFAT">
               <h3>
                  creatorVFAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const creatorVFAT = 14</code></pre>
            </article>
            
            <article class="global" data-name="dataDescriptor64Len">
               <h3>
                  dataDescriptor64Len 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const dataDescriptor64Len = 24</code></pre>
            </article>
            
            <article class="global" data-name="dataDescriptorLen">
               <h3>
                  dataDescriptorLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const dataDescriptorLen = 16</code></pre>
            </article>
            
            <article class="global" data-name="dataDescriptorSignature">
               <h3>
                  dataDescriptorSignature 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const dataDescriptorSignature = 0x08074b50</code></pre>
            </article>
            
            <article class="global" data-name="decompressors">
               <h3>
                  decompressors 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var decompressors sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="directory64EndLen">
               <h3>
                  directory64EndLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directory64EndLen = 56</code></pre>
            </article>
            
            <article class="global" data-name="directory64EndSignature">
               <h3>
                  directory64EndSignature 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directory64EndSignature = 0x06064b50</code></pre>
            </article>
            
            <article class="global" data-name="directory64LocLen">
               <h3>
                  directory64LocLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directory64LocLen = 20</code></pre>
            </article>
            
            <article class="global" data-name="directory64LocSignature">
               <h3>
                  directory64LocSignature 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directory64LocSignature = 0x07064b50</code></pre>
            </article>
            
            <article class="global" data-name="directoryEndLen">
               <h3>
                  directoryEndLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directoryEndLen = 22</code></pre>
            </article>
            
            <article class="global" data-name="directoryEndSignature">
               <h3>
                  directoryEndSignature 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directoryEndSignature = 0x06054b50</code></pre>
            </article>
            
            <article class="global" data-name="directoryHeaderLen">
               <h3>
                  directoryHeaderLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directoryHeaderLen = 46</code></pre>
            </article>
            
            <article class="global" data-name="directoryHeaderSignature">
               <h3>
                  directoryHeaderSignature 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const directoryHeaderSignature = 0x02014b50</code></pre>
            </article>
            
            <article class="global" data-name="dotFile">
               <h3>
                  dotFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dotFile = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errLongExtra">
               <h3>
                  errLongExtra 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLongExtra = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errLongName">
               <h3>
                  errLongName 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLongName = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="extTimeExtraID">
               <h3>
                  extTimeExtraID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const extTimeExtraID = 0x5455</code></pre>
            </article>
            
            <article class="global" data-name="fileHeaderLen">
               <h3>
                  fileHeaderLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fileHeaderLen = 30</code></pre>
            </article>
            
            <article class="global" data-name="fileHeaderSignature">
               <h3>
                  fileHeaderSignature 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fileHeaderSignature = 0x04034b50</code></pre>
            </article>
            
            <article class="global" data-name="flateReaderPool">
               <h3>
                  flateReaderPool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var flateReaderPool sync.Pool</code></pre>
            </article>
            
            <article class="global" data-name="flateWriterPool">
               <h3>
                  flateWriterPool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var flateWriterPool sync.Pool</code></pre>
            </article>
            
            <article class="global" data-name="infoZipUnixExtraID">
               <h3>
                  infoZipUnixExtraID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const infoZipUnixExtraID = 0x5855</code></pre>
            </article>
            
            <article class="global" data-name="msdosDir">
               <h3>
                  msdosDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const msdosDir = 0x10</code></pre>
            </article>
            
            <article class="global" data-name="msdosReadOnly">
               <h3>
                  msdosReadOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const msdosReadOnly = 0x01</code></pre>
            </article>
            
            <article class="global" data-name="ntfsExtraID">
               <h3>
                  ntfsExtraID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ntfsExtraID = 0x000a</code></pre>
            </article>
            
            <article class="global" data-name="s_IFBLK">
               <h3>
                  s_IFBLK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFBLK = 0x6000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFCHR">
               <h3>
                  s_IFCHR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFCHR = 0x2000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFDIR">
               <h3>
                  s_IFDIR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFDIR = 0x4000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFIFO">
               <h3>
                  s_IFIFO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFIFO = 0x1000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFLNK">
               <h3>
                  s_IFLNK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFLNK = 0xa000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFMT">
               <h3>
                  s_IFMT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Unix constants. The specification doesn't mention them,
but these seem to be the values agreed on by tools.</p>
               
               <pre><code>const s_IFMT = 0xf000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFREG">
               <h3>
                  s_IFREG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFREG = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="s_IFSOCK">
               <h3>
                  s_IFSOCK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_IFSOCK = 0xc000</code></pre>
            </article>
            
            <article class="global" data-name="s_ISGID">
               <h3>
                  s_ISGID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_ISGID = 0x400</code></pre>
            </article>
            
            <article class="global" data-name="s_ISUID">
               <h3>
                  s_ISUID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_ISUID = 0x800</code></pre>
            </article>
            
            <article class="global" data-name="s_ISVTX">
               <h3>
                  s_ISVTX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const s_ISVTX = 0x200</code></pre>
            </article>
            
            <article class="global" data-name="uint16max">
               <h3>
                  uint16max 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Limits for non zip64 files.</p>
               
               <pre><code>const uint16max = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="uint32max">
               <h3>
                  uint32max 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const uint32max = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="unixExtraID">
               <h3>
                  unixExtraID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const unixExtraID = 0x000d</code></pre>
            </article>
            
            <article class="global" data-name="zip64ExtraID">
               <h3>
                  zip64ExtraID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Extra header IDs.
IDs 0..31 are reserved for official use by PKWARE.
IDs above that range are defined by third-party vendors.
Since ZIP lacked high precision timestamps (nor an official specification
of the timezone used for the date fields), many competing extra fields
have been invented. Pervasive use effectively makes them "official".
See http://mdfs.net/Docs/Comp/Archiving/Zip/ExtraField</p>
               
               <pre><code>const zip64ExtraID = 0x0001</code></pre>
            </article>
            
            <article class="global" data-name="zipVersion20">
               <h3>
                  zipVersion20 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Version numbers.</p>
               
               <pre><code>const zipVersion20 = 20</code></pre>
            </article>
            
            <article class="global" data-name="zipVersion45">
               <h3>
                  zipVersion45 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const zipVersion45 = 45</code></pre>
            </article>
            
            <article class="global" data-name="zipinsecurepath">
               <h3>
                  zipinsecurepath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var zipinsecurepath = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Compressor">
               <h3>
                  Compressor
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Compressor returns a new compressing writer, writing to w.
The WriteCloser's Close method must be used to flush pending data to w.
The Compressor itself must be safe to invoke from multiple goroutines
simultaneously, but each returned writer will be used only by
one goroutine at a time.</p>
               
               <pre><code>type Compressor func(w io.Writer) (io.WriteCloser, error)</code></pre>
            </article>
            
            <article class="type" data-name="Decompressor">
               <h3>
                  Decompressor
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Decompressor returns a new decompressing reader, reading from r.
The [io.ReadCloser]'s Close method must be used to release associated resources.
The Decompressor itself must be safe to invoke from multiple goroutines
simultaneously, but each returned reader will be used only by
one goroutine at a time.</p>
               
               <pre><code>type Decompressor func(r io.Reader) io.ReadCloser</code></pre>
            </article>
            
            <article class="type" data-name="readBuf">
               <h3>
                  readBuf
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type readBuf []byte</code></pre>
            </article>
            
            <article class="type" data-name="writeBuf">
               <h3>
                  writeBuf
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type writeBuf []byte</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="fileInfoDirEntry">
               <h3>
                  fileInfoDirEntry
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type fileInfoDirEntry interface {
fs.FileInfo
fs.DirEntry
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
               </h3>
               
               <p>A File is a single file in a ZIP archive.
The file information is in the embedded [FileHeader].
The file content can be accessed by calling [File.Open].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type File struct {
FileHeader
zip *Reader
zipr io.ReaderAt
headerOffset int64
zip64 bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="FileHeader">
               <h3>
                  FileHeader
                  <span class="badge">struct</span>
               </h3>
               
               <p>FileHeader describes a file within a ZIP file.
See the [ZIP specification] for details.
[ZIP specification]: https://support.pkware.com/pkzip/appnote</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FileHeader struct {
Name string
Comment string
NonUTF8 bool
CreatorVersion uint16
ReaderVersion uint16
Flags uint16
Method uint16
Modified time.Time
ModifiedTime uint16
ModifiedDate uint16
CRC32 uint32
CompressedSize uint32
UncompressedSize uint32
CompressedSize64 uint64
UncompressedSize64 uint64
Extra []byte
ExternalAttrs uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="ReadCloser">
               <h3>
                  ReadCloser
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ReadCloser is a [Reader] that must be closed when no longer needed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ReadCloser struct {
f *os.File
Reader
}</code></pre>
            </article>
            
            <article class="struct" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Reader serves content from a ZIP archive.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
r io.ReaderAt
File []*File
Comment string
decompressors map[uint16]Decompressor
baseOffset int64
fileListOnce sync.Once
fileList []fileListEntry
}</code></pre>
            </article>
            
            <article class="struct" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
               </h3>
               
               <p>Writer implements a zip file writer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
cw *countWriter
dir []*header
last *fileWriter
closed bool
compressors map[uint16]Compressor
comment string
testHookCloseSizeOffset func(size uint64, offset uint64)
}</code></pre>
            </article>
            
            <article class="struct" data-name="checksumReader">
               <h3>
                  checksumReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type checksumReader struct {
rc io.ReadCloser
hash hash.Hash32
nread uint64
f *File
desr io.Reader
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="countWriter">
               <h3>
                  countWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type countWriter struct {
w io.Writer
count int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="dirReader">
               <h3>
                  dirReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirReader struct {
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="dirWriter">
               <h3>
                  dirWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirWriter struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="directoryEnd">
               <h3>
                  directoryEnd
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type directoryEnd struct {
diskNbr uint32
dirDiskNbr uint32
dirRecordsThisDisk uint64
directoryRecords uint64
directorySize uint64
directoryOffset uint64
commentLen uint16
comment string
}</code></pre>
            </article>
            
            <article class="struct" data-name="fileListEntry">
               <h3>
                  fileListEntry
                  <span class="badge">struct</span>
               </h3>
               
               <p>A fileListEntry is a File and its ename.
If file == nil, the fileListEntry describes a directory without metadata.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileListEntry struct {
name string
file *File
isDir bool
isDup bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="fileWriter">
               <h3>
                  fileWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileWriter struct {
*header
zipw io.Writer
rawCount *countWriter
comp io.WriteCloser
compCount *countWriter
crc32 hash.Hash32
closed bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="header">
               <h3>
                  header
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type header struct {
*FileHeader
offset uint64
raw bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="headerFileInfo">
               <h3>
                  headerFileInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>headerFileInfo implements [fs.FileInfo].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type headerFileInfo struct {
fh *FileHeader
}</code></pre>
            </article>
            
            <article class="struct" data-name="nopCloser">
               <h3>
                  nopCloser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nopCloser struct {
io.Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="openDir">
               <h3>
                  openDir
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type openDir struct {
e *fileListEntry
files []fileListEntry
offset int
}</code></pre>
            </article>
            
            <article class="struct" data-name="pooledFlateReader">
               <h3>
                  pooledFlateReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pooledFlateReader struct {
mu sync.Mutex
fr io.ReadCloser
}</code></pre>
            </article>
            
            <article class="struct" data-name="pooledFlateWriter">
               <h3>
                  pooledFlateWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pooledFlateWriter struct {
mu sync.Mutex
fw *flate.Writer
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddFS">
               <h3>
                  AddFS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddFS adds the files from fs.FS to the archive.
It walks the directory tree starting at the root of the filesystem
adding each file to the zip using deflate while maintaining the directory structure.</p>
               
               <pre><code>func (w *Writer) AddFS(fsys fs.FS) error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *dirReader) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *pooledFlateWriter) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w nopCloser) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *openDir) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the Zip file, rendering it unusable for I/O.</p>
               
               <pre><code>func (rc *ReadCloser) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *pooledFlateReader) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *checksumReader) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close finishes writing the zip file by writing the central directory.
It does not close the underlying writer.</p>
               
               <pre><code>func (w *Writer) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy copies the file f (obtained from a [Reader]) into w. It copies the raw
form directly bypassing decompression, compression, and validation.</p>
               
               <pre><code>func (w *Writer) Copy(f *File) error</code></pre>
            </article>
            
            <article class="function" data-name="Create">
               <h3>
                  Create 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Create adds a file to the zip file using the provided name.
It returns a [Writer] to which the file contents should be written.
The file contents will be compressed using the [Deflate] method.
The name must be a relative path: it must not start with a drive
letter (e.g. C:) or leading slash, and only forward slashes are
allowed. To create a directory instead of a file, add a trailing
slash to the name. Duplicate names will not overwrite previous entries
and are appended to the zip file.
The file's contents must be written to the [io.Writer] before the next
call to [Writer.Create], [Writer.CreateHeader], or [Writer.Close].</p>
               
               <pre><code>func (w *Writer) Create(name string) (io.Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="CreateHeader">
               <h3>
                  CreateHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CreateHeader adds a file to the zip archive using the provided [FileHeader]
for the file metadata. [Writer] takes ownership of fh and may mutate
its fields. The caller must not modify fh after calling [Writer.CreateHeader].
This returns a [Writer] to which the file contents should be written.
The file's contents must be written to the io.Writer before the next
call to [Writer.Create], [Writer.CreateHeader], [Writer.CreateRaw], or [Writer.Close].</p>
               
               <pre><code>func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="CreateRaw">
               <h3>
                  CreateRaw 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CreateRaw adds a file to the zip archive using the provided [FileHeader] and
returns a [Writer] to which the file contents should be written. The file's
contents must be written to the io.Writer before the next call to [Writer.Create],
[Writer.CreateHeader], [Writer.CreateRaw], or [Writer.Close].
In contrast to [Writer.CreateHeader], the bytes passed to Writer are not compressed.
CreateRaw's argument is stored in w. If the argument is a pointer to the embedded
[FileHeader] in a [File] obtained from a [Reader] created from in-memory data,
then w will refer to all of that memory.</p>
               
               <pre><code>func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="DataOffset">
               <h3>
                  DataOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DataOffset returns the offset of the file's possibly-compressed
data, relative to the beginning of the zip file.
Most callers should instead use [File.Open], which transparently
decompresses data and verifies checksums.</p>
               
               <pre><code>func (f *File) DataOffset() (offset int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="FileInfo">
               <h3>
                  FileInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FileInfo returns an fs.FileInfo for the [FileHeader].</p>
               
               <pre><code>func (h *FileHeader) FileInfo() fs.FileInfo</code></pre>
            </article>
            
            <article class="function" data-name="FileInfoHeader">
               <h3>
                  FileInfoHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FileInfoHeader creates a partially-populated [FileHeader] from an
fs.FileInfo.
Because fs.FileInfo's Name method returns only the base name of
the file it describes, it may be necessary to modify the Name field
of the returned header to provide the full path name of the file.
If compression is desired, callers should set the FileHeader.Method
field; it is unset by default.</p>
               
               <pre><code>func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</code></pre>
            </article>
            
            <article class="function" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Flush flushes any buffered data to the underlying writer.
Calling Flush is not normally necessary; calling Close is sufficient.</p>
               
               <pre><code>func (w *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) Info() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) Info() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) IsDir() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ModTime returns the modification time in UTC using the legacy
[ModifiedDate] and [ModifiedTime] fields.
Deprecated: Use [Modified] instead.</p>
               
               <pre><code>func (h *FileHeader) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mode returns the permission and mode bits for the [FileHeader].</p>
               
               <pre><code>func (h *FileHeader) Mode() (mode fs.FileMode)</code></pre>
            </article>
            
            <article class="function" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) Mode() fs.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) Mode() fs.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Only used for directories.</p>
               
               <pre><code>func (f *fileListEntry) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReader returns a new [Reader] reading from r, which is assumed to
have the given size in bytes.
If any file inside the archive uses a non-local name
(as defined by [filepath.IsLocal]) or a name containing backslashes
and the GODEBUG environment variable contains `zipinsecurepath=0`,
NewReader returns the reader with an [ErrInsecurePath] error.
A future version of Go may introduce this behavior by default.
Programs that want to accept non-local names can ignore
the [ErrInsecurePath] error and use the returned reader.</p>
               
               <pre><code>func NewReader(r io.ReaderAt, size int64) (*Reader, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewWriter returns a new [Writer] writing a zip file to w.</p>
               
               <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Open opens the named file in the ZIP archive,
using the semantics of fs.FS.Open:
paths are always slash separated, with no
leading / or ../ elements.</p>
               
               <pre><code>func (r *Reader) Open(name string) (fs.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Open returns a [ReadCloser] that provides access to the [File]'s contents.
Multiple files may be read concurrently.</p>
               
               <pre><code>func (f *File) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="OpenRaw">
               <h3>
                  OpenRaw 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OpenRaw returns a [Reader] that provides access to the [File]'s contents without
decompression.</p>
               
               <pre><code>func (f *File) OpenRaw() (io.Reader, error)</code></pre>
            </article>
            
            <article class="function" data-name="OpenReader">
               <h3>
                  OpenReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>OpenReader will open the Zip file specified by name and return a ReadCloser.
If any file inside the archive uses a non-local name
(as defined by [filepath.IsLocal]) or a name containing backslashes
and the GODEBUG environment variable contains `zipinsecurepath=0`,
OpenReader returns the reader with an ErrInsecurePath error.
A future version of Go may introduce this behavior by default.
Programs that want to accept non-local names can ignore
the ErrInsecurePath error and use the returned reader.</p>
               
               <pre><code>func OpenReader(name string) (*ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *dirReader) Read([]byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *openDir) Read([]byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *pooledFlateReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *checksumReader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *openDir) ReadDir(count int) ([]fs.DirEntry, error)</code></pre>
            </article>
            
            <article class="function" data-name="RegisterCompressor">
               <h3>
                  RegisterCompressor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RegisterCompressor registers or overrides a custom compressor for a specific
method ID. If a compressor for a given method is not found, [Writer] will
default to looking up the compressor at the package level.</p>
               
               <pre><code>func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</code></pre>
            </article>
            
            <article class="function" data-name="RegisterCompressor">
               <h3>
                  RegisterCompressor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RegisterCompressor registers custom compressors for a specified method ID.
The common methods [Store] and [Deflate] are built in.</p>
               
               <pre><code>func RegisterCompressor(method uint16, comp Compressor)</code></pre>
            </article>
            
            <article class="function" data-name="RegisterDecompressor">
               <h3>
                  RegisterDecompressor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RegisterDecompressor allows custom decompressors for a specified method ID.
The common methods [Store] and [Deflate] are built in.</p>
               
               <pre><code>func RegisterDecompressor(method uint16, dcomp Decompressor)</code></pre>
            </article>
            
            <article class="function" data-name="RegisterDecompressor">
               <h3>
                  RegisterDecompressor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RegisterDecompressor registers or overrides a custom decompressor for a
specific method ID. If a decompressor for a given method is not found,
[Reader] will default to looking up the decompressor at the package level.</p>
               
               <pre><code>func (r *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</code></pre>
            </article>
            
            <article class="function" data-name="SetComment">
               <h3>
                  SetComment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetComment sets the end-of-central-directory comment field.
It can only be called before [Writer.Close].</p>
               
               <pre><code>func (w *Writer) SetComment(comment string) error</code></pre>
            </article>
            
            <article class="function" data-name="SetModTime">
               <h3>
                  SetModTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetModTime sets the [Modified], [ModifiedTime], and [ModifiedDate] fields
to the given time in UTC.
Deprecated: Use [Modified] instead.</p>
               
               <pre><code>func (h *FileHeader) SetModTime(t time.Time)</code></pre>
            </article>
            
            <article class="function" data-name="SetMode">
               <h3>
                  SetMode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMode changes the permission and mode bits for the [FileHeader].</p>
               
               <pre><code>func (h *FileHeader) SetMode(mode fs.FileMode)</code></pre>
            </article>
            
            <article class="function" data-name="SetOffset">
               <h3>
                  SetOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetOffset sets the offset of the beginning of the zip data within the
underlying writer. It should be used when the zip data is appended to an
existing file, such as a binary executable.
It must be called before any data is written.</p>
               
               <pre><code>func (w *Writer) SetOffset(n int64)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *openDir) Stat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *checksumReader) Stat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) Sys() any</code></pre>
            </article>
            
            <article class="function" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) Sys() any</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi headerFileInfo) Type() fs.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) Type() fs.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *fileWriter) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dirWriter) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *countWriter) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *pooledFlateWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *fileWriter) close() error</code></pre>
            </article>
            
            <article class="function" data-name="compressor">
               <h3>
                  compressor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *Writer) compressor(method uint16) Compressor</code></pre>
            </article>
            
            <article class="function" data-name="compressor">
               <h3>
                  compressor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func compressor(method uint16) Compressor</code></pre>
            </article>
            
            <article class="function" data-name="decompressor">
               <h3>
                  decompressor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decompressor(method uint16) Decompressor</code></pre>
            </article>
            
            <article class="function" data-name="decompressor">
               <h3>
                  decompressor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Reader) decompressor(method uint16) Decompressor</code></pre>
            </article>
            
            <article class="function" data-name="detectUTF8">
               <h3>
                  detectUTF8 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>detectUTF8 reports whether s is a valid UTF-8 string, and whether the string
must be considered UTF-8 encoding (i.e., not compatible with CP-437, ASCII,
or any other common encoding).</p>
               
               <pre><code>func detectUTF8(s string) (valid bool, require bool)</code></pre>
            </article>
            
            <article class="function" data-name="fileEntryCompare">
               <h3>
                  fileEntryCompare 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileEntryCompare(x string, y string) int</code></pre>
            </article>
            
            <article class="function" data-name="fileModeToUnixMode">
               <h3>
                  fileModeToUnixMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileModeToUnixMode(mode fs.FileMode) uint32</code></pre>
            </article>
            
            <article class="function" data-name="findBodyOffset">
               <h3>
                  findBodyOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findBodyOffset does the minimum work to verify the file has a header
and returns the file body offset.</p>
               
               <pre><code>func (f *File) findBodyOffset() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="findDirectory64End">
               <h3>
                  findDirectory64End 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>findDirectory64End tries to read the zip64 locator just before the
directory end and returns the offset of the zip64 directory end if
found.</p>
               
               <pre><code>func findDirectory64End(r io.ReaderAt, directoryEndOffset int64) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="findSignatureInBlock">
               <h3>
                  findSignatureInBlock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findSignatureInBlock(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="hasDataDescriptor">
               <h3>
                  hasDataDescriptor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *FileHeader) hasDataDescriptor() bool</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Reader) init(rdr io.ReaderAt, size int64) error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="initFileList">
               <h3>
                  initFileList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Reader) initFileList()</code></pre>
            </article>
            
            <article class="function" data-name="isZip64">
               <h3>
                  isZip64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isZip64 reports whether the file size exceeds the 32 bit limit</p>
               
               <pre><code>func (h *FileHeader) isZip64() bool</code></pre>
            </article>
            
            <article class="function" data-name="msDosTimeToTime">
               <h3>
                  msDosTimeToTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>msDosTimeToTime converts an MS-DOS date and time into a time.Time.
The resolution is 2s.
See: https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime</p>
               
               <pre><code>func msDosTimeToTime(dosDate uint16, dosTime uint16) time.Time</code></pre>
            </article>
            
            <article class="function" data-name="msdosModeToFileMode">
               <h3>
                  msdosModeToFileMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func msdosModeToFileMode(m uint32) (mode fs.FileMode)</code></pre>
            </article>
            
            <article class="function" data-name="newFlateReader">
               <h3>
                  newFlateReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFlateReader(r io.Reader) io.ReadCloser</code></pre>
            </article>
            
            <article class="function" data-name="newFlateWriter">
               <h3>
                  newFlateWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFlateWriter(w io.Writer) io.WriteCloser</code></pre>
            </article>
            
            <article class="function" data-name="openLookup">
               <h3>
                  openLookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Reader) openLookup(name string) *fileListEntry</code></pre>
            </article>
            
            <article class="function" data-name="openReadDir">
               <h3>
                  openReadDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Reader) openReadDir(dir string) []fileListEntry</code></pre>
            </article>
            
            <article class="function" data-name="prepare">
               <h3>
                  prepare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>prepare performs the bookkeeping operations required at the start of
CreateHeader and CreateRaw.</p>
               
               <pre><code>func (w *Writer) prepare(fh *FileHeader) error</code></pre>
            </article>
            
            <article class="function" data-name="readDataDescriptor">
               <h3>
                  readDataDescriptor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readDataDescriptor(r io.Reader, f *File) error</code></pre>
            </article>
            
            <article class="function" data-name="readDirectory64End">
               <h3>
                  readDirectory64End 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readDirectory64End reads the zip64 directory end and updates the
directory end with the zip64 directory end values.</p>
               
               <pre><code>func readDirectory64End(r io.ReaderAt, offset int64, d *directoryEnd) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="readDirectoryEnd">
               <h3>
                  readDirectoryEnd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, baseOffset int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readDirectoryHeader">
               <h3>
                  readDirectoryHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readDirectoryHeader attempts to read a directory header from r.
It returns io.ErrUnexpectedEOF if it cannot read a complete header,
and ErrFormat if it doesn't find a valid header signature.</p>
               
               <pre><code>func readDirectoryHeader(f *File, r io.Reader) error</code></pre>
            </article>
            
            <article class="function" data-name="split">
               <h3>
                  split 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func split(name string) (dir string, elem string, isDir bool)</code></pre>
            </article>
            
            <article class="function" data-name="stat">
               <h3>
                  stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fileListEntry) stat() (fileInfoDirEntry, error)</code></pre>
            </article>
            
            <article class="function" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *readBuf) sub(n int) readBuf</code></pre>
            </article>
            
            <article class="function" data-name="timeToMsDosTime">
               <h3>
                  timeToMsDosTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>timeToMsDosTime converts a time.Time to an MS-DOS date and time.
The resolution is 2s.
See: https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-filetimetodosdatetime</p>
               
               <pre><code>func timeToMsDosTime(t time.Time) (fDate uint16, fTime uint16)</code></pre>
            </article>
            
            <article class="function" data-name="timeZone">
               <h3>
                  timeZone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>timeZone returns a *time.Location based on the provided offset.
If the offset is non-sensible, then this uses an offset of zero.</p>
               
               <pre><code>func timeZone(offset time.Duration) *time.Location</code></pre>
            </article>
            
            <article class="function" data-name="toValidName">
               <h3>
                  toValidName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>toValidName coerces name to be a valid name for fs.FS.Open.</p>
               
               <pre><code>func toValidName(name string) string</code></pre>
            </article>
            
            <article class="function" data-name="uint16">
               <h3>
                  uint16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *readBuf) uint16() uint16</code></pre>
            </article>
            
            <article class="function" data-name="uint16">
               <h3>
                  uint16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *writeBuf) uint16(v uint16)</code></pre>
            </article>
            
            <article class="function" data-name="uint32">
               <h3>
                  uint32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *readBuf) uint32() uint32</code></pre>
            </article>
            
            <article class="function" data-name="uint32">
               <h3>
                  uint32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *writeBuf) uint32(v uint32)</code></pre>
            </article>
            
            <article class="function" data-name="uint64">
               <h3>
                  uint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *readBuf) uint64() uint64</code></pre>
            </article>
            
            <article class="function" data-name="uint64">
               <h3>
                  uint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *writeBuf) uint64(v uint64)</code></pre>
            </article>
            
            <article class="function" data-name="uint8">
               <h3>
                  uint8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *readBuf) uint8() uint8</code></pre>
            </article>
            
            <article class="function" data-name="uint8">
               <h3>
                  uint8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *writeBuf) uint8(v uint8)</code></pre>
            </article>
            
            <article class="function" data-name="unixModeToFileMode">
               <h3>
                  unixModeToFileMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unixModeToFileMode(m uint32) fs.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="writeDataDescriptor">
               <h3>
                  writeDataDescriptor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *fileWriter) writeDataDescriptor() error</code></pre>
            </article>
            
            <article class="function" data-name="writeHeader">
               <h3>
                  writeHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeHeader(w io.Writer, h *header) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
