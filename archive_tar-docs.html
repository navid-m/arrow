<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - tar</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>tar</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"errors"
"fmt"
"internal/godebug"
"io/fs"
"maps"
"math"
"path"
"reflect"
"strconv"
"strings"
"time"
"strings"
"bytes"
"io"
"path/filepath"
"strconv"
"strings"
"time"
"syscall"
"time"
"syscall"
"time"
"io/fs"
"os/user"
"runtime"
"strconv"
"sync"
"syscall"
"bytes"
"fmt"
"strconv"
"strings"
"time"
"errors"
"fmt"
"io"
"io/fs"
"maps"
"path"
"slices"
"strings"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrFieldTooLong" data-name="ErrFieldTooLong">
               <h3>
                  ErrFieldTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrFieldTooLong" class="anchor" title="Link to ErrFieldTooLong">#</a>
               </h3>
               
               <pre><code>var ErrFieldTooLong = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrHeader" data-name="ErrHeader">
               <h3>
                  ErrHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrHeader" class="anchor" title="Link to ErrHeader">#</a>
               </h3>
               
               <pre><code>var ErrHeader = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInsecurePath" data-name="ErrInsecurePath">
               <h3>
                  ErrInsecurePath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrInsecurePath" class="anchor" title="Link to ErrInsecurePath">#</a>
               </h3>
               
               <pre><code>var ErrInsecurePath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrWriteAfterClose" data-name="ErrWriteAfterClose">
               <h3>
                  ErrWriteAfterClose 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrWriteAfterClose" class="anchor" title="Link to ErrWriteAfterClose">#</a>
               </h3>
               
               <pre><code>var ErrWriteAfterClose = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrWriteTooLong" data-name="ErrWriteTooLong">
               <h3>
                  ErrWriteTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrWriteTooLong" class="anchor" title="Link to ErrWriteTooLong">#</a>
               </h3>
               
               <pre><code>var ErrWriteTooLong = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FormatGNU" data-name="FormatGNU">
               <h3>
                  FormatGNU 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FormatGNU" class="anchor" title="Link to FormatGNU">#</a>
               </h3>
               
               <p>FormatGNU represents the GNU header format.
The GNU header format is older than the USTAR and PAX standards and
is not compatible with them. The GNU format supports
arbitrary file sizes, filenames of arbitrary encoding and length,
sparse files, and other features.
It is recommended that PAX be chosen over GNU unless the target
application can only parse GNU formatted archives.
Reference:
https://www.gnu.org/software/tar/manual/html_node/Standard.html</p>
               
               <pre><code>const FormatGNU</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FormatPAX" data-name="FormatPAX">
               <h3>
                  FormatPAX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FormatPAX" class="anchor" title="Link to FormatPAX">#</a>
               </h3>
               
               <p>FormatPAX represents the PAX header format defined in POSIX.1-2001.
PAX extends USTAR by writing a special file with Typeflag TypeXHeader
preceding the original header. This file contains a set of key-value
records, which are used to overcome USTAR's shortcomings, in addition to
providing the ability to have sub-second resolution for timestamps.
Some newer formats add their own extensions to PAX by defining their
own keys and assigning certain semantic meaning to the associated values.
For example, sparse file support in PAX is implemented using keys
defined by the GNU manual (e.g., "GNU.sparse.map").
Reference:
http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html</p>
               
               <pre><code>const FormatPAX</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FormatUSTAR" data-name="FormatUSTAR">
               <h3>
                  FormatUSTAR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FormatUSTAR" class="anchor" title="Link to FormatUSTAR">#</a>
               </h3>
               
               <p>FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.
While this format is compatible with most tar readers,
the format has several limitations making it unsuitable for some usages.
Most notably, it cannot support sparse files, files larger than 8GiB,
filenames larger than 256 characters, and non-ASCII filenames.
Reference:
http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06</p>
               
               <pre><code>const FormatUSTAR</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FormatUnknown" data-name="FormatUnknown">
               <h3>
                  FormatUnknown 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FormatUnknown" class="anchor" title="Link to FormatUnknown">#</a>
               </h3>
               
               <p>FormatUnknown indicates that the format is unknown.</p>
               
               <pre><code>const FormatUnknown</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeBlock" data-name="TypeBlock">
               <h3>
                  TypeBlock 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeBlock" class="anchor" title="Link to TypeBlock">#</a>
               </h3>
               
               <p>Type flags for Header.Typeflag.</p>
               
               <pre><code>const TypeBlock = '4'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeChar" data-name="TypeChar">
               <h3>
                  TypeChar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeChar" class="anchor" title="Link to TypeChar">#</a>
               </h3>
               
               <p>Type flags for Header.Typeflag.</p>
               
               <pre><code>const TypeChar = '3'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeCont" data-name="TypeCont">
               <h3>
                  TypeCont 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeCont" class="anchor" title="Link to TypeCont">#</a>
               </h3>
               
               <p>Type '7' is reserved.</p>
               
               <pre><code>const TypeCont = '7'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeDir" data-name="TypeDir">
               <h3>
                  TypeDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeDir" class="anchor" title="Link to TypeDir">#</a>
               </h3>
               
               <p>Type flags for Header.Typeflag.</p>
               
               <pre><code>const TypeDir = '5'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeFifo" data-name="TypeFifo">
               <h3>
                  TypeFifo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeFifo" class="anchor" title="Link to TypeFifo">#</a>
               </h3>
               
               <p>Type flags for Header.Typeflag.</p>
               
               <pre><code>const TypeFifo = '6'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeGNULongLink" data-name="TypeGNULongLink">
               <h3>
                  TypeGNULongLink 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeGNULongLink" class="anchor" title="Link to TypeGNULongLink">#</a>
               </h3>
               
               <p>Type flags for Header.Typeflag.</p>
               
               <pre><code>const TypeGNULongLink = 'K'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeGNULongName" data-name="TypeGNULongName">
               <h3>
                  TypeGNULongName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeGNULongName" class="anchor" title="Link to TypeGNULongName">#</a>
               </h3>
               
               <p>Types 'L' and 'K' are used by the GNU format for a meta file
used to store the path or link name for the next file.
This package transparently handles these types.</p>
               
               <pre><code>const TypeGNULongName = 'L'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeGNUSparse" data-name="TypeGNUSparse">
               <h3>
                  TypeGNUSparse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeGNUSparse" class="anchor" title="Link to TypeGNUSparse">#</a>
               </h3>
               
               <p>Type 'S' indicates a sparse file in the GNU format.</p>
               
               <pre><code>const TypeGNUSparse = 'S'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeLink" data-name="TypeLink">
               <h3>
                  TypeLink 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeLink" class="anchor" title="Link to TypeLink">#</a>
               </h3>
               
               <p>Type '1' to '6' are header-only flags and may not have a data body.</p>
               
               <pre><code>const TypeLink = '1'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeReg" data-name="TypeReg">
               <h3>
                  TypeReg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeReg" class="anchor" title="Link to TypeReg">#</a>
               </h3>
               
               <p>Type '0' indicates a regular file.</p>
               
               <pre><code>const TypeReg = '0'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeRegA" data-name="TypeRegA">
               <h3>
                  TypeRegA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeRegA" class="anchor" title="Link to TypeRegA">#</a>
               </h3>
               
               <p>Deprecated: Use TypeReg instead.</p>
               
               <pre><code>const TypeRegA = '\x00'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeSymlink" data-name="TypeSymlink">
               <h3>
                  TypeSymlink 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeSymlink" class="anchor" title="Link to TypeSymlink">#</a>
               </h3>
               
               <p>Type flags for Header.Typeflag.</p>
               
               <pre><code>const TypeSymlink = '2'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeXGlobalHeader" data-name="TypeXGlobalHeader">
               <h3>
                  TypeXGlobalHeader 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeXGlobalHeader" class="anchor" title="Link to TypeXGlobalHeader">#</a>
               </h3>
               
               <p>Type 'g' is used by the PAX format to store key-value records that
are relevant to all subsequent files.
This package only supports parsing and composing such headers,
but does not currently support persisting the global state across files.</p>
               
               <pre><code>const TypeXGlobalHeader = 'g'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TypeXHeader" data-name="TypeXHeader">
               <h3>
                  TypeXHeader 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TypeXHeader" class="anchor" title="Link to TypeXHeader">#</a>
               </h3>
               
               <p>Type 'x' is used by the PAX format to store key-value records that
are only relevant to the next file.
This package transparently handles these types.</p>
               
               <pre><code>const TypeXHeader = 'x'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>Deliberately hide the meaning of constants from public API.</p>
               
               <pre><code>const _ Format = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="basicKeys" data-name="basicKeys">
               <h3>
                  basicKeys 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#basicKeys" class="anchor" title="Link to basicKeys">#</a>
               </h3>
               
               <p>basicKeys is a set of the PAX keys for which we have built-in support.
This does not contain "charset" or "comment", which are both PAX-specific,
so adding them as first-class features of Header is unlikely.
Users can use the PAXRecords field to set it themselves.</p>
               
               <pre><code>var basicKeys = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blockSize" data-name="blockSize">
               <h3>
                  blockSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#blockSize" class="anchor" title="Link to blockSize">#</a>
               </h3>
               
               <p>Size constants from various tar specifications.</p>
               
               <pre><code>const blockSize = 512</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISBLK" data-name="c_ISBLK">
               <h3>
                  c_ISBLK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISBLK" class="anchor" title="Link to c_ISBLK">#</a>
               </h3>
               
               <pre><code>const c_ISBLK = 060000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISCHR" data-name="c_ISCHR">
               <h3>
                  c_ISCHR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISCHR" class="anchor" title="Link to c_ISCHR">#</a>
               </h3>
               
               <pre><code>const c_ISCHR = 020000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISDIR" data-name="c_ISDIR">
               <h3>
                  c_ISDIR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISDIR" class="anchor" title="Link to c_ISDIR">#</a>
               </h3>
               
               <p>Common Unix mode constants; these are not defined in any common tar standard.
Header.FileInfo understands these, but FileInfoHeader will never produce these.</p>
               
               <pre><code>const c_ISDIR = 040000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISFIFO" data-name="c_ISFIFO">
               <h3>
                  c_ISFIFO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISFIFO" class="anchor" title="Link to c_ISFIFO">#</a>
               </h3>
               
               <pre><code>const c_ISFIFO = 010000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISGID" data-name="c_ISGID">
               <h3>
                  c_ISGID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISGID" class="anchor" title="Link to c_ISGID">#</a>
               </h3>
               
               <pre><code>const c_ISGID = 02000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISLNK" data-name="c_ISLNK">
               <h3>
                  c_ISLNK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISLNK" class="anchor" title="Link to c_ISLNK">#</a>
               </h3>
               
               <pre><code>const c_ISLNK = 0120000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISREG" data-name="c_ISREG">
               <h3>
                  c_ISREG 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISREG" class="anchor" title="Link to c_ISREG">#</a>
               </h3>
               
               <pre><code>const c_ISREG = 0100000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISSOCK" data-name="c_ISSOCK">
               <h3>
                  c_ISSOCK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISSOCK" class="anchor" title="Link to c_ISSOCK">#</a>
               </h3>
               
               <pre><code>const c_ISSOCK = 0140000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISUID" data-name="c_ISUID">
               <h3>
                  c_ISUID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISUID" class="anchor" title="Link to c_ISUID">#</a>
               </h3>
               
               <p>Mode constants from the USTAR spec:
See http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06</p>
               
               <pre><code>const c_ISUID = 04000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="c_ISVTX" data-name="c_ISVTX">
               <h3>
                  c_ISVTX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#c_ISVTX" class="anchor" title="Link to c_ISVTX">#</a>
               </h3>
               
               <pre><code>const c_ISVTX = 01000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMissData" data-name="errMissData">
               <h3>
                  errMissData 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMissData" class="anchor" title="Link to errMissData">#</a>
               </h3>
               
               <pre><code>var errMissData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errUnrefData" data-name="errUnrefData">
               <h3>
                  errUnrefData 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errUnrefData" class="anchor" title="Link to errUnrefData">#</a>
               </h3>
               
               <pre><code>var errUnrefData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errWriteHole" data-name="errWriteHole">
               <h3>
                  errWriteHole 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errWriteHole" class="anchor" title="Link to errWriteHole">#</a>
               </h3>
               
               <pre><code>var errWriteHole = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="formatMax" data-name="formatMax">
               <h3>
                  formatMax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#formatMax" class="anchor" title="Link to formatMax">#</a>
               </h3>
               
               <p>Constants to identify various tar formats.</p>
               
               <pre><code>const formatMax</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="formatNames" data-name="formatNames">
               <h3>
                  formatNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#formatNames" class="anchor" title="Link to formatNames">#</a>
               </h3>
               
               <pre><code>var formatNames = map[Format]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="formatSTAR" data-name="formatSTAR">
               <h3>
                  formatSTAR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#formatSTAR" class="anchor" title="Link to formatSTAR">#</a>
               </h3>
               
               <p>Schily's tar format, which is incompatible with USTAR.
This does not cover STAR extensions to the PAX format; these fall under
the PAX format.</p>
               
               <pre><code>const formatSTAR</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="formatV7" data-name="formatV7">
               <h3>
                  formatV7 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#formatV7" class="anchor" title="Link to formatV7">#</a>
               </h3>
               
               <p>The format of the original Unix V7 tar tool prior to standardization.</p>
               
               <pre><code>const formatV7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="groupMap" data-name="groupMap">
               <h3>
                  groupMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#groupMap" class="anchor" title="Link to groupMap">#</a>
               </h3>
               
               <p>userMap and groupMap caches UID and GID lookups for performance reasons.
The downside is that renaming uname or gname by the OS never takes effect.</p>
               
               <pre><code>var groupMap sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="magicGNU" data-name="magicGNU">
               <h3>
                  magicGNU 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#magicGNU" class="anchor" title="Link to magicGNU">#</a>
               </h3>
               
               <p>Magics used to identify various formats.</p>
               
               <pre><code>const magicGNU = "ustar "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="magicUSTAR" data-name="magicUSTAR">
               <h3>
                  magicUSTAR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#magicUSTAR" class="anchor" title="Link to magicUSTAR">#</a>
               </h3>
               
               <p>Magics used to identify various formats.</p>
               
               <pre><code>const magicUSTAR = "ustar\x00"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxSpecialFileSize" data-name="maxSpecialFileSize">
               <h3>
                  maxSpecialFileSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxSpecialFileSize" class="anchor" title="Link to maxSpecialFileSize">#</a>
               </h3>
               
               <p>Max length of a special file (PAX header, GNU long name or link).
This matches the limit used by libarchive.</p>
               
               <pre><code>const maxSpecialFileSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nameSize" data-name="nameSize">
               <h3>
                  nameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nameSize" class="anchor" title="Link to nameSize">#</a>
               </h3>
               
               <p>Size constants from various tar specifications.</p>
               
               <pre><code>const nameSize = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxAtime" data-name="paxAtime">
               <h3>
                  paxAtime 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxAtime" class="anchor" title="Link to paxAtime">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxAtime = "atime"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxCharset" data-name="paxCharset">
               <h3>
                  paxCharset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxCharset" class="anchor" title="Link to paxCharset">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxCharset = "charset"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxComment" data-name="paxComment">
               <h3>
                  paxComment 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxComment" class="anchor" title="Link to paxComment">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxComment = "comment"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxCtime" data-name="paxCtime">
               <h3>
                  paxCtime 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxCtime" class="anchor" title="Link to paxCtime">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxCtime = "ctime"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparse" data-name="paxGNUSparse">
               <h3>
                  paxGNUSparse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparse" class="anchor" title="Link to paxGNUSparse">#</a>
               </h3>
               
               <p>Keywords for GNU sparse files in a PAX extended header.</p>
               
               <pre><code>const paxGNUSparse = "GNU.sparse."</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseMajor" data-name="paxGNUSparseMajor">
               <h3>
                  paxGNUSparseMajor 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseMajor" class="anchor" title="Link to paxGNUSparseMajor">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseMajor = "GNU.sparse.major"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseMap" data-name="paxGNUSparseMap">
               <h3>
                  paxGNUSparseMap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseMap" class="anchor" title="Link to paxGNUSparseMap">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseMap = "GNU.sparse.map"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseMinor" data-name="paxGNUSparseMinor">
               <h3>
                  paxGNUSparseMinor 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseMinor" class="anchor" title="Link to paxGNUSparseMinor">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseMinor = "GNU.sparse.minor"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseName" data-name="paxGNUSparseName">
               <h3>
                  paxGNUSparseName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseName" class="anchor" title="Link to paxGNUSparseName">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseName = "GNU.sparse.name"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseNumBlocks" data-name="paxGNUSparseNumBlocks">
               <h3>
                  paxGNUSparseNumBlocks 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseNumBlocks" class="anchor" title="Link to paxGNUSparseNumBlocks">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseNumBlocks = "GNU.sparse.numblocks"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseNumBytes" data-name="paxGNUSparseNumBytes">
               <h3>
                  paxGNUSparseNumBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseNumBytes" class="anchor" title="Link to paxGNUSparseNumBytes">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseNumBytes = "GNU.sparse.numbytes"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseOffset" data-name="paxGNUSparseOffset">
               <h3>
                  paxGNUSparseOffset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseOffset" class="anchor" title="Link to paxGNUSparseOffset">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseOffset = "GNU.sparse.offset"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseRealSize" data-name="paxGNUSparseRealSize">
               <h3>
                  paxGNUSparseRealSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseRealSize" class="anchor" title="Link to paxGNUSparseRealSize">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseRealSize = "GNU.sparse.realsize"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGNUSparseSize" data-name="paxGNUSparseSize">
               <h3>
                  paxGNUSparseSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGNUSparseSize" class="anchor" title="Link to paxGNUSparseSize">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGNUSparseSize = "GNU.sparse.size"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGid" data-name="paxGid">
               <h3>
                  paxGid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGid" class="anchor" title="Link to paxGid">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGid = "gid"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxGname" data-name="paxGname">
               <h3>
                  paxGname 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxGname" class="anchor" title="Link to paxGname">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxGname = "gname"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxLinkpath" data-name="paxLinkpath">
               <h3>
                  paxLinkpath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxLinkpath" class="anchor" title="Link to paxLinkpath">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxLinkpath = "linkpath"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxMtime" data-name="paxMtime">
               <h3>
                  paxMtime 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxMtime" class="anchor" title="Link to paxMtime">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxMtime = "mtime"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxNone" data-name="paxNone">
               <h3>
                  paxNone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxNone" class="anchor" title="Link to paxNone">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxNone = ""</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxPath" data-name="paxPath">
               <h3>
                  paxPath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxPath" class="anchor" title="Link to paxPath">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxPath = "path"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxSchilyXattr" data-name="paxSchilyXattr">
               <h3>
                  paxSchilyXattr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxSchilyXattr" class="anchor" title="Link to paxSchilyXattr">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxSchilyXattr = "SCHILY.xattr."</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxSize" data-name="paxSize">
               <h3>
                  paxSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxSize" class="anchor" title="Link to paxSize">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxSize = "size"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxUid" data-name="paxUid">
               <h3>
                  paxUid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxUid" class="anchor" title="Link to paxUid">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxUid = "uid"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paxUname" data-name="paxUname">
               <h3>
                  paxUname 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#paxUname" class="anchor" title="Link to paxUname">#</a>
               </h3>
               
               <p>Keywords for PAX extended header records.</p>
               
               <pre><code>const paxUname = "uname"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="prefixSize" data-name="prefixSize">
               <h3>
                  prefixSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#prefixSize" class="anchor" title="Link to prefixSize">#</a>
               </h3>
               
               <p>Size constants from various tar specifications.</p>
               
               <pre><code>const prefixSize = 155</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sysStat" data-name="sysStat">
               <h3>
                  sysStat 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#sysStat" class="anchor" title="Link to sysStat">#</a>
               </h3>
               
               <p>sysStat, if non-nil, populates h from system-dependent fields of fi.</p>
               
               <pre><code>var sysStat func(fi fs.FileInfo, h *Header, doNameLookups bool) error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tarinsecurepath" data-name="tarinsecurepath">
               <h3>
                  tarinsecurepath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#tarinsecurepath" class="anchor" title="Link to tarinsecurepath">#</a>
               </h3>
               
               <pre><code>var tarinsecurepath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="trailerSTAR" data-name="trailerSTAR">
               <h3>
                  trailerSTAR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#trailerSTAR" class="anchor" title="Link to trailerSTAR">#</a>
               </h3>
               
               <p>Magics used to identify various formats.</p>
               
               <pre><code>const trailerSTAR = "tar\x00"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="userMap" data-name="userMap">
               <h3>
                  userMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#userMap" class="anchor" title="Link to userMap">#</a>
               </h3>
               
               <p>userMap and groupMap caches UID and GID lookups for performance reasons.
The downside is that renaming uname or gname by the OS never takes effect.</p>
               
               <pre><code>var userMap sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="versionGNU" data-name="versionGNU">
               <h3>
                  versionGNU 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#versionGNU" class="anchor" title="Link to versionGNU">#</a>
               </h3>
               
               <p>Magics used to identify various formats.</p>
               
               <pre><code>const versionGNU = " \x00"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="versionUSTAR" data-name="versionUSTAR">
               <h3>
                  versionUSTAR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#versionUSTAR" class="anchor" title="Link to versionUSTAR">#</a>
               </h3>
               
               <p>Magics used to identify various formats.</p>
               
               <pre><code>const versionUSTAR = "00"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zeroBlock" data-name="zeroBlock">
               <h3>
                  zeroBlock 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zeroBlock" class="anchor" title="Link to zeroBlock">#</a>
               </h3>
               
               <pre><code>var zeroBlock block</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format
                  <span class="badge type-badge">type</span>
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format represents the tar archive format.
The original tar format was introduced in Unix V7.
Since then, there have been multiple competing formats attempting to
standardize or extend the V7 format to overcome its limitations.
The most common formats are the USTAR, PAX, and GNU formats,
each with their own advantages and limitations.
The following table captures the capabilities of each format:
|  USTAR |       PAX |       GNU
------------------+--------+-----------+----------
Name              |   256B | unlimited | unlimited
Linkname          |   100B | unlimited | unlimited
Size              | uint33 | unlimited |    uint89
Mode              | uint21 |    uint21 |    uint57
Uid/Gid           | uint21 | unlimited |    uint57
Uname/Gname       |    32B | unlimited |       32B
ModTime           | uint33 | unlimited |     int89
AccessTime        |    n/a | unlimited |     int89
ChangeTime        |    n/a | unlimited |     int89
Devmajor/Devminor | uint21 |    uint21 |    uint57
------------------+--------+-----------+----------
string encoding   |  ASCII |     UTF-8 |    binary
sub-second times  |     no |       yes |        no
sparse files      |     no |       yes |       yes
The table's upper portion shows the [Header] fields, where each format reports
the maximum number of bytes allowed for each string field and
the integer type used to store each numeric field
(where timestamps are stored as the number of seconds since the Unix epoch).
The table's lower portion shows specialized features of each format,
such as supported string encodings, support for sub-second timestamps,
or support for sparse files.
The Writer currently provides no support for sparse files.</p>
               
               <pre><code>type Format int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="block" data-name="block">
               <h3>
                  block
                  <span class="badge type-badge">type</span>
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <pre><code>type block [blockSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="headerError" data-name="headerError">
               <h3>
                  headerError
                  <span class="badge type-badge">type</span>
                  <a href="#headerError" class="anchor" title="Link to headerError">#</a>
               </h3>
               
               <pre><code>type headerError []string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="headerGNU" data-name="headerGNU">
               <h3>
                  headerGNU
                  <span class="badge type-badge">type</span>
                  <a href="#headerGNU" class="anchor" title="Link to headerGNU">#</a>
               </h3>
               
               <pre><code>type headerGNU [blockSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="headerSTAR" data-name="headerSTAR">
               <h3>
                  headerSTAR
                  <span class="badge type-badge">type</span>
                  <a href="#headerSTAR" class="anchor" title="Link to headerSTAR">#</a>
               </h3>
               
               <pre><code>type headerSTAR [blockSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="headerUSTAR" data-name="headerUSTAR">
               <h3>
                  headerUSTAR
                  <span class="badge type-badge">type</span>
                  <a href="#headerUSTAR" class="anchor" title="Link to headerUSTAR">#</a>
               </h3>
               
               <pre><code>type headerUSTAR [blockSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="headerV7" data-name="headerV7">
               <h3>
                  headerV7
                  <span class="badge type-badge">type</span>
                  <a href="#headerV7" class="anchor" title="Link to headerV7">#</a>
               </h3>
               
               <pre><code>type headerV7 [blockSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="numberFormatter" data-name="numberFormatter">
               <h3>
                  numberFormatter
                  <span class="badge type-badge">type</span>
                  <a href="#numberFormatter" class="anchor" title="Link to numberFormatter">#</a>
               </h3>
               
               <pre><code>type numberFormatter func([]byte, int64)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sparseArray" data-name="sparseArray">
               <h3>
                  sparseArray
                  <span class="badge type-badge">type</span>
                  <a href="#sparseArray" class="anchor" title="Link to sparseArray">#</a>
               </h3>
               
               <pre><code>type sparseArray []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sparseDatas" data-name="sparseDatas">
               <h3>
                  sparseDatas
                  <span class="badge type-badge">type</span>
                  <a href="#sparseDatas" class="anchor" title="Link to sparseDatas">#</a>
               </h3>
               
               <p>A sparse file can be represented as either a sparseDatas or a sparseHoles.
As long as the total size is known, they are equivalent and one can be
converted to the other form and back. The various tar formats with sparse
file support represent sparse files in the sparseDatas form. That is, they
specify the fragments in the file that has data, and treat everything else as
having zero bytes. As such, the encoding and decoding logic in this package
deals with sparseDatas.
However, the external API uses sparseHoles instead of sparseDatas because the
zero value of sparseHoles logically represents a normal file (i.e., there are
no holes in it). On the other hand, the zero value of sparseDatas implies
that the file has no data in it, which is rather odd.
As an example, if the underlying raw file contains the 10-byte data:
var compactFile = "abcdefgh"
And the sparse map has the following entries:
var spd sparseDatas = []sparseEntry{
{Offset: 2,  Length: 5},  // Data fragment for 2..6
{Offset: 18, Length: 3},  // Data fragment for 18..20
}
var sph sparseHoles = []sparseEntry{
{Offset: 0,  Length: 2},  // Hole fragment for 0..1
{Offset: 7,  Length: 11}, // Hole fragment for 7..17
{Offset: 21, Length: 4},  // Hole fragment for 21..24
}
Then the content of the resulting sparse file with a Header.Size of 25 is:
var sparseFile = "\x00"*2 + "abcde" + "\x00"*11 + "fgh" + "\x00"*4</p>
               
               <pre><code>type sparseDatas []sparseEntry</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sparseElem" data-name="sparseElem">
               <h3>
                  sparseElem
                  <span class="badge type-badge">type</span>
                  <a href="#sparseElem" class="anchor" title="Link to sparseElem">#</a>
               </h3>
               
               <pre><code>type sparseElem []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sparseHoles" data-name="sparseHoles">
               <h3>
                  sparseHoles
                  <span class="badge type-badge">type</span>
                  <a href="#sparseHoles" class="anchor" title="Link to sparseHoles">#</a>
               </h3>
               
               <p>A sparse file can be represented as either a sparseDatas or a sparseHoles.
As long as the total size is known, they are equivalent and one can be
converted to the other form and back. The various tar formats with sparse
file support represent sparse files in the sparseDatas form. That is, they
specify the fragments in the file that has data, and treat everything else as
having zero bytes. As such, the encoding and decoding logic in this package
deals with sparseDatas.
However, the external API uses sparseHoles instead of sparseDatas because the
zero value of sparseHoles logically represents a normal file (i.e., there are
no holes in it). On the other hand, the zero value of sparseDatas implies
that the file has no data in it, which is rather odd.
As an example, if the underlying raw file contains the 10-byte data:
var compactFile = "abcdefgh"
And the sparse map has the following entries:
var spd sparseDatas = []sparseEntry{
{Offset: 2,  Length: 5},  // Data fragment for 2..6
{Offset: 18, Length: 3},  // Data fragment for 18..20
}
var sph sparseHoles = []sparseEntry{
{Offset: 0,  Length: 2},  // Hole fragment for 0..1
{Offset: 7,  Length: 11}, // Hole fragment for 7..17
{Offset: 21, Length: 4},  // Hole fragment for 21..24
}
Then the content of the resulting sparse file with a Header.Size of 25 is:
var sparseFile = "\x00"*2 + "abcde" + "\x00"*11 + "fgh" + "\x00"*4</p>
               
               <pre><code>type sparseHoles []sparseEntry</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="stringFormatter" data-name="stringFormatter">
               <h3>
                  stringFormatter
                  <span class="badge type-badge">type</span>
                  <a href="#stringFormatter" class="anchor" title="Link to stringFormatter">#</a>
               </h3>
               
               <pre><code>type stringFormatter func([]byte, string)</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="FileInfoNames" data-name="FileInfoNames">
               <h3>
                  FileInfoNames
                  <span class="badge interface-badge">interface</span>
                  <a href="#FileInfoNames" class="anchor" title="Link to FileInfoNames">#</a>
               </h3>
               
               <p>FileInfoNames extends [fs.FileInfo].
Passing an instance of this to [FileInfoHeader] permits the caller
to avoid a system-dependent name lookup by specifying the Uname and Gname directly.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type FileInfoNames interface {
fs.FileInfo
Uname() (string, error)
Gname() (string, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="fileReader" data-name="fileReader">
               <h3>
                  fileReader
                  <span class="badge interface-badge">interface</span>
                  <a href="#fileReader" class="anchor" title="Link to fileReader">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type fileReader interface {
io.Reader
fileState
WriteTo(io.Writer) (int64, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="fileState" data-name="fileState">
               <h3>
                  fileState
                  <span class="badge interface-badge">interface</span>
                  <a href="#fileState" class="anchor" title="Link to fileState">#</a>
               </h3>
               
               <p>fileState tracks the number of logical (includes sparse holes) and physical
(actual in tar archive) bytes remaining for the current file.
Invariant: logicalRemaining >= physicalRemaining</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type fileState interface {
logicalRemaining() int64
physicalRemaining() int64
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="fileWriter" data-name="fileWriter">
               <h3>
                  fileWriter
                  <span class="badge interface-badge">interface</span>
                  <a href="#fileWriter" class="anchor" title="Link to fileWriter">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type fileWriter interface {
io.Writer
fileState
ReadFrom(io.Reader) (int64, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header
                  <span class="badge">struct</span>
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <p>A Header represents a single header in a tar archive.
Some fields may not be populated.
For forward compatibility, users that retrieve a Header from Reader.Next,
mutate it in some ways, and then pass it back to Writer.WriteHeader
should do so by creating a new Header and copying the fields
that they are interested in preserving.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Header struct {
Typeflag byte
Name string
Linkname string
Size int64
Mode int64
Uid int
Gid int
Uname string
Gname string
ModTime time.Time
AccessTime time.Time
ChangeTime time.Time
Devmajor int64
Devminor int64
Xattrs map[string]string
PAXRecords map[string]string
Format Format
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>Reader provides sequential access to the contents of a tar archive.
Reader.Next advances to the next file in the archive (including the first),
and then Reader can be treated as an io.Reader to access the file's data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
r io.Reader
pad int64
curr fileReader
blk block
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>Writer provides sequential writing of a tar archive.
[Writer.WriteHeader] begins a new file with the provided [Header],
and then Writer can be treated as an io.Writer to supply that file's data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
w io.Writer
pad int64
curr fileWriter
hdr Header
blk block
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="formatter" data-name="formatter">
               <h3>
                  formatter
                  <span class="badge">struct</span>
                  <a href="#formatter" class="anchor" title="Link to formatter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type formatter struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="headerFileInfo" data-name="headerFileInfo">
               <h3>
                  headerFileInfo
                  <span class="badge">struct</span>
                  <a href="#headerFileInfo" class="anchor" title="Link to headerFileInfo">#</a>
               </h3>
               
               <p>headerFileInfo implements fs.FileInfo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type headerFileInfo struct {
h *Header
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parser" data-name="parser">
               <h3>
                  parser
                  <span class="badge">struct</span>
                  <a href="#parser" class="anchor" title="Link to parser">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parser struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regFileReader" data-name="regFileReader">
               <h3>
                  regFileReader
                  <span class="badge">struct</span>
                  <a href="#regFileReader" class="anchor" title="Link to regFileReader">#</a>
               </h3>
               
               <p>regFileReader is a fileReader for reading data from a regular file entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regFileReader struct {
r io.Reader
nb int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regFileWriter" data-name="regFileWriter">
               <h3>
                  regFileWriter
                  <span class="badge">struct</span>
                  <a href="#regFileWriter" class="anchor" title="Link to regFileWriter">#</a>
               </h3>
               
               <p>regFileWriter is a fileWriter for writing data to a regular file entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regFileWriter struct {
w io.Writer
nb int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sparseEntry" data-name="sparseEntry">
               <h3>
                  sparseEntry
                  <span class="badge">struct</span>
                  <a href="#sparseEntry" class="anchor" title="Link to sparseEntry">#</a>
               </h3>
               
               <p>sparseEntry represents a Length-sized fragment at Offset in the file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sparseEntry struct {
Offset int64
Length int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sparseFileReader" data-name="sparseFileReader">
               <h3>
                  sparseFileReader
                  <span class="badge">struct</span>
                  <a href="#sparseFileReader" class="anchor" title="Link to sparseFileReader">#</a>
               </h3>
               
               <p>sparseFileReader is a fileReader for reading data from a sparse file entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sparseFileReader struct {
fr fileReader
sp sparseHoles
pos int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sparseFileWriter" data-name="sparseFileWriter">
               <h3>
                  sparseFileWriter
                  <span class="badge">struct</span>
                  <a href="#sparseFileWriter" class="anchor" title="Link to sparseFileWriter">#</a>
               </h3>
               
               <p>sparseFileWriter is a fileWriter for writing data to a sparse file entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sparseFileWriter struct {
fw fileWriter
sp sparseDatas
pos int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zeroReader" data-name="zeroReader">
               <h3>
                  zeroReader
                  <span class="badge">struct</span>
                  <a href="#zeroReader" class="anchor" title="Link to zeroReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zeroReader struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zeroWriter" data-name="zeroWriter">
               <h3>
                  zeroWriter
                  <span class="badge">struct</span>
                  <a href="#zeroWriter" class="anchor" title="Link to zeroWriter">#</a>
               </h3>
               
               <p>zeroWriter may only be written with NULs, otherwise it returns errWriteHole.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zeroWriter struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddFS" data-name="AddFS">
               <h3>
                  AddFS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddFS" class="anchor" title="Link to AddFS">#</a>
               </h3>
               
               <p>AddFS adds the files from fs.FS to the archive.
It walks the directory tree starting at the root of the filesystem
adding each file to the tar archive while maintaining the directory structure.</p>
               
               <pre><code>func (tw *Writer) AddFS(fsys fs.FS) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the tar archive by flushing the padding, and writing the footer.
If the current file (from a prior call to [Writer.WriteHeader]) is not fully written,
then this returns an error.</p>
               
               <pre><code>func (tw *Writer) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (he headerError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileInfo" data-name="FileInfo">
               <h3>
                  FileInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FileInfo" class="anchor" title="Link to FileInfo">#</a>
               </h3>
               
               <p>FileInfo returns an fs.FileInfo for the Header.</p>
               
               <pre><code>func (h *Header) FileInfo() fs.FileInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileInfoHeader" data-name="FileInfoHeader">
               <h3>
                  FileInfoHeader 
                  <span class="badge">function</span>
                  
                  <a href="#FileInfoHeader" class="anchor" title="Link to FileInfoHeader">#</a>
               </h3>
               
               <p>FileInfoHeader creates a partially-populated [Header] from fi.
If fi describes a symlink, FileInfoHeader records link as the link target.
If fi describes a directory, a slash is appended to the name.
Since fs.FileInfo's Name method only returns the base name of
the file it describes, it may be necessary to modify Header.Name
to provide the full path name of the file.
If fi implements [FileInfoNames]
Header.Gname and Header.Uname
are provided by the methods of the interface.</p>
               
               <pre><code>func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush finishes writing the current file's block padding.
The current file must be fully written before Flush can be called.
This is unnecessary as the next call to [Writer.WriteHeader] or [Writer.Close]
will implicitly flush out the file's padding.</p>
               
               <pre><code>func (tw *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (fi headerFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code>func (fi headerFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <p>Mode returns the permission and mode bits for the headerFileInfo.</p>
               
               <pre><code>func (fi headerFileInfo) Mode() (mode fs.FileMode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the base name of the file.</p>
               
               <pre><code>func (fi headerFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader creates a new [Reader] reading from r.</p>
               
               <pre><code>func NewReader(r io.Reader) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter creates a new Writer writing to w.</p>
               
               <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next advances to the next entry in the tar archive.
The Header.Size determines how many bytes can be read for the next file.
Any remaining data in the current file is automatically discarded.
At the end of the archive, Next returns the error io.EOF.
If Next encounters a non-local name (as defined by [filepath.IsLocal])
and the GODEBUG environment variable contains `tarinsecurepath=0`,
Next returns the header with an [ErrInsecurePath] error.
A future version of Go may introduce this behavior by default.
Programs that want to accept non-local names can ignore
the [ErrInsecurePath] error and use the returned header.</p>
               
               <pre><code>func (tr *Reader) Next() (*Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (sr *sparseFileReader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (fr *regFileReader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (zeroReader) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads from the current file in the tar archive.
It returns (0, io.EOF) when it reaches the end of that file,
until [Next] is called to advance to the next file.
If the current file is sparse, then the regions marked as a hole
are read back as NUL-bytes.
Calling Read on special types like [TypeLink], [TypeSymlink], [TypeChar],
[TypeBlock], [TypeDir], and [TypeFifo] returns (0, [io.EOF]) regardless of what
the [Header.Size] claims.</p>
               
               <pre><code>func (tr *Reader) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <pre><code>func (sw *sparseFileWriter) ReadFrom(r io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <pre><code>func (fw *regFileWriter) ReadFrom(r io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code>func (fi headerFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (f Format) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (fi headerFileInfo) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <pre><code>func (fi headerFileInfo) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (sw *sparseFileWriter) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (zeroWriter) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (fw *regFileWriter) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes to the current file in the tar archive.
Write returns the error [ErrWriteTooLong] if more than
Header.Size bytes are written after [Writer.WriteHeader].
Calling Write on special types like [TypeLink], [TypeSymlink], [TypeChar],
[TypeBlock], [TypeDir], and [TypeFifo] returns (0, [ErrWriteTooLong]) regardless
of what the [Header.Size] claims.</p>
               
               <pre><code>func (tw *Writer) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteHeader" data-name="WriteHeader">
               <h3>
                  WriteHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteHeader" class="anchor" title="Link to WriteHeader">#</a>
               </h3>
               
               <p>WriteHeader writes hdr and prepares to accept the file's contents.
The Header.Size determines how many bytes can be written for the next file.
If the current file is not fully written, then this returns an error.
This implicitly flushes any padding necessary before writing the header.</p>
               
               <pre><code>func (tw *Writer) WriteHeader(hdr *Header) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <pre><code>func (fr *regFileReader) WriteTo(w io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <pre><code>func (sr *sparseFileReader) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="accessTime" data-name="accessTime">
               <h3>
                  accessTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#accessTime" class="anchor" title="Link to accessTime">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) accessTime() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="accessTime" data-name="accessTime">
               <h3>
                  accessTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#accessTime" class="anchor" title="Link to accessTime">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) accessTime() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alignSparseEntries" data-name="alignSparseEntries">
               <h3>
                  alignSparseEntries 
                  <span class="badge">function</span>
                  
                  <a href="#alignSparseEntries" class="anchor" title="Link to alignSparseEntries">#</a>
               </h3>
               
               <p>alignSparseEntries mutates src and returns dst where each fragment's
starting offset is aligned up to the nearest block edge, and each
ending offset is aligned down to the nearest block edge.
Even though the Go tar Reader and the BSD tar utility can handle entries
with arbitrary offsets and lengths, the GNU tar utility can only handle
offsets and lengths that are multiples of blockSize.</p>
               
               <pre><code>func alignSparseEntries(src []sparseEntry, size int64) []sparseEntry</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allowedFormats" data-name="allowedFormats">
               <h3>
                  allowedFormats 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#allowedFormats" class="anchor" title="Link to allowedFormats">#</a>
               </h3>
               
               <p>allowedFormats determines which formats can be used.
The value returned is the logical OR of multiple possible formats.
If the value is FormatUnknown, then the input Header cannot be encoded
and an error is returned explaining why.
As a by-product of checking the fields, this function returns paxHdrs, which
contain all fields that could not be directly encoded.
A value receiver ensures that this method does not mutate the source Header.</p>
               
               <pre><code>func (h Header) allowedFormats() (format Format, paxHdrs map[string]string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockPadding" data-name="blockPadding">
               <h3>
                  blockPadding 
                  <span class="badge">function</span>
                  
                  <a href="#blockPadding" class="anchor" title="Link to blockPadding">#</a>
               </h3>
               
               <p>blockPadding computes the number of bytes needed to pad offset up to the
nearest block edge where 0 <= n < blockSize.</p>
               
               <pre><code>func blockPadding(offset int64) (n int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="changeTime" data-name="changeTime">
               <h3>
                  changeTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#changeTime" class="anchor" title="Link to changeTime">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) changeTime() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="changeTime" data-name="changeTime">
               <h3>
                  changeTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#changeTime" class="anchor" title="Link to changeTime">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) changeTime() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chksum" data-name="chksum">
               <h3>
                  chksum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#chksum" class="anchor" title="Link to chksum">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) chksum() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeChecksum" data-name="computeChecksum">
               <h3>
                  computeChecksum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#computeChecksum" class="anchor" title="Link to computeChecksum">#</a>
               </h3>
               
               <p>computeChecksum computes the checksum for the header block.
POSIX specifies a sum of the unsigned byte values, but the Sun tar used
signed byte values.
We compute and return both.</p>
               
               <pre><code>func (b *block) computeChecksum() (unsigned int64, signed int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="devMajor" data-name="devMajor">
               <h3>
                  devMajor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#devMajor" class="anchor" title="Link to devMajor">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) devMajor() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="devMajor" data-name="devMajor">
               <h3>
                  devMajor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#devMajor" class="anchor" title="Link to devMajor">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) devMajor() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="devMajor" data-name="devMajor">
               <h3>
                  devMajor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#devMajor" class="anchor" title="Link to devMajor">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) devMajor() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="devMinor" data-name="devMinor">
               <h3>
                  devMinor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#devMinor" class="anchor" title="Link to devMinor">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) devMinor() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="devMinor" data-name="devMinor">
               <h3>
                  devMinor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#devMinor" class="anchor" title="Link to devMinor">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) devMinor() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="devMinor" data-name="devMinor">
               <h3>
                  devMinor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#devMinor" class="anchor" title="Link to devMinor">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) devMinor() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="discard" data-name="discard">
               <h3>
                  discard 
                  <span class="badge">function</span>
                  
                  <a href="#discard" class="anchor" title="Link to discard">#</a>
               </h3>
               
               <p>discard skips n bytes in r, reporting an error if unable to do so.</p>
               
               <pre><code>func discard(r io.Reader, n int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endOffset" data-name="endOffset">
               <h3>
                  endOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endOffset" class="anchor" title="Link to endOffset">#</a>
               </h3>
               
               <pre><code>func (s sparseEntry) endOffset() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ensureEOF" data-name="ensureEOF">
               <h3>
                  ensureEOF 
                  <span class="badge">function</span>
                  
                  <a href="#ensureEOF" class="anchor" title="Link to ensureEOF">#</a>
               </h3>
               
               <p>ensureEOF checks whether r is at EOF, reporting ErrWriteTooLong if not so.</p>
               
               <pre><code>func ensureEOF(r io.Reader) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entry" data-name="entry">
               <h3>
                  entry 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entry" class="anchor" title="Link to entry">#</a>
               </h3>
               
               <pre><code>func (s sparseArray) entry(i int) sparseElem</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fitsInBase256" data-name="fitsInBase256">
               <h3>
                  fitsInBase256 
                  <span class="badge">function</span>
                  
                  <a href="#fitsInBase256" class="anchor" title="Link to fitsInBase256">#</a>
               </h3>
               
               <p>fitsInBase256 reports whether x can be encoded into n bytes using base-256
encoding. Unlike octal encoding, base-256 encoding does not require that the
string ends with a NUL character. Thus, all n bytes are available for output.
If operating in binary mode, this assumes strict GNU binary mode; which means
that the first byte can only be either 0x80 or 0xff. Thus, the first byte is
equivalent to the sign bit in two's complement form.</p>
               
               <pre><code>func fitsInBase256(n int, x int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fitsInOctal" data-name="fitsInOctal">
               <h3>
                  fitsInOctal 
                  <span class="badge">function</span>
                  
                  <a href="#fitsInOctal" class="anchor" title="Link to fitsInOctal">#</a>
               </h3>
               
               <p>fitsInOctal reports whether the integer x fits in a field n-bytes long
using octal encoding with the appropriate NUL terminator.</p>
               
               <pre><code>func fitsInOctal(n int, x int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatNumeric" data-name="formatNumeric">
               <h3>
                  formatNumeric 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#formatNumeric" class="anchor" title="Link to formatNumeric">#</a>
               </h3>
               
               <p>formatNumeric encodes x into b using base-8 (octal) encoding if possible.
Otherwise it will attempt to use base-256 (binary) encoding.</p>
               
               <pre><code>func (f *formatter) formatNumeric(b []byte, x int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatOctal" data-name="formatOctal">
               <h3>
                  formatOctal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#formatOctal" class="anchor" title="Link to formatOctal">#</a>
               </h3>
               
               <pre><code>func (f *formatter) formatOctal(b []byte, x int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatPAXRecord" data-name="formatPAXRecord">
               <h3>
                  formatPAXRecord 
                  <span class="badge">function</span>
                  
                  <a href="#formatPAXRecord" class="anchor" title="Link to formatPAXRecord">#</a>
               </h3>
               
               <p>formatPAXRecord formats a single PAX record, prefixing it with the
appropriate length.</p>
               
               <pre><code>func formatPAXRecord(k string, v string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatPAXTime" data-name="formatPAXTime">
               <h3>
                  formatPAXTime 
                  <span class="badge">function</span>
                  
                  <a href="#formatPAXTime" class="anchor" title="Link to formatPAXTime">#</a>
               </h3>
               
               <p>formatPAXTime converts ts into a time of the form %d.%d as described in the
PAX specification. This function is capable of negative timestamps.</p>
               
               <pre><code>func formatPAXTime(ts time.Time) (s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatString" data-name="formatString">
               <h3>
                  formatString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#formatString" class="anchor" title="Link to formatString">#</a>
               </h3>
               
               <p>formatString copies s into b, NUL-terminating if possible.</p>
               
               <pre><code>func (f *formatter) formatString(b []byte, s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getFormat" data-name="getFormat">
               <h3>
                  getFormat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getFormat" class="anchor" title="Link to getFormat">#</a>
               </h3>
               
               <p>getFormat checks that the block is a valid tar header based on the checksum.
It then attempts to guess the specific format based on magic values.
If the checksum fails, then FormatUnknown is returned.</p>
               
               <pre><code>func (b *block) getFormat() Format</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gid" data-name="gid">
               <h3>
                  gid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gid" class="anchor" title="Link to gid">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) gid() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="groupName" data-name="groupName">
               <h3>
                  groupName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#groupName" class="anchor" title="Link to groupName">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) groupName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="groupName" data-name="groupName">
               <h3>
                  groupName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#groupName" class="anchor" title="Link to groupName">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) groupName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="groupName" data-name="groupName">
               <h3>
                  groupName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#groupName" class="anchor" title="Link to groupName">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) groupName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleRegularFile" data-name="handleRegularFile">
               <h3>
                  handleRegularFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleRegularFile" class="anchor" title="Link to handleRegularFile">#</a>
               </h3>
               
               <p>handleRegularFile sets up the current file reader and padding such that it
can only read the following logical data section. It will properly handle
special headers that contain no data section.</p>
               
               <pre><code>func (tr *Reader) handleRegularFile(hdr *Header) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleSparseFile" data-name="handleSparseFile">
               <h3>
                  handleSparseFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleSparseFile" class="anchor" title="Link to handleSparseFile">#</a>
               </h3>
               
               <p>handleSparseFile checks if the current file is a sparse format of any type
and sets the curr reader appropriately.</p>
               
               <pre><code>func (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="has" data-name="has">
               <h3>
                  has 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#has" class="anchor" title="Link to has">#</a>
               </h3>
               
               <pre><code>func (f Format) has(f2 Format) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasNUL" data-name="hasNUL">
               <h3>
                  hasNUL 
                  <span class="badge">function</span>
                  
                  <a href="#hasNUL" class="anchor" title="Link to hasNUL">#</a>
               </h3>
               
               <p>hasNUL reports whether the NUL character exists within s.</p>
               
               <pre><code>func hasNUL(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="invertSparseEntries" data-name="invertSparseEntries">
               <h3>
                  invertSparseEntries 
                  <span class="badge">function</span>
                  
                  <a href="#invertSparseEntries" class="anchor" title="Link to invertSparseEntries">#</a>
               </h3>
               
               <p>invertSparseEntries converts a sparse map from one form to the other.
If the input is sparseHoles, then it will output sparseDatas and vice-versa.
The input must have been already validated.
This function mutates src and returns a normalized map where:
- adjacent fragments are coalesced together
- only the last fragment may be empty
- the endOffset of the last fragment is the total size</p>
               
               <pre><code>func invertSparseEntries(src []sparseEntry, size int64) []sparseEntry</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isASCII" data-name="isASCII">
               <h3>
                  isASCII 
                  <span class="badge">function</span>
                  
                  <a href="#isASCII" class="anchor" title="Link to isASCII">#</a>
               </h3>
               
               <p>isASCII reports whether the input is an ASCII C-style string.</p>
               
               <pre><code>func isASCII(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExtended" data-name="isExtended">
               <h3>
                  isExtended 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isExtended" class="anchor" title="Link to isExtended">#</a>
               </h3>
               
               <pre><code>func (s sparseArray) isExtended() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isHeaderOnlyType" data-name="isHeaderOnlyType">
               <h3>
                  isHeaderOnlyType 
                  <span class="badge">function</span>
                  
                  <a href="#isHeaderOnlyType" class="anchor" title="Link to isHeaderOnlyType">#</a>
               </h3>
               
               <p>isHeaderOnlyType checks if the given type flag is of the type that has no
data section even if a size is specified.</p>
               
               <pre><code>func isHeaderOnlyType(flag byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="length" data-name="length">
               <h3>
                  length 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#length" class="anchor" title="Link to length">#</a>
               </h3>
               
               <pre><code>func (s sparseElem) length() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkName" data-name="linkName">
               <h3>
                  linkName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkName" class="anchor" title="Link to linkName">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) linkName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logicalRemaining" data-name="logicalRemaining">
               <h3>
                  logicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logicalRemaining" class="anchor" title="Link to logicalRemaining">#</a>
               </h3>
               
               <p>logicalRemaining implements fileState.logicalRemaining.</p>
               
               <pre><code>func (fr regFileReader) logicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logicalRemaining" data-name="logicalRemaining">
               <h3>
                  logicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logicalRemaining" class="anchor" title="Link to logicalRemaining">#</a>
               </h3>
               
               <p>logicalRemaining implements fileState.logicalRemaining.</p>
               
               <pre><code>func (fw regFileWriter) logicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logicalRemaining" data-name="logicalRemaining">
               <h3>
                  logicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logicalRemaining" class="anchor" title="Link to logicalRemaining">#</a>
               </h3>
               
               <pre><code>func (sw sparseFileWriter) logicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logicalRemaining" data-name="logicalRemaining">
               <h3>
                  logicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logicalRemaining" class="anchor" title="Link to logicalRemaining">#</a>
               </h3>
               
               <pre><code>func (sr sparseFileReader) logicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="magic" data-name="magic">
               <h3>
                  magic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#magic" class="anchor" title="Link to magic">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) magic() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="magic" data-name="magic">
               <h3>
                  magic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#magic" class="anchor" title="Link to magic">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) magic() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="magic" data-name="magic">
               <h3>
                  magic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#magic" class="anchor" title="Link to magic">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) magic() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxEntries" data-name="maxEntries">
               <h3>
                  maxEntries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxEntries" class="anchor" title="Link to maxEntries">#</a>
               </h3>
               
               <pre><code>func (s sparseArray) maxEntries() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayBe" data-name="mayBe">
               <h3>
                  mayBe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mayBe" class="anchor" title="Link to mayBe">#</a>
               </h3>
               
               <pre><code>func (f *Format) mayBe(f2 Format)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayOnlyBe" data-name="mayOnlyBe">
               <h3>
                  mayOnlyBe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mayOnlyBe" class="anchor" title="Link to mayOnlyBe">#</a>
               </h3>
               
               <pre><code>func (f *Format) mayOnlyBe(f2 Format)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergePAX" data-name="mergePAX">
               <h3>
                  mergePAX 
                  <span class="badge">function</span>
                  
                  <a href="#mergePAX" class="anchor" title="Link to mergePAX">#</a>
               </h3>
               
               <p>mergePAX merges paxHdrs into hdr for all relevant fields of Header.</p>
               
               <pre><code>func mergePAX(hdr *Header, paxHdrs map[string]string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modTime" data-name="modTime">
               <h3>
                  modTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modTime" class="anchor" title="Link to modTime">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) modTime() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mode" data-name="mode">
               <h3>
                  mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mode" class="anchor" title="Link to mode">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) mode() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustNotBe" data-name="mustNotBe">
               <h3>
                  mustNotBe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustNotBe" class="anchor" title="Link to mustNotBe">#</a>
               </h3>
               
               <pre><code>func (f *Format) mustNotBe(f2 Format)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustReadFull" data-name="mustReadFull">
               <h3>
                  mustReadFull 
                  <span class="badge">function</span>
                  
                  <a href="#mustReadFull" class="anchor" title="Link to mustReadFull">#</a>
               </h3>
               
               <p>mustReadFull is like io.ReadFull except it returns
io.ErrUnexpectedEOF when io.EOF is hit before len(b) bytes are read.</p>
               
               <pre><code>func mustReadFull(r io.Reader, b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) name() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="next" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#next" class="anchor" title="Link to next">#</a>
               </h3>
               
               <pre><code>func (tr *Reader) next() (*Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="offset" data-name="offset">
               <h3>
                  offset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#offset" class="anchor" title="Link to offset">#</a>
               </h3>
               
               <pre><code>func (s sparseElem) offset() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseNumeric" data-name="parseNumeric">
               <h3>
                  parseNumeric 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseNumeric" class="anchor" title="Link to parseNumeric">#</a>
               </h3>
               
               <p>parseNumeric parses the input as being encoded in either base-256 or octal.
This function may return negative numbers.
If parsing fails or an integer overflow occurs, err will be set.</p>
               
               <pre><code>func (p *parser) parseNumeric(b []byte) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseOctal" data-name="parseOctal">
               <h3>
                  parseOctal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseOctal" class="anchor" title="Link to parseOctal">#</a>
               </h3>
               
               <pre><code>func (p *parser) parseOctal(b []byte) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePAX" data-name="parsePAX">
               <h3>
                  parsePAX 
                  <span class="badge">function</span>
                  
                  <a href="#parsePAX" class="anchor" title="Link to parsePAX">#</a>
               </h3>
               
               <p>parsePAX parses PAX headers.
If an extended header (type 'x') is invalid, ErrHeader is returned.</p>
               
               <pre><code>func parsePAX(r io.Reader) (map[string]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePAXRecord" data-name="parsePAXRecord">
               <h3>
                  parsePAXRecord 
                  <span class="badge">function</span>
                  
                  <a href="#parsePAXRecord" class="anchor" title="Link to parsePAXRecord">#</a>
               </h3>
               
               <p>parsePAXRecord parses the input PAX record string into a key-value pair.
If parsing is successful, it will slice off the currently read record and
return the remainder as r.</p>
               
               <pre><code>func parsePAXRecord(s string) (k string, v string, r string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePAXTime" data-name="parsePAXTime">
               <h3>
                  parsePAXTime 
                  <span class="badge">function</span>
                  
                  <a href="#parsePAXTime" class="anchor" title="Link to parsePAXTime">#</a>
               </h3>
               
               <p>parsePAXTime takes a string of the form %d.%d as described in the PAX
specification. Note that this implementation allows for negative timestamps,
which is allowed for by the PAX specification, but not always portable.</p>
               
               <pre><code>func parsePAXTime(s string) (time.Time, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseString" data-name="parseString">
               <h3>
                  parseString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseString" class="anchor" title="Link to parseString">#</a>
               </h3>
               
               <p>parseString parses bytes as a NUL-terminated C-style string.
If a NUL byte is not found then the whole slice is returned as a string.</p>
               
               <pre><code>func (*parser) parseString(b []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="physicalRemaining" data-name="physicalRemaining">
               <h3>
                  physicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#physicalRemaining" class="anchor" title="Link to physicalRemaining">#</a>
               </h3>
               
               <pre><code>func (sw sparseFileWriter) physicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="physicalRemaining" data-name="physicalRemaining">
               <h3>
                  physicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#physicalRemaining" class="anchor" title="Link to physicalRemaining">#</a>
               </h3>
               
               <p>physicalRemaining implements fileState.physicalRemaining.</p>
               
               <pre><code>func (fr regFileReader) physicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="physicalRemaining" data-name="physicalRemaining">
               <h3>
                  physicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#physicalRemaining" class="anchor" title="Link to physicalRemaining">#</a>
               </h3>
               
               <p>physicalRemaining implements fileState.physicalRemaining.</p>
               
               <pre><code>func (fw regFileWriter) physicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="physicalRemaining" data-name="physicalRemaining">
               <h3>
                  physicalRemaining 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#physicalRemaining" class="anchor" title="Link to physicalRemaining">#</a>
               </h3>
               
               <pre><code>func (sr sparseFileReader) physicalRemaining() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prefix" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prefix" class="anchor" title="Link to prefix">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) prefix() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prefix" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prefix" class="anchor" title="Link to prefix">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) prefix() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrom" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrom" class="anchor" title="Link to readFrom">#</a>
               </h3>
               
               <p>readFrom populates the content of the current file by reading from r.
The bytes read must match the number of remaining bytes in the current file.
If the current file is sparse and r is an io.ReadSeeker,
then readFrom uses Seek to skip past holes defined in Header.SparseHoles,
assuming that skipped regions are all NULs.
This always reads the last byte to ensure r is the right size.
TODO(dsnet): Re-export this when adding sparse file support.
See https://golang.org/issue/22735</p>
               
               <pre><code>func (tw *Writer) readFrom(r io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGNUSparseMap0x1" data-name="readGNUSparseMap0x1">
               <h3>
                  readGNUSparseMap0x1 
                  <span class="badge">function</span>
                  
                  <a href="#readGNUSparseMap0x1" class="anchor" title="Link to readGNUSparseMap0x1">#</a>
               </h3>
               
               <p>readGNUSparseMap0x1 reads the sparse map as stored in GNU's PAX sparse format
version 0.1. The sparse map is stored in the PAX headers.</p>
               
               <pre><code>func readGNUSparseMap0x1(paxHdrs map[string]string) (sparseDatas, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGNUSparseMap1x0" data-name="readGNUSparseMap1x0">
               <h3>
                  readGNUSparseMap1x0 
                  <span class="badge">function</span>
                  
                  <a href="#readGNUSparseMap1x0" class="anchor" title="Link to readGNUSparseMap1x0">#</a>
               </h3>
               
               <p>readGNUSparseMap1x0 reads the sparse map as stored in GNU's PAX sparse format
version 1.0. The format of the sparse map consists of a series of
newline-terminated numeric fields. The first field is the number of entries
and is always present. Following this are the entries, consisting of two
fields (offset, length). This function must stop reading at the end
boundary of the block containing the last newline.
Note that the GNU manual says that numeric values should be encoded in octal
format. However, the GNU tar utility itself outputs these values in decimal.
As such, this library treats values as being encoded in decimal.</p>
               
               <pre><code>func readGNUSparseMap1x0(r io.Reader) (sparseDatas, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGNUSparsePAXHeaders" data-name="readGNUSparsePAXHeaders">
               <h3>
                  readGNUSparsePAXHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readGNUSparsePAXHeaders" class="anchor" title="Link to readGNUSparsePAXHeaders">#</a>
               </h3>
               
               <p>readGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers.
If they are found, then this function reads the sparse map and returns it.
This assumes that 0.0 headers have already been converted to 0.1 headers
by the PAX header parsing logic.</p>
               
               <pre><code>func (tr *Reader) readGNUSparsePAXHeaders(hdr *Header) (sparseDatas, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readHeader" data-name="readHeader">
               <h3>
                  readHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readHeader" class="anchor" title="Link to readHeader">#</a>
               </h3>
               
               <p>readHeader reads the next block header and assumes that the underlying reader
is already aligned to a block boundary. It returns the raw block of the
header in case further processing is required.
The err will be set to io.EOF only when one of the following occurs:
- Exactly 0 bytes are read and EOF is hit.
- Exactly 1 block of zeros is read and EOF is hit.
- At least 2 blocks of zeros are read.</p>
               
               <pre><code>func (tr *Reader) readHeader() (*Header, *block, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readOldGNUSparseMap" data-name="readOldGNUSparseMap">
               <h3>
                  readOldGNUSparseMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readOldGNUSparseMap" class="anchor" title="Link to readOldGNUSparseMap">#</a>
               </h3>
               
               <p>readOldGNUSparseMap reads the sparse map from the old GNU sparse format.
The sparse map is stored in the tar header if it's small enough.
If it's larger than four entries, then one or more extension headers are used
to store the rest of the sparse map.
The Header.Size does not reflect the size of any extended headers used.
Thus, this function will read from the raw io.Reader to fetch extra headers.
This method mutates blk in the process.</p>
               
               <pre><code>func (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) (sparseDatas, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readSpecialFile" data-name="readSpecialFile">
               <h3>
                  readSpecialFile 
                  <span class="badge">function</span>
                  
                  <a href="#readSpecialFile" class="anchor" title="Link to readSpecialFile">#</a>
               </h3>
               
               <p>readSpecialFile is like io.ReadAll except it returns
ErrFieldTooLong if more than maxSpecialFileSize is read.</p>
               
               <pre><code>func readSpecialFile(r io.Reader) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="realSize" data-name="realSize">
               <h3>
                  realSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#realSize" class="anchor" title="Link to realSize">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) realSize() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <p>reset clears the block with all zeros.</p>
               
               <pre><code>func (b *block) reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setFormat" data-name="setFormat">
               <h3>
                  setFormat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setFormat" class="anchor" title="Link to setFormat">#</a>
               </h3>
               
               <p>setFormat writes the magic values necessary for specified format
and then updates the checksum accordingly.</p>
               
               <pre><code>func (b *block) setFormat(format Format)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="size" data-name="size">
               <h3>
                  size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#size" class="anchor" title="Link to size">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) size() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sparse" data-name="sparse">
               <h3>
                  sparse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sparse" class="anchor" title="Link to sparse">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) sparse() sparseArray</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitUSTARPath" data-name="splitUSTARPath">
               <h3>
                  splitUSTARPath 
                  <span class="badge">function</span>
                  
                  <a href="#splitUSTARPath" class="anchor" title="Link to splitUSTARPath">#</a>
               </h3>
               
               <p>splitUSTARPath splits a path according to USTAR prefix and suffix rules.
If the path is not splittable, then it will return ("", "", false).</p>
               
               <pre><code>func splitUSTARPath(name string) (prefix string, suffix string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statAtime" data-name="statAtime">
               <h3>
                  statAtime 
                  <span class="badge">function</span>
                  
                  <a href="#statAtime" class="anchor" title="Link to statAtime">#</a>
               </h3>
               
               <pre><code>func statAtime(st *syscall.Stat_t) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statAtime" data-name="statAtime">
               <h3>
                  statAtime 
                  <span class="badge">function</span>
                  
                  <a href="#statAtime" class="anchor" title="Link to statAtime">#</a>
               </h3>
               
               <pre><code>func statAtime(st *syscall.Stat_t) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statCtime" data-name="statCtime">
               <h3>
                  statCtime 
                  <span class="badge">function</span>
                  
                  <a href="#statCtime" class="anchor" title="Link to statCtime">#</a>
               </h3>
               
               <pre><code>func statCtime(st *syscall.Stat_t) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statCtime" data-name="statCtime">
               <h3>
                  statCtime 
                  <span class="badge">function</span>
                  
                  <a href="#statCtime" class="anchor" title="Link to statCtime">#</a>
               </h3>
               
               <pre><code>func statCtime(st *syscall.Stat_t) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statUnix" data-name="statUnix">
               <h3>
                  statUnix 
                  <span class="badge">function</span>
                  
                  <a href="#statUnix" class="anchor" title="Link to statUnix">#</a>
               </h3>
               
               <pre><code>func statUnix(fi fs.FileInfo, h *Header, doNameLookups bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="templateV7Plus" data-name="templateV7Plus">
               <h3>
                  templateV7Plus 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#templateV7Plus" class="anchor" title="Link to templateV7Plus">#</a>
               </h3>
               
               <p>templateV7Plus fills out the V7 fields of a block using values from hdr.
It also fills out fields (uname, gname, devmajor, devminor) that are
shared in the USTAR, PAX, and GNU formats using the provided formatters.
The block returned is only valid until the next call to
templateV7Plus or writeRawFile.</p>
               
               <pre><code>func (tw *Writer) templateV7Plus(hdr *Header, fmtStr stringFormatter, fmtNum numberFormatter) *block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toASCII" data-name="toASCII">
               <h3>
                  toASCII 
                  <span class="badge">function</span>
                  
                  <a href="#toASCII" class="anchor" title="Link to toASCII">#</a>
               </h3>
               
               <p>toASCII converts the input to an ASCII C-style string.
This is a best effort conversion, so invalid characters are dropped.</p>
               
               <pre><code>func toASCII(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toGNU" data-name="toGNU">
               <h3>
                  toGNU 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toGNU" class="anchor" title="Link to toGNU">#</a>
               </h3>
               
               <pre><code>func (b *block) toGNU() *headerGNU</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toSTAR" data-name="toSTAR">
               <h3>
                  toSTAR 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toSTAR" class="anchor" title="Link to toSTAR">#</a>
               </h3>
               
               <pre><code>func (b *block) toSTAR() *headerSTAR</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toSparse" data-name="toSparse">
               <h3>
                  toSparse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toSparse" class="anchor" title="Link to toSparse">#</a>
               </h3>
               
               <pre><code>func (b *block) toSparse() sparseArray</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toUSTAR" data-name="toUSTAR">
               <h3>
                  toUSTAR 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toUSTAR" class="anchor" title="Link to toUSTAR">#</a>
               </h3>
               
               <pre><code>func (b *block) toUSTAR() *headerUSTAR</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toV7" data-name="toV7">
               <h3>
                  toV7 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toV7" class="anchor" title="Link to toV7">#</a>
               </h3>
               
               <p>Convert block to any number of formats.</p>
               
               <pre><code>func (b *block) toV7() *headerV7</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trailer" data-name="trailer">
               <h3>
                  trailer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trailer" class="anchor" title="Link to trailer">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) trailer() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryReadFull" data-name="tryReadFull">
               <h3>
                  tryReadFull 
                  <span class="badge">function</span>
                  
                  <a href="#tryReadFull" class="anchor" title="Link to tryReadFull">#</a>
               </h3>
               
               <p>tryReadFull is like io.ReadFull except it returns
io.EOF when it is hit before len(b) bytes are read.</p>
               
               <pre><code>func tryReadFull(r io.Reader, b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeFlag" data-name="typeFlag">
               <h3>
                  typeFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeFlag" class="anchor" title="Link to typeFlag">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) typeFlag() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uid" data-name="uid">
               <h3>
                  uid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uid" class="anchor" title="Link to uid">#</a>
               </h3>
               
               <pre><code>func (h *headerV7) uid() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="userName" data-name="userName">
               <h3>
                  userName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#userName" class="anchor" title="Link to userName">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) userName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="userName" data-name="userName">
               <h3>
                  userName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#userName" class="anchor" title="Link to userName">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) userName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="userName" data-name="userName">
               <h3>
                  userName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#userName" class="anchor" title="Link to userName">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) userName() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="v7" data-name="v7">
               <h3>
                  v7 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#v7" class="anchor" title="Link to v7">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) v7() *headerV7</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="v7" data-name="v7">
               <h3>
                  v7 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#v7" class="anchor" title="Link to v7">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) v7() *headerV7</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="v7" data-name="v7">
               <h3>
                  v7 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#v7" class="anchor" title="Link to v7">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) v7() *headerV7</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validPAXRecord" data-name="validPAXRecord">
               <h3>
                  validPAXRecord 
                  <span class="badge">function</span>
                  
                  <a href="#validPAXRecord" class="anchor" title="Link to validPAXRecord">#</a>
               </h3>
               
               <p>validPAXRecord reports whether the key-value pair is valid where each
record is formatted as:
"%d %s=%s\n" % (size, key, value)
Keys and values should be UTF-8, but the number of bad writers out there
forces us to be a more liberal.
Thus, we only reject all keys with NUL, and only reject NULs in values
for the PAX version of the USTAR string fields.
The key must not contain an '=' character.</p>
               
               <pre><code>func validPAXRecord(k string, v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateSparseEntries" data-name="validateSparseEntries">
               <h3>
                  validateSparseEntries 
                  <span class="badge">function</span>
                  
                  <a href="#validateSparseEntries" class="anchor" title="Link to validateSparseEntries">#</a>
               </h3>
               
               <p>validateSparseEntries reports whether sp is a valid sparse map.
It does not matter whether sp represents data fragments or hole fragments.</p>
               
               <pre><code>func validateSparseEntries(sp []sparseEntry, size int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="version" data-name="version">
               <h3>
                  version 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#version" class="anchor" title="Link to version">#</a>
               </h3>
               
               <pre><code>func (h *headerSTAR) version() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="version" data-name="version">
               <h3>
                  version 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#version" class="anchor" title="Link to version">#</a>
               </h3>
               
               <pre><code>func (h *headerGNU) version() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="version" data-name="version">
               <h3>
                  version 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#version" class="anchor" title="Link to version">#</a>
               </h3>
               
               <pre><code>func (h *headerUSTAR) version() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeGNUHeader" data-name="writeGNUHeader">
               <h3>
                  writeGNUHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeGNUHeader" class="anchor" title="Link to writeGNUHeader">#</a>
               </h3>
               
               <pre><code>func (tw *Writer) writeGNUHeader(hdr *Header) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writePAXHeader" data-name="writePAXHeader">
               <h3>
                  writePAXHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writePAXHeader" class="anchor" title="Link to writePAXHeader">#</a>
               </h3>
               
               <pre><code>func (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeRawFile" data-name="writeRawFile">
               <h3>
                  writeRawFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeRawFile" class="anchor" title="Link to writeRawFile">#</a>
               </h3>
               
               <p>writeRawFile writes a minimal file with the given name and flag type.
It uses format to encode the header format and will write data as the body.
It uses default values for all of the other fields (as BSD and GNU tar does).</p>
               
               <pre><code>func (tw *Writer) writeRawFile(name string, data string, flag byte, format Format) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeRawHeader" data-name="writeRawHeader">
               <h3>
                  writeRawHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeRawHeader" class="anchor" title="Link to writeRawHeader">#</a>
               </h3>
               
               <p>writeRawHeader writes the value of blk, regardless of its value.
It sets up the Writer such that it can accept a file of the given size.
If the flag is a special header-only flag, then the size is treated as zero.</p>
               
               <pre><code>func (tw *Writer) writeRawHeader(blk *block, size int64, flag byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeTo" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeTo" class="anchor" title="Link to writeTo">#</a>
               </h3>
               
               <p>writeTo writes the content of the current file to w.
The bytes written matches the number of remaining bytes in the current file.
If the current file is sparse and w is an io.WriteSeeker,
then writeTo uses Seek to skip past holes defined in Header.SparseHoles,
assuming that skipped regions are filled with NULs.
This always writes the last byte to ensure w is the right size.
TODO(dsnet): Re-export this when adding sparse file support.
See https://golang.org/issue/22735</p>
               
               <pre><code>func (tr *Reader) writeTo(w io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeUSTARHeader" data-name="writeUSTARHeader">
               <h3>
                  writeUSTARHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeUSTARHeader" class="anchor" title="Link to writeUSTARHeader">#</a>
               </h3>
               
               <pre><code>func (tw *Writer) writeUSTARHeader(hdr *Header) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>