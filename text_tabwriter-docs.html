<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - tabwriter</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>tabwriter</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"io"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AlignRight" data-name="AlignRight">
               <h3>
                  AlignRight 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AlignRight" class="anchor" title="Link to AlignRight">#</a>
               </h3>
               
               <p>Force right-alignment of cell content.
Default is left-alignment.</p>
               
               <pre><code>const AlignRight</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Debug" data-name="Debug">
               <h3>
                  Debug 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Debug" class="anchor" title="Link to Debug">#</a>
               </h3>
               
               <p>Print a vertical bar ('|') between columns (after formatting).
Discarded columns appear as zero-width columns ("||").</p>
               
               <pre><code>const Debug</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DiscardEmptyColumns" data-name="DiscardEmptyColumns">
               <h3>
                  DiscardEmptyColumns 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DiscardEmptyColumns" class="anchor" title="Link to DiscardEmptyColumns">#</a>
               </h3>
               
               <p>Handle empty columns as if they were not present in
the input in the first place.</p>
               
               <pre><code>const DiscardEmptyColumns</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Escape" data-name="Escape">
               <h3>
                  Escape 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Escape" class="anchor" title="Link to Escape">#</a>
               </h3>
               
               <p>To escape a text segment, bracket it with Escape characters.
For instance, the tab in this string "Ignore this tab: \xff\t\xff"
does not terminate a cell and constitutes a single character of
width one for formatting purposes.
The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</p>
               
               <pre><code>const Escape = '\xff'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FilterHTML" data-name="FilterHTML">
               <h3>
                  FilterHTML 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FilterHTML" class="anchor" title="Link to FilterHTML">#</a>
               </h3>
               
               <p>Ignore html tags and treat entities (starting with '&'
and ending in ';') as single characters (width = 1).</p>
               
               <pre><code>const FilterHTML uint = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StripEscape" data-name="StripEscape">
               <h3>
                  StripEscape 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StripEscape" class="anchor" title="Link to StripEscape">#</a>
               </h3>
               
               <p>Strip Escape characters bracketing escaped text segments
instead of passing them through unchanged with the text.</p>
               
               <pre><code>const StripEscape</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TabIndent" data-name="TabIndent">
               <h3>
                  TabIndent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TabIndent" class="anchor" title="Link to TabIndent">#</a>
               </h3>
               
               <p>Always use tabs for indentation columns (i.e., padding of
leading empty cells on the left) independent of padchar.</p>
               
               <pre><code>const TabIndent</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hbar" data-name="hbar">
               <h3>
                  hbar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hbar" class="anchor" title="Link to hbar">#</a>
               </h3>
               
               <pre><code>var hbar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="newline" data-name="newline">
               <h3>
                  newline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#newline" class="anchor" title="Link to newline">#</a>
               </h3>
               
               <pre><code>var newline = []byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tabs" data-name="tabs">
               <h3>
                  tabs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#tabs" class="anchor" title="Link to tabs">#</a>
               </h3>
               
               <pre><code>var tabs = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vbar" data-name="vbar">
               <h3>
                  vbar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vbar" class="anchor" title="Link to vbar">#</a>
               </h3>
               
               <pre><code>var vbar = []byte{...}</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>A Writer is a filter that inserts padding around tab-delimited
columns in its input to align them in the output.
The Writer treats incoming bytes as UTF-8-encoded text consisting
of cells terminated by horizontal ('\t') or vertical ('\v') tabs,
and newline ('\n') or formfeed ('\f') characters; both newline and
formfeed act as line breaks.
Tab-terminated cells in contiguous lines constitute a column. The
Writer inserts padding as needed to make all cells in a column have
the same width, effectively aligning the columns. It assumes that
all characters have the same width, except for tabs for which a
tabwidth must be specified. Column cells must be tab-terminated, not
tab-separated: non-tab terminated trailing text at the end of a line
forms a cell but that cell is not part of an aligned column.
For instance, in this example (where | stands for a horizontal tab):
aaaa|bbb|d
aa  |b  |dd
a   |
aa  |cccc|eee
the b and c are in distinct columns (the b column is not contiguous
all the way). The d and e are not in a column at all (there's no
terminating tab, nor would the column be contiguous).
The Writer assumes that all Unicode code points have the same width;
this may not be true in some fonts or if the string contains combining
characters.
If [DiscardEmptyColumns] is set, empty columns that are terminated
entirely by vertical (or "soft") tabs are discarded. Columns
terminated by horizontal (or "hard") tabs are not affected by
this flag.
If a Writer is configured to filter HTML, HTML tags and entities
are passed through. The widths of tags and entities are
assumed to be zero (tags) and one (entities) for formatting purposes.
A segment of text may be escaped by bracketing it with [Escape]
characters. The tabwriter passes escaped text segments through
unchanged. In particular, it does not interpret any tabs or line
breaks within the segment. If the [StripEscape] flag is set, the
Escape characters are stripped from the output; otherwise they
are passed through as well. For the purpose of formatting, the
width of the escaped text is always computed excluding the Escape
characters.
The formfeed character acts like a newline but it also terminates
all columns in the current line (effectively calling [Writer.Flush]). Tab-
terminated cells in the next line start new columns. Unless found
inside an HTML tag or inside an escaped text segment, formfeed
characters appear as newlines in the output.
The Writer must buffer input internally, because proper spacing
of one line may depend on the cells in future lines. Clients must
call Flush when done calling [Writer.Write].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
output io.Writer
minwidth int
tabwidth int
padding int
padbytes [8]byte
flags uint
buf []byte
pos int
cell cell
endChar byte
lines [][]cell
widths []int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cell" data-name="cell">
               <h3>
                  cell
                  <span class="badge">struct</span>
                  <a href="#cell" class="anchor" title="Link to cell">#</a>
               </h3>
               
               <p>A cell represents a segment of text terminated by tabs or line breaks.
The text itself is stored in a separate buffer; cell only describes the
segment's size in bytes, its width in runes, and whether it's an htab
('\t') terminated cell.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cell struct {
size int
width int
htab bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="osError" data-name="osError">
               <h3>
                  osError
                  <span class="badge">struct</span>
                  <a href="#osError" class="anchor" title="Link to osError">#</a>
               </h3>
               
               <p>local error wrapper so we can distinguish errors we want to return
as errors from genuine panics (which we don't want to return as errors)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type osError struct {
err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush should be called after the last call to [Writer.Write] to ensure
that any data buffered in the [Writer] is written to output. Any
incomplete escape sequence at the end is considered
complete for formatting purposes.</p>
               
               <pre><code>func (b *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>A [Writer] must be initialized with a call to Init. The first parameter (output)
specifies the filter output. The remaining parameters control the formatting:
minwidth	minimal cell width including any padding
tabwidth	width of tab characters (equivalent number of spaces)
padding		padding added to a cell before computing its width
padchar		ASCII char used for padding
if padchar == '\t', the Writer will assume that the
width of a '\t' in the formatted output is tabwidth,
and cells are left-aligned independent of align_left
(for correct-looking results, tabwidth must correspond
to the tab width in the viewer displaying the result)
flags		formatting control</p>
               
               <pre><code>func (b *Writer) Init(output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter allocates and initializes a new [Writer].
The parameters are the same as for the Init function.</p>
               
               <pre><code>func NewWriter(output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes buf to the writer b.
The only errors returned are ones encountered
while writing to the underlying output stream.</p>
               
               <pre><code>func (b *Writer) Write(buf []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addLine" data-name="addLine">
               <h3>
                  addLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addLine" class="anchor" title="Link to addLine">#</a>
               </h3>
               
               <p>addLine adds a new line.
flushed is a hint indicating whether the underlying writer was just flushed.
If so, the previous line is not likely to be a good indicator of the new line's cells.</p>
               
               <pre><code>func (b *Writer) addLine(flushed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <p>Append text to current cell.</p>
               
               <pre><code>func (b *Writer) append(text []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dump" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dump" class="anchor" title="Link to dump">#</a>
               </h3>
               
               <p>debugging support (keep code around)</p>
               
               <pre><code>func (b *Writer) dump()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endEscape" data-name="endEscape">
               <h3>
                  endEscape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endEscape" class="anchor" title="Link to endEscape">#</a>
               </h3>
               
               <p>Terminate escaped mode. If the escaped text was an HTML tag, its width
is assumed to be zero for formatting purposes; if it was an HTML entity,
its width is assumed to be one. In all other cases, the width is the
unicode width of the text.</p>
               
               <pre><code>func (b *Writer) endEscape()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <p>flush is the internal version of Flush, with a named return value which we
don't want to expose.</p>
               
               <pre><code>func (b *Writer) flush() (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flushNoDefers" data-name="flushNoDefers">
               <h3>
                  flushNoDefers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flushNoDefers" class="anchor" title="Link to flushNoDefers">#</a>
               </h3>
               
               <p>flushNoDefers is like flush, but without a deferred handlePanic call. This
can be called from other methods which already have their own deferred
handlePanic calls, such as Write, and avoid the extra defer work.</p>
               
               <pre><code>func (b *Writer) flushNoDefers()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="format" data-name="format">
               <h3>
                  format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#format" class="anchor" title="Link to format">#</a>
               </h3>
               
               <p>Format the text between line0 and line1 (excluding line1); pos
is the buffer position corresponding to the beginning of line0.
Returns the buffer position corresponding to the beginning of
line1 and an error, if any.</p>
               
               <pre><code>func (b *Writer) format(pos0 int, line0 int, line1 int) (pos int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handlePanic" data-name="handlePanic">
               <h3>
                  handlePanic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handlePanic" class="anchor" title="Link to handlePanic">#</a>
               </h3>
               
               <pre><code>func (b *Writer) handlePanic(err *error, op string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <p>Reset the current state.</p>
               
               <pre><code>func (b *Writer) reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startEscape" data-name="startEscape">
               <h3>
                  startEscape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startEscape" class="anchor" title="Link to startEscape">#</a>
               </h3>
               
               <p>Start escaped mode.</p>
               
               <pre><code>func (b *Writer) startEscape(ch byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="terminateCell" data-name="terminateCell">
               <h3>
                  terminateCell 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#terminateCell" class="anchor" title="Link to terminateCell">#</a>
               </h3>
               
               <p>Terminate the current cell by adding it to the list of cells of the
current line. Returns the number of cells in that line.</p>
               
               <pre><code>func (b *Writer) terminateCell(htab bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateWidth" data-name="updateWidth">
               <h3>
                  updateWidth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateWidth" class="anchor" title="Link to updateWidth">#</a>
               </h3>
               
               <p>Update the cell width.</p>
               
               <pre><code>func (b *Writer) updateWidth()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write0" data-name="write0">
               <h3>
                  write0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write0" class="anchor" title="Link to write0">#</a>
               </h3>
               
               <pre><code>func (b *Writer) write0(buf []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeLines" data-name="writeLines">
               <h3>
                  writeLines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeLines" class="anchor" title="Link to writeLines">#</a>
               </h3>
               
               <pre><code>func (b *Writer) writeLines(pos0 int, line0 int, line1 int) (pos int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeN" data-name="writeN">
               <h3>
                  writeN 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeN" class="anchor" title="Link to writeN">#</a>
               </h3>
               
               <pre><code>func (b *Writer) writeN(src []byte, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writePadding" data-name="writePadding">
               <h3>
                  writePadding 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writePadding" class="anchor" title="Link to writePadding">#</a>
               </h3>
               
               <pre><code>func (b *Writer) writePadding(textw int, cellw int, useTabs bool)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>