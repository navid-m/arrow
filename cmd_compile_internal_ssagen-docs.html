<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>ssagen - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>ssagen</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"internal/buildcfg"
"log"
"os"
"strings"
"cmd/compile/internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/obj/wasm"
rtabi "internal/abi"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/obj"
"fmt"
"internal/abi"
"internal/buildcfg"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/sys"
"fmt"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"fmt"
"internal/buildcfg"
"os"
"slices"
"sort"
"strings"
"sync"
"cmd/compile/internal/base"
"cmd/compile/internal/inline"
"cmd/compile/internal/ir"
"cmd/compile/internal/liveness"
"cmd/compile/internal/objw"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"container/heap"
"fmt"
"cmd/compile/internal/ir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/src"
"bufio"
"bytes"
"fmt"
"go/constant"
"html"
"internal/buildcfg"
"os"
"path/filepath"
"slices"
"strings"
"cmd/compile/internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/liveness"
"cmd/compile/internal/objw"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/rttype"
"cmd/compile/internal/ssa"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/internal/sys"
rtabi "internal/abi"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Arch" data-name="Arch">
               <h3>
                  Arch 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Arch" class="anchor" title="Link to Arch">#</a>
               </h3>
               
               <pre><code class="language-go">var Arch ArchInfo</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BoundsCheckFunc" data-name="BoundsCheckFunc">
               <h3>
                  BoundsCheckFunc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#BoundsCheckFunc" class="anchor" title="Link to BoundsCheckFunc">#</a>
               </h3>
               
               <pre><code class="language-go">var BoundsCheckFunc [ssa.BoundsKindCount]*obj.LSym</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ExtendCheckFunc" data-name="ExtendCheckFunc">
               <h3>
                  ExtendCheckFunc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ExtendCheckFunc" class="anchor" title="Link to ExtendCheckFunc">#</a>
               </h3>
               
               <pre><code class="language-go">var ExtendCheckFunc [ssa.BoundsKindCount]*obj.LSym</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callDefer" data-name="callDefer">
               <h3>
                  callDefer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#callDefer" class="anchor" title="Link to callDefer">#</a>
               </h3>
               
               <pre><code class="language-go">const callDefer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callDeferStack" data-name="callDeferStack">
               <h3>
                  callDeferStack 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#callDeferStack" class="anchor" title="Link to callDeferStack">#</a>
               </h3>
               
               <pre><code class="language-go">const callDeferStack</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callGo" data-name="callGo">
               <h3>
                  callGo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#callGo" class="anchor" title="Link to callGo">#</a>
               </h3>
               
               <pre><code class="language-go">const callGo</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callNormal" data-name="callNormal">
               <h3>
                  callNormal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#callNormal" class="anchor" title="Link to callNormal">#</a>
               </h3>
               
               <pre><code class="language-go">const callNormal callKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callTail" data-name="callTail">
               <h3>
                  callTail 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#callTail" class="anchor" title="Link to callTail">#</a>
               </h3>
               
               <pre><code class="language-go">const callTail</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="capVar" data-name="capVar">
               <h3>
                  capVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#capVar" class="anchor" title="Link to capVar">#</a>
               </h3>
               
               <pre><code class="language-go">var capVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugPhi" data-name="debugPhi">
               <h3>
                  debugPhi 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugPhi" class="anchor" title="Link to debugPhi">#</a>
               </h3>
               
               <pre><code class="language-go">const debugPhi = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="deferBitsVar" data-name="deferBitsVar">
               <h3>
                  deferBitsVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#deferBitsVar" class="anchor" title="Link to deferBitsVar">#</a>
               </h3>
               
               <pre><code class="language-go">var deferBitsVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="deferStructFnField" data-name="deferStructFnField">
               <h3>
                  deferStructFnField 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#deferStructFnField" class="anchor" title="Link to deferStructFnField">#</a>
               </h3>
               
                  <p class="doc-comment">deferStructFnField is the field index of _defer.fn.</p>
               
               <pre><code class="language-go">const deferStructFnField = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="deferType" data-name="deferType">
               <h3>
                  deferType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#deferType" class="anchor" title="Link to deferType">#</a>
               </h3>
               
               <pre><code class="language-go">var deferType *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="f32_u32" data-name="f32_u32">
               <h3>
                  f32_u32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#f32_u32" class="anchor" title="Link to f32_u32">#</a>
               </h3>
               
               <pre><code class="language-go">var f32_u32 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="f32_u64" data-name="f32_u64">
               <h3>
                  f32_u64 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#f32_u64" class="anchor" title="Link to f32_u64">#</a>
               </h3>
               
               <pre><code class="language-go">var f32_u64 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="f64_u32" data-name="f64_u32">
               <h3>
                  f64_u32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#f64_u32" class="anchor" title="Link to f64_u32">#</a>
               </h3>
               
               <pre><code class="language-go">var f64_u32 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="f64_u64" data-name="f64_u64">
               <h3>
                  f64_u64 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#f64_u64" class="anchor" title="Link to f64_u64">#</a>
               </h3>
               
               <pre><code class="language-go">var f64_u64 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fpConvOpToSSA" data-name="fpConvOpToSSA">
               <h3>
                  fpConvOpToSSA 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fpConvOpToSSA" class="anchor" title="Link to fpConvOpToSSA">#</a>
               </h3>
               
               <pre><code class="language-go">var fpConvOpToSSA = map[twoTypes]twoOpsAndType{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fpConvOpToSSA32" data-name="fpConvOpToSSA32">
               <h3>
                  fpConvOpToSSA32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fpConvOpToSSA32" class="anchor" title="Link to fpConvOpToSSA32">#</a>
               </h3>
               
                  <p class="doc-comment">this map is used only for 32-bit arch, and only includes the difference
on 32-bit arch, don't use int64<->float conversion for uint32</p>
               
               <pre><code class="language-go">var fpConvOpToSSA32 = map[twoTypes]twoOpsAndType{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="globalMapInitLsyms" data-name="globalMapInitLsyms">
               <h3>
                  globalMapInitLsyms 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#globalMapInitLsyms" class="anchor" title="Link to globalMapInitLsyms">#</a>
               </h3>
               
                  <p class="doc-comment">globalMapInitLsyms records the LSym of each map.init.NNN outlined
map initializer function created by the compiler.</p>
               
               <pre><code class="language-go">var globalMapInitLsyms map[*obj.LSym]struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashVar" data-name="hashVar">
               <h3>
                  hashVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hashVar" class="anchor" title="Link to hashVar">#</a>
               </h3>
               
               <pre><code class="language-go">var hashVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="instrumentMove" data-name="instrumentMove">
               <h3>
                  instrumentMove 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#instrumentMove" class="anchor" title="Link to instrumentMove">#</a>
               </h3>
               
               <pre><code class="language-go">const instrumentMove</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="instrumentRead" data-name="instrumentRead">
               <h3>
                  instrumentRead 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#instrumentRead" class="anchor" title="Link to instrumentRead">#</a>
               </h3>
               
               <pre><code class="language-go">const instrumentRead = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="instrumentWrite" data-name="instrumentWrite">
               <h3>
                  instrumentWrite 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#instrumentWrite" class="anchor" title="Link to instrumentWrite">#</a>
               </h3>
               
               <pre><code class="language-go">const instrumentWrite</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intrinsics" data-name="intrinsics">
               <h3>
                  intrinsics 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#intrinsics" class="anchor" title="Link to intrinsics">#</a>
               </h3>
               
               <pre><code class="language-go">var intrinsics intrinsicBuilders</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="largeStackFrames" data-name="largeStackFrames">
               <h3>
                  largeStackFrames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#largeStackFrames" class="anchor" title="Link to largeStackFrames">#</a>
               </h3>
               
               <pre><code class="language-go">var largeStackFrames []largeStack</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="largeStackFramesMu" data-name="largeStackFramesMu">
               <h3>
                  largeStackFramesMu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#largeStackFramesMu" class="anchor" title="Link to largeStackFramesMu">#</a>
               </h3>
               
               <pre><code class="language-go">var largeStackFramesMu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lenVar" data-name="lenVar">
               <h3>
                  lenVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lenVar" class="anchor" title="Link to lenVar">#</a>
               </h3>
               
               <pre><code class="language-go">var lenVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxStackSize" data-name="maxStackSize">
               <h3>
                  maxStackSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxStackSize" class="anchor" title="Link to maxStackSize">#</a>
               </h3>
               
               <pre><code class="language-go">const maxStackSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memVar" data-name="memVar">
               <h3>
                  memVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memVar" class="anchor" title="Link to memVar">#</a>
               </h3>
               
                  <p class="doc-comment">marker node for the memory variable</p>
               
               <pre><code class="language-go">var memVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nowritebarrierrecCheck" data-name="nowritebarrierrecCheck">
               <h3>
                  nowritebarrierrecCheck 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nowritebarrierrecCheck" class="anchor" title="Link to nowritebarrierrecCheck">#</a>
               </h3>
               
               <pre><code class="language-go">var nowritebarrierrecCheck *nowritebarrierrecChecker</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okVar" data-name="okVar">
               <h3>
                  okVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okVar" class="anchor" title="Link to okVar">#</a>
               </h3>
               
               <pre><code class="language-go">var okVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opToSSA" data-name="opToSSA">
               <h3>
                  opToSSA 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#opToSSA" class="anchor" title="Link to opToSSA">#</a>
               </h3>
               
               <pre><code class="language-go">var opToSSA = map[opAndType]ssa.Op{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ptrVar" data-name="ptrVar">
               <h3>
                  ptrVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ptrVar" class="anchor" title="Link to ptrVar">#</a>
               </h3>
               
                  <p class="doc-comment">marker nodes for temporary variables</p>
               
               <pre><code class="language-go">var ptrVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="shareDeferExits" data-name="shareDeferExits">
               <h3>
                  shareDeferExits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#shareDeferExits" class="anchor" title="Link to shareDeferExits">#</a>
               </h3>
               
                  <p class="doc-comment">If true, share as many open-coded defer exits as possible (with the downside of
worse line-number information)</p>
               
               <pre><code class="language-go">const shareDeferExits = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="shiftOpToSSA" data-name="shiftOpToSSA">
               <h3>
                  shiftOpToSSA 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#shiftOpToSSA" class="anchor" title="Link to shiftOpToSSA">#</a>
               </h3>
               
               <pre><code class="language-go">var shiftOpToSSA = map[opAndTwoTypes]ssa.Op{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skipCap" data-name="skipCap">
               <h3>
                  skipCap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#skipCap" class="anchor" title="Link to skipCap">#</a>
               </h3>
               
               <pre><code class="language-go">const skipCap</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skipLen" data-name="skipLen">
               <h3>
                  skipLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#skipLen" class="anchor" title="Link to skipLen">#</a>
               </h3>
               
               <pre><code class="language-go">const skipLen</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skipPtr" data-name="skipPtr">
               <h3>
                  skipPtr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#skipPtr" class="anchor" title="Link to skipPtr">#</a>
               </h3>
               
               <pre><code class="language-go">const skipPtr skipMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="smallBlocks" data-name="smallBlocks">
               <h3>
                  smallBlocks 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#smallBlocks" class="anchor" title="Link to smallBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">const smallBlocks = 500</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="softFloatOps" data-name="softFloatOps">
               <h3>
                  softFloatOps 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#softFloatOps" class="anchor" title="Link to softFloatOps">#</a>
               </h3>
               
               <pre><code class="language-go">var softFloatOps map[ssa.Op]sfRtCallDef</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaCaches" data-name="ssaCaches">
               <h3>
                  ssaCaches 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaCaches" class="anchor" title="Link to ssaCaches">#</a>
               </h3>
               
               <pre><code class="language-go">var ssaCaches []ssa.Cache</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaConfig" data-name="ssaConfig">
               <h3>
                  ssaConfig 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaConfig" class="anchor" title="Link to ssaConfig">#</a>
               </h3>
               
               <pre><code class="language-go">var ssaConfig *ssa.Config</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaDir" data-name="ssaDir">
               <h3>
                  ssaDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaDir" class="anchor" title="Link to ssaDir">#</a>
               </h3>
               
               <pre><code class="language-go">var ssaDir string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaDump" data-name="ssaDump">
               <h3>
                  ssaDump 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaDump" class="anchor" title="Link to ssaDump">#</a>
               </h3>
               
               <pre><code class="language-go">var ssaDump string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaDumpCFG" data-name="ssaDumpCFG">
               <h3>
                  ssaDumpCFG 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaDumpCFG" class="anchor" title="Link to ssaDumpCFG">#</a>
               </h3>
               
               <pre><code class="language-go">var ssaDumpCFG string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaDumpFile" data-name="ssaDumpFile">
               <h3>
                  ssaDumpFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ssaDumpFile" class="anchor" title="Link to ssaDumpFile">#</a>
               </h3>
               
               <pre><code class="language-go">const ssaDumpFile = "ssa.html"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaDumpInlined" data-name="ssaDumpInlined">
               <h3>
                  ssaDumpInlined 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaDumpInlined" class="anchor" title="Link to ssaDumpInlined">#</a>
               </h3>
               
                  <p class="doc-comment">ssaDumpInlined holds all inlined functions when ssaDump contains a function name.</p>
               
               <pre><code class="language-go">var ssaDumpInlined []*ir.Func</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssaDumpStdout" data-name="ssaDumpStdout">
               <h3>
                  ssaDumpStdout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssaDumpStdout" class="anchor" title="Link to ssaDumpStdout">#</a>
               </h3>
               
               <pre><code class="language-go">var ssaDumpStdout bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typVar" data-name="typVar">
               <h3>
                  typVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#typVar" class="anchor" title="Link to typVar">#</a>
               </h3>
               
               <pre><code class="language-go">var typVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="u32_f32" data-name="u32_f32">
               <h3>
                  u32_f32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#u32_f32" class="anchor" title="Link to u32_f32">#</a>
               </h3>
               
               <pre><code class="language-go">var u32_f32 = u322fcvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="u32_f64" data-name="u32_f64">
               <h3>
                  u32_f64 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#u32_f64" class="anchor" title="Link to u32_f64">#</a>
               </h3>
               
               <pre><code class="language-go">var u32_f64 = u322fcvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="u64_f32" data-name="u64_f32">
               <h3>
                  u64_f32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#u64_f32" class="anchor" title="Link to u64_f32">#</a>
               </h3>
               
               <pre><code class="language-go">var u64_f32 = u642fcvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="u64_f64" data-name="u64_f64">
               <h3>
                  u64_f64 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#u64_f64" class="anchor" title="Link to u64_f64">#</a>
               </h3>
               
               <pre><code class="language-go">var u64_f64 = u642fcvtTab{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uint64fpConvOpToSSA" data-name="uint64fpConvOpToSSA">
               <h3>
                  uint64fpConvOpToSSA 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#uint64fpConvOpToSSA" class="anchor" title="Link to uint64fpConvOpToSSA">#</a>
               </h3>
               
                  <p class="doc-comment">uint64<->float conversions, only on machines that have instructions for that</p>
               
               <pre><code class="language-go">var uint64fpConvOpToSSA = map[twoTypes]twoOpsAndType{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="callKind" data-name="callKind">
               <h3>
                  callKind
                  <span class="badge type-badge">type</span>
                  <a href="#callKind" class="anchor" title="Link to callKind">#</a>
               </h3>
               
               <pre><code class="language-go">type callKind int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="instrumentKind" data-name="instrumentKind">
               <h3>
                  instrumentKind
                  <span class="badge type-badge">type</span>
                  <a href="#instrumentKind" class="anchor" title="Link to instrumentKind">#</a>
               </h3>
               
               <pre><code class="language-go">type instrumentKind uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="intrinsicBuilder" data-name="intrinsicBuilder">
               <h3>
                  intrinsicBuilder
                  <span class="badge type-badge">type</span>
                  <a href="#intrinsicBuilder" class="anchor" title="Link to intrinsicBuilder">#</a>
               </h3>
               
               <p>An intrinsicBuilder converts a call node n into an ssa value that
implements that call as an intrinsic. args is a list of arguments to the func.</p>
               
               <pre><code class="language-go">type intrinsicBuilder func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="intrinsicBuilders" data-name="intrinsicBuilders">
               <h3>
                  intrinsicBuilders
                  <span class="badge type-badge">type</span>
                  <a href="#intrinsicBuilders" class="anchor" title="Link to intrinsicBuilders">#</a>
               </h3>
               
               <pre><code class="language-go">type intrinsicBuilders map[intrinsicKey]intrinsicBuilder</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="skipMask" data-name="skipMask">
               <h3>
                  skipMask
                  <span class="badge type-badge">type</span>
                  <a href="#skipMask" class="anchor" title="Link to skipMask">#</a>
               </h3>
               
               <pre><code class="language-go">type skipMask uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ArchInfo" data-name="ArchInfo">
               <h3>
                  ArchInfo
                  <span class="badge">struct</span>
                  <a href="#ArchInfo" class="anchor" title="Link to ArchInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ArchInfo struct {
LinkArch *obj.LinkArch
REGSP int
MAXWIDTH int64
SoftFloat bool
PadFrame func(int64) int64
ZeroRange func(*objw.Progs, *obj.Prog, int64, int64, *uint32) *obj.Prog
Ginsnop func(*objw.Progs) *obj.Prog
SSAMarkMoves func(*State, *ssa.Block)
SSAGenValue func(*State, *ssa.Value)
SSAGenBlock func(s *State, b *ssa.Block, next *ssa.Block)
LoadRegResult func(s *State, f *ssa.Func, t *types.Type, reg int16, n *ir.Name, off int64) *obj.Prog
SpillArgReg func(pp *objw.Progs, p *obj.Prog, f *ssa.Func, t *types.Type, reg int16, n *ir.Name, off int64) *obj.Prog
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Branch" data-name="Branch">
               <h3>
                  Branch
                  <span class="badge">struct</span>
                  <a href="#Branch" class="anchor" title="Link to Branch">#</a>
               </h3>
               
               <p>Branch is an unresolved branch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Branch struct {
P *obj.Prog
B *ssa.Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="IndexJump" data-name="IndexJump">
               <h3>
                  IndexJump
                  <span class="badge">struct</span>
                  <a href="#IndexJump" class="anchor" title="Link to IndexJump">#</a>
               </h3>
               
               <p>For generating consecutive jump instructions to model a specific branching</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type IndexJump struct {
Jump obj.As
Index int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="State" data-name="State">
               <h3>
                  State
                  <span class="badge">struct</span>
                  <a href="#State" class="anchor" title="Link to State">#</a>
               </h3>
               
               <p>State contains state needed during Prog generation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type State struct {
ABI obj.ABI
pp *objw.Progs
Branches []Branch
JumpTables []*ssa.Block
bstart []*obj.Prog
maxarg int64
livenessMap liveness.Map
partLiveArgs map[*ir.Name]bool
lineRunStart *obj.Prog
OnWasmStackSkipped int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SymABIs" data-name="SymABIs">
               <h3>
                  SymABIs
                  <span class="badge">struct</span>
                  <a href="#SymABIs" class="anchor" title="Link to SymABIs">#</a>
               </h3>
               
               <p>SymABIs records information provided by the assembler about symbol
definition ABIs and reference ABIs.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type SymABIs struct {
defs map[string]obj.ABI
refs map[string]obj.ABISet
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="blockHeap" data-name="blockHeap">
               <h3>
                  blockHeap
                  <span class="badge">struct</span>
                  <a href="#blockHeap" class="anchor" title="Link to blockHeap">#</a>
               </h3>
               
               <p>A block heap is used as a priority queue to implement the PiggyBank
from Sreedhar and Gao.  That paper uses an array which is better
asymptotically but worse in the common case when the PiggyBank
holds a sparse set of blocks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type blockHeap struct {
a []*ssa.Block
level []int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="domBlock" data-name="domBlock">
               <h3>
                  domBlock
                  <span class="badge">struct</span>
                  <a href="#domBlock" class="anchor" title="Link to domBlock">#</a>
               </h3>
               
               <p>domBlock contains extra per-block information to record the dominator tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type domBlock struct {
firstChild *ssa.Block
sibling *ssa.Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="f2uCvtTab" data-name="f2uCvtTab">
               <h3>
                  f2uCvtTab
                  <span class="badge">struct</span>
                  <a href="#f2uCvtTab" class="anchor" title="Link to f2uCvtTab">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type f2uCvtTab struct {
ltf ssa.Op
cvt2U ssa.Op
subf ssa.Op
or ssa.Op
floatValue func(*state, *types.Type, float64) *ssa.Value
intValue func(*state, *types.Type, int64) *ssa.Value
cutoff uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="funcLine" data-name="funcLine">
               <h3>
                  funcLine
                  <span class="badge">struct</span>
                  <a href="#funcLine" class="anchor" title="Link to funcLine">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type funcLine struct {
f *obj.LSym
base *src.PosBase
line uint
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fwdRefAux" data-name="fwdRefAux">
               <h3>
                  fwdRefAux
                  <span class="badge">struct</span>
                  <a href="#fwdRefAux" class="anchor" title="Link to fwdRefAux">#</a>
               </h3>
               
               <p>fwdRefAux wraps an arbitrary ir.Node as an ssa.Aux for use with OpFwdref.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fwdRefAux struct {
_ [0]func()
N ir.Node
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="intrinsicBuildConfig" data-name="intrinsicBuildConfig">
               <h3>
                  intrinsicBuildConfig
                  <span class="badge">struct</span>
                  <a href="#intrinsicBuildConfig" class="anchor" title="Link to intrinsicBuildConfig">#</a>
               </h3>
               
               <p>intrinsicBuildConfig specifies the config to use for intrinsic building.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type intrinsicBuildConfig struct {
instrumenting bool
go386 string
goamd64 int
goarm buildcfg.GoarmFeatures
goarm64 buildcfg.Goarm64Features
gomips string
gomips64 string
goppc64 int
goriscv64 int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="intrinsicKey" data-name="intrinsicKey">
               <h3>
                  intrinsicKey
                  <span class="badge">struct</span>
                  <a href="#intrinsicKey" class="anchor" title="Link to intrinsicKey">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type intrinsicKey struct {
arch *sys.Arch
pkg string
fn string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="largeStack" data-name="largeStack">
               <h3>
                  largeStack
                  <span class="badge">struct</span>
                  <a href="#largeStack" class="anchor" title="Link to largeStack">#</a>
               </h3>
               
               <p>largeStack is info about a function whose stack frame is too large (rare).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type largeStack struct {
locals int64
args int64
callee int64
pos src.XPos
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nowritebarrierrecCall" data-name="nowritebarrierrecCall">
               <h3>
                  nowritebarrierrecCall
                  <span class="badge">struct</span>
                  <a href="#nowritebarrierrecCall" class="anchor" title="Link to nowritebarrierrecCall">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nowritebarrierrecCall struct {
target *ir.Func
lineno src.XPos
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nowritebarrierrecChecker" data-name="nowritebarrierrecChecker">
               <h3>
                  nowritebarrierrecChecker
                  <span class="badge">struct</span>
                  <a href="#nowritebarrierrecChecker" class="anchor" title="Link to nowritebarrierrecChecker">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nowritebarrierrecChecker struct {
extraCalls map[*ir.Func][]nowritebarrierrecCall
curfn *ir.Func
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="opAndTwoTypes" data-name="opAndTwoTypes">
               <h3>
                  opAndTwoTypes
                  <span class="badge">struct</span>
                  <a href="#opAndTwoTypes" class="anchor" title="Link to opAndTwoTypes">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type opAndTwoTypes struct {
op ir.Op
etype1 types.Kind
etype2 types.Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="opAndType" data-name="opAndType">
               <h3>
                  opAndType
                  <span class="badge">struct</span>
                  <a href="#opAndType" class="anchor" title="Link to opAndType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type opAndType struct {
op ir.Op
etype types.Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="openDeferInfo" data-name="openDeferInfo">
               <h3>
                  openDeferInfo
                  <span class="badge">struct</span>
                  <a href="#openDeferInfo" class="anchor" title="Link to openDeferInfo">#</a>
               </h3>
               
               <p>Information about each open-coded defer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type openDeferInfo struct {
n *ir.CallExpr
closure *ssa.Value
closureNode *ir.Name
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="phiState" data-name="phiState">
               <h3>
                  phiState
                  <span class="badge">struct</span>
                  <a href="#phiState" class="anchor" title="Link to phiState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type phiState struct {
s *state
f *ssa.Func
defvars []map[ir.Node]*ssa.Value
varnum map[ir.Node]int32
idom []*ssa.Block
tree []domBlock
level []int32
priq blockHeap
q []*ssa.Block
queued *sparseSet
hasPhi *sparseSet
hasDef *sparseSet
placeholder *ssa.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sfRtCallDef" data-name="sfRtCallDef">
               <h3>
                  sfRtCallDef
                  <span class="badge">struct</span>
                  <a href="#sfRtCallDef" class="anchor" title="Link to sfRtCallDef">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sfRtCallDef struct {
rtfn *obj.LSym
rtype types.Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="simplePhiState" data-name="simplePhiState">
               <h3>
                  simplePhiState
                  <span class="badge">struct</span>
                  <a href="#simplePhiState" class="anchor" title="Link to simplePhiState">#</a>
               </h3>
               
               <p>Variant to use for small functions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type simplePhiState struct {
s *state
f *ssa.Func
fwdrefs []*ssa.Value
defvars []map[ir.Node]*ssa.Value
reachable []bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sparseSet" data-name="sparseSet">
               <h3>
                  sparseSet
                  <span class="badge">struct</span>
                  <a href="#sparseSet" class="anchor" title="Link to sparseSet">#</a>
               </h3>
               
               <p>copy of ../ssa/sparseset.go
TODO: move this file to ../ssa, then use sparseSet there.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sparseSet struct {
dense []ssa.ID
sparse []int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ssaLabel" data-name="ssaLabel">
               <h3>
                  ssaLabel
                  <span class="badge">struct</span>
                  <a href="#ssaLabel" class="anchor" title="Link to ssaLabel">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ssaLabel struct {
target *ssa.Block
breakTarget *ssa.Block
continueTarget *ssa.Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ssafn" data-name="ssafn">
               <h3>
                  ssafn
                  <span class="badge">struct</span>
                  <a href="#ssafn" class="anchor" title="Link to ssafn">#</a>
               </h3>
               
               <p>ssafn holds frontend information about a function that the backend is processing.
It also exports a bunch of compiler services for the ssa backend.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ssafn struct {
curfn *ir.Func
strings map[string]*obj.LSym
stksize int64
stkptrsize int64
stkalign int64
log bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="state" data-name="state">
               <h3>
                  state
                  <span class="badge">struct</span>
                  <a href="#state" class="anchor" title="Link to state">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type state struct {
config *ssa.Config
f *ssa.Func
curfn *ir.Func
labels map[string]*ssaLabel
breakTo *ssa.Block
continueTo *ssa.Block
curBlock *ssa.Block
vars map[ir.Node]*ssa.Value
fwdVars map[ir.Node]*ssa.Value
defvars []map[ir.Node]*ssa.Value
decladdrs map[*ir.Name]*ssa.Value
startmem *ssa.Value
sp *ssa.Value
sb *ssa.Value
deferBitsAddr *ssa.Value
deferBitsTemp *ir.Name
line []src.XPos
lastPos src.XPos
panics map[funcLine]*ssa.Block
cgoUnsafeArgs bool
hasdefer bool
softFloat bool
hasOpenDefers bool
checkPtrEnabled bool
instrumentEnterExit bool
instrumentMemory bool
openDefers []*openDeferInfo
lastDeferExit *ssa.Block
lastDeferFinalBlock *ssa.Block
lastDeferCount int
prevCall *ssa.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="twoOpsAndType" data-name="twoOpsAndType">
               <h3>
                  twoOpsAndType
                  <span class="badge">struct</span>
                  <a href="#twoOpsAndType" class="anchor" title="Link to twoOpsAndType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type twoOpsAndType struct {
op1 ssa.Op
op2 ssa.Op
intermediateType types.Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="twoTypes" data-name="twoTypes">
               <h3>
                  twoTypes
                  <span class="badge">struct</span>
                  <a href="#twoTypes" class="anchor" title="Link to twoTypes">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type twoTypes struct {
etype1 types.Kind
etype2 types.Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="u322fcvtTab" data-name="u322fcvtTab">
               <h3>
                  u322fcvtTab
                  <span class="badge">struct</span>
                  <a href="#u322fcvtTab" class="anchor" title="Link to u322fcvtTab">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type u322fcvtTab struct {
cvtI2F ssa.Op
cvtF2F ssa.Op
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="u642fcvtTab" data-name="u642fcvtTab">
               <h3>
                  u642fcvtTab
                  <span class="badge">struct</span>
                  <a href="#u642fcvtTab" class="anchor" title="Link to u642fcvtTab">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type u642fcvtTab struct {
leq ssa.Op
cvt2F ssa.Op
and ssa.Op
rsh ssa.Op
or ssa.Op
add ssa.Op
one func(*state, *types.Type, int64) *ssa.Value
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AbiForBodylessFuncStackMap" data-name="AbiForBodylessFuncStackMap">
               <h3>
                  AbiForBodylessFuncStackMap 
                  <span class="badge">function</span>
                  
                  <a href="#AbiForBodylessFuncStackMap" class="anchor" title="Link to AbiForBodylessFuncStackMap">#</a>
               </h3>
               
               <p>AbiForBodylessFuncStackMap returns the ABI for a bodyless function's stack map.
This is not necessarily the ABI used to call it.
Currently (1.17 dev) such a stack map is always ABI0;
any ABI wrapper that is present is nosplit, hence a precise
stack map is not needed there (the parameters survive only long
enough to call the wrapped assembly function).
This always returns a freshly copied ABI.</p>
               
               <pre><code class="language-go">func AbiForBodylessFuncStackMap(fn *ir.Func) *abi.ABIConfig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddAux" data-name="AddAux">
               <h3>
                  AddAux 
                  <span class="badge">function</span>
                  
                  <a href="#AddAux" class="anchor" title="Link to AddAux">#</a>
               </h3>
               
               <p>AddAux adds the offset in the aux fields (AuxInt and Aux) of v to a.</p>
               
               <pre><code class="language-go">func AddAux(a *obj.Addr, v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddAux2" data-name="AddAux2">
               <h3>
                  AddAux2 
                  <span class="badge">function</span>
                  
                  <a href="#AddAux2" class="anchor" title="Link to AddAux2">#</a>
               </h3>
               
               <pre><code class="language-go">func AddAux2(a *obj.Addr, v *ssa.Value, offset int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddrAuto" data-name="AddrAuto">
               <h3>
                  AddrAuto 
                  <span class="badge">function</span>
                  
                  <a href="#AddrAuto" class="anchor" title="Link to AddrAuto">#</a>
               </h3>
               
               <pre><code class="language-go">func AddrAuto(a *obj.Addr, v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllocFrame" data-name="AllocFrame">
               <h3>
                  AllocFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllocFrame" class="anchor" title="Link to AllocFrame">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ssafn) AllocFrame(f *ssa.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Br" data-name="Br">
               <h3>
                  Br 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Br" class="anchor" title="Link to Br">#</a>
               </h3>
               
               <p>Br emits a single branch instruction and returns the instruction.
Not all architectures need the returned instruction, but otherwise
the boilerplate is common to all.</p>
               
               <pre><code class="language-go">func (s *State) Br(op obj.As, target *ssa.Block) *obj.Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Call" data-name="Call">
               <h3>
                  Call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Call" class="anchor" title="Link to Call">#</a>
               </h3>
               
               <p>Call returns a new CALL instruction for the SSA value v.
It uses PrepareCall to prepare the call.</p>
               
               <pre><code class="language-go">func (s *State) Call(v *ssa.Value) *obj.Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanBeAnSSAAux" data-name="CanBeAnSSAAux">
               <h3>
                  CanBeAnSSAAux 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanBeAnSSAAux" class="anchor" title="Link to CanBeAnSSAAux">#</a>
               </h3>
               
               <pre><code class="language-go">func (fwdRefAux) CanBeAnSSAAux()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckArgReg" data-name="CheckArgReg">
               <h3>
                  CheckArgReg 
                  <span class="badge">function</span>
                  
                  <a href="#CheckArgReg" class="anchor" title="Link to CheckArgReg">#</a>
               </h3>
               
               <p>CheckArgReg ensures that v is in the function's entry block.</p>
               
               <pre><code class="language-go">func CheckArgReg(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckLargeStacks" data-name="CheckLargeStacks">
               <h3>
                  CheckLargeStacks 
                  <span class="badge">function</span>
                  
                  <a href="#CheckLargeStacks" class="anchor" title="Link to CheckLargeStacks">#</a>
               </h3>
               
               <pre><code class="language-go">func CheckLargeStacks()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckLoweredGetClosurePtr" data-name="CheckLoweredGetClosurePtr">
               <h3>
                  CheckLoweredGetClosurePtr 
                  <span class="badge">function</span>
                  
                  <a href="#CheckLoweredGetClosurePtr" class="anchor" title="Link to CheckLoweredGetClosurePtr">#</a>
               </h3>
               
               <p>CheckLoweredGetClosurePtr checks that v is the first instruction in the function's entry block,
except for incoming in-register arguments.
The output of LoweredGetClosurePtr is generally hardwired to the correct register.
That register contains the closure pointer on closure entry.</p>
               
               <pre><code class="language-go">func CheckLoweredGetClosurePtr(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckLoweredPhi" data-name="CheckLoweredPhi">
               <h3>
                  CheckLoweredPhi 
                  <span class="badge">function</span>
                  
                  <a href="#CheckLoweredPhi" class="anchor" title="Link to CheckLoweredPhi">#</a>
               </h3>
               
               <p>CheckLoweredPhi checks that regalloc and stackalloc correctly handled phi values.
Called during ssaGenValue.</p>
               
               <pre><code class="language-go">func CheckLoweredPhi(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CombJump" data-name="CombJump">
               <h3>
                  CombJump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CombJump" class="anchor" title="Link to CombJump">#</a>
               </h3>
               
               <p>CombJump generates combinational instructions (2 at present) for a block jump,
thereby the behaviour of non-standard condition codes could be simulated</p>
               
               <pre><code class="language-go">func (s *State) CombJump(b *ssa.Block, next *ssa.Block, jumps *[2][2]IndexJump)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compile" data-name="Compile">
               <h3>
                  Compile 
                  <span class="badge">function</span>
                  
                  <a href="#Compile" class="anchor" title="Link to Compile">#</a>
               </h3>
               
               <p>Compile builds an SSA backend function,
uses it to generate a plist,
and flushes that plist to machine code.
worker indicates which of the backend workers is doing the processing.</p>
               
               <pre><code class="language-go">func Compile(fn *ir.Func, worker int, profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateWasmImportWrapper" data-name="CreateWasmImportWrapper">
               <h3>
                  CreateWasmImportWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#CreateWasmImportWrapper" class="anchor" title="Link to CreateWasmImportWrapper">#</a>
               </h3>
               
               <p>CreateWasmImportWrapper creates a wrapper for imported WASM functions to
adapt them to the Go calling convention. The body for this function is
generated in cmd/internal/obj/wasm/wasmobj.go</p>
               
               <pre><code class="language-go">func CreateWasmImportWrapper(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DebugFriendlySetPosFrom" data-name="DebugFriendlySetPosFrom">
               <h3>
                  DebugFriendlySetPosFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DebugFriendlySetPosFrom" class="anchor" title="Link to DebugFriendlySetPosFrom">#</a>
               </h3>
               
               <p>DebugFriendlySetPosFrom adjusts Pos.IsStmt subject to heuristics
that reduce "jumpy" line number churn when debugging.
Spill/fill/copy instructions from the register allocator,
phi functions, and instructions with a no-pos position
are examples of instructions that can cause churn.</p>
               
               <pre><code class="language-go">func (s *State) DebugFriendlySetPosFrom(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Debug_checknil" data-name="Debug_checknil">
               <h3>
                  Debug_checknil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Debug_checknil" class="anchor" title="Link to Debug_checknil">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ssafn) Debug_checknil() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Debug_checknil" data-name="Debug_checknil">
               <h3>
                  Debug_checknil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Debug_checknil" class="anchor" title="Link to Debug_checknil">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) Debug_checknil() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DumpInline" data-name="DumpInline">
               <h3>
                  DumpInline 
                  <span class="badge">function</span>
                  
                  <a href="#DumpInline" class="anchor" title="Link to DumpInline">#</a>
               </h3>
               
               <pre><code class="language-go">func DumpInline(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmitArgInfo" data-name="EmitArgInfo">
               <h3>
                  EmitArgInfo 
                  <span class="badge">function</span>
                  
                  <a href="#EmitArgInfo" class="anchor" title="Link to EmitArgInfo">#</a>
               </h3>
               
               <p>emit argument info (locations on stack) of f for traceback.</p>
               
               <pre><code class="language-go">func EmitArgInfo(f *ir.Func, abiInfo *abi.ABIParamResultInfo) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnableNoWriteBarrierRecCheck" data-name="EnableNoWriteBarrierRecCheck">
               <h3>
                  EnableNoWriteBarrierRecCheck 
                  <span class="badge">function</span>
                  
                  <a href="#EnableNoWriteBarrierRecCheck" class="anchor" title="Link to EnableNoWriteBarrierRecCheck">#</a>
               </h3>
               
               <pre><code class="language-go">func EnableNoWriteBarrierRecCheck()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <p>Fatalf reports a compiler error and exits.</p>
               
               <pre><code class="language-go">func (e *ssafn) Fatalf(pos src.XPos, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) Fatalf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ssafn) Func() *ir.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncInfo" data-name="FuncInfo">
               <h3>
                  FuncInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FuncInfo" class="anchor" title="Link to FuncInfo">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *State) FuncInfo() *obj.FuncInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GenABIWrappers" data-name="GenABIWrappers">
               <h3>
                  GenABIWrappers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GenABIWrappers" class="anchor" title="Link to GenABIWrappers">#</a>
               </h3>
               
               <p>GenABIWrappers applies ABI information to Funcs and generates ABI
wrapper functions where necessary.</p>
               
               <pre><code class="language-go">func (s *SymABIs) GenABIWrappers()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GenWasmExportWrapper" data-name="GenWasmExportWrapper">
               <h3>
                  GenWasmExportWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#GenWasmExportWrapper" class="anchor" title="Link to GenWasmExportWrapper">#</a>
               </h3>
               
               <pre><code class="language-go">func GenWasmExportWrapper(wrapped *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitConfig" data-name="InitConfig">
               <h3>
                  InitConfig 
                  <span class="badge">function</span>
                  
                  <a href="#InitConfig" class="anchor" title="Link to InitConfig">#</a>
               </h3>
               
               <pre><code class="language-go">func InitConfig()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitEnv" data-name="InitEnv">
               <h3>
                  InitEnv 
                  <span class="badge">function</span>
                  
                  <a href="#InitEnv" class="anchor" title="Link to InitEnv">#</a>
               </h3>
               
               <pre><code class="language-go">func InitEnv()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitTables" data-name="InitTables">
               <h3>
                  InitTables 
                  <span class="badge">function</span>
                  
                  <a href="#InitTables" class="anchor" title="Link to InitTables">#</a>
               </h3>
               
               <pre><code class="language-go">func InitTables()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsIntrinsicCall" data-name="IsIntrinsicCall">
               <h3>
                  IsIntrinsicCall 
                  <span class="badge">function</span>
                  
                  <a href="#IsIntrinsicCall" class="anchor" title="Link to IsIntrinsicCall">#</a>
               </h3>
               
               <pre><code class="language-go">func IsIntrinsicCall(n *ir.CallExpr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *blockHeap) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *blockHeap) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Log" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Log" class="anchor" title="Link to Log">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) Log() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Log" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Log" class="anchor" title="Link to Log">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ssafn) Log() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Logf" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Logf" class="anchor" title="Link to Logf">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) Logf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Logf" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Logf" class="anchor" title="Link to Logf">#</a>
               </h3>
               
               <p>Logf logs a message from the compiler.</p>
               
               <pre><code class="language-go">func (e *ssafn) Logf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewSymABIs" data-name="NewSymABIs">
               <h3>
                  NewSymABIs 
                  <span class="badge">function</span>
                  
                  <a href="#NewSymABIs" class="anchor" title="Link to NewSymABIs">#</a>
               </h3>
               
               <pre><code class="language-go">func NewSymABIs() *SymABIs</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NoWriteBarrierRecCheck" data-name="NoWriteBarrierRecCheck">
               <h3>
                  NoWriteBarrierRecCheck 
                  <span class="badge">function</span>
                  
                  <a href="#NoWriteBarrierRecCheck" class="anchor" title="Link to NoWriteBarrierRecCheck">#</a>
               </h3>
               
               <pre><code class="language-go">func NoWriteBarrierRecCheck()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pc" data-name="Pc">
               <h3>
                  Pc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pc" class="anchor" title="Link to Pc">#</a>
               </h3>
               
               <p>Pc returns the current Prog.</p>
               
               <pre><code class="language-go">func (s *State) Pc() *obj.Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *blockHeap) Pop() interface{}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PrepareCall" data-name="PrepareCall">
               <h3>
                  PrepareCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PrepareCall" class="anchor" title="Link to PrepareCall">#</a>
               </h3>
               
               <p>PrepareCall prepares to emit a CALL instruction for v and does call-related bookkeeping.
It must be called immediately before emitting the actual CALL instruction,
since it emits PCDATA for the stack map at the call (calls are safe points).</p>
               
               <pre><code class="language-go">func (s *State) PrepareCall(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prog" data-name="Prog">
               <h3>
                  Prog 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Prog" class="anchor" title="Link to Prog">#</a>
               </h3>
               
               <p>Prog appends a new Prog.</p>
               
               <pre><code class="language-go">func (s *State) Prog(as obj.As) *obj.Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *blockHeap) Push(x interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadSymABIs" data-name="ReadSymABIs">
               <h3>
                  ReadSymABIs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadSymABIs" class="anchor" title="Link to ReadSymABIs">#</a>
               </h3>
               
               <p>ReadSymABIs reads a symabis file that specifies definitions and
references of text symbols by ABI.
The symabis format is a set of lines, where each line is a sequence
of whitespace-separated fields. The first field is a verb and is
either "def" for defining a symbol ABI or "ref" for referencing a
symbol using an ABI. For both "def" and "ref", the second field is
the symbol name and the third field is the ABI name, as one of the
named cmd/internal/obj.ABI constants.</p>
               
               <pre><code class="language-go">func (s *SymABIs) ReadSymABIs(file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterMapInitLsym" data-name="RegisterMapInitLsym">
               <h3>
                  RegisterMapInitLsym 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterMapInitLsym" class="anchor" title="Link to RegisterMapInitLsym">#</a>
               </h3>
               
               <p>RegisterMapInitLsym records "s" in the set of outlined map initializer
functions.</p>
               
               <pre><code class="language-go">func RegisterMapInitLsym(s *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPos" data-name="SetPos">
               <h3>
                  SetPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPos" class="anchor" title="Link to SetPos">#</a>
               </h3>
               
               <p>SetPos sets the current source position.</p>
               
               <pre><code class="language-go">func (s *State) SetPos(pos src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SpillSlotAddr" data-name="SpillSlotAddr">
               <h3>
                  SpillSlotAddr 
                  <span class="badge">function</span>
                  
                  <a href="#SpillSlotAddr" class="anchor" title="Link to SpillSlotAddr">#</a>
               </h3>
               
               <p>SpillSlotAddr uses LocalSlot information to initialize an obj.Addr
The resulting addr is used in a non-standard context -- in the prologue
of a function, before the frame has been constructed, so the standard
addressing for the parameters will be wrong.</p>
               
               <pre><code class="language-go">func SpillSlotAddr(spill ssa.Spill, baseReg int16, extraOffset int64) obj.Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitSlot" data-name="SplitSlot">
               <h3>
                  SplitSlot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SplitSlot" class="anchor" title="Link to SplitSlot">#</a>
               </h3>
               
               <p>SplitSlot returns a slot representing the data of parent starting at offset.</p>
               
               <pre><code class="language-go">func (e *ssafn) SplitSlot(parent *ssa.LocalSlot, suffix string, offset int64, t *types.Type) ssa.LocalSlot</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StackOffset" data-name="StackOffset">
               <h3>
                  StackOffset 
                  <span class="badge">function</span>
                  
                  <a href="#StackOffset" class="anchor" title="Link to StackOffset">#</a>
               </h3>
               
               <p>StackOffset returns the stack location of a LocalSlot relative to the
stack pointer, suitable for use in a DWARF location entry. This has nothing
to do with its offset in the user variable.</p>
               
               <pre><code class="language-go">func StackOffset(slot ssa.LocalSlot) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StringData" data-name="StringData">
               <h3>
                  StringData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StringData" class="anchor" title="Link to StringData">#</a>
               </h3>
               
               <p>StringData returns a symbol which
is the data component of a global string constant containing s.</p>
               
               <pre><code class="language-go">func (e *ssafn) StringData(s string) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *blockHeap) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Syslook" data-name="Syslook">
               <h3>
                  Syslook 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Syslook" class="anchor" title="Link to Syslook">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ssafn) Syslook(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TailCall" data-name="TailCall">
               <h3>
                  TailCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TailCall" class="anchor" title="Link to TailCall">#</a>
               </h3>
               
               <p>TailCall returns a new tail call instruction for the SSA value v.
It is like Call, but for a tail call.</p>
               
               <pre><code class="language-go">func (s *State) TailCall(v *ssa.Value) *obj.Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UseArgs" data-name="UseArgs">
               <h3>
                  UseArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UseArgs" class="anchor" title="Link to UseArgs">#</a>
               </h3>
               
               <p>UseArgs records the fact that an instruction needs a certain amount of
callee args space for its use.</p>
               
               <pre><code class="language-go">func (s *State) UseArgs(n int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UseWriteBarrier" data-name="UseWriteBarrier">
               <h3>
                  UseWriteBarrier 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UseWriteBarrier" class="anchor" title="Link to UseWriteBarrier">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ssafn) UseWriteBarrier() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Warnl" data-name="Warnl">
               <h3>
                  Warnl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Warnl" class="anchor" title="Link to Warnl">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) Warnl(pos src.XPos, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Warnl" data-name="Warnl">
               <h3>
                  Warnl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Warnl" class="anchor" title="Link to Warnl">#</a>
               </h3>
               
               <p>Warnl reports a "warning", which is usually flag-triggered
logging output for the benefit of tests.</p>
               
               <pre><code class="language-go">func (e *ssafn) Warnl(pos src.XPos, fmt_ string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abiForFunc" data-name="abiForFunc">
               <h3>
                  abiForFunc 
                  <span class="badge">function</span>
                  
                  <a href="#abiForFunc" class="anchor" title="Link to abiForFunc">#</a>
               </h3>
               
               <p>abiForFunc implements ABI policy for a function, but does not return a copy of the ABI.
Passing a nil function returns the default ABI based on experiment configuration.</p>
               
               <pre><code class="language-go">func abiForFunc(fn *ir.Func, abi0 *abi.ABIConfig, abi1 *abi.ABIConfig) *abi.ABIConfig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds the intrinsic builder b for pkg.fn for the given architecture.</p>
               
               <pre><code class="language-go">func (ib intrinsicBuilders) add(arch *sys.Arch, pkg string, fn string, b intrinsicBuilder)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *sparseSet) add(x ssa.ID)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addForArchs" data-name="addForArchs">
               <h3>
                  addForArchs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addForArchs" class="anchor" title="Link to addForArchs">#</a>
               </h3>
               
               <p>addForArchs adds the intrinsic builder b for pkg.fn for the given architectures.</p>
               
               <pre><code class="language-go">func (ib intrinsicBuilders) addForArchs(pkg string, fn string, b intrinsicBuilder, archs ...*sys.Arch)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addForFamilies" data-name="addForFamilies">
               <h3>
                  addForFamilies 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addForFamilies" class="anchor" title="Link to addForFamilies">#</a>
               </h3>
               
               <p>addForFamilies does the same as addForArchs but operates on architecture families.</p>
               
               <pre><code class="language-go">func (ib intrinsicBuilders) addForFamilies(pkg string, fn string, b intrinsicBuilder, archFamilies ...sys.ArchFamily)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addNamedValue" data-name="addNamedValue">
               <h3>
                  addNamedValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addNamedValue" class="anchor" title="Link to addNamedValue">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) addNamedValue(n *ir.Name, v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addr" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addr" class="anchor" title="Link to addr">#</a>
               </h3>
               
               <p>addr converts the address of the expression n to SSA, adds it to s and returns the SSA result.
The value that the returned Value represents is guaranteed to be non-nil.</p>
               
               <pre><code class="language-go">func (s *state) addr(n ir.Node) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alias" data-name="alias">
               <h3>
                  alias 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#alias" class="anchor" title="Link to alias">#</a>
               </h3>
               
               <p>alias aliases pkg.fn to targetPkg.targetFn for all architectures in archs
for which targetPkg.targetFn already exists.</p>
               
               <pre><code class="language-go">func (ib intrinsicBuilders) alias(pkg string, fn string, targetPkg string, targetFn string, archs ...*sys.Arch)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <p>append converts an OAPPEND node to SSA.
If inplace is false, it converts the OAPPEND expression n to an ssa.Value,
adds it to s, and returns the Value.
If inplace is true, it writes the result of the OAPPEND expression n
back to the slice being appended to, and returns nil.
inplace MUST be set to false if the slice can be SSA'd.
Note: this code only handles fixed-count appends. Dotdotdot appends
have already been rewritten at this point (by walk).</p>
               
               <pre><code class="language-go">func (s *state) append(n *ir.CallExpr, inplace bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <p>assign does left = right.
Right has already been evaluated to ssa, left has not.
If deref is true, then we do left = *right instead (and right has already been nil-checked).
If deref is true and right == nil, just do left = 0.
skip indicates assignments (at the top level) that can be avoided.
mayOverlap indicates whether left&right might partially overlap in memory. Default is false.</p>
               
               <pre><code class="language-go">func (s *state) assign(left ir.Node, right *ssa.Value, deref bool, skip skipMask)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignWhichMayOverlap" data-name="assignWhichMayOverlap">
               <h3>
                  assignWhichMayOverlap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignWhichMayOverlap" class="anchor" title="Link to assignWhichMayOverlap">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) assignWhichMayOverlap(left ir.Node, right *ssa.Value, deref bool, skip skipMask, mayOverlap bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boundsCheck" data-name="boundsCheck">
               <h3>
                  boundsCheck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#boundsCheck" class="anchor" title="Link to boundsCheck">#</a>
               </h3>
               
               <p>boundsCheck generates bounds checking code. Checks if 0 <= idx <[=] len, branches to exit if not.
Starts a new block on return.
On input, len must be converted to full int width and be nonnegative.
Returns idx converted to full int width.
If bounded is true then caller guarantees the index is not out of bounds
(but boundsCheck will still extend the index to full int width).</p>
               
               <pre><code class="language-go">func (s *state) boundsCheck(idx *ssa.Value, len *ssa.Value, kind ssa.BoundsKind, bounded bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildssa" data-name="buildssa">
               <h3>
                  buildssa 
                  <span class="badge">function</span>
                  
                  <a href="#buildssa" class="anchor" title="Link to buildssa">#</a>
               </h3>
               
               <p>buildssa builds an SSA function for fn.
worker indicates which of the backend workers is doing the processing.</p>
               
               <pre><code class="language-go">func buildssa(fn *ir.Func, worker int, isPgoHot bool) *ssa.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <p>Calls the function n using the specified call type.
Returns the address of the return value (or nil if none).</p>
               
               <pre><code class="language-go">func (s *state) call(n *ir.CallExpr, k callKind, returnResultAddr bool, deferExtra ir.Expr) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callAddr" data-name="callAddr">
               <h3>
                  callAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callAddr" class="anchor" title="Link to callAddr">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) callAddr(n *ir.CallExpr, k callKind) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callResult" data-name="callResult">
               <h3>
                  callResult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callResult" class="anchor" title="Link to callResult">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) callResult(n *ir.CallExpr, k callKind) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callTargetLSym" data-name="callTargetLSym">
               <h3>
                  callTargetLSym 
                  <span class="badge">function</span>
                  
                  <a href="#callTargetLSym" class="anchor" title="Link to callTargetLSym">#</a>
               </h3>
               
               <p>callTargetLSym returns the correct LSym to call 'callee' using its ABI.</p>
               
               <pre><code class="language-go">func callTargetLSym(callee *ir.Name) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canSSA" data-name="canSSA">
               <h3>
                  canSSA 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canSSA" class="anchor" title="Link to canSSA">#</a>
               </h3>
               
               <p>canSSA reports whether n is SSA-able.
n must be an ONAME (or an ODOT sequence with an ONAME base).</p>
               
               <pre><code class="language-go">func (s *state) canSSA(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canSSAName" data-name="canSSAName">
               <h3>
                  canSSAName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canSSAName" class="anchor" title="Link to canSSAName">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) canSSAName(name *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canonicalize" data-name="canonicalize">
               <h3>
                  canonicalize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canonicalize" class="anchor" title="Link to canonicalize">#</a>
               </h3>
               
               <p>canonicalize returns the canonical name used for a linker symbol in
s's maps. Symbols in this package may be written either as "".X or
with the package's import path already in the symbol. This rewrites
both to use the full path, which matches compiler-generated linker
symbol names.</p>
               
               <pre><code class="language-go">func (s *SymABIs) canonicalize(linksym string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *nowritebarrierrecChecker) check()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <p>If cmp (a bool) is false, panic using the given function.</p>
               
               <pre><code class="language-go">func (s *state) check(cmp *ssa.Value, fn *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPtrAlignment" data-name="checkPtrAlignment">
               <h3>
                  checkPtrAlignment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkPtrAlignment" class="anchor" title="Link to checkPtrAlignment">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) checkPtrAlignment(n *ir.ConvExpr, v *ssa.Value, count *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clear" data-name="clear">
               <h3>
                  clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clear" class="anchor" title="Link to clear">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *sparseSet) clear()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clobberBase" data-name="clobberBase">
               <h3>
                  clobberBase 
                  <span class="badge">function</span>
                  
                  <a href="#clobberBase" class="anchor" title="Link to clobberBase">#</a>
               </h3>
               
               <pre><code class="language-go">func clobberBase(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmpstackvarlt" data-name="cmpstackvarlt">
               <h3>
                  cmpstackvarlt 
                  <span class="badge">function</span>
                  
                  <a href="#cmpstackvarlt" class="anchor" title="Link to cmpstackvarlt">#</a>
               </h3>
               
               <p>cmpstackvarlt reports whether the stack variable a sorts before b.</p>
               
               <pre><code class="language-go">func cmpstackvarlt(a *ir.Name, b *ir.Name, mls *liveness.MergeLocalsState) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="concreteEtype" data-name="concreteEtype">
               <h3>
                  concreteEtype 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#concreteEtype" class="anchor" title="Link to concreteEtype">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) concreteEtype(t *types.Type) types.Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="condBranch" data-name="condBranch">
               <h3>
                  condBranch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#condBranch" class="anchor" title="Link to condBranch">#</a>
               </h3>
               
               <p>condBranch evaluates the boolean expression cond and branches to yes
if cond is true and no if cond is false.
This function is intended to handle && and || better than just calling
s.expr(cond) and branching on the result.</p>
               
               <pre><code class="language-go">func (s *state) condBranch(cond ir.Node, yes *ssa.Block, no *ssa.Block, likely int8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constBool" data-name="constBool">
               <h3>
                  constBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constBool" class="anchor" title="Link to constBool">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constBool(c bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constEmptyString" data-name="constEmptyString">
               <h3>
                  constEmptyString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constEmptyString" class="anchor" title="Link to constEmptyString">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constEmptyString(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constFloat32" data-name="constFloat32">
               <h3>
                  constFloat32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constFloat32" class="anchor" title="Link to constFloat32">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constFloat32(t *types.Type, c float64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constFloat64" data-name="constFloat64">
               <h3>
                  constFloat64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constFloat64" class="anchor" title="Link to constFloat64">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constFloat64(t *types.Type, c float64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constInt" data-name="constInt">
               <h3>
                  constInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constInt" class="anchor" title="Link to constInt">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constInt(t *types.Type, c int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constInt16" data-name="constInt16">
               <h3>
                  constInt16 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constInt16" class="anchor" title="Link to constInt16">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constInt16(t *types.Type, c int16) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constInt32" data-name="constInt32">
               <h3>
                  constInt32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constInt32" class="anchor" title="Link to constInt32">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constInt32(t *types.Type, c int32) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constInt64" data-name="constInt64">
               <h3>
                  constInt64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constInt64" class="anchor" title="Link to constInt64">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constInt64(t *types.Type, c int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constInt8" data-name="constInt8">
               <h3>
                  constInt8 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constInt8" class="anchor" title="Link to constInt8">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constInt8(t *types.Type, c int8) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constInterface" data-name="constInterface">
               <h3>
                  constInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constInterface" class="anchor" title="Link to constInterface">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constInterface(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constNil" data-name="constNil">
               <h3>
                  constNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constNil" class="anchor" title="Link to constNil">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constNil(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constOffPtrSP" data-name="constOffPtrSP">
               <h3>
                  constOffPtrSP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constOffPtrSP" class="anchor" title="Link to constOffPtrSP">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) constOffPtrSP(t *types.Type, c int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constSlice" data-name="constSlice">
               <h3>
                  constSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constSlice" class="anchor" title="Link to constSlice">#</a>
               </h3>
               
               <p>const* routines add a new const value to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) constSlice(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contains" data-name="contains">
               <h3>
                  contains 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#contains" class="anchor" title="Link to contains">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *sparseSet) contains(x ssa.ID) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="conv" data-name="conv">
               <h3>
                  conv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#conv" class="anchor" title="Link to conv">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) conv(n ir.Node, v *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deferstruct" data-name="deferstruct">
               <h3>
                  deferstruct 
                  <span class="badge">function</span>
                  
                  <a href="#deferstruct" class="anchor" title="Link to deferstruct">#</a>
               </h3>
               
               <p>deferstruct returns a type interchangeable with runtime._defer.
Make sure this stays in sync with runtime/runtime2.go:_defer.</p>
               
               <pre><code class="language-go">func deferstruct() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defframe" data-name="defframe">
               <h3>
                  defframe 
                  <span class="badge">function</span>
                  
                  <a href="#defframe" class="anchor" title="Link to defframe">#</a>
               </h3>
               
               <pre><code class="language-go">func defframe(s *State, e *ssafn, f *ssa.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dottype" data-name="dottype">
               <h3>
                  dottype 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dottype" class="anchor" title="Link to dottype">#</a>
               </h3>
               
               <p>dottype generates SSA for a type assertion node.
commaok indicates whether to panic or return a bool.
If commaok is false, resok will be nil.</p>
               
               <pre><code class="language-go">func (s *state) dottype(n *ir.TypeAssertExpr, commaok bool) (res *ssa.Value, resok *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dottype1" data-name="dottype1">
               <h3>
                  dottype1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dottype1" class="anchor" title="Link to dottype1">#</a>
               </h3>
               
               <p>dottype1 implements a x.(T) operation. iface is the argument (x), dst is the type we're asserting to (T)
and src is the type we're asserting from.
source is the *runtime._type of src
target is the *runtime._type of dst.
If src is a nonempty interface and dst is not an interface, targetItab is an itab representing (dst, src). Otherwise it is nil.
commaok is true if the caller wants a boolean success value. Otherwise, the generated code panics if the conversion fails.
descriptor is a compiler-allocated internal/abi.TypeAssert whose address is passed to runtime.typeAssert when
the target type is a compile-time-known non-empty interface. It may be nil.</p>
               
               <pre><code class="language-go">func (s *state) dottype1(pos src.XPos, src *types.Type, dst *types.Type, iface *ssa.Value, source *ssa.Value, target *ssa.Value, targetItab *ssa.Value, commaok bool, descriptor *obj.LSym) (res *ssa.Value, resok *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpSourcesColumn" data-name="dumpSourcesColumn">
               <h3>
                  dumpSourcesColumn 
                  <span class="badge">function</span>
                  
                  <a href="#dumpSourcesColumn" class="anchor" title="Link to dumpSourcesColumn">#</a>
               </h3>
               
               <pre><code class="language-go">func dumpSourcesColumn(writer *ssa.HTMLWriter, fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dynamicDottype" data-name="dynamicDottype">
               <h3>
                  dynamicDottype 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dynamicDottype" class="anchor" title="Link to dynamicDottype">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) dynamicDottype(n *ir.DynamicTypeAssertExpr, commaok bool) (res *ssa.Value, resok *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitArgInfo" data-name="emitArgInfo">
               <h3>
                  emitArgInfo 
                  <span class="badge">function</span>
                  
                  <a href="#emitArgInfo" class="anchor" title="Link to emitArgInfo">#</a>
               </h3>
               
               <p>emit argument info (locations on stack) for traceback.</p>
               
               <pre><code class="language-go">func emitArgInfo(e *ssafn, f *ssa.Func, pp *objw.Progs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitOpenDeferInfo" data-name="emitOpenDeferInfo">
               <h3>
                  emitOpenDeferInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emitOpenDeferInfo" class="anchor" title="Link to emitOpenDeferInfo">#</a>
               </h3>
               
               <p>emitOpenDeferInfo emits FUNCDATA information about the defers in a function
that is using open-coded defers.  This funcdata is used to determine the active
defers in a function and execute those defers during panic processing.
The funcdata is all encoded in varints (since values will almost always be less than
128, but stack offsets could potentially be up to 2Gbyte). All "locations" (offsets)
for stack variables are specified as the number of bytes below varp (pointer to the
top of the local variables) for their starting address. The format is:
- Offset of the deferBits variable
- Offset of the first closure slot (the rest are laid out consecutively).</p>
               
               <pre><code class="language-go">func (s *state) emitOpenDeferInfo()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitWrappedFuncInfo" data-name="emitWrappedFuncInfo">
               <h3>
                  emitWrappedFuncInfo 
                  <span class="badge">function</span>
                  
                  <a href="#emitWrappedFuncInfo" class="anchor" title="Link to emitWrappedFuncInfo">#</a>
               </h3>
               
               <p>for wrapper, emit info of wrapped function.</p>
               
               <pre><code class="language-go">func emitWrappedFuncInfo(e *ssafn, pp *objw.Progs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endBlock" data-name="endBlock">
               <h3>
                  endBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endBlock" class="anchor" title="Link to endBlock">#</a>
               </h3>
               
               <p>endBlock marks the end of generating code for the current block.
Returns the (former) current block. Returns nil if there is no current
block, i.e. if no code flows to the current execution point.</p>
               
               <pre><code class="language-go">func (s *state) endBlock() *ssa.Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryBlock" data-name="entryBlock">
               <h3>
                  entryBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryBlock" class="anchor" title="Link to entryBlock">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) entryBlock() *ssa.Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue0" data-name="entryNewValue0">
               <h3>
                  entryNewValue0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue0" class="anchor" title="Link to entryNewValue0">#</a>
               </h3>
               
               <p>entryNewValue0 adds a new value with no arguments to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue0(op ssa.Op, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue0A" data-name="entryNewValue0A">
               <h3>
                  entryNewValue0A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue0A" class="anchor" title="Link to entryNewValue0A">#</a>
               </h3>
               
               <p>entryNewValue0A adds a new value with no arguments and an aux value to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue0A(op ssa.Op, t *types.Type, aux ssa.Aux) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue1" data-name="entryNewValue1">
               <h3>
                  entryNewValue1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue1" class="anchor" title="Link to entryNewValue1">#</a>
               </h3>
               
               <p>entryNewValue1 adds a new value with one argument to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue1A" data-name="entryNewValue1A">
               <h3>
                  entryNewValue1A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue1A" class="anchor" title="Link to entryNewValue1A">#</a>
               </h3>
               
               <p>entryNewValue1A adds a new value with one argument and an aux value to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue1A(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue1I" data-name="entryNewValue1I">
               <h3>
                  entryNewValue1I 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue1I" class="anchor" title="Link to entryNewValue1I">#</a>
               </h3>
               
               <p>entryNewValue1I adds a new value with one argument and an auxint value to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue1I(op ssa.Op, t *types.Type, auxint int64, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue2" data-name="entryNewValue2">
               <h3>
                  entryNewValue2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue2" class="anchor" title="Link to entryNewValue2">#</a>
               </h3>
               
               <p>entryNewValue2 adds a new value with two arguments to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryNewValue2A" data-name="entryNewValue2A">
               <h3>
                  entryNewValue2A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryNewValue2A" class="anchor" title="Link to entryNewValue2A">#</a>
               </h3>
               
               <p>entryNewValue2A adds a new value with two arguments and an aux value to the entry block.</p>
               
               <pre><code class="language-go">func (s *state) entryNewValue2A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="etypesign" data-name="etypesign">
               <h3>
                  etypesign 
                  <span class="badge">function</span>
                  
                  <a href="#etypesign" class="anchor" title="Link to etypesign">#</a>
               </h3>
               
               <p>etypesign returns the signed-ness of e, for integer/pointer etypes.
-1 means signed, +1 means unsigned, 0 means non-integer/non-pointer.</p>
               
               <pre><code class="language-go">func etypesign(e types.Kind) int8</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exit" data-name="exit">
               <h3>
                  exit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exit" class="anchor" title="Link to exit">#</a>
               </h3>
               
               <p>exit processes any code that needs to be generated just before returning.
It returns a BlockRet block that ends the control flow. Its control value
will be set to the final memory state.</p>
               
               <pre><code class="language-go">func (s *state) exit() *ssa.Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <p>expr converts the expression n to ssa, adds it to s and returns the ssa result.</p>
               
               <pre><code class="language-go">func (s *state) expr(n ir.Node) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprCheckPtr" data-name="exprCheckPtr">
               <h3>
                  exprCheckPtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprCheckPtr" class="anchor" title="Link to exprCheckPtr">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) exprCheckPtr(n ir.Node, checkPtrOK bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprPtr" data-name="exprPtr">
               <h3>
                  exprPtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprPtr" class="anchor" title="Link to exprPtr">#</a>
               </h3>
               
               <p>exprPtr evaluates n to a pointer and nil-checks it.</p>
               
               <pre><code class="language-go">func (s *state) exprPtr(n ir.Node, bounded bool, lineno src.XPos) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extendIndex" data-name="extendIndex">
               <h3>
                  extendIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#extendIndex" class="anchor" title="Link to extendIndex">#</a>
               </h3>
               
               <p>extendIndex extends v to a full int width.
panic with the given kind if v does not fit in an int (only on 32-bit archs).</p>
               
               <pre><code class="language-go">func (s *state) extendIndex(idx *ssa.Value, len *ssa.Value, kind ssa.BoundsKind, bounded bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldIdx" data-name="fieldIdx">
               <h3>
                  fieldIdx 
                  <span class="badge">function</span>
                  
                  <a href="#fieldIdx" class="anchor" title="Link to fieldIdx">#</a>
               </h3>
               
               <p>fieldIdx finds the index of the field referred to by the ODOT node n.</p>
               
               <pre><code class="language-go">func fieldIdx(n *ir.SelectorExpr) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldtrack" data-name="fieldtrack">
               <h3>
                  fieldtrack 
                  <span class="badge">function</span>
                  
                  <a href="#fieldtrack" class="anchor" title="Link to fieldtrack">#</a>
               </h3>
               
               <p>fieldtrack adds R_USEFIELD relocations to fnsym to record any
struct fields that it used.</p>
               
               <pre><code class="language-go">func fieldtrack(fnsym *obj.LSym, tracked map[*obj.LSym]struct{...})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findExtraCalls" data-name="findExtraCalls">
               <h3>
                  findExtraCalls 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findExtraCalls" class="anchor" title="Link to findExtraCalls">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *nowritebarrierrecChecker) findExtraCalls(nn ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findIntrinsic" data-name="findIntrinsic">
               <h3>
                  findIntrinsic 
                  <span class="badge">function</span>
                  
                  <a href="#findIntrinsic" class="anchor" title="Link to findIntrinsic">#</a>
               </h3>
               
               <p>findIntrinsic returns a function which builds the SSA equivalent of the
function identified by the symbol sym.  If sym is not an intrinsic call, returns nil.</p>
               
               <pre><code class="language-go">func findIntrinsic(sym *types.Sym) intrinsicBuilder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="float32ToUint32" data-name="float32ToUint32">
               <h3>
                  float32ToUint32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#float32ToUint32" class="anchor" title="Link to float32ToUint32">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) float32ToUint32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="float32ToUint64" data-name="float32ToUint64">
               <h3>
                  float32ToUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#float32ToUint64" class="anchor" title="Link to float32ToUint64">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) float32ToUint64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="float64ToUint32" data-name="float64ToUint32">
               <h3>
                  float64ToUint32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#float64ToUint32" class="anchor" title="Link to float64ToUint32">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) float64ToUint32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="float64ToUint64" data-name="float64ToUint64">
               <h3>
                  float64ToUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#float64ToUint64" class="anchor" title="Link to float64ToUint64">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) float64ToUint64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="floatToUint" data-name="floatToUint">
               <h3>
                  floatToUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#floatToUint" class="anchor" title="Link to floatToUint">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) floatToUint(cvttab *f2uCvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forEachWrapperABI" data-name="forEachWrapperABI">
               <h3>
                  forEachWrapperABI 
                  <span class="badge">function</span>
                  
                  <a href="#forEachWrapperABI" class="anchor" title="Link to forEachWrapperABI">#</a>
               </h3>
               
               <pre><code class="language-go">func forEachWrapperABI(fn *ir.Func, cb func(fn *ir.Func, wrapperABI obj.ABI))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genssa" data-name="genssa">
               <h3>
                  genssa 
                  <span class="badge">function</span>
                  
                  <a href="#genssa" class="anchor" title="Link to genssa">#</a>
               </h3>
               
               <p>genssa appends entries to pp for each instruction in f.</p>
               
               <pre><code class="language-go">func genssa(f *ssa.Func, pp *objw.Progs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getClosureAndRcvr" data-name="getClosureAndRcvr">
               <h3>
                  getClosureAndRcvr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getClosureAndRcvr" class="anchor" title="Link to getClosureAndRcvr">#</a>
               </h3>
               
               <p>getClosureAndRcvr returns values for the appropriate closure and receiver of an
interface call</p>
               
               <pre><code class="language-go">func (s *state) getClosureAndRcvr(fn *ir.SelectorExpr) (*ssa.Value, *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initIntrinsics" data-name="initIntrinsics">
               <h3>
                  initIntrinsics 
                  <span class="badge">function</span>
                  
                  <a href="#initIntrinsics" class="anchor" title="Link to initIntrinsics">#</a>
               </h3>
               
               <pre><code class="language-go">func initIntrinsics(cfg *intrinsicBuildConfig)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insertPhis" data-name="insertPhis">
               <h3>
                  insertPhis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insertPhis" class="anchor" title="Link to insertPhis">#</a>
               </h3>
               
               <p>insertPhis finds all the places in the function where a phi is
necessary and inserts them.
Uses FwdRef ops to find all uses of variables, and s.defvars to find
all definitions.
Phi values are inserted, and all FwdRefs are changed to a Copy
of the appropriate phi or definition.
TODO: make this part of cmd/compile/internal/ssa somehow?</p>
               
               <pre><code class="language-go">func (s *state) insertPhis()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insertPhis" data-name="insertPhis">
               <h3>
                  insertPhis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insertPhis" class="anchor" title="Link to insertPhis">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *phiState) insertPhis()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insertPhis" data-name="insertPhis">
               <h3>
                  insertPhis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insertPhis" class="anchor" title="Link to insertPhis">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *simplePhiState) insertPhis()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insertVarPhis" data-name="insertVarPhis">
               <h3>
                  insertVarPhis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insertVarPhis" class="anchor" title="Link to insertVarPhis">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *phiState) insertVarPhis(n int, var_ ir.Node, defs []*ssa.Block, typ *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instrument" data-name="instrument">
               <h3>
                  instrument 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instrument" class="anchor" title="Link to instrument">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) instrument(t *types.Type, addr *ssa.Value, kind instrumentKind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instrument2" data-name="instrument2">
               <h3>
                  instrument2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instrument2" class="anchor" title="Link to instrument2">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) instrument2(t *types.Type, addr *ssa.Value, addr2 *ssa.Value, kind instrumentKind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instrumentFields" data-name="instrumentFields">
               <h3>
                  instrumentFields 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instrumentFields" class="anchor" title="Link to instrumentFields">#</a>
               </h3>
               
               <p>instrumentFields instruments a read/write operation on addr.
If it is instrumenting for MSAN or ASAN and t is a struct type, it instruments
operation for each field, instead of for the whole struct.</p>
               
               <pre><code class="language-go">func (s *state) instrumentFields(t *types.Type, addr *ssa.Value, kind instrumentKind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instrumentMove" data-name="instrumentMove">
               <h3>
                  instrumentMove 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instrumentMove" class="anchor" title="Link to instrumentMove">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) instrumentMove(t *types.Type, dst *ssa.Value, src *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intDivide" data-name="intDivide">
               <h3>
                  intDivide 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intDivide" class="anchor" title="Link to intDivide">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) intDivide(n ir.Node, a *ssa.Value, b *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intrinsicArgs" data-name="intrinsicArgs">
               <h3>
                  intrinsicArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intrinsicArgs" class="anchor" title="Link to intrinsicArgs">#</a>
               </h3>
               
               <p>intrinsicArgs extracts args from n, evaluates them to SSA values, and returns them.</p>
               
               <pre><code class="language-go">func (s *state) intrinsicArgs(n *ir.CallExpr) []*ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intrinsicCall" data-name="intrinsicCall">
               <h3>
                  intrinsicCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intrinsicCall" class="anchor" title="Link to intrinsicCall">#</a>
               </h3>
               
               <p>intrinsicCall converts a call to a recognized intrinsic function into the intrinsic SSA operation.</p>
               
               <pre><code class="language-go">func (s *state) intrinsicCall(n *ir.CallExpr) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="label" data-name="label">
               <h3>
                  label 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#label" class="anchor" title="Link to label">#</a>
               </h3>
               
               <p>label returns the label associated with sym, creating it if necessary.</p>
               
               <pre><code class="language-go">func (s *state) label(sym *types.Sym) *ssaLabel</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) load(t *types.Type, src *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup looks up the intrinsic for a pkg.fn on the specified architecture.</p>
               
               <pre><code class="language-go">func (ib intrinsicBuilders) lookup(arch *sys.Arch, pkg string, fn string) intrinsicBuilder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupVarOutgoing" data-name="lookupVarOutgoing">
               <h3>
                  lookupVarOutgoing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupVarOutgoing" class="anchor" title="Link to lookupVarOutgoing">#</a>
               </h3>
               
               <p>lookupVarOutgoing finds the variable's value at the end of block b.</p>
               
               <pre><code class="language-go">func (s *simplePhiState) lookupVarOutgoing(b *ssa.Block, t *types.Type, var_ ir.Node, line src.XPos) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeABIWrapper" data-name="makeABIWrapper">
               <h3>
                  makeABIWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#makeABIWrapper" class="anchor" title="Link to makeABIWrapper">#</a>
               </h3>
               
               <p>makeABIWrapper creates a new function that will be called with
wrapperABI and calls "f" using f.ABI.</p>
               
               <pre><code class="language-go">func makeABIWrapper(f *ir.Func, wrapperABI obj.ABI)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeNilCheckClosure" data-name="maybeNilCheckClosure">
               <h3>
                  maybeNilCheckClosure 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybeNilCheckClosure" class="anchor" title="Link to maybeNilCheckClosure">#</a>
               </h3>
               
               <p>maybeNilCheckClosure checks if a nil check of a closure is needed in some
architecture-dependent situations and, if so, emits the nil check.</p>
               
               <pre><code class="language-go">func (s *state) maybeNilCheckClosure(closure *ssa.Value, k callKind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mem" data-name="mem">
               <h3>
                  mem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mem" class="anchor" title="Link to mem">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) mem() *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minMax" data-name="minMax">
               <h3>
                  minMax 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#minMax" class="anchor" title="Link to minMax">#</a>
               </h3>
               
               <p>minMax converts an OMIN/OMAX builtin call into SSA.</p>
               
               <pre><code class="language-go">func (s *state) minMax(n *ir.CallExpr) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="move" data-name="move">
               <h3>
                  move 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#move" class="anchor" title="Link to move">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) move(t *types.Type, dst *ssa.Value, src *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moveWhichMayOverlap" data-name="moveWhichMayOverlap">
               <h3>
                  moveWhichMayOverlap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#moveWhichMayOverlap" class="anchor" title="Link to moveWhichMayOverlap">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) moveWhichMayOverlap(t *types.Type, dst *ssa.Value, src *ssa.Value, mayOverlap bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needAlloc" data-name="needAlloc">
               <h3>
                  needAlloc 
                  <span class="badge">function</span>
                  
                  <a href="#needAlloc" class="anchor" title="Link to needAlloc">#</a>
               </h3>
               
               <p>needAlloc reports whether n is within the current frame, for which we need to
allocate space. In particular, it excludes arguments and results, which are in
the callers frame.</p>
               
               <pre><code class="language-go">func needAlloc(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newHeapaddr" data-name="newHeapaddr">
               <h3>
                  newHeapaddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newHeapaddr" class="anchor" title="Link to newHeapaddr">#</a>
               </h3>
               
               <p>newHeapaddr allocates heap memory for n and sets its heap address.</p>
               
               <pre><code class="language-go">func (s *state) newHeapaddr(n *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newNowritebarrierrecChecker" data-name="newNowritebarrierrecChecker">
               <h3>
                  newNowritebarrierrecChecker 
                  <span class="badge">function</span>
                  
                  <a href="#newNowritebarrierrecChecker" class="anchor" title="Link to newNowritebarrierrecChecker">#</a>
               </h3>
               
               <p>newNowritebarrierrecChecker creates a nowritebarrierrecChecker. It
must be called before walk.</p>
               
               <pre><code class="language-go">func newNowritebarrierrecChecker() *nowritebarrierrecChecker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newObject" data-name="newObject">
               <h3>
                  newObject 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newObject" class="anchor" title="Link to newObject">#</a>
               </h3>
               
               <p>newObject returns an SSA value denoting new(typ).</p>
               
               <pre><code class="language-go">func (s *state) newObject(typ *types.Type, rtype *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newSparseSet" data-name="newSparseSet">
               <h3>
                  newSparseSet 
                  <span class="badge">function</span>
                  
                  <a href="#newSparseSet" class="anchor" title="Link to newSparseSet">#</a>
               </h3>
               
               <p>newSparseSet returns a sparseSet that can represent
integers between 0 and n-1.</p>
               
               <pre><code class="language-go">func newSparseSet(n int) *sparseSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue0" data-name="newValue0">
               <h3>
                  newValue0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue0" class="anchor" title="Link to newValue0">#</a>
               </h3>
               
               <p>newValue0 adds a new value with no arguments to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue0(op ssa.Op, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue0A" data-name="newValue0A">
               <h3>
                  newValue0A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue0A" class="anchor" title="Link to newValue0A">#</a>
               </h3>
               
               <p>newValue0A adds a new value with no arguments and an aux value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue0A(op ssa.Op, t *types.Type, aux ssa.Aux) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue0I" data-name="newValue0I">
               <h3>
                  newValue0I 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue0I" class="anchor" title="Link to newValue0I">#</a>
               </h3>
               
               <p>newValue0I adds a new value with no arguments and an auxint value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue0I(op ssa.Op, t *types.Type, auxint int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue1" data-name="newValue1">
               <h3>
                  newValue1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue1" class="anchor" title="Link to newValue1">#</a>
               </h3>
               
               <p>newValue1 adds a new value with one argument to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue1A" data-name="newValue1A">
               <h3>
                  newValue1A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue1A" class="anchor" title="Link to newValue1A">#</a>
               </h3>
               
               <p>newValue1A adds a new value with one argument and an aux value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue1A(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue1Apos" data-name="newValue1Apos">
               <h3>
                  newValue1Apos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue1Apos" class="anchor" title="Link to newValue1Apos">#</a>
               </h3>
               
               <p>newValue1Apos adds a new value with one argument and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
               
               <pre><code class="language-go">func (s *state) newValue1Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value, isStmt bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue1I" data-name="newValue1I">
               <h3>
                  newValue1I 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue1I" class="anchor" title="Link to newValue1I">#</a>
               </h3>
               
               <p>newValue1I adds a new value with one argument and an auxint value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue1I(op ssa.Op, t *types.Type, aux int64, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue2" data-name="newValue2">
               <h3>
                  newValue2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue2" class="anchor" title="Link to newValue2">#</a>
               </h3>
               
               <p>newValue2 adds a new value with two arguments to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue2A" data-name="newValue2A">
               <h3>
                  newValue2A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue2A" class="anchor" title="Link to newValue2A">#</a>
               </h3>
               
               <p>newValue2A adds a new value with two arguments and an aux value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue2A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue2Apos" data-name="newValue2Apos">
               <h3>
                  newValue2Apos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue2Apos" class="anchor" title="Link to newValue2Apos">#</a>
               </h3>
               
               <p>newValue2Apos adds a new value with two arguments and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
               
               <pre><code class="language-go">func (s *state) newValue2Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, isStmt bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue2I" data-name="newValue2I">
               <h3>
                  newValue2I 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue2I" class="anchor" title="Link to newValue2I">#</a>
               </h3>
               
               <p>newValue2I adds a new value with two arguments and an auxint value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue2I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue3" data-name="newValue3">
               <h3>
                  newValue3 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue3" class="anchor" title="Link to newValue3">#</a>
               </h3>
               
               <p>newValue3 adds a new value with three arguments to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue3(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue3A" data-name="newValue3A">
               <h3>
                  newValue3A 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue3A" class="anchor" title="Link to newValue3A">#</a>
               </h3>
               
               <p>newValue3A adds a new value with three arguments and an aux value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue3A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue3Apos" data-name="newValue3Apos">
               <h3>
                  newValue3Apos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue3Apos" class="anchor" title="Link to newValue3Apos">#</a>
               </h3>
               
               <p>newValue3Apos adds a new value with three arguments and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
               
               <pre><code class="language-go">func (s *state) newValue3Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, isStmt bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue3I" data-name="newValue3I">
               <h3>
                  newValue3I 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue3I" class="anchor" title="Link to newValue3I">#</a>
               </h3>
               
               <p>newValue3I adds a new value with three arguments and an auxint value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue3I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue4" data-name="newValue4">
               <h3>
                  newValue4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue4" class="anchor" title="Link to newValue4">#</a>
               </h3>
               
               <p>newValue4 adds a new value with four arguments to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue4(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, arg3 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValue4I" data-name="newValue4I">
               <h3>
                  newValue4I 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValue4I" class="anchor" title="Link to newValue4I">#</a>
               </h3>
               
               <p>newValue4I adds a new value with four arguments and an auxint value to the current block.</p>
               
               <pre><code class="language-go">func (s *state) newValue4I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, arg3 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValueOrSfCall1" data-name="newValueOrSfCall1">
               <h3>
                  newValueOrSfCall1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValueOrSfCall1" class="anchor" title="Link to newValueOrSfCall1">#</a>
               </h3>
               
               <p>newValueOrSfCall* are wrappers around newValue*, which may create a call to a
soft-float runtime function instead (when emitting soft-float code).</p>
               
               <pre><code class="language-go">func (s *state) newValueOrSfCall1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newValueOrSfCall2" data-name="newValueOrSfCall2">
               <h3>
                  newValueOrSfCall2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newValueOrSfCall2" class="anchor" title="Link to newValueOrSfCall2">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) newValueOrSfCall2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nilCheck" data-name="nilCheck">
               <h3>
                  nilCheck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nilCheck" class="anchor" title="Link to nilCheck">#</a>
               </h3>
               
               <p>nilCheck generates nil pointer checking code.
Used only for automatically inserted nil checks,
not for user code like 'x != nil'.
Returns a "definitely not nil" copy of x to ensure proper ordering
of the uses of the post-nilcheck pointer.</p>
               
               <pre><code class="language-go">func (s *state) nilCheck(ptr *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oneJump" data-name="oneJump">
               <h3>
                  oneJump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oneJump" class="anchor" title="Link to oneJump">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *State) oneJump(b *ssa.Block, jump *IndexJump)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDeferExit" data-name="openDeferExit">
               <h3>
                  openDeferExit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openDeferExit" class="anchor" title="Link to openDeferExit">#</a>
               </h3>
               
               <p>openDeferExit generates SSA for processing all the open coded defers at exit.
The code involves loading deferBits, and checking each of the bits to see if
the corresponding defer statement was executed. For each bit that is turned
on, the associated defer call is made.</p>
               
               <pre><code class="language-go">func (s *state) openDeferExit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDeferRecord" data-name="openDeferRecord">
               <h3>
                  openDeferRecord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openDeferRecord" class="anchor" title="Link to openDeferRecord">#</a>
               </h3>
               
               <p>openDeferRecord adds code to evaluate and store the function for an open-code defer
call, and records info about the defer, so we can generate proper code on the
exit paths. n is the sub-node of the defer node that is the actual function
call. We will also record funcdata information on where the function is stored
(as well as the deferBits variable), and this will enable us to run the proper
defer calls during panics.</p>
               
               <pre><code class="language-go">func (s *state) openDeferRecord(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDeferSave" data-name="openDeferSave">
               <h3>
                  openDeferSave 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openDeferSave" class="anchor" title="Link to openDeferSave">#</a>
               </h3>
               
               <p>openDeferSave generates SSA nodes to store a value (with type t) for an
open-coded defer at an explicit autotmp location on the stack, so it can be
reloaded and used for the appropriate call on exit. Type t must be a function type
(therefore SSAable). val is the value to be stored. The function returns an SSA
value representing a pointer to the autotmp location.</p>
               
               <pre><code class="language-go">func (s *state) openDeferSave(t *types.Type, val *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="paramsToHeap" data-name="paramsToHeap">
               <h3>
                  paramsToHeap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#paramsToHeap" class="anchor" title="Link to paramsToHeap">#</a>
               </h3>
               
               <p>paramsToHeap produces code to allocate memory for heap-escaped parameters
and to copy non-result parameters' values from the stack.</p>
               
               <pre><code class="language-go">func (s *state) paramsToHeap()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="paramsToWasmFields" data-name="paramsToWasmFields">
               <h3>
                  paramsToWasmFields 
                  <span class="badge">function</span>
                  
                  <a href="#paramsToWasmFields" class="anchor" title="Link to paramsToWasmFields">#</a>
               </h3>
               
               <pre><code class="language-go">func paramsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekPos" data-name="peekPos">
               <h3>
                  peekPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekPos" class="anchor" title="Link to peekPos">#</a>
               </h3>
               
               <p>peekPos peeks the top of the line number stack.</p>
               
               <pre><code class="language-go">func (s *state) peekPos() src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popLine" data-name="popLine">
               <h3>
                  popLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popLine" class="anchor" title="Link to popLine">#</a>
               </h3>
               
               <p>popLine pops the top of the line number stack.</p>
               
               <pre><code class="language-go">func (s *state) popLine()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushLine" data-name="pushLine">
               <h3>
                  pushLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushLine" class="anchor" title="Link to pushLine">#</a>
               </h3>
               
               <p>pushLine pushes a line number on the line number stack.</p>
               
               <pre><code class="language-go">func (s *state) pushLine(line src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putArg" data-name="putArg">
               <h3>
                  putArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putArg" class="anchor" title="Link to putArg">#</a>
               </h3>
               
               <p>putArg evaluates n for the purpose of passing it as an argument to a function and returns the value for the call.</p>
               
               <pre><code class="language-go">func (s *state) putArg(n ir.Node, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rawLoad" data-name="rawLoad">
               <h3>
                  rawLoad 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rawLoad" class="anchor" title="Link to rawLoad">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) rawLoad(t *types.Type, src *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFuncLines" data-name="readFuncLines">
               <h3>
                  readFuncLines 
                  <span class="badge">function</span>
                  
                  <a href="#readFuncLines" class="anchor" title="Link to readFuncLines">#</a>
               </h3>
               
               <pre><code class="language-go">func readFuncLines(file string, start uint, end uint) (*ssa.FuncLines, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordCall" data-name="recordCall">
               <h3>
                  recordCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordCall" class="anchor" title="Link to recordCall">#</a>
               </h3>
               
               <p>recordCall records a call from ODCLFUNC node "from", to function
symbol "to" at position pos.
This should be done as late as possible during compilation to
capture precise call graphs. The target of the call is an LSym
because that's all we know after we start SSA.
This can be called concurrently for different from Nodes.</p>
               
               <pre><code class="language-go">func (c *nowritebarrierrecChecker) recordCall(fn *ir.Func, to *obj.LSym, pos src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="referenceTypeBuiltin" data-name="referenceTypeBuiltin">
               <h3>
                  referenceTypeBuiltin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#referenceTypeBuiltin" class="anchor" title="Link to referenceTypeBuiltin">#</a>
               </h3>
               
               <p>referenceTypeBuiltin generates code for the len/cap builtins for maps and channels.</p>
               
               <pre><code class="language-go">func (s *state) referenceTypeBuiltin(n *ir.UnaryExpr, x *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reflectType" data-name="reflectType">
               <h3>
                  reflectType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reflectType" class="anchor" title="Link to reflectType">#</a>
               </h3>
               
               <p>reflectType returns an SSA value representing a pointer to typ's
reflection type descriptor.</p>
               
               <pre><code class="language-go">func (s *state) reflectType(typ *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveFwdRefs" data-name="resolveFwdRefs">
               <h3>
                  resolveFwdRefs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resolveFwdRefs" class="anchor" title="Link to resolveFwdRefs">#</a>
               </h3>
               
               <p>resolveFwdRefs links all FwdRef uses up to their nearest dominating definition.</p>
               
               <pre><code class="language-go">func (s *phiState) resolveFwdRefs()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resultAddrOfCall" data-name="resultAddrOfCall">
               <h3>
                  resultAddrOfCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resultAddrOfCall" class="anchor" title="Link to resultAddrOfCall">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) resultAddrOfCall(c *ssa.Value, which int64, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resultOfCall" data-name="resultOfCall">
               <h3>
                  resultOfCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resultOfCall" class="anchor" title="Link to resultOfCall">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) resultOfCall(c *ssa.Value, which int64, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resultsToWasmFields" data-name="resultsToWasmFields">
               <h3>
                  resultsToWasmFields 
                  <span class="badge">function</span>
                  
                  <a href="#resultsToWasmFields" class="anchor" title="Link to resultsToWasmFields">#</a>
               </h3>
               
               <pre><code class="language-go">func resultsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtcall" data-name="rtcall">
               <h3>
                  rtcall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtcall" class="anchor" title="Link to rtcall">#</a>
               </h3>
               
               <p>rtcall issues a call to the given runtime function fn with the listed args.
Returns a slice of results of the given result types.
The call is added to the end of the current block.
If returns is false, the block is marked as an exit block.</p>
               
               <pre><code class="language-go">func (s *state) rtcall(fn *obj.LSym, returns bool, results []*types.Type, args ...*ssa.Value) []*ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setHeapaddr" data-name="setHeapaddr">
               <h3>
                  setHeapaddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setHeapaddr" class="anchor" title="Link to setHeapaddr">#</a>
               </h3>
               
               <p>setHeapaddr allocates a new PAUTO variable to store ptr (which must be non-nil)
and then sets it as n's heap address.</p>
               
               <pre><code class="language-go">func (s *state) setHeapaddr(pos src.XPos, n *ir.Name, ptr *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupWasmExport" data-name="setupWasmExport">
               <h3>
                  setupWasmExport 
                  <span class="badge">function</span>
                  
                  <a href="#setupWasmExport" class="anchor" title="Link to setupWasmExport">#</a>
               </h3>
               
               <p>setupWasmExport calculates the params and results in terms of WebAssembly values for the given function,
and sets up the wasmexport metadata.</p>
               
               <pre><code class="language-go">func setupWasmExport(f *ir.Func, wrapped *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupWasmImport" data-name="setupWasmImport">
               <h3>
                  setupWasmImport 
                  <span class="badge">function</span>
                  
                  <a href="#setupWasmImport" class="anchor" title="Link to setupWasmImport">#</a>
               </h3>
               
               <p>setupWasmImport calculates the params and results in terms of WebAssembly values for the given function,
and sets up the wasmimport metadata.</p>
               
               <pre><code class="language-go">func setupWasmImport(f *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sfcall" data-name="sfcall">
               <h3>
                  sfcall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sfcall" class="anchor" title="Link to sfcall">#</a>
               </h3>
               
               <p>TODO: do not emit sfcall if operation can be optimized to constant in later
opt phase</p>
               
               <pre><code class="language-go">func (s *state) sfcall(op ssa.Op, args ...*ssa.Value) (*ssa.Value, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="slice" data-name="slice">
               <h3>
                  slice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#slice" class="anchor" title="Link to slice">#</a>
               </h3>
               
               <p>slice computes the slice v[i:j:k] and returns ptr, len, and cap of result.
i,j,k may be nil, in which case they are set to their default value.
v may be a slice, string or pointer to an array.</p>
               
               <pre><code class="language-go">func (s *state) slice(v *ssa.Value, i *ssa.Value, j *ssa.Value, k *ssa.Value, bounded bool) (p *ssa.Value, l *ssa.Value, c *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="softfloatInit" data-name="softfloatInit">
               <h3>
                  softfloatInit 
                  <span class="badge">function</span>
                  
                  <a href="#softfloatInit" class="anchor" title="Link to softfloatInit">#</a>
               </h3>
               
               <pre><code class="language-go">func softfloatInit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="split" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#split" class="anchor" title="Link to split">#</a>
               </h3>
               
               <p>split breaks up a tuple-typed value into its 2 parts.</p>
               
               <pre><code class="language-go">func (s *state) split(v *ssa.Value) (*ssa.Value, *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ssaMarker" data-name="ssaMarker">
               <h3>
                  ssaMarker 
                  <span class="badge">function</span>
                  
                  <a href="#ssaMarker" class="anchor" title="Link to ssaMarker">#</a>
               </h3>
               
               <pre><code class="language-go">func ssaMarker(name string) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ssaOp" data-name="ssaOp">
               <h3>
                  ssaOp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ssaOp" class="anchor" title="Link to ssaOp">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) ssaOp(op ir.Op, t *types.Type) ssa.Op</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ssaShiftOp" data-name="ssaShiftOp">
               <h3>
                  ssaShiftOp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ssaShiftOp" class="anchor" title="Link to ssaShiftOp">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) ssaShiftOp(op ir.Op, t *types.Type, u *types.Type) ssa.Op</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startBlock" data-name="startBlock">
               <h3>
                  startBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startBlock" class="anchor" title="Link to startBlock">#</a>
               </h3>
               
               <p>startBlock sets the current block we're generating code in to b.</p>
               
               <pre><code class="language-go">func (s *state) startBlock(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <p>stmt converts the statement n to SSA and adds it to s.</p>
               
               <pre><code class="language-go">func (s *state) stmt(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmtList" data-name="stmtList">
               <h3>
                  stmtList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmtList" class="anchor" title="Link to stmtList">#</a>
               </h3>
               
               <p>stmtList converts the statement list n to SSA and adds it to s.</p>
               
               <pre><code class="language-go">func (s *state) stmtList(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="store" data-name="store">
               <h3>
                  store 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#store" class="anchor" title="Link to store">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) store(t *types.Type, dst *ssa.Value, val *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeArgWithBase" data-name="storeArgWithBase">
               <h3>
                  storeArgWithBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#storeArgWithBase" class="anchor" title="Link to storeArgWithBase">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) storeArgWithBase(n ir.Node, t *types.Type, base *ssa.Value, off int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeParameterRegsToStack" data-name="storeParameterRegsToStack">
               <h3>
                  storeParameterRegsToStack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#storeParameterRegsToStack" class="anchor" title="Link to storeParameterRegsToStack">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) storeParameterRegsToStack(abi *abi.ABIConfig, paramAssignment *abi.ABIParamAssignment, n *ir.Name, addr *ssa.Value, pointersOnly bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeType" data-name="storeType">
               <h3>
                  storeType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#storeType" class="anchor" title="Link to storeType">#</a>
               </h3>
               
               <p>do *left = right for type t.</p>
               
               <pre><code class="language-go">func (s *state) storeType(t *types.Type, left *ssa.Value, right *ssa.Value, skip skipMask, leftIsStmt bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeTypePtrs" data-name="storeTypePtrs">
               <h3>
                  storeTypePtrs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#storeTypePtrs" class="anchor" title="Link to storeTypePtrs">#</a>
               </h3>
               
               <p>do *left = right for all pointer parts of t.</p>
               
               <pre><code class="language-go">func (s *state) storeTypePtrs(t *types.Type, left *ssa.Value, right *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeTypeScalars" data-name="storeTypeScalars">
               <h3>
                  storeTypeScalars 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#storeTypeScalars" class="anchor" title="Link to storeTypeScalars">#</a>
               </h3>
               
               <p>do *left = right for all scalar (non-pointer) parts of t.</p>
               
               <pre><code class="language-go">func (s *state) storeTypeScalars(t *types.Type, left *ssa.Value, right *ssa.Value, skip skipMask)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="temp" data-name="temp">
               <h3>
                  temp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#temp" class="anchor" title="Link to temp">#</a>
               </h3>
               
               <p>temp allocates a temp of type t at position pos</p>
               
               <pre><code class="language-go">func (s *state) temp(pos src.XPos, t *types.Type) (*ir.Name, *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ternary" data-name="ternary">
               <h3>
                  ternary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ternary" class="anchor" title="Link to ternary">#</a>
               </h3>
               
               <p>ternary emits code to evaluate cond ? x : y.</p>
               
               <pre><code class="language-go">func (s *state) ternary(cond *ssa.Value, x *ssa.Value, y *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint32Tofloat" data-name="uint32Tofloat">
               <h3>
                  uint32Tofloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint32Tofloat" class="anchor" title="Link to uint32Tofloat">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uint32Tofloat(cvttab *u322fcvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint32Tofloat32" data-name="uint32Tofloat32">
               <h3>
                  uint32Tofloat32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint32Tofloat32" class="anchor" title="Link to uint32Tofloat32">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uint32Tofloat32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint32Tofloat64" data-name="uint32Tofloat64">
               <h3>
                  uint32Tofloat64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint32Tofloat64" class="anchor" title="Link to uint32Tofloat64">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uint32Tofloat64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint64Tofloat" data-name="uint64Tofloat">
               <h3>
                  uint64Tofloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint64Tofloat" class="anchor" title="Link to uint64Tofloat">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uint64Tofloat(cvttab *u642fcvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint64Tofloat32" data-name="uint64Tofloat32">
               <h3>
                  uint64Tofloat32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint64Tofloat32" class="anchor" title="Link to uint64Tofloat32">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uint64Tofloat32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint64Tofloat64" data-name="uint64Tofloat64">
               <h3>
                  uint64Tofloat64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint64Tofloat64" class="anchor" title="Link to uint64Tofloat64">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uint64Tofloat64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uintptrConstant" data-name="uintptrConstant">
               <h3>
                  uintptrConstant 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uintptrConstant" class="anchor" title="Link to uintptrConstant">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) uintptrConstant(v uint64) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateUnsetPredPos" data-name="updateUnsetPredPos">
               <h3>
                  updateUnsetPredPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateUnsetPredPos" class="anchor" title="Link to updateUnsetPredPos">#</a>
               </h3>
               
               <p>updateUnsetPredPos propagates the earliest-value position information for b
towards all of b's predecessors that need a position, and recurs on that
predecessor if its position is updated. B should have a non-empty position.</p>
               
               <pre><code class="language-go">func (s *state) updateUnsetPredPos(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="variable" data-name="variable">
               <h3>
                  variable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#variable" class="anchor" title="Link to variable">#</a>
               </h3>
               
               <p>variable returns the value of a variable at the current location.</p>
               
               <pre><code class="language-go">func (s *state) variable(n ir.Node, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wasmElemTypeAllowed" data-name="wasmElemTypeAllowed">
               <h3>
                  wasmElemTypeAllowed 
                  <span class="badge">function</span>
                  
                  <a href="#wasmElemTypeAllowed" class="anchor" title="Link to wasmElemTypeAllowed">#</a>
               </h3>
               
               <p>wasmElemTypeAllowed reports whether t is allowed to be passed in memory
(as a pointer's element type, a field of it, etc.) between the Go wasm
module and the host.</p>
               
               <pre><code class="language-go">func wasmElemTypeAllowed(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="weakenGlobalMapInitRelocs" data-name="weakenGlobalMapInitRelocs">
               <h3>
                  weakenGlobalMapInitRelocs 
                  <span class="badge">function</span>
                  
                  <a href="#weakenGlobalMapInitRelocs" class="anchor" title="Link to weakenGlobalMapInitRelocs">#</a>
               </h3>
               
               <p>weakenGlobalMapInitRelocs walks through all of the relocations on a
given a package init function "fn" and looks for relocs that target
outlined global map initializer functions; if it finds any such
relocs, it flags them as R_WEAK.</p>
               
               <pre><code class="language-go">func weakenGlobalMapInitRelocs(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="zero" data-name="zero">
               <h3>
                  zero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#zero" class="anchor" title="Link to zero">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *state) zero(t *types.Type, dst *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="zeroResults" data-name="zeroResults">
               <h3>
                  zeroResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#zeroResults" class="anchor" title="Link to zeroResults">#</a>
               </h3>
               
               <p>zeroResults zeros the return values at the start of the function.
We need to do this very early in the function.  Defer might stop a
panic and show the return values as they exist at the time of
panic.  For precise stacks, the garbage collector assumes results
are always live, so we need to zero them before any allocations,
even allocations to move params/results to the heap.</p>
               
               <pre><code class="language-go">func (s *state) zeroResults()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="zeroVal" data-name="zeroVal">
               <h3>
                  zeroVal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#zeroVal" class="anchor" title="Link to zeroVal">#</a>
               </h3>
               
               <p>zeroVal returns the zero value for type t.</p>
               
               <pre><code class="language-go">func (s *state) zeroVal(t *types.Type) *ssa.Value</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>