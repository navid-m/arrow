<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ssagen</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>ssagen</code>
         </h1>
         <hr />
         
         <article class="global" data-name="Arch">
            <h2>Arch</h2>
            <hr />
            
            <pre><code>Arch ArchInfo</code></pre>
         </article>
         
         <article class="global" data-name="intrinsics">
            <h2>intrinsics</h2>
            <hr />
            
            <pre><code>intrinsics intrinsicBuilders</code></pre>
         </article>
         
         <article class="global" data-name="updateIntrinsics">
            <h2>updateIntrinsics</h2>
            <hr />
            
            <pre><code>updateIntrinsics</code></pre>
         </article>
         
         <article class="global" data-name="wantIntrinsics">
            <h2>wantIntrinsics</h2>
            <hr />
            
            <pre><code>wantIntrinsics</code></pre>
         </article>
         
         <article class="global" data-name="nowritebarrierrecCheck">
            <h2>nowritebarrierrecCheck</h2>
            <hr />
            
            <pre><code>nowritebarrierrecCheck *nowritebarrierrecChecker</code></pre>
         </article>
         
         <article class="global" data-name="maxStackSize">
            <h2>maxStackSize</h2>
            <hr />
            
            <pre><code>maxStackSize</code></pre>
         </article>
         
         <article class="global" data-name="globalMapInitLsyms">
            <h2>globalMapInitLsyms</h2>
            <hr />
            
            <p>globalMapInitLsyms records the LSym of each map.init.NNN outlined
map initializer function created by the compiler.</p>
            
            <pre><code>globalMapInitLsyms *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="largeStackFramesMu">
            <h2>largeStackFramesMu</h2>
            <hr />
            
            <pre><code>largeStackFramesMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="largeStackFrames">
            <h2>largeStackFrames</h2>
            <hr />
            
            <pre><code>largeStackFrames []largeStack</code></pre>
         </article>
         
         <article class="global" data-name="smallBlocks">
            <h2>smallBlocks</h2>
            <hr />
            
            <pre><code>smallBlocks</code></pre>
         </article>
         
         <article class="global" data-name="debugPhi">
            <h2>debugPhi</h2>
            <hr />
            
            <pre><code>debugPhi</code></pre>
         </article>
         
         <article class="global" data-name="ssaConfig">
            <h2>ssaConfig</h2>
            <hr />
            
            <pre><code>ssaConfig *ssa.Config</code></pre>
         </article>
         
         <article class="global" data-name="ssaCaches">
            <h2>ssaCaches</h2>
            <hr />
            
            <pre><code>ssaCaches []ssa.Cache</code></pre>
         </article>
         
         <article class="global" data-name="ssaDump">
            <h2>ssaDump</h2>
            <hr />
            
            <pre><code>ssaDump string</code></pre>
         </article>
         
         <article class="global" data-name="ssaDir">
            <h2>ssaDir</h2>
            <hr />
            
            <pre><code>ssaDir string</code></pre>
         </article>
         
         <article class="global" data-name="ssaDumpStdout">
            <h2>ssaDumpStdout</h2>
            <hr />
            
            <pre><code>ssaDumpStdout bool</code></pre>
         </article>
         
         <article class="global" data-name="ssaDumpCFG">
            <h2>ssaDumpCFG</h2>
            <hr />
            
            <pre><code>ssaDumpCFG string</code></pre>
         </article>
         
         <article class="global" data-name="ssaDumpFile">
            <h2>ssaDumpFile</h2>
            <hr />
            
            <pre><code>ssaDumpFile</code></pre>
         </article>
         
         <article class="global" data-name="ssaDumpInlined">
            <h2>ssaDumpInlined</h2>
            <hr />
            
            <p>ssaDumpInlined holds all inlined functions when ssaDump contains a function name.</p>
            
            <pre><code>ssaDumpInlined []*ir.Func</code></pre>
         </article>
         
         <article class="global" data-name="memVar">
            <h2>memVar</h2>
            <hr />
            
            <p>marker node for the memory variable</p>
            
            <pre><code>memVar</code></pre>
         </article>
         
         <article class="global" data-name="ptrVar">
            <h2>ptrVar</h2>
            <hr />
            
            <p>marker nodes for temporary variables</p>
            
            <pre><code>ptrVar</code></pre>
         </article>
         
         <article class="global" data-name="lenVar">
            <h2>lenVar</h2>
            <hr />
            
            <pre><code>lenVar</code></pre>
         </article>
         
         <article class="global" data-name="capVar">
            <h2>capVar</h2>
            <hr />
            
            <pre><code>capVar</code></pre>
         </article>
         
         <article class="global" data-name="typVar">
            <h2>typVar</h2>
            <hr />
            
            <pre><code>typVar</code></pre>
         </article>
         
         <article class="global" data-name="okVar">
            <h2>okVar</h2>
            <hr />
            
            <pre><code>okVar</code></pre>
         </article>
         
         <article class="global" data-name="deferBitsVar">
            <h2>deferBitsVar</h2>
            <hr />
            
            <pre><code>deferBitsVar</code></pre>
         </article>
         
         <article class="global" data-name="hashVar">
            <h2>hashVar</h2>
            <hr />
            
            <pre><code>hashVar</code></pre>
         </article>
         
         <article class="global" data-name="instrumentRead">
            <h2>instrumentRead</h2>
            <hr />
            
            <pre><code>instrumentRead</code></pre>
         </article>
         
         <article class="global" data-name="instrumentWrite">
            <h2>instrumentWrite</h2>
            <hr />
            
            <pre><code>instrumentWrite</code></pre>
         </article>
         
         <article class="global" data-name="instrumentMove">
            <h2>instrumentMove</h2>
            <hr />
            
            <pre><code>instrumentMove</code></pre>
         </article>
         
         <article class="global" data-name="shareDeferExits">
            <h2>shareDeferExits</h2>
            <hr />
            
            <p>If true, share as many open-coded defer exits as possible (with the downside of
worse line-number information)</p>
            
            <pre><code>shareDeferExits</code></pre>
         </article>
         
         <article class="global" data-name="opToSSA">
            <h2>opToSSA</h2>
            <hr />
            
            <pre><code>opToSSA</code></pre>
         </article>
         
         <article class="global" data-name="fpConvOpToSSA">
            <h2>fpConvOpToSSA</h2>
            <hr />
            
            <pre><code>fpConvOpToSSA</code></pre>
         </article>
         
         <article class="global" data-name="fpConvOpToSSA32">
            <h2>fpConvOpToSSA32</h2>
            <hr />
            
            <p>this map is used only for 32-bit arch, and only includes the difference
on 32-bit arch, don't use int64<->float conversion for uint32</p>
            
            <pre><code>fpConvOpToSSA32</code></pre>
         </article>
         
         <article class="global" data-name="uint64fpConvOpToSSA">
            <h2>uint64fpConvOpToSSA</h2>
            <hr />
            
            <p>uint64<->float conversions, only on machines that have instructions for that</p>
            
            <pre><code>uint64fpConvOpToSSA</code></pre>
         </article>
         
         <article class="global" data-name="shiftOpToSSA">
            <h2>shiftOpToSSA</h2>
            <hr />
            
            <pre><code>shiftOpToSSA</code></pre>
         </article>
         
         <article class="global" data-name="skipPtr">
            <h2>skipPtr</h2>
            <hr />
            
            <pre><code>skipPtr skipMask</code></pre>
         </article>
         
         <article class="global" data-name="skipLen">
            <h2>skipLen</h2>
            <hr />
            
            <pre><code>skipLen</code></pre>
         </article>
         
         <article class="global" data-name="skipCap">
            <h2>skipCap</h2>
            <hr />
            
            <pre><code>skipCap</code></pre>
         </article>
         
         <article class="global" data-name="callNormal">
            <h2>callNormal</h2>
            <hr />
            
            <pre><code>callNormal callKind</code></pre>
         </article>
         
         <article class="global" data-name="callDefer">
            <h2>callDefer</h2>
            <hr />
            
            <pre><code>callDefer</code></pre>
         </article>
         
         <article class="global" data-name="callDeferStack">
            <h2>callDeferStack</h2>
            <hr />
            
            <pre><code>callDeferStack</code></pre>
         </article>
         
         <article class="global" data-name="callGo">
            <h2>callGo</h2>
            <hr />
            
            <pre><code>callGo</code></pre>
         </article>
         
         <article class="global" data-name="callTail">
            <h2>callTail</h2>
            <hr />
            
            <pre><code>callTail</code></pre>
         </article>
         
         <article class="global" data-name="softFloatOps">
            <h2>softFloatOps</h2>
            <hr />
            
            <pre><code>softFloatOps *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="u64_f64">
            <h2>u64_f64</h2>
            <hr />
            
            <pre><code>u64_f64</code></pre>
         </article>
         
         <article class="global" data-name="u64_f32">
            <h2>u64_f32</h2>
            <hr />
            
            <pre><code>u64_f32</code></pre>
         </article>
         
         <article class="global" data-name="u32_f64">
            <h2>u32_f64</h2>
            <hr />
            
            <pre><code>u32_f64</code></pre>
         </article>
         
         <article class="global" data-name="u32_f32">
            <h2>u32_f32</h2>
            <hr />
            
            <pre><code>u32_f32</code></pre>
         </article>
         
         <article class="global" data-name="f32_u64">
            <h2>f32_u64</h2>
            <hr />
            
            <pre><code>f32_u64</code></pre>
         </article>
         
         <article class="global" data-name="f64_u64">
            <h2>f64_u64</h2>
            <hr />
            
            <pre><code>f64_u64</code></pre>
         </article>
         
         <article class="global" data-name="f32_u32">
            <h2>f32_u32</h2>
            <hr />
            
            <pre><code>f32_u32</code></pre>
         </article>
         
         <article class="global" data-name="f64_u32">
            <h2>f64_u32</h2>
            <hr />
            
            <pre><code>f64_u32</code></pre>
         </article>
         
         <article class="global" data-name="deferStructFnField">
            <h2>deferStructFnField</h2>
            <hr />
            
            <p>deferStructFnField is the field index of _defer.fn.</p>
            
            <pre><code>deferStructFnField</code></pre>
         </article>
         
         <article class="global" data-name="deferType">
            <h2>deferType</h2>
            <hr />
            
            <pre><code>deferType *types.Type</code></pre>
         </article>
         
         <article class="global" data-name="BoundsCheckFunc">
            <h2>BoundsCheckFunc</h2>
            <hr />
            
            <pre><code>BoundsCheckFunc []*obj.LSym</code></pre>
         </article>
         
         <article class="global" data-name="ExtendCheckFunc">
            <h2>ExtendCheckFunc</h2>
            <hr />
            
            <pre><code>ExtendCheckFunc []*obj.LSym</code></pre>
         </article>
          
         <article class="struct" data-name="ArchInfo">
            <h2>type ArchInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">LinkArch *obj.LinkArch
REGSP int
MAXWIDTH int64
SoftFloat bool
PadFrame func
ZeroRange func
Ginsnop func
SSAMarkMoves func
SSAGenValue func
SSAGenBlock func
LoadRegResult func
SpillArgReg func</code></pre>
         </article>
         
         <article class="struct" data-name="intrinsicKey">
            <h2>type intrinsicKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">arch *sys.Arch
pkg string
fn string</code></pre>
         </article>
         
         <article class="struct" data-name="intrinsicBuildConfig">
            <h2>type intrinsicBuildConfig struct</h2>
            <hr />
            
            <p>intrinsicBuildConfig specifies the config to use for intrinsic building.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">instrumenting bool
go386 string
goamd64 int
goarm buildcfg.GoarmFeatures
goarm64 buildcfg.Goarm64Features
gomips string
gomips64 string
goppc64 int
goriscv64 int</code></pre>
         </article>
         
         <article class="struct" data-name="testIntrinsicKey">
            <h2>type testIntrinsicKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">archName string
pkg string
fn string</code></pre>
         </article>
         
         <article class="struct" data-name="nowritebarrierrecChecker">
            <h2>type nowritebarrierrecChecker struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">extraCalls *ast.MapType
curfn *ir.Func</code></pre>
         </article>
         
         <article class="struct" data-name="nowritebarrierrecCall">
            <h2>type nowritebarrierrecCall struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">target *ir.Func
lineno src.XPos</code></pre>
         </article>
         
         <article class="struct" data-name="largeStack">
            <h2>type largeStack struct</h2>
            <hr />
            
            <p>largeStack is info about a function whose stack frame is too large (rare).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">locals int64
args int64
callee int64
pos src.XPos</code></pre>
         </article>
         
         <article class="struct" data-name="fwdRefAux">
            <h2>type fwdRefAux struct</h2>
            <hr />
            
            <p>fwdRefAux wraps an arbitrary ir.Node as an ssa.Aux for use with OpFwdref.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">_ []func
N ir.Node</code></pre>
         </article>
         
         <article class="struct" data-name="phiState">
            <h2>type phiState struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s *state
f *ssa.Func
defvars []*ast.MapType
varnum *ast.MapType
idom []*ssa.Block
tree []domBlock
level []int32
priq blockHeap
q []*ssa.Block
queued *sparseSet
hasPhi *sparseSet
hasDef *sparseSet
placeholder *ssa.Value</code></pre>
         </article>
         
         <article class="struct" data-name="domBlock">
            <h2>type domBlock struct</h2>
            <hr />
            
            <p>domBlock contains extra per-block information to record the dominator tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">firstChild *ssa.Block
sibling *ssa.Block</code></pre>
         </article>
         
         <article class="struct" data-name="blockHeap">
            <h2>type blockHeap struct</h2>
            <hr />
            
            <p>A block heap is used as a priority queue to implement the PiggyBank
from Sreedhar and Gao.  That paper uses an array which is better
asymptotically but worse in the common case when the PiggyBank
holds a sparse set of blocks.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">a []*ssa.Block
level []int32</code></pre>
         </article>
         
         <article class="struct" data-name="sparseSet">
            <h2>type sparseSet struct</h2>
            <hr />
            
            <p>copy of ../ssa/sparseset.go
TODO: move this file to ../ssa, then use sparseSet there.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dense []ssa.ID
sparse []int32</code></pre>
         </article>
         
         <article class="struct" data-name="simplePhiState">
            <h2>type simplePhiState struct</h2>
            <hr />
            
            <p>Variant to use for small functions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">s *state
f *ssa.Func
fwdrefs []*ssa.Value
defvars []*ast.MapType
reachable []bool</code></pre>
         </article>
         
         <article class="struct" data-name="openDeferInfo">
            <h2>type openDeferInfo struct</h2>
            <hr />
            
            <p>Information about each open-coded defer.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">n *ir.CallExpr
closure *ssa.Value
closureNode *ir.Name</code></pre>
         </article>
         
         <article class="struct" data-name="state">
            <h2>type state struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">config *ssa.Config
f *ssa.Func
curfn *ir.Func
labels *ast.MapType
breakTo *ssa.Block
continueTo *ssa.Block
curBlock *ssa.Block
vars *ast.MapType
fwdVars *ast.MapType
defvars []*ast.MapType
decladdrs *ast.MapType
startmem *ssa.Value
sp *ssa.Value
sb *ssa.Value
deferBitsAddr *ssa.Value
deferBitsTemp *ir.Name
line []src.XPos
lastPos src.XPos
panics *ast.MapType
cgoUnsafeArgs bool
hasdefer bool
softFloat bool
hasOpenDefers bool
checkPtrEnabled bool
instrumentEnterExit bool
instrumentMemory bool
openDefers []*openDeferInfo
lastDeferExit *ssa.Block
lastDeferFinalBlock *ssa.Block
lastDeferCount int
prevCall *ssa.Value</code></pre>
         </article>
         
         <article class="struct" data-name="funcLine">
            <h2>type funcLine struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">f *obj.LSym
base *src.PosBase
line uint</code></pre>
         </article>
         
         <article class="struct" data-name="ssaLabel">
            <h2>type ssaLabel struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">target *ssa.Block
breakTarget *ssa.Block
continueTarget *ssa.Block</code></pre>
         </article>
         
         <article class="struct" data-name="opAndType">
            <h2>type opAndType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">op ir.Op
etype types.Kind</code></pre>
         </article>
         
         <article class="struct" data-name="opAndTwoTypes">
            <h2>type opAndTwoTypes struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">op ir.Op
etype1 types.Kind
etype2 types.Kind</code></pre>
         </article>
         
         <article class="struct" data-name="twoTypes">
            <h2>type twoTypes struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">etype1 types.Kind
etype2 types.Kind</code></pre>
         </article>
         
         <article class="struct" data-name="twoOpsAndType">
            <h2>type twoOpsAndType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">op1 ssa.Op
op2 ssa.Op
intermediateType types.Kind</code></pre>
         </article>
         
         <article class="struct" data-name="sfRtCallDef">
            <h2>type sfRtCallDef struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rtfn *obj.LSym
rtype types.Kind</code></pre>
         </article>
         
         <article class="struct" data-name="u642fcvtTab">
            <h2>type u642fcvtTab struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">leq ssa.Op
cvt2F ssa.Op
and ssa.Op
rsh ssa.Op
or ssa.Op
add ssa.Op
one func</code></pre>
         </article>
         
         <article class="struct" data-name="u322fcvtTab">
            <h2>type u322fcvtTab struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">cvtI2F ssa.Op
cvtF2F ssa.Op</code></pre>
         </article>
         
         <article class="struct" data-name="f2uCvtTab">
            <h2>type f2uCvtTab struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ltf ssa.Op
cvt2U ssa.Op
subf ssa.Op
or ssa.Op
floatValue func
intValue func
cutoff uint64</code></pre>
         </article>
         
         <article class="struct" data-name="Branch">
            <h2>type Branch struct</h2>
            <hr />
            
            <p>Branch is an unresolved branch.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">P *obj.Prog
B *ssa.Block</code></pre>
         </article>
         
         <article class="struct" data-name="State">
            <h2>type State struct</h2>
            <hr />
            
            <p>State contains state needed during Prog generation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ABI obj.ABI
pp *objw.Progs
Branches []Branch
JumpTables []*ssa.Block
bstart []*obj.Prog
maxarg int64
livenessMap liveness.Map
partLiveArgs *ast.MapType
lineRunStart *obj.Prog
OnWasmStackSkipped int</code></pre>
         </article>
         
         <article class="struct" data-name="IndexJump">
            <h2>type IndexJump struct</h2>
            <hr />
            
            <p>For generating consecutive jump instructions to model a specific branching</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Jump obj.As
Index int</code></pre>
         </article>
         
         <article class="struct" data-name="ssafn">
            <h2>type ssafn struct</h2>
            <hr />
            
            <p>ssafn holds frontend information about a function that the backend is processing.
It also exports a bunch of compiler services for the ssa backend.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">curfn *ir.Func
strings *ast.MapType
stksize int64
stkptrsize int64
stkalign int64
log bool</code></pre>
         </article>
         
         <article class="struct" data-name="SymABIs">
            <h2>type SymABIs struct</h2>
            <hr />
            
            <p>SymABIs records information provided by the assembler about symbol
definition ABIs and reference ABIs.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">defs *ast.MapType
refs *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add adds the intrinsic builder b for pkg.fn for the given architecture.</p>
            
            <pre><code>func add(arch *sys.Arch, pkg string, fn string, b intrinsicBuilder)</code></pre>
         </article>
         
         <article class="function" data-name="addForArchs">
            <h2>addForArchs</h2>
            <hr />
            
            <p>addForArchs adds the intrinsic builder b for pkg.fn for the given architectures.</p>
            
            <pre><code>func addForArchs(pkg string, fn string, b intrinsicBuilder, archs ...*sys.Arch)</code></pre>
         </article>
         
         <article class="function" data-name="addForFamilies">
            <h2>addForFamilies</h2>
            <hr />
            
            <p>addForFamilies does the same as addForArchs but operates on architecture families.</p>
            
            <pre><code>func addForFamilies(pkg string, fn string, b intrinsicBuilder, archFamilies ...sys.ArchFamily)</code></pre>
         </article>
         
         <article class="function" data-name="alias">
            <h2>alias</h2>
            <hr />
            
            <p>alias aliases pkg.fn to targetPkg.targetFn for all architectures in archs
for which targetPkg.targetFn already exists.</p>
            
            <pre><code>func alias(pkg string, fn string, targetPkg string, targetFn string, archs ...*sys.Arch)</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup looks up the intrinsic for a pkg.fn on the specified architecture.</p>
            
            <pre><code>func lookup(arch *sys.Arch, pkg string, fn string) intrinsicBuilder</code></pre>
         </article>
         
         <article class="function" data-name="initIntrinsics">
            <h2>initIntrinsics</h2>
            <hr />
            
            <pre><code>func initIntrinsics(cfg *intrinsicBuildConfig)</code></pre>
         </article>
         
         <article class="function" data-name="findIntrinsic">
            <h2>findIntrinsic</h2>
            <hr />
            
            <p>findIntrinsic returns a function which builds the SSA equivalent of the
function identified by the symbol sym.  If sym is not an intrinsic call, returns nil.</p>
            
            <pre><code>func findIntrinsic(sym *types.Sym) intrinsicBuilder</code></pre>
         </article>
         
         <article class="function" data-name="IsIntrinsicCall">
            <h2>IsIntrinsicCall</h2>
            <hr />
            
            <pre><code>func IsIntrinsicCall(n *ir.CallExpr) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestIntrinsics">
            <h2>TestIntrinsics</h2>
            <hr />
            
            <pre><code>func TestIntrinsics(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIntrinsicBuilders">
            <h2>TestIntrinsicBuilders</h2>
            <hr />
            
            <pre><code>func TestIntrinsicBuilders(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="EnableNoWriteBarrierRecCheck">
            <h2>EnableNoWriteBarrierRecCheck</h2>
            <hr />
            
            <pre><code>func EnableNoWriteBarrierRecCheck()</code></pre>
         </article>
         
         <article class="function" data-name="NoWriteBarrierRecCheck">
            <h2>NoWriteBarrierRecCheck</h2>
            <hr />
            
            <pre><code>func NoWriteBarrierRecCheck()</code></pre>
         </article>
         
         <article class="function" data-name="newNowritebarrierrecChecker">
            <h2>newNowritebarrierrecChecker</h2>
            <hr />
            
            <p>newNowritebarrierrecChecker creates a nowritebarrierrecChecker. It
must be called before walk.</p>
            
            <pre><code>func newNowritebarrierrecChecker() *nowritebarrierrecChecker</code></pre>
         </article>
         
         <article class="function" data-name="findExtraCalls">
            <h2>findExtraCalls</h2>
            <hr />
            
            <pre><code>func findExtraCalls(nn ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="recordCall">
            <h2>recordCall</h2>
            <hr />
            
            <p>recordCall records a call from ODCLFUNC node "from", to function
symbol "to" at position pos.

This should be done as late as possible during compilation to
capture precise call graphs. The target of the call is an LSym
because that's all we know after we start SSA.

This can be called concurrently for different from Nodes.</p>
            
            <pre><code>func recordCall(fn *ir.Func, to *obj.LSym, pos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <pre><code>func check()</code></pre>
         </article>
         
         <article class="function" data-name="cmpstackvarlt">
            <h2>cmpstackvarlt</h2>
            <hr />
            
            <p>cmpstackvarlt reports whether the stack variable a sorts before b.</p>
            
            <pre><code>func cmpstackvarlt(a *ir.Name, b *ir.Name, mls *liveness.MergeLocalsState) bool</code></pre>
         </article>
         
         <article class="function" data-name="needAlloc">
            <h2>needAlloc</h2>
            <hr />
            
            <p>needAlloc reports whether n is within the current frame, for which we need to
allocate space. In particular, it excludes arguments and results, which are in
the callers frame.</p>
            
            <pre><code>func needAlloc(n *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="AllocFrame">
            <h2>AllocFrame</h2>
            <hr />
            
            <pre><code>func AllocFrame(f *ssa.Func)</code></pre>
         </article>
         
         <article class="function" data-name="Compile">
            <h2>Compile</h2>
            <hr />
            
            <p>Compile builds an SSA backend function,
uses it to generate a plist,
and flushes that plist to machine code.
worker indicates which of the backend workers is doing the processing.</p>
            
            <pre><code>func Compile(fn *ir.Func, worker int, profile *pgoir.Profile)</code></pre>
         </article>
         
         <article class="function" data-name="RegisterMapInitLsym">
            <h2>RegisterMapInitLsym</h2>
            <hr />
            
            <p>RegisterMapInitLsym records "s" in the set of outlined map initializer
functions.</p>
            
            <pre><code>func RegisterMapInitLsym(s *obj.LSym)</code></pre>
         </article>
         
         <article class="function" data-name="weakenGlobalMapInitRelocs">
            <h2>weakenGlobalMapInitRelocs</h2>
            <hr />
            
            <p>weakenGlobalMapInitRelocs walks through all of the relocations on a
given a package init function "fn" and looks for relocs that target
outlined global map initializer functions; if it finds any such
relocs, it flags them as R_WEAK.</p>
            
            <pre><code>func weakenGlobalMapInitRelocs(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="StackOffset">
            <h2>StackOffset</h2>
            <hr />
            
            <p>StackOffset returns the stack location of a LocalSlot relative to the
stack pointer, suitable for use in a DWARF location entry. This has nothing
to do with its offset in the user variable.</p>
            
            <pre><code>func StackOffset(slot ssa.LocalSlot) int32</code></pre>
         </article>
         
         <article class="function" data-name="fieldtrack">
            <h2>fieldtrack</h2>
            <hr />
            
            <p>fieldtrack adds R_USEFIELD relocations to fnsym to record any
struct fields that it used.</p>
            
            <pre><code>func fieldtrack(fnsym *obj.LSym, tracked *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="CheckLargeStacks">
            <h2>CheckLargeStacks</h2>
            <hr />
            
            <pre><code>func CheckLargeStacks()</code></pre>
         </article>
         
         <article class="function" data-name="CanBeAnSSAAux">
            <h2>CanBeAnSSAAux</h2>
            <hr />
            
            <pre><code>func CanBeAnSSAAux()</code></pre>
         </article>
         
         <article class="function" data-name="insertPhis">
            <h2>insertPhis</h2>
            <hr />
            
            <p>insertPhis finds all the places in the function where a phi is
necessary and inserts them.
Uses FwdRef ops to find all uses of variables, and s.defvars to find
all definitions.
Phi values are inserted, and all FwdRefs are changed to a Copy
of the appropriate phi or definition.
TODO: make this part of cmd/compile/internal/ssa somehow?</p>
            
            <pre><code>func insertPhis()</code></pre>
         </article>
         
         <article class="function" data-name="insertPhis">
            <h2>insertPhis</h2>
            <hr />
            
            <pre><code>func insertPhis()</code></pre>
         </article>
         
         <article class="function" data-name="insertVarPhis">
            <h2>insertVarPhis</h2>
            <hr />
            
            <pre><code>func insertVarPhis(n int, var_ ir.Node, defs []*ssa.Block, typ *types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="resolveFwdRefs">
            <h2>resolveFwdRefs</h2>
            <hr />
            
            <p>resolveFwdRefs links all FwdRef uses up to their nearest dominating definition.</p>
            
            <pre><code>func resolveFwdRefs()</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Push">
            <h2>Push</h2>
            <hr />
            
            <pre><code>func Push(x *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Pop">
            <h2>Pop</h2>
            <hr />
            
            <pre><code>func Pop() *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="newSparseSet">
            <h2>newSparseSet</h2>
            <hr />
            
            <p>newSparseSet returns a sparseSet that can represent
integers between 0 and n-1.</p>
            
            <pre><code>func newSparseSet(n int) *sparseSet</code></pre>
         </article>
         
         <article class="function" data-name="contains">
            <h2>contains</h2>
            <hr />
            
            <pre><code>func contains(x ssa.ID) bool</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(x ssa.ID)</code></pre>
         </article>
         
         <article class="function" data-name="clear">
            <h2>clear</h2>
            <hr />
            
            <pre><code>func clear()</code></pre>
         </article>
         
         <article class="function" data-name="insertPhis">
            <h2>insertPhis</h2>
            <hr />
            
            <pre><code>func insertPhis()</code></pre>
         </article>
         
         <article class="function" data-name="lookupVarOutgoing">
            <h2>lookupVarOutgoing</h2>
            <hr />
            
            <p>lookupVarOutgoing finds the variable's value at the end of block b.</p>
            
            <pre><code>func lookupVarOutgoing(b *ssa.Block, t *types.Type, var_ ir.Node, line src.XPos) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="DumpInline">
            <h2>DumpInline</h2>
            <hr />
            
            <pre><code>func DumpInline(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="InitEnv">
            <h2>InitEnv</h2>
            <hr />
            
            <pre><code>func InitEnv()</code></pre>
         </article>
         
         <article class="function" data-name="InitConfig">
            <h2>InitConfig</h2>
            <hr />
            
            <pre><code>func InitConfig()</code></pre>
         </article>
         
         <article class="function" data-name="InitTables">
            <h2>InitTables</h2>
            <hr />
            
            <pre><code>func InitTables()</code></pre>
         </article>
         
         <article class="function" data-name="AbiForBodylessFuncStackMap">
            <h2>AbiForBodylessFuncStackMap</h2>
            <hr />
            
            <p>AbiForBodylessFuncStackMap returns the ABI for a bodyless function's stack map.
This is not necessarily the ABI used to call it.
Currently (1.17 dev) such a stack map is always ABI0;
any ABI wrapper that is present is nosplit, hence a precise
stack map is not needed there (the parameters survive only long
enough to call the wrapped assembly function).
This always returns a freshly copied ABI.</p>
            
            <pre><code>func AbiForBodylessFuncStackMap(fn *ir.Func) *abi.ABIConfig</code></pre>
         </article>
         
         <article class="function" data-name="abiForFunc">
            <h2>abiForFunc</h2>
            <hr />
            
            <p>abiForFunc implements ABI policy for a function, but does not return a copy of the ABI.
Passing a nil function returns the default ABI based on experiment configuration.</p>
            
            <pre><code>func abiForFunc(fn *ir.Func, abi0 *abi.ABIConfig, abi1 *abi.ABIConfig) *abi.ABIConfig</code></pre>
         </article>
         
         <article class="function" data-name="emitOpenDeferInfo">
            <h2>emitOpenDeferInfo</h2>
            <hr />
            
            <p>emitOpenDeferInfo emits FUNCDATA information about the defers in a function
that is using open-coded defers.  This funcdata is used to determine the active
defers in a function and execute those defers during panic processing.

The funcdata is all encoded in varints (since values will almost always be less than
128, but stack offsets could potentially be up to 2Gbyte). All "locations" (offsets)
for stack variables are specified as the number of bytes below varp (pointer to the
top of the local variables) for their starting address. The format is:

  - Offset of the deferBits variable
  - Offset of the first closure slot (the rest are laid out consecutively).</p>
            
            <pre><code>func emitOpenDeferInfo()</code></pre>
         </article>
         
         <article class="function" data-name="buildssa">
            <h2>buildssa</h2>
            <hr />
            
            <p>buildssa builds an SSA function for fn.
worker indicates which of the backend workers is doing the processing.</p>
            
            <pre><code>func buildssa(fn *ir.Func, worker int, isPgoHot bool) *ssa.Func</code></pre>
         </article>
         
         <article class="function" data-name="storeParameterRegsToStack">
            <h2>storeParameterRegsToStack</h2>
            <hr />
            
            <pre><code>func storeParameterRegsToStack(abi *abi.ABIConfig, paramAssignment *abi.ABIParamAssignment, n *ir.Name, addr *ssa.Value, pointersOnly bool)</code></pre>
         </article>
         
         <article class="function" data-name="zeroResults">
            <h2>zeroResults</h2>
            <hr />
            
            <p>zeroResults zeros the return values at the start of the function.
We need to do this very early in the function.  Defer might stop a
panic and show the return values as they exist at the time of
panic.  For precise stacks, the garbage collector assumes results
are always live, so we need to zero them before any allocations,
even allocations to move params/results to the heap.</p>
            
            <pre><code>func zeroResults()</code></pre>
         </article>
         
         <article class="function" data-name="paramsToHeap">
            <h2>paramsToHeap</h2>
            <hr />
            
            <p>paramsToHeap produces code to allocate memory for heap-escaped parameters
and to copy non-result parameters' values from the stack.</p>
            
            <pre><code>func paramsToHeap()</code></pre>
         </article>
         
         <article class="function" data-name="newHeapaddr">
            <h2>newHeapaddr</h2>
            <hr />
            
            <p>newHeapaddr allocates heap memory for n and sets its heap address.</p>
            
            <pre><code>func newHeapaddr(n *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="setHeapaddr">
            <h2>setHeapaddr</h2>
            <hr />
            
            <p>setHeapaddr allocates a new PAUTO variable to store ptr (which must be non-nil)
and then sets it as n's heap address.</p>
            
            <pre><code>func setHeapaddr(pos src.XPos, n *ir.Name, ptr *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="newObject">
            <h2>newObject</h2>
            <hr />
            
            <p>newObject returns an SSA value denoting new(typ).</p>
            
            <pre><code>func newObject(typ *types.Type, rtype *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="checkPtrAlignment">
            <h2>checkPtrAlignment</h2>
            <hr />
            
            <pre><code>func checkPtrAlignment(n *ir.ConvExpr, v *ssa.Value, count *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="reflectType">
            <h2>reflectType</h2>
            <hr />
            
            <p>reflectType returns an SSA value representing a pointer to typ's
reflection type descriptor.</p>
            
            <pre><code>func reflectType(typ *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="dumpSourcesColumn">
            <h2>dumpSourcesColumn</h2>
            <hr />
            
            <pre><code>func dumpSourcesColumn(writer *ssa.HTMLWriter, fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="readFuncLines">
            <h2>readFuncLines</h2>
            <hr />
            
            <pre><code>func readFuncLines(file string, start uint, end uint) (*ssa.FuncLines, error)</code></pre>
         </article>
         
         <article class="function" data-name="updateUnsetPredPos">
            <h2>updateUnsetPredPos</h2>
            <hr />
            
            <p>updateUnsetPredPos propagates the earliest-value position information for b
towards all of b's predecessors that need a position, and recurs on that
predecessor if its position is updated. B should have a non-empty position.</p>
            
            <pre><code>func updateUnsetPredPos(b *ssa.Block)</code></pre>
         </article>
         
         <article class="function" data-name="label">
            <h2>label</h2>
            <hr />
            
            <p>label returns the label associated with sym, creating it if necessary.</p>
            
            <pre><code>func label(sym *types.Sym) *ssaLabel</code></pre>
         </article>
         
         <article class="function" data-name="Logf">
            <h2>Logf</h2>
            <hr />
            
            <pre><code>func Logf(msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Log">
            <h2>Log</h2>
            <hr />
            
            <pre><code>func Log() bool</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <pre><code>func Fatalf(msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Warnl">
            <h2>Warnl</h2>
            <hr />
            
            <pre><code>func Warnl(pos src.XPos, msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Debug_checknil">
            <h2>Debug_checknil</h2>
            <hr />
            
            <pre><code>func Debug_checknil() bool</code></pre>
         </article>
         
         <article class="function" data-name="ssaMarker">
            <h2>ssaMarker</h2>
            <hr />
            
            <pre><code>func ssaMarker(name string) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="startBlock">
            <h2>startBlock</h2>
            <hr />
            
            <p>startBlock sets the current block we're generating code in to b.</p>
            
            <pre><code>func startBlock(b *ssa.Block)</code></pre>
         </article>
         
         <article class="function" data-name="endBlock">
            <h2>endBlock</h2>
            <hr />
            
            <p>endBlock marks the end of generating code for the current block.
Returns the (former) current block. Returns nil if there is no current
block, i.e. if no code flows to the current execution point.</p>
            
            <pre><code>func endBlock() *ssa.Block</code></pre>
         </article>
         
         <article class="function" data-name="pushLine">
            <h2>pushLine</h2>
            <hr />
            
            <p>pushLine pushes a line number on the line number stack.</p>
            
            <pre><code>func pushLine(line src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="popLine">
            <h2>popLine</h2>
            <hr />
            
            <p>popLine pops the top of the line number stack.</p>
            
            <pre><code>func popLine()</code></pre>
         </article>
         
         <article class="function" data-name="peekPos">
            <h2>peekPos</h2>
            <hr />
            
            <p>peekPos peeks the top of the line number stack.</p>
            
            <pre><code>func peekPos() src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="newValue0">
            <h2>newValue0</h2>
            <hr />
            
            <p>newValue0 adds a new value with no arguments to the current block.</p>
            
            <pre><code>func newValue0(op ssa.Op, t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue0A">
            <h2>newValue0A</h2>
            <hr />
            
            <p>newValue0A adds a new value with no arguments and an aux value to the current block.</p>
            
            <pre><code>func newValue0A(op ssa.Op, t *types.Type, aux ssa.Aux) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue0I">
            <h2>newValue0I</h2>
            <hr />
            
            <p>newValue0I adds a new value with no arguments and an auxint value to the current block.</p>
            
            <pre><code>func newValue0I(op ssa.Op, t *types.Type, auxint int64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue1">
            <h2>newValue1</h2>
            <hr />
            
            <p>newValue1 adds a new value with one argument to the current block.</p>
            
            <pre><code>func newValue1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue1A">
            <h2>newValue1A</h2>
            <hr />
            
            <p>newValue1A adds a new value with one argument and an aux value to the current block.</p>
            
            <pre><code>func newValue1A(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue1Apos">
            <h2>newValue1Apos</h2>
            <hr />
            
            <p>newValue1Apos adds a new value with one argument and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
            
            <pre><code>func newValue1Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value, isStmt bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue1I">
            <h2>newValue1I</h2>
            <hr />
            
            <p>newValue1I adds a new value with one argument and an auxint value to the current block.</p>
            
            <pre><code>func newValue1I(op ssa.Op, t *types.Type, aux int64, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue2">
            <h2>newValue2</h2>
            <hr />
            
            <p>newValue2 adds a new value with two arguments to the current block.</p>
            
            <pre><code>func newValue2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue2A">
            <h2>newValue2A</h2>
            <hr />
            
            <p>newValue2A adds a new value with two arguments and an aux value to the current block.</p>
            
            <pre><code>func newValue2A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue2Apos">
            <h2>newValue2Apos</h2>
            <hr />
            
            <p>newValue2Apos adds a new value with two arguments and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
            
            <pre><code>func newValue2Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, isStmt bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue2I">
            <h2>newValue2I</h2>
            <hr />
            
            <p>newValue2I adds a new value with two arguments and an auxint value to the current block.</p>
            
            <pre><code>func newValue2I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue3">
            <h2>newValue3</h2>
            <hr />
            
            <p>newValue3 adds a new value with three arguments to the current block.</p>
            
            <pre><code>func newValue3(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue3I">
            <h2>newValue3I</h2>
            <hr />
            
            <p>newValue3I adds a new value with three arguments and an auxint value to the current block.</p>
            
            <pre><code>func newValue3I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue3A">
            <h2>newValue3A</h2>
            <hr />
            
            <p>newValue3A adds a new value with three arguments and an aux value to the current block.</p>
            
            <pre><code>func newValue3A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue3Apos">
            <h2>newValue3Apos</h2>
            <hr />
            
            <p>newValue3Apos adds a new value with three arguments and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
            
            <pre><code>func newValue3Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, isStmt bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue4">
            <h2>newValue4</h2>
            <hr />
            
            <p>newValue4 adds a new value with four arguments to the current block.</p>
            
            <pre><code>func newValue4(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, arg3 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValue4I">
            <h2>newValue4I</h2>
            <hr />
            
            <p>newValue4I adds a new value with four arguments and an auxint value to the current block.</p>
            
            <pre><code>func newValue4I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, arg3 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryBlock">
            <h2>entryBlock</h2>
            <hr />
            
            <pre><code>func entryBlock() *ssa.Block</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue0">
            <h2>entryNewValue0</h2>
            <hr />
            
            <p>entryNewValue0 adds a new value with no arguments to the entry block.</p>
            
            <pre><code>func entryNewValue0(op ssa.Op, t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue0A">
            <h2>entryNewValue0A</h2>
            <hr />
            
            <p>entryNewValue0A adds a new value with no arguments and an aux value to the entry block.</p>
            
            <pre><code>func entryNewValue0A(op ssa.Op, t *types.Type, aux ssa.Aux) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue1">
            <h2>entryNewValue1</h2>
            <hr />
            
            <p>entryNewValue1 adds a new value with one argument to the entry block.</p>
            
            <pre><code>func entryNewValue1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue1I">
            <h2>entryNewValue1I</h2>
            <hr />
            
            <p>entryNewValue1I adds a new value with one argument and an auxint value to the entry block.</p>
            
            <pre><code>func entryNewValue1I(op ssa.Op, t *types.Type, auxint int64, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue1A">
            <h2>entryNewValue1A</h2>
            <hr />
            
            <p>entryNewValue1A adds a new value with one argument and an aux value to the entry block.</p>
            
            <pre><code>func entryNewValue1A(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue2">
            <h2>entryNewValue2</h2>
            <hr />
            
            <p>entryNewValue2 adds a new value with two arguments to the entry block.</p>
            
            <pre><code>func entryNewValue2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="entryNewValue2A">
            <h2>entryNewValue2A</h2>
            <hr />
            
            <p>entryNewValue2A adds a new value with two arguments and an aux value to the entry block.</p>
            
            <pre><code>func entryNewValue2A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constSlice">
            <h2>constSlice</h2>
            <hr />
            
            <p>const* routines add a new const value to the entry block.</p>
            
            <pre><code>func constSlice(t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constInterface">
            <h2>constInterface</h2>
            <hr />
            
            <pre><code>func constInterface(t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constNil">
            <h2>constNil</h2>
            <hr />
            
            <pre><code>func constNil(t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constEmptyString">
            <h2>constEmptyString</h2>
            <hr />
            
            <pre><code>func constEmptyString(t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constBool">
            <h2>constBool</h2>
            <hr />
            
            <pre><code>func constBool(c bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constInt8">
            <h2>constInt8</h2>
            <hr />
            
            <pre><code>func constInt8(t *types.Type, c int8) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constInt16">
            <h2>constInt16</h2>
            <hr />
            
            <pre><code>func constInt16(t *types.Type, c int16) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constInt32">
            <h2>constInt32</h2>
            <hr />
            
            <pre><code>func constInt32(t *types.Type, c int32) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constInt64">
            <h2>constInt64</h2>
            <hr />
            
            <pre><code>func constInt64(t *types.Type, c int64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constFloat32">
            <h2>constFloat32</h2>
            <hr />
            
            <pre><code>func constFloat32(t *types.Type, c float64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constFloat64">
            <h2>constFloat64</h2>
            <hr />
            
            <pre><code>func constFloat64(t *types.Type, c float64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constInt">
            <h2>constInt</h2>
            <hr />
            
            <pre><code>func constInt(t *types.Type, c int64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="constOffPtrSP">
            <h2>constOffPtrSP</h2>
            <hr />
            
            <pre><code>func constOffPtrSP(t *types.Type, c int64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValueOrSfCall1">
            <h2>newValueOrSfCall1</h2>
            <hr />
            
            <p>newValueOrSfCall* are wrappers around newValue*, which may create a call to a
soft-float runtime function instead (when emitting soft-float code).</p>
            
            <pre><code>func newValueOrSfCall1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="newValueOrSfCall2">
            <h2>newValueOrSfCall2</h2>
            <hr />
            
            <pre><code>func newValueOrSfCall2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="instrument">
            <h2>instrument</h2>
            <hr />
            
            <pre><code>func instrument(t *types.Type, addr *ssa.Value, kind instrumentKind)</code></pre>
         </article>
         
         <article class="function" data-name="instrumentFields">
            <h2>instrumentFields</h2>
            <hr />
            
            <p>instrumentFields instruments a read/write operation on addr.
If it is instrumenting for MSAN or ASAN and t is a struct type, it instruments
operation for each field, instead of for the whole struct.</p>
            
            <pre><code>func instrumentFields(t *types.Type, addr *ssa.Value, kind instrumentKind)</code></pre>
         </article>
         
         <article class="function" data-name="instrumentMove">
            <h2>instrumentMove</h2>
            <hr />
            
            <pre><code>func instrumentMove(t *types.Type, dst *ssa.Value, src *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="instrument2">
            <h2>instrument2</h2>
            <hr />
            
            <pre><code>func instrument2(t *types.Type, addr *ssa.Value, addr2 *ssa.Value, kind instrumentKind)</code></pre>
         </article>
         
         <article class="function" data-name="load">
            <h2>load</h2>
            <hr />
            
            <pre><code>func load(t *types.Type, src *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="rawLoad">
            <h2>rawLoad</h2>
            <hr />
            
            <pre><code>func rawLoad(t *types.Type, src *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="store">
            <h2>store</h2>
            <hr />
            
            <pre><code>func store(t *types.Type, dst *ssa.Value, val *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="zero">
            <h2>zero</h2>
            <hr />
            
            <pre><code>func zero(t *types.Type, dst *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="move">
            <h2>move</h2>
            <hr />
            
            <pre><code>func move(t *types.Type, dst *ssa.Value, src *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="moveWhichMayOverlap">
            <h2>moveWhichMayOverlap</h2>
            <hr />
            
            <pre><code>func moveWhichMayOverlap(t *types.Type, dst *ssa.Value, src *ssa.Value, mayOverlap bool)</code></pre>
         </article>
         
         <article class="function" data-name="stmtList">
            <h2>stmtList</h2>
            <hr />
            
            <p>stmtList converts the statement list n to SSA and adds it to s.</p>
            
            <pre><code>func stmtList(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="stmt">
            <h2>stmt</h2>
            <hr />
            
            <p>stmt converts the statement n to SSA and adds it to s.</p>
            
            <pre><code>func stmt(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="exit">
            <h2>exit</h2>
            <hr />
            
            <p>exit processes any code that needs to be generated just before returning.
It returns a BlockRet block that ends the control flow. Its control value
will be set to the final memory state.</p>
            
            <pre><code>func exit() *ssa.Block</code></pre>
         </article>
         
         <article class="function" data-name="concreteEtype">
            <h2>concreteEtype</h2>
            <hr />
            
            <pre><code>func concreteEtype(t *types.Type) types.Kind</code></pre>
         </article>
         
         <article class="function" data-name="ssaOp">
            <h2>ssaOp</h2>
            <hr />
            
            <pre><code>func ssaOp(op ir.Op, t *types.Type) ssa.Op</code></pre>
         </article>
         
         <article class="function" data-name="ssaShiftOp">
            <h2>ssaShiftOp</h2>
            <hr />
            
            <pre><code>func ssaShiftOp(op ir.Op, t *types.Type, u *types.Type) ssa.Op</code></pre>
         </article>
         
         <article class="function" data-name="uintptrConstant">
            <h2>uintptrConstant</h2>
            <hr />
            
            <pre><code>func uintptrConstant(v uint64) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="conv">
            <h2>conv</h2>
            <hr />
            
            <pre><code>func conv(n ir.Node, v *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <p>expr converts the expression n to ssa, adds it to s and returns the ssa result.</p>
            
            <pre><code>func expr(n ir.Node) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="exprCheckPtr">
            <h2>exprCheckPtr</h2>
            <hr />
            
            <pre><code>func exprCheckPtr(n ir.Node, checkPtrOK bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="resultOfCall">
            <h2>resultOfCall</h2>
            <hr />
            
            <pre><code>func resultOfCall(c *ssa.Value, which int64, t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="resultAddrOfCall">
            <h2>resultAddrOfCall</h2>
            <hr />
            
            <pre><code>func resultAddrOfCall(c *ssa.Value, which int64, t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <p>append converts an OAPPEND node to SSA.
If inplace is false, it converts the OAPPEND expression n to an ssa.Value,
adds it to s, and returns the Value.
If inplace is true, it writes the result of the OAPPEND expression n
back to the slice being appended to, and returns nil.
inplace MUST be set to false if the slice can be SSA'd.
Note: this code only handles fixed-count appends. Dotdotdot appends
have already been rewritten at this point (by walk).</p>
            
            <pre><code>func append(n *ir.CallExpr, inplace bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="minMax">
            <h2>minMax</h2>
            <hr />
            
            <p>minMax converts an OMIN/OMAX builtin call into SSA.</p>
            
            <pre><code>func minMax(n *ir.CallExpr) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="ternary">
            <h2>ternary</h2>
            <hr />
            
            <p>ternary emits code to evaluate cond ? x : y.</p>
            
            <pre><code>func ternary(cond *ssa.Value, x *ssa.Value, y *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="condBranch">
            <h2>condBranch</h2>
            <hr />
            
            <p>condBranch evaluates the boolean expression cond and branches to yes
if cond is true and no if cond is false.
This function is intended to handle && and || better than just calling
s.expr(cond) and branching on the result.</p>
            
            <pre><code>func condBranch(cond ir.Node, yes *ssa.Block, no *ssa.Block, likely int8)</code></pre>
         </article>
         
         <article class="function" data-name="assign">
            <h2>assign</h2>
            <hr />
            
            <p>assign does left = right.
Right has already been evaluated to ssa, left has not.
If deref is true, then we do left = *right instead (and right has already been nil-checked).
If deref is true and right == nil, just do left = 0.
skip indicates assignments (at the top level) that can be avoided.
mayOverlap indicates whether left&right might partially overlap in memory. Default is false.</p>
            
            <pre><code>func assign(left ir.Node, right *ssa.Value, deref bool, skip skipMask)</code></pre>
         </article>
         
         <article class="function" data-name="assignWhichMayOverlap">
            <h2>assignWhichMayOverlap</h2>
            <hr />
            
            <pre><code>func assignWhichMayOverlap(left ir.Node, right *ssa.Value, deref bool, skip skipMask, mayOverlap bool)</code></pre>
         </article>
         
         <article class="function" data-name="zeroVal">
            <h2>zeroVal</h2>
            <hr />
            
            <p>zeroVal returns the zero value for type t.</p>
            
            <pre><code>func zeroVal(t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="softfloatInit">
            <h2>softfloatInit</h2>
            <hr />
            
            <pre><code>func softfloatInit()</code></pre>
         </article>
         
         <article class="function" data-name="sfcall">
            <h2>sfcall</h2>
            <hr />
            
            <p>TODO: do not emit sfcall if operation can be optimized to constant in later
opt phase</p>
            
            <pre><code>func sfcall(op ssa.Op, args ...*ssa.Value) (*ssa.Value, bool)</code></pre>
         </article>
         
         <article class="function" data-name="split">
            <h2>split</h2>
            <hr />
            
            <p>split breaks up a tuple-typed value into its 2 parts.</p>
            
            <pre><code>func split(v *ssa.Value) (*ssa.Value, *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="intrinsicCall">
            <h2>intrinsicCall</h2>
            <hr />
            
            <p>intrinsicCall converts a call to a recognized intrinsic function into the intrinsic SSA operation.</p>
            
            <pre><code>func intrinsicCall(n *ir.CallExpr) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="intrinsicArgs">
            <h2>intrinsicArgs</h2>
            <hr />
            
            <p>intrinsicArgs extracts args from n, evaluates them to SSA values, and returns them.</p>
            
            <pre><code>func intrinsicArgs(n *ir.CallExpr) []*ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="openDeferRecord">
            <h2>openDeferRecord</h2>
            <hr />
            
            <p>openDeferRecord adds code to evaluate and store the function for an open-code defer
call, and records info about the defer, so we can generate proper code on the
exit paths. n is the sub-node of the defer node that is the actual function
call. We will also record funcdata information on where the function is stored
(as well as the deferBits variable), and this will enable us to run the proper
defer calls during panics.</p>
            
            <pre><code>func openDeferRecord(n *ir.CallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="openDeferSave">
            <h2>openDeferSave</h2>
            <hr />
            
            <p>openDeferSave generates SSA nodes to store a value (with type t) for an
open-coded defer at an explicit autotmp location on the stack, so it can be
reloaded and used for the appropriate call on exit. Type t must be a function type
(therefore SSAable). val is the value to be stored. The function returns an SSA
value representing a pointer to the autotmp location.</p>
            
            <pre><code>func openDeferSave(t *types.Type, val *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="openDeferExit">
            <h2>openDeferExit</h2>
            <hr />
            
            <p>openDeferExit generates SSA for processing all the open coded defers at exit.
The code involves loading deferBits, and checking each of the bits to see if
the corresponding defer statement was executed. For each bit that is turned
on, the associated defer call is made.</p>
            
            <pre><code>func openDeferExit()</code></pre>
         </article>
         
         <article class="function" data-name="callResult">
            <h2>callResult</h2>
            <hr />
            
            <pre><code>func callResult(n *ir.CallExpr, k callKind) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="callAddr">
            <h2>callAddr</h2>
            <hr />
            
            <pre><code>func callAddr(n *ir.CallExpr, k callKind) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="call">
            <h2>call</h2>
            <hr />
            
            <p>Calls the function n using the specified call type.
Returns the address of the return value (or nil if none).</p>
            
            <pre><code>func call(n *ir.CallExpr, k callKind, returnResultAddr bool, deferExtra ir.Expr) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="maybeNilCheckClosure">
            <h2>maybeNilCheckClosure</h2>
            <hr />
            
            <p>maybeNilCheckClosure checks if a nil check of a closure is needed in some
architecture-dependent situations and, if so, emits the nil check.</p>
            
            <pre><code>func maybeNilCheckClosure(closure *ssa.Value, k callKind)</code></pre>
         </article>
         
         <article class="function" data-name="getClosureAndRcvr">
            <h2>getClosureAndRcvr</h2>
            <hr />
            
            <p>getClosureAndRcvr returns values for the appropriate closure and receiver of an
interface call</p>
            
            <pre><code>func getClosureAndRcvr(fn *ir.SelectorExpr) (*ssa.Value, *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="etypesign">
            <h2>etypesign</h2>
            <hr />
            
            <p>etypesign returns the signed-ness of e, for integer/pointer etypes.
-1 means signed, +1 means unsigned, 0 means non-integer/non-pointer.</p>
            
            <pre><code>func etypesign(e types.Kind) int8</code></pre>
         </article>
         
         <article class="function" data-name="addr">
            <h2>addr</h2>
            <hr />
            
            <p>addr converts the address of the expression n to SSA, adds it to s and returns the SSA result.
The value that the returned Value represents is guaranteed to be non-nil.</p>
            
            <pre><code>func addr(n ir.Node) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="canSSA">
            <h2>canSSA</h2>
            <hr />
            
            <p>canSSA reports whether n is SSA-able.
n must be an ONAME (or an ODOT sequence with an ONAME base).</p>
            
            <pre><code>func canSSA(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="canSSAName">
            <h2>canSSAName</h2>
            <hr />
            
            <pre><code>func canSSAName(name *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="exprPtr">
            <h2>exprPtr</h2>
            <hr />
            
            <p>exprPtr evaluates n to a pointer and nil-checks it.</p>
            
            <pre><code>func exprPtr(n ir.Node, bounded bool, lineno src.XPos) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="nilCheck">
            <h2>nilCheck</h2>
            <hr />
            
            <p>nilCheck generates nil pointer checking code.
Used only for automatically inserted nil checks,
not for user code like 'x != nil'.
Returns a "definitely not nil" copy of x to ensure proper ordering
of the uses of the post-nilcheck pointer.</p>
            
            <pre><code>func nilCheck(ptr *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="boundsCheck">
            <h2>boundsCheck</h2>
            <hr />
            
            <p>boundsCheck generates bounds checking code. Checks if 0 <= idx <[=] len, branches to exit if not.
Starts a new block on return.
On input, len must be converted to full int width and be nonnegative.
Returns idx converted to full int width.
If bounded is true then caller guarantees the index is not out of bounds
(but boundsCheck will still extend the index to full int width).</p>
            
            <pre><code>func boundsCheck(idx *ssa.Value, len *ssa.Value, kind ssa.BoundsKind, bounded bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <p>If cmp (a bool) is false, panic using the given function.</p>
            
            <pre><code>func check(cmp *ssa.Value, fn *obj.LSym)</code></pre>
         </article>
         
         <article class="function" data-name="intDivide">
            <h2>intDivide</h2>
            <hr />
            
            <pre><code>func intDivide(n ir.Node, a *ssa.Value, b *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="rtcall">
            <h2>rtcall</h2>
            <hr />
            
            <p>rtcall issues a call to the given runtime function fn with the listed args.
Returns a slice of results of the given result types.
The call is added to the end of the current block.
If returns is false, the block is marked as an exit block.</p>
            
            <pre><code>func rtcall(fn *obj.LSym, returns bool, results []*types.Type, args ...*ssa.Value) []*ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="storeType">
            <h2>storeType</h2>
            <hr />
            
            <p>do *left = right for type t.</p>
            
            <pre><code>func storeType(t *types.Type, left *ssa.Value, right *ssa.Value, skip skipMask, leftIsStmt bool)</code></pre>
         </article>
         
         <article class="function" data-name="storeTypeScalars">
            <h2>storeTypeScalars</h2>
            <hr />
            
            <p>do *left = right for all scalar (non-pointer) parts of t.</p>
            
            <pre><code>func storeTypeScalars(t *types.Type, left *ssa.Value, right *ssa.Value, skip skipMask)</code></pre>
         </article>
         
         <article class="function" data-name="storeTypePtrs">
            <h2>storeTypePtrs</h2>
            <hr />
            
            <p>do *left = right for all pointer parts of t.</p>
            
            <pre><code>func storeTypePtrs(t *types.Type, left *ssa.Value, right *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="putArg">
            <h2>putArg</h2>
            <hr />
            
            <p>putArg evaluates n for the purpose of passing it as an argument to a function and returns the value for the call.</p>
            
            <pre><code>func putArg(n ir.Node, t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="storeArgWithBase">
            <h2>storeArgWithBase</h2>
            <hr />
            
            <pre><code>func storeArgWithBase(n ir.Node, t *types.Type, base *ssa.Value, off int64)</code></pre>
         </article>
         
         <article class="function" data-name="slice">
            <h2>slice</h2>
            <hr />
            
            <p>slice computes the slice v[i:j:k] and returns ptr, len, and cap of result.
i,j,k may be nil, in which case they are set to their default value.
v may be a slice, string or pointer to an array.</p>
            
            <pre><code>func slice(v *ssa.Value, i *ssa.Value, j *ssa.Value, k *ssa.Value, bounded bool) (p *ssa.Value, l *ssa.Value, c *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="uint64Tofloat64">
            <h2>uint64Tofloat64</h2>
            <hr />
            
            <pre><code>func uint64Tofloat64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="uint64Tofloat32">
            <h2>uint64Tofloat32</h2>
            <hr />
            
            <pre><code>func uint64Tofloat32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="uint64Tofloat">
            <h2>uint64Tofloat</h2>
            <hr />
            
            <pre><code>func uint64Tofloat(cvttab *u642fcvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="uint32Tofloat64">
            <h2>uint32Tofloat64</h2>
            <hr />
            
            <pre><code>func uint32Tofloat64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="uint32Tofloat32">
            <h2>uint32Tofloat32</h2>
            <hr />
            
            <pre><code>func uint32Tofloat32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="uint32Tofloat">
            <h2>uint32Tofloat</h2>
            <hr />
            
            <pre><code>func uint32Tofloat(cvttab *u322fcvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="referenceTypeBuiltin">
            <h2>referenceTypeBuiltin</h2>
            <hr />
            
            <p>referenceTypeBuiltin generates code for the len/cap builtins for maps and channels.</p>
            
            <pre><code>func referenceTypeBuiltin(n *ir.UnaryExpr, x *ssa.Value) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="float32ToUint64">
            <h2>float32ToUint64</h2>
            <hr />
            
            <pre><code>func float32ToUint64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="float64ToUint64">
            <h2>float64ToUint64</h2>
            <hr />
            
            <pre><code>func float64ToUint64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="float32ToUint32">
            <h2>float32ToUint32</h2>
            <hr />
            
            <pre><code>func float32ToUint32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="float64ToUint32">
            <h2>float64ToUint32</h2>
            <hr />
            
            <pre><code>func float64ToUint32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="floatToUint">
            <h2>floatToUint</h2>
            <hr />
            
            <pre><code>func floatToUint(cvttab *f2uCvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="dottype">
            <h2>dottype</h2>
            <hr />
            
            <p>dottype generates SSA for a type assertion node.
commaok indicates whether to panic or return a bool.
If commaok is false, resok will be nil.</p>
            
            <pre><code>func dottype(n *ir.TypeAssertExpr, commaok bool) (res *ssa.Value, resok *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="dynamicDottype">
            <h2>dynamicDottype</h2>
            <hr />
            
            <pre><code>func dynamicDottype(n *ir.DynamicTypeAssertExpr, commaok bool) (res *ssa.Value, resok *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="dottype1">
            <h2>dottype1</h2>
            <hr />
            
            <p>dottype1 implements a x.(T) operation. iface is the argument (x), dst is the type we're asserting to (T)
and src is the type we're asserting from.
source is the *runtime._type of src
target is the *runtime._type of dst.
If src is a nonempty interface and dst is not an interface, targetItab is an itab representing (dst, src). Otherwise it is nil.
commaok is true if the caller wants a boolean success value. Otherwise, the generated code panics if the conversion fails.
descriptor is a compiler-allocated internal/abi.TypeAssert whose address is passed to runtime.typeAssert when
the target type is a compile-time-known non-empty interface. It may be nil.</p>
            
            <pre><code>func dottype1(pos src.XPos, src *types.Type, dst *types.Type, iface *ssa.Value, source *ssa.Value, target *ssa.Value, targetItab *ssa.Value, commaok bool, descriptor *obj.LSym) (res *ssa.Value, resok *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="temp">
            <h2>temp</h2>
            <hr />
            
            <p>temp allocates a temp of type t at position pos</p>
            
            <pre><code>func temp(pos src.XPos, t *types.Type) (*ir.Name, *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="variable">
            <h2>variable</h2>
            <hr />
            
            <p>variable returns the value of a variable at the current location.</p>
            
            <pre><code>func variable(n ir.Node, t *types.Type) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="mem">
            <h2>mem</h2>
            <hr />
            
            <pre><code>func mem() *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="addNamedValue">
            <h2>addNamedValue</h2>
            <hr />
            
            <pre><code>func addNamedValue(n *ir.Name, v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="FuncInfo">
            <h2>FuncInfo</h2>
            <hr />
            
            <pre><code>func FuncInfo() *obj.FuncInfo</code></pre>
         </article>
         
         <article class="function" data-name="Prog">
            <h2>Prog</h2>
            <hr />
            
            <p>Prog appends a new Prog.</p>
            
            <pre><code>func Prog(as obj.As) *obj.Prog</code></pre>
         </article>
         
         <article class="function" data-name="Pc">
            <h2>Pc</h2>
            <hr />
            
            <p>Pc returns the current Prog.</p>
            
            <pre><code>func Pc() *obj.Prog</code></pre>
         </article>
         
         <article class="function" data-name="SetPos">
            <h2>SetPos</h2>
            <hr />
            
            <p>SetPos sets the current source position.</p>
            
            <pre><code>func SetPos(pos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="Br">
            <h2>Br</h2>
            <hr />
            
            <p>Br emits a single branch instruction and returns the instruction.
Not all architectures need the returned instruction, but otherwise
the boilerplate is common to all.</p>
            
            <pre><code>func Br(op obj.As, target *ssa.Block) *obj.Prog</code></pre>
         </article>
         
         <article class="function" data-name="DebugFriendlySetPosFrom">
            <h2>DebugFriendlySetPosFrom</h2>
            <hr />
            
            <p>DebugFriendlySetPosFrom adjusts Pos.IsStmt subject to heuristics
that reduce "jumpy" line number churn when debugging.
Spill/fill/copy instructions from the register allocator,
phi functions, and instructions with a no-pos position
are examples of instructions that can cause churn.</p>
            
            <pre><code>func DebugFriendlySetPosFrom(v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="emitArgInfo">
            <h2>emitArgInfo</h2>
            <hr />
            
            <p>emit argument info (locations on stack) for traceback.</p>
            
            <pre><code>func emitArgInfo(e *ssafn, f *ssa.Func, pp *objw.Progs)</code></pre>
         </article>
         
         <article class="function" data-name="EmitArgInfo">
            <h2>EmitArgInfo</h2>
            <hr />
            
            <p>emit argument info (locations on stack) of f for traceback.</p>
            
            <pre><code>func EmitArgInfo(f *ir.Func, abiInfo *abi.ABIParamResultInfo) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="emitWrappedFuncInfo">
            <h2>emitWrappedFuncInfo</h2>
            <hr />
            
            <p>for wrapper, emit info of wrapped function.</p>
            
            <pre><code>func emitWrappedFuncInfo(e *ssafn, pp *objw.Progs)</code></pre>
         </article>
         
         <article class="function" data-name="genssa">
            <h2>genssa</h2>
            <hr />
            
            <p>genssa appends entries to pp for each instruction in f.</p>
            
            <pre><code>func genssa(f *ssa.Func, pp *objw.Progs)</code></pre>
         </article>
         
         <article class="function" data-name="defframe">
            <h2>defframe</h2>
            <hr />
            
            <pre><code>func defframe(s *State, e *ssafn, f *ssa.Func)</code></pre>
         </article>
         
         <article class="function" data-name="oneJump">
            <h2>oneJump</h2>
            <hr />
            
            <pre><code>func oneJump(b *ssa.Block, jump *IndexJump)</code></pre>
         </article>
         
         <article class="function" data-name="CombJump">
            <h2>CombJump</h2>
            <hr />
            
            <p>CombJump generates combinational instructions (2 at present) for a block jump,
thereby the behaviour of non-standard condition codes could be simulated</p>
            
            <pre><code>func CombJump(b *ssa.Block, next *ssa.Block, jumps *[][]IndexJump)</code></pre>
         </article>
         
         <article class="function" data-name="AddAux">
            <h2>AddAux</h2>
            <hr />
            
            <p>AddAux adds the offset in the aux fields (AuxInt and Aux) of v to a.</p>
            
            <pre><code>func AddAux(a *obj.Addr, v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="AddAux2">
            <h2>AddAux2</h2>
            <hr />
            
            <pre><code>func AddAux2(a *obj.Addr, v *ssa.Value, offset int64)</code></pre>
         </article>
         
         <article class="function" data-name="extendIndex">
            <h2>extendIndex</h2>
            <hr />
            
            <p>extendIndex extends v to a full int width.
panic with the given kind if v does not fit in an int (only on 32-bit archs).</p>
            
            <pre><code>func extendIndex(idx *ssa.Value, len *ssa.Value, kind ssa.BoundsKind, bounded bool) *ssa.Value</code></pre>
         </article>
         
         <article class="function" data-name="CheckLoweredPhi">
            <h2>CheckLoweredPhi</h2>
            <hr />
            
            <p>CheckLoweredPhi checks that regalloc and stackalloc correctly handled phi values.
Called during ssaGenValue.</p>
            
            <pre><code>func CheckLoweredPhi(v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="CheckLoweredGetClosurePtr">
            <h2>CheckLoweredGetClosurePtr</h2>
            <hr />
            
            <p>CheckLoweredGetClosurePtr checks that v is the first instruction in the function's entry block,
except for incoming in-register arguments.
The output of LoweredGetClosurePtr is generally hardwired to the correct register.
That register contains the closure pointer on closure entry.</p>
            
            <pre><code>func CheckLoweredGetClosurePtr(v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="CheckArgReg">
            <h2>CheckArgReg</h2>
            <hr />
            
            <p>CheckArgReg ensures that v is in the function's entry block.</p>
            
            <pre><code>func CheckArgReg(v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="AddrAuto">
            <h2>AddrAuto</h2>
            <hr />
            
            <pre><code>func AddrAuto(a *obj.Addr, v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="Call">
            <h2>Call</h2>
            <hr />
            
            <p>Call returns a new CALL instruction for the SSA value v.
It uses PrepareCall to prepare the call.</p>
            
            <pre><code>func Call(v *ssa.Value) *obj.Prog</code></pre>
         </article>
         
         <article class="function" data-name="TailCall">
            <h2>TailCall</h2>
            <hr />
            
            <p>TailCall returns a new tail call instruction for the SSA value v.
It is like Call, but for a tail call.</p>
            
            <pre><code>func TailCall(v *ssa.Value) *obj.Prog</code></pre>
         </article>
         
         <article class="function" data-name="PrepareCall">
            <h2>PrepareCall</h2>
            <hr />
            
            <p>PrepareCall prepares to emit a CALL instruction for v and does call-related bookkeeping.
It must be called immediately before emitting the actual CALL instruction,
since it emits PCDATA for the stack map at the call (calls are safe points).</p>
            
            <pre><code>func PrepareCall(v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="UseArgs">
            <h2>UseArgs</h2>
            <hr />
            
            <p>UseArgs records the fact that an instruction needs a certain amount of
callee args space for its use.</p>
            
            <pre><code>func UseArgs(n int64)</code></pre>
         </article>
         
         <article class="function" data-name="fieldIdx">
            <h2>fieldIdx</h2>
            <hr />
            
            <p>fieldIdx finds the index of the field referred to by the ODOT node n.</p>
            
            <pre><code>func fieldIdx(n *ir.SelectorExpr) int</code></pre>
         </article>
         
         <article class="function" data-name="StringData">
            <h2>StringData</h2>
            <hr />
            
            <p>StringData returns a symbol which
is the data component of a global string constant containing s.</p>
            
            <pre><code>func StringData(s string) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="SplitSlot">
            <h2>SplitSlot</h2>
            <hr />
            
            <p>SplitSlot returns a slot representing the data of parent starting at offset.</p>
            
            <pre><code>func SplitSlot(parent *ssa.LocalSlot, suffix string, offset int64, t *types.Type) ssa.LocalSlot</code></pre>
         </article>
         
         <article class="function" data-name="Logf">
            <h2>Logf</h2>
            <hr />
            
            <p>Logf logs a message from the compiler.</p>
            
            <pre><code>func Logf(msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Log">
            <h2>Log</h2>
            <hr />
            
            <pre><code>func Log() bool</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <p>Fatalf reports a compiler error and exits.</p>
            
            <pre><code>func Fatalf(pos src.XPos, msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Warnl">
            <h2>Warnl</h2>
            <hr />
            
            <p>Warnl reports a "warning", which is usually flag-triggered
logging output for the benefit of tests.</p>
            
            <pre><code>func Warnl(pos src.XPos, fmt_ string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Debug_checknil">
            <h2>Debug_checknil</h2>
            <hr />
            
            <pre><code>func Debug_checknil() bool</code></pre>
         </article>
         
         <article class="function" data-name="UseWriteBarrier">
            <h2>UseWriteBarrier</h2>
            <hr />
            
            <pre><code>func UseWriteBarrier() bool</code></pre>
         </article>
         
         <article class="function" data-name="Syslook">
            <h2>Syslook</h2>
            <hr />
            
            <pre><code>func Syslook(name string) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="Func">
            <h2>Func</h2>
            <hr />
            
            <pre><code>func Func() *ir.Func</code></pre>
         </article>
         
         <article class="function" data-name="clobberBase">
            <h2>clobberBase</h2>
            <hr />
            
            <pre><code>func clobberBase(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="callTargetLSym">
            <h2>callTargetLSym</h2>
            <hr />
            
            <p>callTargetLSym returns the correct LSym to call 'callee' using its ABI.</p>
            
            <pre><code>func callTargetLSym(callee *ir.Name) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="deferstruct">
            <h2>deferstruct</h2>
            <hr />
            
            <p>deferstruct returns a type interchangeable with runtime._defer.
Make sure this stays in sync with runtime/runtime2.go:_defer.</p>
            
            <pre><code>func deferstruct() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="SpillSlotAddr">
            <h2>SpillSlotAddr</h2>
            <hr />
            
            <p>SpillSlotAddr uses LocalSlot information to initialize an obj.Addr
The resulting addr is used in a non-standard context -- in the prologue
of a function, before the frame has been constructed, so the standard
addressing for the parameters will be wrong.</p>
            
            <pre><code>func SpillSlotAddr(spill ssa.Spill, baseReg int16, extraOffset int64) obj.Addr</code></pre>
         </article>
         
         <article class="function" data-name="NewSymABIs">
            <h2>NewSymABIs</h2>
            <hr />
            
            <pre><code>func NewSymABIs() *SymABIs</code></pre>
         </article>
         
         <article class="function" data-name="canonicalize">
            <h2>canonicalize</h2>
            <hr />
            
            <p>canonicalize returns the canonical name used for a linker symbol in
s's maps. Symbols in this package may be written either as "".X or
with the package's import path already in the symbol. This rewrites
both to use the full path, which matches compiler-generated linker
symbol names.</p>
            
            <pre><code>func canonicalize(linksym string) string</code></pre>
         </article>
         
         <article class="function" data-name="ReadSymABIs">
            <h2>ReadSymABIs</h2>
            <hr />
            
            <p>ReadSymABIs reads a symabis file that specifies definitions and
references of text symbols by ABI.

The symabis format is a set of lines, where each line is a sequence
of whitespace-separated fields. The first field is a verb and is
either "def" for defining a symbol ABI or "ref" for referencing a
symbol using an ABI. For both "def" and "ref", the second field is
the symbol name and the third field is the ABI name, as one of the
named cmd/internal/obj.ABI constants.</p>
            
            <pre><code>func ReadSymABIs(file string)</code></pre>
         </article>
         
         <article class="function" data-name="GenABIWrappers">
            <h2>GenABIWrappers</h2>
            <hr />
            
            <p>GenABIWrappers applies ABI information to Funcs and generates ABI
wrapper functions where necessary.</p>
            
            <pre><code>func GenABIWrappers()</code></pre>
         </article>
         
         <article class="function" data-name="forEachWrapperABI">
            <h2>forEachWrapperABI</h2>
            <hr />
            
            <pre><code>func forEachWrapperABI(fn *ir.Func, cb func)</code></pre>
         </article>
         
         <article class="function" data-name="makeABIWrapper">
            <h2>makeABIWrapper</h2>
            <hr />
            
            <p>makeABIWrapper creates a new function that will be called with
wrapperABI and calls "f" using f.ABI.</p>
            
            <pre><code>func makeABIWrapper(f *ir.Func, wrapperABI obj.ABI)</code></pre>
         </article>
         
         <article class="function" data-name="CreateWasmImportWrapper">
            <h2>CreateWasmImportWrapper</h2>
            <hr />
            
            <p>CreateWasmImportWrapper creates a wrapper for imported WASM functions to
adapt them to the Go calling convention. The body for this function is
generated in cmd/internal/obj/wasm/wasmobj.go</p>
            
            <pre><code>func CreateWasmImportWrapper(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="GenWasmExportWrapper">
            <h2>GenWasmExportWrapper</h2>
            <hr />
            
            <pre><code>func GenWasmExportWrapper(wrapped *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="paramsToWasmFields">
            <h2>paramsToWasmFields</h2>
            <hr />
            
            <pre><code>func paramsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField</code></pre>
         </article>
         
         <article class="function" data-name="resultsToWasmFields">
            <h2>resultsToWasmFields</h2>
            <hr />
            
            <pre><code>func resultsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField</code></pre>
         </article>
         
         <article class="function" data-name="wasmElemTypeAllowed">
            <h2>wasmElemTypeAllowed</h2>
            <hr />
            
            <p>wasmElemTypeAllowed reports whether t is allowed to be passed in memory
(as a pointer's element type, a field of it, etc.) between the Go wasm
module and the host.</p>
            
            <pre><code>func wasmElemTypeAllowed(t *types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="setupWasmImport">
            <h2>setupWasmImport</h2>
            <hr />
            
            <p>setupWasmImport calculates the params and results in terms of WebAssembly values for the given function,
and sets up the wasmimport metadata.</p>
            
            <pre><code>func setupWasmImport(f *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="setupWasmExport">
            <h2>setupWasmExport</h2>
            <hr />
            
            <p>setupWasmExport calculates the params and results in terms of WebAssembly values for the given function,
and sets up the wasmexport metadata.</p>
            
            <pre><code>func setupWasmExport(f *ir.Func, wrapped *ir.Func)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
