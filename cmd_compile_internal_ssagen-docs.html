<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ssagen</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>ssagen</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bufio"
"bytes"
"fmt"
"go/constant"
"html"
"internal/buildcfg"
"os"
"path/filepath"
"slices"
"strings"
"cmd/compile/internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/liveness"
"cmd/compile/internal/objw"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/rttype"
"cmd/compile/internal/ssa"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/internal/sys"
rtabi "internal/abi"
"fmt"
"internal/buildcfg"
"log"
"os"
"strings"
"cmd/compile/internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/obj/wasm"
rtabi "internal/abi"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/obj"
"fmt"
"internal/abi"
"internal/buildcfg"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/sys"
"fmt"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"fmt"
"internal/buildcfg"
"os"
"slices"
"sort"
"strings"
"sync"
"cmd/compile/internal/base"
"cmd/compile/internal/inline"
"cmd/compile/internal/ir"
"cmd/compile/internal/liveness"
"cmd/compile/internal/objw"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"container/heap"
"fmt"
"cmd/compile/internal/ir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/types"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Arch">
               <h3>
                  Arch 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Arch ArchInfo</code></pre>
            </article>
            
            <article class="global" data-name="BoundsCheckFunc">
               <h3>
                  BoundsCheckFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var BoundsCheckFunc [ssa.BoundsKindCount]*obj.LSym</code></pre>
            </article>
            
            <article class="global" data-name="ExtendCheckFunc">
               <h3>
                  ExtendCheckFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ExtendCheckFunc [ssa.BoundsKindCount]*obj.LSym</code></pre>
            </article>
            
            <article class="global" data-name="callDefer">
               <h3>
                  callDefer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const callDefer</code></pre>
            </article>
            
            <article class="global" data-name="callDeferStack">
               <h3>
                  callDeferStack 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const callDeferStack</code></pre>
            </article>
            
            <article class="global" data-name="callGo">
               <h3>
                  callGo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const callGo</code></pre>
            </article>
            
            <article class="global" data-name="callNormal">
               <h3>
                  callNormal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const callNormal callKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="callTail">
               <h3>
                  callTail 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const callTail</code></pre>
            </article>
            
            <article class="global" data-name="capVar">
               <h3>
                  capVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var capVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="debugPhi">
               <h3>
                  debugPhi 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugPhi = false</code></pre>
            </article>
            
            <article class="global" data-name="deferBitsVar">
               <h3>
                  deferBitsVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var deferBitsVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="deferStructFnField">
               <h3>
                  deferStructFnField 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>deferStructFnField is the field index of _defer.fn.</p>
               
               <pre><code>const deferStructFnField = 4</code></pre>
            </article>
            
            <article class="global" data-name="deferType">
               <h3>
                  deferType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var deferType *types.Type</code></pre>
            </article>
            
            <article class="global" data-name="f32_u32">
               <h3>
                  f32_u32 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var f32_u32 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="f32_u64">
               <h3>
                  f32_u64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var f32_u64 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="f64_u32">
               <h3>
                  f64_u32 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var f64_u32 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="f64_u64">
               <h3>
                  f64_u64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var f64_u64 = f2uCvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="fpConvOpToSSA">
               <h3>
                  fpConvOpToSSA 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fpConvOpToSSA = map[twoTypes]twoOpsAndType{...}</code></pre>
            </article>
            
            <article class="global" data-name="fpConvOpToSSA32">
               <h3>
                  fpConvOpToSSA32 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>this map is used only for 32-bit arch, and only includes the difference
on 32-bit arch, don't use int64<->float conversion for uint32</p>
               
               <pre><code>var fpConvOpToSSA32 = map[twoTypes]twoOpsAndType{...}</code></pre>
            </article>
            
            <article class="global" data-name="globalMapInitLsyms">
               <h3>
                  globalMapInitLsyms 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>globalMapInitLsyms records the LSym of each map.init.NNN outlined
map initializer function created by the compiler.</p>
               
               <pre><code>var globalMapInitLsyms map[*obj.LSym]struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="hashVar">
               <h3>
                  hashVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hashVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="instrumentMove">
               <h3>
                  instrumentMove 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const instrumentMove</code></pre>
            </article>
            
            <article class="global" data-name="instrumentRead">
               <h3>
                  instrumentRead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const instrumentRead = iota</code></pre>
            </article>
            
            <article class="global" data-name="instrumentWrite">
               <h3>
                  instrumentWrite 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const instrumentWrite</code></pre>
            </article>
            
            <article class="global" data-name="intrinsics">
               <h3>
                  intrinsics 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var intrinsics intrinsicBuilders</code></pre>
            </article>
            
            <article class="global" data-name="largeStackFrames">
               <h3>
                  largeStackFrames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var largeStackFrames []largeStack</code></pre>
            </article>
            
            <article class="global" data-name="largeStackFramesMu">
               <h3>
                  largeStackFramesMu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var largeStackFramesMu sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="lenVar">
               <h3>
                  lenVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lenVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxStackSize">
               <h3>
                  maxStackSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxStackSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="memVar">
               <h3>
                  memVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>marker node for the memory variable</p>
               
               <pre><code>var memVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="nowritebarrierrecCheck">
               <h3>
                  nowritebarrierrecCheck 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nowritebarrierrecCheck *nowritebarrierrecChecker</code></pre>
            </article>
            
            <article class="global" data-name="okVar">
               <h3>
                  okVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var okVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="opToSSA">
               <h3>
                  opToSSA 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var opToSSA = map[opAndType]ssa.Op{...}</code></pre>
            </article>
            
            <article class="global" data-name="ptrVar">
               <h3>
                  ptrVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>marker nodes for temporary variables</p>
               
               <pre><code>var ptrVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="shareDeferExits">
               <h3>
                  shareDeferExits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>If true, share as many open-coded defer exits as possible (with the downside of
worse line-number information)</p>
               
               <pre><code>const shareDeferExits = false</code></pre>
            </article>
            
            <article class="global" data-name="shiftOpToSSA">
               <h3>
                  shiftOpToSSA 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var shiftOpToSSA = map[opAndTwoTypes]ssa.Op{...}</code></pre>
            </article>
            
            <article class="global" data-name="skipCap">
               <h3>
                  skipCap 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const skipCap</code></pre>
            </article>
            
            <article class="global" data-name="skipLen">
               <h3>
                  skipLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const skipLen</code></pre>
            </article>
            
            <article class="global" data-name="skipPtr">
               <h3>
                  skipPtr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const skipPtr skipMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="smallBlocks">
               <h3>
                  smallBlocks 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const smallBlocks = 500</code></pre>
            </article>
            
            <article class="global" data-name="softFloatOps">
               <h3>
                  softFloatOps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var softFloatOps map[ssa.Op]sfRtCallDef</code></pre>
            </article>
            
            <article class="global" data-name="ssaCaches">
               <h3>
                  ssaCaches 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssaCaches []ssa.Cache</code></pre>
            </article>
            
            <article class="global" data-name="ssaConfig">
               <h3>
                  ssaConfig 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssaConfig *ssa.Config</code></pre>
            </article>
            
            <article class="global" data-name="ssaDir">
               <h3>
                  ssaDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssaDir string</code></pre>
            </article>
            
            <article class="global" data-name="ssaDump">
               <h3>
                  ssaDump 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssaDump string</code></pre>
            </article>
            
            <article class="global" data-name="ssaDumpCFG">
               <h3>
                  ssaDumpCFG 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssaDumpCFG string</code></pre>
            </article>
            
            <article class="global" data-name="ssaDumpFile">
               <h3>
                  ssaDumpFile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ssaDumpFile = "ssa.html"</code></pre>
            </article>
            
            <article class="global" data-name="ssaDumpInlined">
               <h3>
                  ssaDumpInlined 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ssaDumpInlined holds all inlined functions when ssaDump contains a function name.</p>
               
               <pre><code>var ssaDumpInlined []*ir.Func</code></pre>
            </article>
            
            <article class="global" data-name="ssaDumpStdout">
               <h3>
                  ssaDumpStdout 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssaDumpStdout bool</code></pre>
            </article>
            
            <article class="global" data-name="typVar">
               <h3>
                  typVar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var typVar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="u32_f32">
               <h3>
                  u32_f32 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var u32_f32 = u322fcvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="u32_f64">
               <h3>
                  u32_f64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var u32_f64 = u322fcvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="u64_f32">
               <h3>
                  u64_f32 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var u64_f32 = u642fcvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="u64_f64">
               <h3>
                  u64_f64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var u64_f64 = u642fcvtTab{...}</code></pre>
            </article>
            
            <article class="global" data-name="uint64fpConvOpToSSA">
               <h3>
                  uint64fpConvOpToSSA 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>uint64<->float conversions, only on machines that have instructions for that</p>
               
               <pre><code>var uint64fpConvOpToSSA = map[twoTypes]twoOpsAndType{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="callKind">
               <h3>
                  callKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type callKind int8</code></pre>
            </article>
            
            <article class="type" data-name="instrumentKind">
               <h3>
                  instrumentKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type instrumentKind uint8</code></pre>
            </article>
            
            <article class="type" data-name="intrinsicBuilder">
               <h3>
                  intrinsicBuilder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An intrinsicBuilder converts a call node n into an ssa value that
implements that call as an intrinsic. args is a list of arguments to the func.</p>
               
               <pre><code>type intrinsicBuilder func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="type" data-name="intrinsicBuilders">
               <h3>
                  intrinsicBuilders
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type intrinsicBuilders map[intrinsicKey]intrinsicBuilder</code></pre>
            </article>
            
            <article class="type" data-name="skipMask">
               <h3>
                  skipMask
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type skipMask uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ArchInfo">
               <h3>
                  ArchInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ArchInfo struct {
LinkArch *obj.LinkArch
REGSP int
MAXWIDTH int64
SoftFloat bool
PadFrame func(int64) int64
ZeroRange func(*objw.Progs, *obj.Prog, int64, int64, *uint32) *obj.Prog
Ginsnop func(*objw.Progs) *obj.Prog
SSAMarkMoves func(*State, *ssa.Block)
SSAGenValue func(*State, *ssa.Value)
SSAGenBlock func(s *State, b *ssa.Block, next *ssa.Block)
LoadRegResult func(s *State, f *ssa.Func, t *types.Type, reg int16, n *ir.Name, off int64) *obj.Prog
SpillArgReg func(pp *objw.Progs, p *obj.Prog, f *ssa.Func, t *types.Type, reg int16, n *ir.Name, off int64) *obj.Prog
}</code></pre>
            </article>
            
            <article class="struct" data-name="Branch">
               <h3>
                  Branch
                  <span class="badge">struct</span>
               </h3>
               
               <p>Branch is an unresolved branch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Branch struct {
P *obj.Prog
B *ssa.Block
}</code></pre>
            </article>
            
            <article class="struct" data-name="IndexJump">
               <h3>
                  IndexJump
                  <span class="badge">struct</span>
               </h3>
               
               <p>For generating consecutive jump instructions to model a specific branching</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IndexJump struct {
Jump obj.As
Index int
}</code></pre>
            </article>
            
            <article class="struct" data-name="State">
               <h3>
                  State
                  <span class="badge">struct</span>
               </h3>
               
               <p>State contains state needed during Prog generation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type State struct {
ABI obj.ABI
pp *objw.Progs
Branches []Branch
JumpTables []*ssa.Block
bstart []*obj.Prog
maxarg int64
livenessMap liveness.Map
partLiveArgs map[*ir.Name]bool
lineRunStart *obj.Prog
OnWasmStackSkipped int
}</code></pre>
            </article>
            
            <article class="struct" data-name="SymABIs">
               <h3>
                  SymABIs
                  <span class="badge">struct</span>
               </h3>
               
               <p>SymABIs records information provided by the assembler about symbol
definition ABIs and reference ABIs.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SymABIs struct {
defs map[string]obj.ABI
refs map[string]obj.ABISet
}</code></pre>
            </article>
            
            <article class="struct" data-name="blockHeap">
               <h3>
                  blockHeap
                  <span class="badge">struct</span>
               </h3>
               
               <p>A block heap is used as a priority queue to implement the PiggyBank
from Sreedhar and Gao.  That paper uses an array which is better
asymptotically but worse in the common case when the PiggyBank
holds a sparse set of blocks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type blockHeap struct {
a []*ssa.Block
level []int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="domBlock">
               <h3>
                  domBlock
                  <span class="badge">struct</span>
               </h3>
               
               <p>domBlock contains extra per-block information to record the dominator tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type domBlock struct {
firstChild *ssa.Block
sibling *ssa.Block
}</code></pre>
            </article>
            
            <article class="struct" data-name="f2uCvtTab">
               <h3>
                  f2uCvtTab
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type f2uCvtTab struct {
ltf ssa.Op
cvt2U ssa.Op
subf ssa.Op
or ssa.Op
floatValue func(*state, *types.Type, float64) *ssa.Value
intValue func(*state, *types.Type, int64) *ssa.Value
cutoff uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="funcLine">
               <h3>
                  funcLine
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type funcLine struct {
f *obj.LSym
base *src.PosBase
line uint
}</code></pre>
            </article>
            
            <article class="struct" data-name="fwdRefAux">
               <h3>
                  fwdRefAux
                  <span class="badge">struct</span>
               </h3>
               
               <p>fwdRefAux wraps an arbitrary ir.Node as an ssa.Aux for use with OpFwdref.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fwdRefAux struct {
_ [0]func()
N ir.Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="intrinsicBuildConfig">
               <h3>
                  intrinsicBuildConfig
                  <span class="badge">struct</span>
               </h3>
               
               <p>intrinsicBuildConfig specifies the config to use for intrinsic building.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type intrinsicBuildConfig struct {
instrumenting bool
go386 string
goamd64 int
goarm buildcfg.GoarmFeatures
goarm64 buildcfg.Goarm64Features
gomips string
gomips64 string
goppc64 int
goriscv64 int
}</code></pre>
            </article>
            
            <article class="struct" data-name="intrinsicKey">
               <h3>
                  intrinsicKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type intrinsicKey struct {
arch *sys.Arch
pkg string
fn string
}</code></pre>
            </article>
            
            <article class="struct" data-name="largeStack">
               <h3>
                  largeStack
                  <span class="badge">struct</span>
               </h3>
               
               <p>largeStack is info about a function whose stack frame is too large (rare).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type largeStack struct {
locals int64
args int64
callee int64
pos src.XPos
}</code></pre>
            </article>
            
            <article class="struct" data-name="nowritebarrierrecCall">
               <h3>
                  nowritebarrierrecCall
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nowritebarrierrecCall struct {
target *ir.Func
lineno src.XPos
}</code></pre>
            </article>
            
            <article class="struct" data-name="nowritebarrierrecChecker">
               <h3>
                  nowritebarrierrecChecker
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nowritebarrierrecChecker struct {
extraCalls map[*ir.Func][]nowritebarrierrecCall
curfn *ir.Func
}</code></pre>
            </article>
            
            <article class="struct" data-name="opAndTwoTypes">
               <h3>
                  opAndTwoTypes
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type opAndTwoTypes struct {
op ir.Op
etype1 types.Kind
etype2 types.Kind
}</code></pre>
            </article>
            
            <article class="struct" data-name="opAndType">
               <h3>
                  opAndType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type opAndType struct {
op ir.Op
etype types.Kind
}</code></pre>
            </article>
            
            <article class="struct" data-name="openDeferInfo">
               <h3>
                  openDeferInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>Information about each open-coded defer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type openDeferInfo struct {
n *ir.CallExpr
closure *ssa.Value
closureNode *ir.Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="phiState">
               <h3>
                  phiState
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type phiState struct {
s *state
f *ssa.Func
defvars []map[ir.Node]*ssa.Value
varnum map[ir.Node]int32
idom []*ssa.Block
tree []domBlock
level []int32
priq blockHeap
q []*ssa.Block
queued *sparseSet
hasPhi *sparseSet
hasDef *sparseSet
placeholder *ssa.Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="sfRtCallDef">
               <h3>
                  sfRtCallDef
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sfRtCallDef struct {
rtfn *obj.LSym
rtype types.Kind
}</code></pre>
            </article>
            
            <article class="struct" data-name="simplePhiState">
               <h3>
                  simplePhiState
                  <span class="badge">struct</span>
               </h3>
               
               <p>Variant to use for small functions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type simplePhiState struct {
s *state
f *ssa.Func
fwdrefs []*ssa.Value
defvars []map[ir.Node]*ssa.Value
reachable []bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="sparseSet">
               <h3>
                  sparseSet
                  <span class="badge">struct</span>
               </h3>
               
               <p>copy of ../ssa/sparseset.go
TODO: move this file to ../ssa, then use sparseSet there.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sparseSet struct {
dense []ssa.ID
sparse []int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="ssaLabel">
               <h3>
                  ssaLabel
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ssaLabel struct {
target *ssa.Block
breakTarget *ssa.Block
continueTarget *ssa.Block
}</code></pre>
            </article>
            
            <article class="struct" data-name="ssafn">
               <h3>
                  ssafn
                  <span class="badge">struct</span>
               </h3>
               
               <p>ssafn holds frontend information about a function that the backend is processing.
It also exports a bunch of compiler services for the ssa backend.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ssafn struct {
curfn *ir.Func
strings map[string]*obj.LSym
stksize int64
stkptrsize int64
stkalign int64
log bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="state">
               <h3>
                  state
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type state struct {
config *ssa.Config
f *ssa.Func
curfn *ir.Func
labels map[string]*ssaLabel
breakTo *ssa.Block
continueTo *ssa.Block
curBlock *ssa.Block
vars map[ir.Node]*ssa.Value
fwdVars map[ir.Node]*ssa.Value
defvars []map[ir.Node]*ssa.Value
decladdrs map[*ir.Name]*ssa.Value
startmem *ssa.Value
sp *ssa.Value
sb *ssa.Value
deferBitsAddr *ssa.Value
deferBitsTemp *ir.Name
line []src.XPos
lastPos src.XPos
panics map[funcLine]*ssa.Block
cgoUnsafeArgs bool
hasdefer bool
softFloat bool
hasOpenDefers bool
checkPtrEnabled bool
instrumentEnterExit bool
instrumentMemory bool
openDefers []*openDeferInfo
lastDeferExit *ssa.Block
lastDeferFinalBlock *ssa.Block
lastDeferCount int
prevCall *ssa.Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="twoOpsAndType">
               <h3>
                  twoOpsAndType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type twoOpsAndType struct {
op1 ssa.Op
op2 ssa.Op
intermediateType types.Kind
}</code></pre>
            </article>
            
            <article class="struct" data-name="twoTypes">
               <h3>
                  twoTypes
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type twoTypes struct {
etype1 types.Kind
etype2 types.Kind
}</code></pre>
            </article>
            
            <article class="struct" data-name="u322fcvtTab">
               <h3>
                  u322fcvtTab
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type u322fcvtTab struct {
cvtI2F ssa.Op
cvtF2F ssa.Op
}</code></pre>
            </article>
            
            <article class="struct" data-name="u642fcvtTab">
               <h3>
                  u642fcvtTab
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type u642fcvtTab struct {
leq ssa.Op
cvt2F ssa.Op
and ssa.Op
rsh ssa.Op
or ssa.Op
add ssa.Op
one func(*state, *types.Type, int64) *ssa.Value
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AbiForBodylessFuncStackMap">
               <h3>
                  AbiForBodylessFuncStackMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AbiForBodylessFuncStackMap returns the ABI for a bodyless function's stack map.
This is not necessarily the ABI used to call it.
Currently (1.17 dev) such a stack map is always ABI0;
any ABI wrapper that is present is nosplit, hence a precise
stack map is not needed there (the parameters survive only long
enough to call the wrapped assembly function).
This always returns a freshly copied ABI.</p>
               
               <pre><code>func AbiForBodylessFuncStackMap(fn *ir.Func) *abi.ABIConfig</code></pre>
            </article>
            
            <article class="function" data-name="AddAux">
               <h3>
                  AddAux 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddAux adds the offset in the aux fields (AuxInt and Aux) of v to a.</p>
               
               <pre><code>func AddAux(a *obj.Addr, v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="AddAux2">
               <h3>
                  AddAux2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func AddAux2(a *obj.Addr, v *ssa.Value, offset int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddrAuto">
               <h3>
                  AddrAuto 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func AddrAuto(a *obj.Addr, v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="AllocFrame">
               <h3>
                  AllocFrame 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ssafn) AllocFrame(f *ssa.Func)</code></pre>
            </article>
            
            <article class="function" data-name="Br">
               <h3>
                  Br 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Br emits a single branch instruction and returns the instruction.
Not all architectures need the returned instruction, but otherwise
the boilerplate is common to all.</p>
               
               <pre><code>func (s *State) Br(op obj.As, target *ssa.Block) *obj.Prog</code></pre>
            </article>
            
            <article class="function" data-name="Call">
               <h3>
                  Call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Call returns a new CALL instruction for the SSA value v.
It uses PrepareCall to prepare the call.</p>
               
               <pre><code>func (s *State) Call(v *ssa.Value) *obj.Prog</code></pre>
            </article>
            
            <article class="function" data-name="CanBeAnSSAAux">
               <h3>
                  CanBeAnSSAAux 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fwdRefAux) CanBeAnSSAAux()</code></pre>
            </article>
            
            <article class="function" data-name="CheckArgReg">
               <h3>
                  CheckArgReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckArgReg ensures that v is in the function's entry block.</p>
               
               <pre><code>func CheckArgReg(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="CheckLargeStacks">
               <h3>
                  CheckLargeStacks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func CheckLargeStacks()</code></pre>
            </article>
            
            <article class="function" data-name="CheckLoweredGetClosurePtr">
               <h3>
                  CheckLoweredGetClosurePtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckLoweredGetClosurePtr checks that v is the first instruction in the function's entry block,
except for incoming in-register arguments.
The output of LoweredGetClosurePtr is generally hardwired to the correct register.
That register contains the closure pointer on closure entry.</p>
               
               <pre><code>func CheckLoweredGetClosurePtr(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="CheckLoweredPhi">
               <h3>
                  CheckLoweredPhi 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckLoweredPhi checks that regalloc and stackalloc correctly handled phi values.
Called during ssaGenValue.</p>
               
               <pre><code>func CheckLoweredPhi(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="CombJump">
               <h3>
                  CombJump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CombJump generates combinational instructions (2 at present) for a block jump,
thereby the behaviour of non-standard condition codes could be simulated</p>
               
               <pre><code>func (s *State) CombJump(b *ssa.Block, next *ssa.Block, jumps *[2][2]IndexJump)</code></pre>
            </article>
            
            <article class="function" data-name="Compile">
               <h3>
                  Compile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Compile builds an SSA backend function,
uses it to generate a plist,
and flushes that plist to machine code.
worker indicates which of the backend workers is doing the processing.</p>
               
               <pre><code>func Compile(fn *ir.Func, worker int, profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function" data-name="CreateWasmImportWrapper">
               <h3>
                  CreateWasmImportWrapper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CreateWasmImportWrapper creates a wrapper for imported WASM functions to
adapt them to the Go calling convention. The body for this function is
generated in cmd/internal/obj/wasm/wasmobj.go</p>
               
               <pre><code>func CreateWasmImportWrapper(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="DebugFriendlySetPosFrom">
               <h3>
                  DebugFriendlySetPosFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DebugFriendlySetPosFrom adjusts Pos.IsStmt subject to heuristics
that reduce "jumpy" line number churn when debugging.
Spill/fill/copy instructions from the register allocator,
phi functions, and instructions with a no-pos position
are examples of instructions that can cause churn.</p>
               
               <pre><code>func (s *State) DebugFriendlySetPosFrom(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="Debug_checknil">
               <h3>
                  Debug_checknil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) Debug_checknil() bool</code></pre>
            </article>
            
            <article class="function" data-name="Debug_checknil">
               <h3>
                  Debug_checknil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ssafn) Debug_checknil() bool</code></pre>
            </article>
            
            <article class="function" data-name="DumpInline">
               <h3>
                  DumpInline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func DumpInline(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="EmitArgInfo">
               <h3>
                  EmitArgInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>emit argument info (locations on stack) of f for traceback.</p>
               
               <pre><code>func EmitArgInfo(f *ir.Func, abiInfo *abi.ABIParamResultInfo) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="EnableNoWriteBarrierRecCheck">
               <h3>
                  EnableNoWriteBarrierRecCheck 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func EnableNoWriteBarrierRecCheck()</code></pre>
            </article>
            
            <article class="function" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fatalf reports a compiler error and exits.</p>
               
               <pre><code>func (e *ssafn) Fatalf(pos src.XPos, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) Fatalf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Func">
               <h3>
                  Func 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ssafn) Func() *ir.Func</code></pre>
            </article>
            
            <article class="function" data-name="FuncInfo">
               <h3>
                  FuncInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *State) FuncInfo() *obj.FuncInfo</code></pre>
            </article>
            
            <article class="function" data-name="GenABIWrappers">
               <h3>
                  GenABIWrappers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GenABIWrappers applies ABI information to Funcs and generates ABI
wrapper functions where necessary.</p>
               
               <pre><code>func (s *SymABIs) GenABIWrappers()</code></pre>
            </article>
            
            <article class="function" data-name="GenWasmExportWrapper">
               <h3>
                  GenWasmExportWrapper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func GenWasmExportWrapper(wrapped *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="InitConfig">
               <h3>
                  InitConfig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func InitConfig()</code></pre>
            </article>
            
            <article class="function" data-name="InitEnv">
               <h3>
                  InitEnv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func InitEnv()</code></pre>
            </article>
            
            <article class="function" data-name="InitTables">
               <h3>
                  InitTables 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func InitTables()</code></pre>
            </article>
            
            <article class="function" data-name="IsIntrinsicCall">
               <h3>
                  IsIntrinsicCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsIntrinsicCall(n *ir.CallExpr) bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *blockHeap) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *blockHeap) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) Log() bool</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ssafn) Log() bool</code></pre>
            </article>
            
            <article class="function" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Logf logs a message from the compiler.</p>
               
               <pre><code>func (e *ssafn) Logf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) Logf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="NewSymABIs">
               <h3>
                  NewSymABIs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSymABIs() *SymABIs</code></pre>
            </article>
            
            <article class="function" data-name="NoWriteBarrierRecCheck">
               <h3>
                  NoWriteBarrierRecCheck 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NoWriteBarrierRecCheck()</code></pre>
            </article>
            
            <article class="function" data-name="Pc">
               <h3>
                  Pc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pc returns the current Prog.</p>
               
               <pre><code>func (s *State) Pc() *obj.Prog</code></pre>
            </article>
            
            <article class="function" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *blockHeap) Pop() interface{}</code></pre>
            </article>
            
            <article class="function" data-name="PrepareCall">
               <h3>
                  PrepareCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PrepareCall prepares to emit a CALL instruction for v and does call-related bookkeeping.
It must be called immediately before emitting the actual CALL instruction,
since it emits PCDATA for the stack map at the call (calls are safe points).</p>
               
               <pre><code>func (s *State) PrepareCall(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="Prog">
               <h3>
                  Prog 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prog appends a new Prog.</p>
               
               <pre><code>func (s *State) Prog(as obj.As) *obj.Prog</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *blockHeap) Push(x interface{})</code></pre>
            </article>
            
            <article class="function" data-name="ReadSymABIs">
               <h3>
                  ReadSymABIs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadSymABIs reads a symabis file that specifies definitions and
references of text symbols by ABI.
The symabis format is a set of lines, where each line is a sequence
of whitespace-separated fields. The first field is a verb and is
either "def" for defining a symbol ABI or "ref" for referencing a
symbol using an ABI. For both "def" and "ref", the second field is
the symbol name and the third field is the ABI name, as one of the
named cmd/internal/obj.ABI constants.</p>
               
               <pre><code>func (s *SymABIs) ReadSymABIs(file string)</code></pre>
            </article>
            
            <article class="function" data-name="RegisterMapInitLsym">
               <h3>
                  RegisterMapInitLsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RegisterMapInitLsym records "s" in the set of outlined map initializer
functions.</p>
               
               <pre><code>func RegisterMapInitLsym(s *obj.LSym)</code></pre>
            </article>
            
            <article class="function" data-name="SetPos">
               <h3>
                  SetPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetPos sets the current source position.</p>
               
               <pre><code>func (s *State) SetPos(pos src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="SpillSlotAddr">
               <h3>
                  SpillSlotAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SpillSlotAddr uses LocalSlot information to initialize an obj.Addr
The resulting addr is used in a non-standard context -- in the prologue
of a function, before the frame has been constructed, so the standard
addressing for the parameters will be wrong.</p>
               
               <pre><code>func SpillSlotAddr(spill ssa.Spill, baseReg int16, extraOffset int64) obj.Addr</code></pre>
            </article>
            
            <article class="function" data-name="SplitSlot">
               <h3>
                  SplitSlot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SplitSlot returns a slot representing the data of parent starting at offset.</p>
               
               <pre><code>func (e *ssafn) SplitSlot(parent *ssa.LocalSlot, suffix string, offset int64, t *types.Type) ssa.LocalSlot</code></pre>
            </article>
            
            <article class="function" data-name="StackOffset">
               <h3>
                  StackOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StackOffset returns the stack location of a LocalSlot relative to the
stack pointer, suitable for use in a DWARF location entry. This has nothing
to do with its offset in the user variable.</p>
               
               <pre><code>func StackOffset(slot ssa.LocalSlot) int32</code></pre>
            </article>
            
            <article class="function" data-name="StringData">
               <h3>
                  StringData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StringData returns a symbol which
is the data component of a global string constant containing s.</p>
               
               <pre><code>func (e *ssafn) StringData(s string) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *blockHeap) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Syslook">
               <h3>
                  Syslook 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ssafn) Syslook(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="TailCall">
               <h3>
                  TailCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TailCall returns a new tail call instruction for the SSA value v.
It is like Call, but for a tail call.</p>
               
               <pre><code>func (s *State) TailCall(v *ssa.Value) *obj.Prog</code></pre>
            </article>
            
            <article class="function" data-name="UseArgs">
               <h3>
                  UseArgs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UseArgs records the fact that an instruction needs a certain amount of
callee args space for its use.</p>
               
               <pre><code>func (s *State) UseArgs(n int64)</code></pre>
            </article>
            
            <article class="function" data-name="UseWriteBarrier">
               <h3>
                  UseWriteBarrier 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ssafn) UseWriteBarrier() bool</code></pre>
            </article>
            
            <article class="function" data-name="Warnl">
               <h3>
                  Warnl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Warnl reports a "warning", which is usually flag-triggered
logging output for the benefit of tests.</p>
               
               <pre><code>func (e *ssafn) Warnl(pos src.XPos, fmt_ string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Warnl">
               <h3>
                  Warnl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) Warnl(pos src.XPos, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="abiForFunc">
               <h3>
                  abiForFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>abiForFunc implements ABI policy for a function, but does not return a copy of the ABI.
Passing a nil function returns the default ABI based on experiment configuration.</p>
               
               <pre><code>func abiForFunc(fn *ir.Func, abi0 *abi.ABIConfig, abi1 *abi.ABIConfig) *abi.ABIConfig</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add adds the intrinsic builder b for pkg.fn for the given architecture.</p>
               
               <pre><code>func (ib intrinsicBuilders) add(arch *sys.Arch, pkg string, fn string, b intrinsicBuilder)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *sparseSet) add(x ssa.ID)</code></pre>
            </article>
            
            <article class="function" data-name="addForArchs">
               <h3>
                  addForArchs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addForArchs adds the intrinsic builder b for pkg.fn for the given architectures.</p>
               
               <pre><code>func (ib intrinsicBuilders) addForArchs(pkg string, fn string, b intrinsicBuilder, archs ...*sys.Arch)</code></pre>
            </article>
            
            <article class="function" data-name="addForFamilies">
               <h3>
                  addForFamilies 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addForFamilies does the same as addForArchs but operates on architecture families.</p>
               
               <pre><code>func (ib intrinsicBuilders) addForFamilies(pkg string, fn string, b intrinsicBuilder, archFamilies ...sys.ArchFamily)</code></pre>
            </article>
            
            <article class="function" data-name="addNamedValue">
               <h3>
                  addNamedValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) addNamedValue(n *ir.Name, v *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addr converts the address of the expression n to SSA, adds it to s and returns the SSA result.
The value that the returned Value represents is guaranteed to be non-nil.</p>
               
               <pre><code>func (s *state) addr(n ir.Node) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="alias">
               <h3>
                  alias 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>alias aliases pkg.fn to targetPkg.targetFn for all architectures in archs
for which targetPkg.targetFn already exists.</p>
               
               <pre><code>func (ib intrinsicBuilders) alias(pkg string, fn string, targetPkg string, targetFn string, archs ...*sys.Arch)</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>append converts an OAPPEND node to SSA.
If inplace is false, it converts the OAPPEND expression n to an ssa.Value,
adds it to s, and returns the Value.
If inplace is true, it writes the result of the OAPPEND expression n
back to the slice being appended to, and returns nil.
inplace MUST be set to false if the slice can be SSA'd.
Note: this code only handles fixed-count appends. Dotdotdot appends
have already been rewritten at this point (by walk).</p>
               
               <pre><code>func (s *state) append(n *ir.CallExpr, inplace bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assign does left = right.
Right has already been evaluated to ssa, left has not.
If deref is true, then we do left = *right instead (and right has already been nil-checked).
If deref is true and right == nil, just do left = 0.
skip indicates assignments (at the top level) that can be avoided.
mayOverlap indicates whether left&right might partially overlap in memory. Default is false.</p>
               
               <pre><code>func (s *state) assign(left ir.Node, right *ssa.Value, deref bool, skip skipMask)</code></pre>
            </article>
            
            <article class="function" data-name="assignWhichMayOverlap">
               <h3>
                  assignWhichMayOverlap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) assignWhichMayOverlap(left ir.Node, right *ssa.Value, deref bool, skip skipMask, mayOverlap bool)</code></pre>
            </article>
            
            <article class="function" data-name="boundsCheck">
               <h3>
                  boundsCheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>boundsCheck generates bounds checking code. Checks if 0 <= idx <[=] len, branches to exit if not.
Starts a new block on return.
On input, len must be converted to full int width and be nonnegative.
Returns idx converted to full int width.
If bounded is true then caller guarantees the index is not out of bounds
(but boundsCheck will still extend the index to full int width).</p>
               
               <pre><code>func (s *state) boundsCheck(idx *ssa.Value, len *ssa.Value, kind ssa.BoundsKind, bounded bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="buildssa">
               <h3>
                  buildssa 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>buildssa builds an SSA function for fn.
worker indicates which of the backend workers is doing the processing.</p>
               
               <pre><code>func buildssa(fn *ir.Func, worker int, isPgoHot bool) *ssa.Func</code></pre>
            </article>
            
            <article class="function" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Calls the function n using the specified call type.
Returns the address of the return value (or nil if none).</p>
               
               <pre><code>func (s *state) call(n *ir.CallExpr, k callKind, returnResultAddr bool, deferExtra ir.Expr) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="callAddr">
               <h3>
                  callAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) callAddr(n *ir.CallExpr, k callKind) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="callResult">
               <h3>
                  callResult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) callResult(n *ir.CallExpr, k callKind) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="callTargetLSym">
               <h3>
                  callTargetLSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>callTargetLSym returns the correct LSym to call 'callee' using its ABI.</p>
               
               <pre><code>func callTargetLSym(callee *ir.Name) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="canSSA">
               <h3>
                  canSSA 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>canSSA reports whether n is SSA-able.
n must be an ONAME (or an ODOT sequence with an ONAME base).</p>
               
               <pre><code>func (s *state) canSSA(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="canSSAName">
               <h3>
                  canSSAName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) canSSAName(name *ir.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="canonicalize">
               <h3>
                  canonicalize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>canonicalize returns the canonical name used for a linker symbol in
s's maps. Symbols in this package may be written either as "".X or
with the package's import path already in the symbol. This rewrites
both to use the full path, which matches compiler-generated linker
symbol names.</p>
               
               <pre><code>func (s *SymABIs) canonicalize(linksym string) string</code></pre>
            </article>
            
            <article class="function" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>If cmp (a bool) is false, panic using the given function.</p>
               
               <pre><code>func (s *state) check(cmp *ssa.Value, fn *obj.LSym)</code></pre>
            </article>
            
            <article class="function" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *nowritebarrierrecChecker) check()</code></pre>
            </article>
            
            <article class="function" data-name="checkPtrAlignment">
               <h3>
                  checkPtrAlignment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) checkPtrAlignment(n *ir.ConvExpr, v *ssa.Value, count *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="clear">
               <h3>
                  clear 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *sparseSet) clear()</code></pre>
            </article>
            
            <article class="function" data-name="clobberBase">
               <h3>
                  clobberBase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func clobberBase(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="cmpstackvarlt">
               <h3>
                  cmpstackvarlt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cmpstackvarlt reports whether the stack variable a sorts before b.</p>
               
               <pre><code>func cmpstackvarlt(a *ir.Name, b *ir.Name, mls *liveness.MergeLocalsState) bool</code></pre>
            </article>
            
            <article class="function" data-name="concreteEtype">
               <h3>
                  concreteEtype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) concreteEtype(t *types.Type) types.Kind</code></pre>
            </article>
            
            <article class="function" data-name="condBranch">
               <h3>
                  condBranch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>condBranch evaluates the boolean expression cond and branches to yes
if cond is true and no if cond is false.
This function is intended to handle && and || better than just calling
s.expr(cond) and branching on the result.</p>
               
               <pre><code>func (s *state) condBranch(cond ir.Node, yes *ssa.Block, no *ssa.Block, likely int8)</code></pre>
            </article>
            
            <article class="function" data-name="constBool">
               <h3>
                  constBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constBool(c bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constEmptyString">
               <h3>
                  constEmptyString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constEmptyString(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constFloat32">
               <h3>
                  constFloat32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constFloat32(t *types.Type, c float64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constFloat64">
               <h3>
                  constFloat64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constFloat64(t *types.Type, c float64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constInt">
               <h3>
                  constInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constInt(t *types.Type, c int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constInt16">
               <h3>
                  constInt16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constInt16(t *types.Type, c int16) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constInt32">
               <h3>
                  constInt32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constInt32(t *types.Type, c int32) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constInt64">
               <h3>
                  constInt64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constInt64(t *types.Type, c int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constInt8">
               <h3>
                  constInt8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constInt8(t *types.Type, c int8) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constInterface">
               <h3>
                  constInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constInterface(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constNil">
               <h3>
                  constNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constNil(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constOffPtrSP">
               <h3>
                  constOffPtrSP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) constOffPtrSP(t *types.Type, c int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="constSlice">
               <h3>
                  constSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>const* routines add a new const value to the entry block.</p>
               
               <pre><code>func (s *state) constSlice(t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="contains">
               <h3>
                  contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *sparseSet) contains(x ssa.ID) bool</code></pre>
            </article>
            
            <article class="function" data-name="conv">
               <h3>
                  conv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) conv(n ir.Node, v *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="deferstruct">
               <h3>
                  deferstruct 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>deferstruct returns a type interchangeable with runtime._defer.
Make sure this stays in sync with runtime/runtime2.go:_defer.</p>
               
               <pre><code>func deferstruct() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="defframe">
               <h3>
                  defframe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func defframe(s *State, e *ssafn, f *ssa.Func)</code></pre>
            </article>
            
            <article class="function" data-name="dottype">
               <h3>
                  dottype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dottype generates SSA for a type assertion node.
commaok indicates whether to panic or return a bool.
If commaok is false, resok will be nil.</p>
               
               <pre><code>func (s *state) dottype(n *ir.TypeAssertExpr, commaok bool) (res *ssa.Value, resok *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="dottype1">
               <h3>
                  dottype1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dottype1 implements a x.(T) operation. iface is the argument (x), dst is the type we're asserting to (T)
and src is the type we're asserting from.
source is the *runtime._type of src
target is the *runtime._type of dst.
If src is a nonempty interface and dst is not an interface, targetItab is an itab representing (dst, src). Otherwise it is nil.
commaok is true if the caller wants a boolean success value. Otherwise, the generated code panics if the conversion fails.
descriptor is a compiler-allocated internal/abi.TypeAssert whose address is passed to runtime.typeAssert when
the target type is a compile-time-known non-empty interface. It may be nil.</p>
               
               <pre><code>func (s *state) dottype1(pos src.XPos, src *types.Type, dst *types.Type, iface *ssa.Value, source *ssa.Value, target *ssa.Value, targetItab *ssa.Value, commaok bool, descriptor *obj.LSym) (res *ssa.Value, resok *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="dumpSourcesColumn">
               <h3>
                  dumpSourcesColumn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpSourcesColumn(writer *ssa.HTMLWriter, fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="dynamicDottype">
               <h3>
                  dynamicDottype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) dynamicDottype(n *ir.DynamicTypeAssertExpr, commaok bool) (res *ssa.Value, resok *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="emitArgInfo">
               <h3>
                  emitArgInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>emit argument info (locations on stack) for traceback.</p>
               
               <pre><code>func emitArgInfo(e *ssafn, f *ssa.Func, pp *objw.Progs)</code></pre>
            </article>
            
            <article class="function" data-name="emitOpenDeferInfo">
               <h3>
                  emitOpenDeferInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emitOpenDeferInfo emits FUNCDATA information about the defers in a function
that is using open-coded defers.  This funcdata is used to determine the active
defers in a function and execute those defers during panic processing.
The funcdata is all encoded in varints (since values will almost always be less than
128, but stack offsets could potentially be up to 2Gbyte). All "locations" (offsets)
for stack variables are specified as the number of bytes below varp (pointer to the
top of the local variables) for their starting address. The format is:
- Offset of the deferBits variable
- Offset of the first closure slot (the rest are laid out consecutively).</p>
               
               <pre><code>func (s *state) emitOpenDeferInfo()</code></pre>
            </article>
            
            <article class="function" data-name="emitWrappedFuncInfo">
               <h3>
                  emitWrappedFuncInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>for wrapper, emit info of wrapped function.</p>
               
               <pre><code>func emitWrappedFuncInfo(e *ssafn, pp *objw.Progs)</code></pre>
            </article>
            
            <article class="function" data-name="endBlock">
               <h3>
                  endBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>endBlock marks the end of generating code for the current block.
Returns the (former) current block. Returns nil if there is no current
block, i.e. if no code flows to the current execution point.</p>
               
               <pre><code>func (s *state) endBlock() *ssa.Block</code></pre>
            </article>
            
            <article class="function" data-name="entryBlock">
               <h3>
                  entryBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) entryBlock() *ssa.Block</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue0">
               <h3>
                  entryNewValue0 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue0 adds a new value with no arguments to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue0(op ssa.Op, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue0A">
               <h3>
                  entryNewValue0A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue0A adds a new value with no arguments and an aux value to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue0A(op ssa.Op, t *types.Type, aux ssa.Aux) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue1">
               <h3>
                  entryNewValue1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue1 adds a new value with one argument to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue1A">
               <h3>
                  entryNewValue1A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue1A adds a new value with one argument and an aux value to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue1A(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue1I">
               <h3>
                  entryNewValue1I 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue1I adds a new value with one argument and an auxint value to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue1I(op ssa.Op, t *types.Type, auxint int64, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue2">
               <h3>
                  entryNewValue2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue2 adds a new value with two arguments to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="entryNewValue2A">
               <h3>
                  entryNewValue2A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryNewValue2A adds a new value with two arguments and an aux value to the entry block.</p>
               
               <pre><code>func (s *state) entryNewValue2A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="etypesign">
               <h3>
                  etypesign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>etypesign returns the signed-ness of e, for integer/pointer etypes.
-1 means signed, +1 means unsigned, 0 means non-integer/non-pointer.</p>
               
               <pre><code>func etypesign(e types.Kind) int8</code></pre>
            </article>
            
            <article class="function" data-name="exit">
               <h3>
                  exit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>exit processes any code that needs to be generated just before returning.
It returns a BlockRet block that ends the control flow. Its control value
will be set to the final memory state.</p>
               
               <pre><code>func (s *state) exit() *ssa.Block</code></pre>
            </article>
            
            <article class="function" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>expr converts the expression n to ssa, adds it to s and returns the ssa result.</p>
               
               <pre><code>func (s *state) expr(n ir.Node) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="exprCheckPtr">
               <h3>
                  exprCheckPtr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) exprCheckPtr(n ir.Node, checkPtrOK bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="exprPtr">
               <h3>
                  exprPtr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>exprPtr evaluates n to a pointer and nil-checks it.</p>
               
               <pre><code>func (s *state) exprPtr(n ir.Node, bounded bool, lineno src.XPos) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="extendIndex">
               <h3>
                  extendIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>extendIndex extends v to a full int width.
panic with the given kind if v does not fit in an int (only on 32-bit archs).</p>
               
               <pre><code>func (s *state) extendIndex(idx *ssa.Value, len *ssa.Value, kind ssa.BoundsKind, bounded bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="fieldIdx">
               <h3>
                  fieldIdx 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fieldIdx finds the index of the field referred to by the ODOT node n.</p>
               
               <pre><code>func fieldIdx(n *ir.SelectorExpr) int</code></pre>
            </article>
            
            <article class="function" data-name="fieldtrack">
               <h3>
                  fieldtrack 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fieldtrack adds R_USEFIELD relocations to fnsym to record any
struct fields that it used.</p>
               
               <pre><code>func fieldtrack(fnsym *obj.LSym, tracked map[*obj.LSym]struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="findExtraCalls">
               <h3>
                  findExtraCalls 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *nowritebarrierrecChecker) findExtraCalls(nn ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="findIntrinsic">
               <h3>
                  findIntrinsic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>findIntrinsic returns a function which builds the SSA equivalent of the
function identified by the symbol sym.  If sym is not an intrinsic call, returns nil.</p>
               
               <pre><code>func findIntrinsic(sym *types.Sym) intrinsicBuilder</code></pre>
            </article>
            
            <article class="function" data-name="float32ToUint32">
               <h3>
                  float32ToUint32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) float32ToUint32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="float32ToUint64">
               <h3>
                  float32ToUint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) float32ToUint64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="float64ToUint32">
               <h3>
                  float64ToUint32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) float64ToUint32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="float64ToUint64">
               <h3>
                  float64ToUint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) float64ToUint64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="floatToUint">
               <h3>
                  floatToUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) floatToUint(cvttab *f2uCvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="forEachWrapperABI">
               <h3>
                  forEachWrapperABI 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func forEachWrapperABI(fn *ir.Func, cb func(fn *ir.Func, wrapperABI obj.ABI))</code></pre>
            </article>
            
            <article class="function" data-name="genssa">
               <h3>
                  genssa 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>genssa appends entries to pp for each instruction in f.</p>
               
               <pre><code>func genssa(f *ssa.Func, pp *objw.Progs)</code></pre>
            </article>
            
            <article class="function" data-name="getClosureAndRcvr">
               <h3>
                  getClosureAndRcvr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getClosureAndRcvr returns values for the appropriate closure and receiver of an
interface call</p>
               
               <pre><code>func (s *state) getClosureAndRcvr(fn *ir.SelectorExpr) (*ssa.Value, *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="initIntrinsics">
               <h3>
                  initIntrinsics 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initIntrinsics(cfg *intrinsicBuildConfig)</code></pre>
            </article>
            
            <article class="function" data-name="insertPhis">
               <h3>
                  insertPhis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *phiState) insertPhis()</code></pre>
            </article>
            
            <article class="function" data-name="insertPhis">
               <h3>
                  insertPhis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *simplePhiState) insertPhis()</code></pre>
            </article>
            
            <article class="function" data-name="insertPhis">
               <h3>
                  insertPhis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insertPhis finds all the places in the function where a phi is
necessary and inserts them.
Uses FwdRef ops to find all uses of variables, and s.defvars to find
all definitions.
Phi values are inserted, and all FwdRefs are changed to a Copy
of the appropriate phi or definition.
TODO: make this part of cmd/compile/internal/ssa somehow?</p>
               
               <pre><code>func (s *state) insertPhis()</code></pre>
            </article>
            
            <article class="function" data-name="insertVarPhis">
               <h3>
                  insertVarPhis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *phiState) insertVarPhis(n int, var_ ir.Node, defs []*ssa.Block, typ *types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="instrument">
               <h3>
                  instrument 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) instrument(t *types.Type, addr *ssa.Value, kind instrumentKind)</code></pre>
            </article>
            
            <article class="function" data-name="instrument2">
               <h3>
                  instrument2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) instrument2(t *types.Type, addr *ssa.Value, addr2 *ssa.Value, kind instrumentKind)</code></pre>
            </article>
            
            <article class="function" data-name="instrumentFields">
               <h3>
                  instrumentFields 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>instrumentFields instruments a read/write operation on addr.
If it is instrumenting for MSAN or ASAN and t is a struct type, it instruments
operation for each field, instead of for the whole struct.</p>
               
               <pre><code>func (s *state) instrumentFields(t *types.Type, addr *ssa.Value, kind instrumentKind)</code></pre>
            </article>
            
            <article class="function" data-name="instrumentMove">
               <h3>
                  instrumentMove 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) instrumentMove(t *types.Type, dst *ssa.Value, src *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="intDivide">
               <h3>
                  intDivide 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) intDivide(n ir.Node, a *ssa.Value, b *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="intrinsicArgs">
               <h3>
                  intrinsicArgs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>intrinsicArgs extracts args from n, evaluates them to SSA values, and returns them.</p>
               
               <pre><code>func (s *state) intrinsicArgs(n *ir.CallExpr) []*ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="intrinsicCall">
               <h3>
                  intrinsicCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>intrinsicCall converts a call to a recognized intrinsic function into the intrinsic SSA operation.</p>
               
               <pre><code>func (s *state) intrinsicCall(n *ir.CallExpr) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="label">
               <h3>
                  label 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>label returns the label associated with sym, creating it if necessary.</p>
               
               <pre><code>func (s *state) label(sym *types.Sym) *ssaLabel</code></pre>
            </article>
            
            <article class="function" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) load(t *types.Type, src *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup looks up the intrinsic for a pkg.fn on the specified architecture.</p>
               
               <pre><code>func (ib intrinsicBuilders) lookup(arch *sys.Arch, pkg string, fn string) intrinsicBuilder</code></pre>
            </article>
            
            <article class="function" data-name="lookupVarOutgoing">
               <h3>
                  lookupVarOutgoing 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupVarOutgoing finds the variable's value at the end of block b.</p>
               
               <pre><code>func (s *simplePhiState) lookupVarOutgoing(b *ssa.Block, t *types.Type, var_ ir.Node, line src.XPos) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="makeABIWrapper">
               <h3>
                  makeABIWrapper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeABIWrapper creates a new function that will be called with
wrapperABI and calls "f" using f.ABI.</p>
               
               <pre><code>func makeABIWrapper(f *ir.Func, wrapperABI obj.ABI)</code></pre>
            </article>
            
            <article class="function" data-name="maybeNilCheckClosure">
               <h3>
                  maybeNilCheckClosure 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>maybeNilCheckClosure checks if a nil check of a closure is needed in some
architecture-dependent situations and, if so, emits the nil check.</p>
               
               <pre><code>func (s *state) maybeNilCheckClosure(closure *ssa.Value, k callKind)</code></pre>
            </article>
            
            <article class="function" data-name="mem">
               <h3>
                  mem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) mem() *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="minMax">
               <h3>
                  minMax 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>minMax converts an OMIN/OMAX builtin call into SSA.</p>
               
               <pre><code>func (s *state) minMax(n *ir.CallExpr) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="move">
               <h3>
                  move 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) move(t *types.Type, dst *ssa.Value, src *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="moveWhichMayOverlap">
               <h3>
                  moveWhichMayOverlap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) moveWhichMayOverlap(t *types.Type, dst *ssa.Value, src *ssa.Value, mayOverlap bool)</code></pre>
            </article>
            
            <article class="function" data-name="needAlloc">
               <h3>
                  needAlloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>needAlloc reports whether n is within the current frame, for which we need to
allocate space. In particular, it excludes arguments and results, which are in
the callers frame.</p>
               
               <pre><code>func needAlloc(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="newHeapaddr">
               <h3>
                  newHeapaddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newHeapaddr allocates heap memory for n and sets its heap address.</p>
               
               <pre><code>func (s *state) newHeapaddr(n *ir.Name)</code></pre>
            </article>
            
            <article class="function" data-name="newNowritebarrierrecChecker">
               <h3>
                  newNowritebarrierrecChecker 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newNowritebarrierrecChecker creates a nowritebarrierrecChecker. It
must be called before walk.</p>
               
               <pre><code>func newNowritebarrierrecChecker() *nowritebarrierrecChecker</code></pre>
            </article>
            
            <article class="function" data-name="newObject">
               <h3>
                  newObject 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newObject returns an SSA value denoting new(typ).</p>
               
               <pre><code>func (s *state) newObject(typ *types.Type, rtype *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newSparseSet">
               <h3>
                  newSparseSet 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newSparseSet returns a sparseSet that can represent
integers between 0 and n-1.</p>
               
               <pre><code>func newSparseSet(n int) *sparseSet</code></pre>
            </article>
            
            <article class="function" data-name="newValue0">
               <h3>
                  newValue0 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue0 adds a new value with no arguments to the current block.</p>
               
               <pre><code>func (s *state) newValue0(op ssa.Op, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue0A">
               <h3>
                  newValue0A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue0A adds a new value with no arguments and an aux value to the current block.</p>
               
               <pre><code>func (s *state) newValue0A(op ssa.Op, t *types.Type, aux ssa.Aux) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue0I">
               <h3>
                  newValue0I 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue0I adds a new value with no arguments and an auxint value to the current block.</p>
               
               <pre><code>func (s *state) newValue0I(op ssa.Op, t *types.Type, auxint int64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue1">
               <h3>
                  newValue1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue1 adds a new value with one argument to the current block.</p>
               
               <pre><code>func (s *state) newValue1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue1A">
               <h3>
                  newValue1A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue1A adds a new value with one argument and an aux value to the current block.</p>
               
               <pre><code>func (s *state) newValue1A(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue1Apos">
               <h3>
                  newValue1Apos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue1Apos adds a new value with one argument and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
               
               <pre><code>func (s *state) newValue1Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg *ssa.Value, isStmt bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue1I">
               <h3>
                  newValue1I 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue1I adds a new value with one argument and an auxint value to the current block.</p>
               
               <pre><code>func (s *state) newValue1I(op ssa.Op, t *types.Type, aux int64, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue2">
               <h3>
                  newValue2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue2 adds a new value with two arguments to the current block.</p>
               
               <pre><code>func (s *state) newValue2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue2A">
               <h3>
                  newValue2A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue2A adds a new value with two arguments and an aux value to the current block.</p>
               
               <pre><code>func (s *state) newValue2A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue2Apos">
               <h3>
                  newValue2Apos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue2Apos adds a new value with two arguments and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
               
               <pre><code>func (s *state) newValue2Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, isStmt bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue2I">
               <h3>
                  newValue2I 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue2I adds a new value with two arguments and an auxint value to the current block.</p>
               
               <pre><code>func (s *state) newValue2I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue3">
               <h3>
                  newValue3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue3 adds a new value with three arguments to the current block.</p>
               
               <pre><code>func (s *state) newValue3(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue3A">
               <h3>
                  newValue3A 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue3A adds a new value with three arguments and an aux value to the current block.</p>
               
               <pre><code>func (s *state) newValue3A(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue3Apos">
               <h3>
                  newValue3Apos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue3Apos adds a new value with three arguments and an aux value to the current block.
isStmt determines whether the created values may be a statement or not
(i.e., false means never, yes means maybe).</p>
               
               <pre><code>func (s *state) newValue3Apos(op ssa.Op, t *types.Type, aux ssa.Aux, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, isStmt bool) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue3I">
               <h3>
                  newValue3I 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue3I adds a new value with three arguments and an auxint value to the current block.</p>
               
               <pre><code>func (s *state) newValue3I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue4">
               <h3>
                  newValue4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue4 adds a new value with four arguments to the current block.</p>
               
               <pre><code>func (s *state) newValue4(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, arg3 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValue4I">
               <h3>
                  newValue4I 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValue4I adds a new value with four arguments and an auxint value to the current block.</p>
               
               <pre><code>func (s *state) newValue4I(op ssa.Op, t *types.Type, aux int64, arg0 *ssa.Value, arg1 *ssa.Value, arg2 *ssa.Value, arg3 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValueOrSfCall1">
               <h3>
                  newValueOrSfCall1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newValueOrSfCall* are wrappers around newValue*, which may create a call to a
soft-float runtime function instead (when emitting soft-float code).</p>
               
               <pre><code>func (s *state) newValueOrSfCall1(op ssa.Op, t *types.Type, arg *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="newValueOrSfCall2">
               <h3>
                  newValueOrSfCall2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) newValueOrSfCall2(op ssa.Op, t *types.Type, arg0 *ssa.Value, arg1 *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="nilCheck">
               <h3>
                  nilCheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nilCheck generates nil pointer checking code.
Used only for automatically inserted nil checks,
not for user code like 'x != nil'.
Returns a "definitely not nil" copy of x to ensure proper ordering
of the uses of the post-nilcheck pointer.</p>
               
               <pre><code>func (s *state) nilCheck(ptr *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="oneJump">
               <h3>
                  oneJump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *State) oneJump(b *ssa.Block, jump *IndexJump)</code></pre>
            </article>
            
            <article class="function" data-name="openDeferExit">
               <h3>
                  openDeferExit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>openDeferExit generates SSA for processing all the open coded defers at exit.
The code involves loading deferBits, and checking each of the bits to see if
the corresponding defer statement was executed. For each bit that is turned
on, the associated defer call is made.</p>
               
               <pre><code>func (s *state) openDeferExit()</code></pre>
            </article>
            
            <article class="function" data-name="openDeferRecord">
               <h3>
                  openDeferRecord 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>openDeferRecord adds code to evaluate and store the function for an open-code defer
call, and records info about the defer, so we can generate proper code on the
exit paths. n is the sub-node of the defer node that is the actual function
call. We will also record funcdata information on where the function is stored
(as well as the deferBits variable), and this will enable us to run the proper
defer calls during panics.</p>
               
               <pre><code>func (s *state) openDeferRecord(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function" data-name="openDeferSave">
               <h3>
                  openDeferSave 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>openDeferSave generates SSA nodes to store a value (with type t) for an
open-coded defer at an explicit autotmp location on the stack, so it can be
reloaded and used for the appropriate call on exit. Type t must be a function type
(therefore SSAable). val is the value to be stored. The function returns an SSA
value representing a pointer to the autotmp location.</p>
               
               <pre><code>func (s *state) openDeferSave(t *types.Type, val *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="paramsToHeap">
               <h3>
                  paramsToHeap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>paramsToHeap produces code to allocate memory for heap-escaped parameters
and to copy non-result parameters' values from the stack.</p>
               
               <pre><code>func (s *state) paramsToHeap()</code></pre>
            </article>
            
            <article class="function" data-name="paramsToWasmFields">
               <h3>
                  paramsToWasmFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func paramsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField</code></pre>
            </article>
            
            <article class="function" data-name="peekPos">
               <h3>
                  peekPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peekPos peeks the top of the line number stack.</p>
               
               <pre><code>func (s *state) peekPos() src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="popLine">
               <h3>
                  popLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>popLine pops the top of the line number stack.</p>
               
               <pre><code>func (s *state) popLine()</code></pre>
            </article>
            
            <article class="function" data-name="pushLine">
               <h3>
                  pushLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pushLine pushes a line number on the line number stack.</p>
               
               <pre><code>func (s *state) pushLine(line src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="putArg">
               <h3>
                  putArg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>putArg evaluates n for the purpose of passing it as an argument to a function and returns the value for the call.</p>
               
               <pre><code>func (s *state) putArg(n ir.Node, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="rawLoad">
               <h3>
                  rawLoad 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) rawLoad(t *types.Type, src *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="readFuncLines">
               <h3>
                  readFuncLines 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readFuncLines(file string, start uint, end uint) (*ssa.FuncLines, error)</code></pre>
            </article>
            
            <article class="function" data-name="recordCall">
               <h3>
                  recordCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>recordCall records a call from ODCLFUNC node "from", to function
symbol "to" at position pos.
This should be done as late as possible during compilation to
capture precise call graphs. The target of the call is an LSym
because that's all we know after we start SSA.
This can be called concurrently for different from Nodes.</p>
               
               <pre><code>func (c *nowritebarrierrecChecker) recordCall(fn *ir.Func, to *obj.LSym, pos src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="referenceTypeBuiltin">
               <h3>
                  referenceTypeBuiltin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>referenceTypeBuiltin generates code for the len/cap builtins for maps and channels.</p>
               
               <pre><code>func (s *state) referenceTypeBuiltin(n *ir.UnaryExpr, x *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="reflectType">
               <h3>
                  reflectType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reflectType returns an SSA value representing a pointer to typ's
reflection type descriptor.</p>
               
               <pre><code>func (s *state) reflectType(typ *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="resolveFwdRefs">
               <h3>
                  resolveFwdRefs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resolveFwdRefs links all FwdRef uses up to their nearest dominating definition.</p>
               
               <pre><code>func (s *phiState) resolveFwdRefs()</code></pre>
            </article>
            
            <article class="function" data-name="resultAddrOfCall">
               <h3>
                  resultAddrOfCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) resultAddrOfCall(c *ssa.Value, which int64, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="resultOfCall">
               <h3>
                  resultOfCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) resultOfCall(c *ssa.Value, which int64, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="resultsToWasmFields">
               <h3>
                  resultsToWasmFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func resultsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField</code></pre>
            </article>
            
            <article class="function" data-name="rtcall">
               <h3>
                  rtcall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rtcall issues a call to the given runtime function fn with the listed args.
Returns a slice of results of the given result types.
The call is added to the end of the current block.
If returns is false, the block is marked as an exit block.</p>
               
               <pre><code>func (s *state) rtcall(fn *obj.LSym, returns bool, results []*types.Type, args ...*ssa.Value) []*ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="setHeapaddr">
               <h3>
                  setHeapaddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setHeapaddr allocates a new PAUTO variable to store ptr (which must be non-nil)
and then sets it as n's heap address.</p>
               
               <pre><code>func (s *state) setHeapaddr(pos src.XPos, n *ir.Name, ptr *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="setupWasmExport">
               <h3>
                  setupWasmExport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setupWasmExport calculates the params and results in terms of WebAssembly values for the given function,
and sets up the wasmexport metadata.</p>
               
               <pre><code>func setupWasmExport(f *ir.Func, wrapped *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="setupWasmImport">
               <h3>
                  setupWasmImport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setupWasmImport calculates the params and results in terms of WebAssembly values for the given function,
and sets up the wasmimport metadata.</p>
               
               <pre><code>func setupWasmImport(f *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="sfcall">
               <h3>
                  sfcall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TODO: do not emit sfcall if operation can be optimized to constant in later
opt phase</p>
               
               <pre><code>func (s *state) sfcall(op ssa.Op, args ...*ssa.Value) (*ssa.Value, bool)</code></pre>
            </article>
            
            <article class="function" data-name="slice">
               <h3>
                  slice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>slice computes the slice v[i:j:k] and returns ptr, len, and cap of result.
i,j,k may be nil, in which case they are set to their default value.
v may be a slice, string or pointer to an array.</p>
               
               <pre><code>func (s *state) slice(v *ssa.Value, i *ssa.Value, j *ssa.Value, k *ssa.Value, bounded bool) (p *ssa.Value, l *ssa.Value, c *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="softfloatInit">
               <h3>
                  softfloatInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func softfloatInit()</code></pre>
            </article>
            
            <article class="function" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>split breaks up a tuple-typed value into its 2 parts.</p>
               
               <pre><code>func (s *state) split(v *ssa.Value) (*ssa.Value, *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="ssaMarker">
               <h3>
                  ssaMarker 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ssaMarker(name string) *ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="ssaOp">
               <h3>
                  ssaOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) ssaOp(op ir.Op, t *types.Type) ssa.Op</code></pre>
            </article>
            
            <article class="function" data-name="ssaShiftOp">
               <h3>
                  ssaShiftOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) ssaShiftOp(op ir.Op, t *types.Type, u *types.Type) ssa.Op</code></pre>
            </article>
            
            <article class="function" data-name="startBlock">
               <h3>
                  startBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>startBlock sets the current block we're generating code in to b.</p>
               
               <pre><code>func (s *state) startBlock(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stmt converts the statement n to SSA and adds it to s.</p>
               
               <pre><code>func (s *state) stmt(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="stmtList">
               <h3>
                  stmtList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stmtList converts the statement list n to SSA and adds it to s.</p>
               
               <pre><code>func (s *state) stmtList(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="store">
               <h3>
                  store 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) store(t *types.Type, dst *ssa.Value, val *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="storeArgWithBase">
               <h3>
                  storeArgWithBase 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) storeArgWithBase(n ir.Node, t *types.Type, base *ssa.Value, off int64)</code></pre>
            </article>
            
            <article class="function" data-name="storeParameterRegsToStack">
               <h3>
                  storeParameterRegsToStack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) storeParameterRegsToStack(abi *abi.ABIConfig, paramAssignment *abi.ABIParamAssignment, n *ir.Name, addr *ssa.Value, pointersOnly bool)</code></pre>
            </article>
            
            <article class="function" data-name="storeType">
               <h3>
                  storeType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>do *left = right for type t.</p>
               
               <pre><code>func (s *state) storeType(t *types.Type, left *ssa.Value, right *ssa.Value, skip skipMask, leftIsStmt bool)</code></pre>
            </article>
            
            <article class="function" data-name="storeTypePtrs">
               <h3>
                  storeTypePtrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>do *left = right for all pointer parts of t.</p>
               
               <pre><code>func (s *state) storeTypePtrs(t *types.Type, left *ssa.Value, right *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="storeTypeScalars">
               <h3>
                  storeTypeScalars 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>do *left = right for all scalar (non-pointer) parts of t.</p>
               
               <pre><code>func (s *state) storeTypeScalars(t *types.Type, left *ssa.Value, right *ssa.Value, skip skipMask)</code></pre>
            </article>
            
            <article class="function" data-name="temp">
               <h3>
                  temp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>temp allocates a temp of type t at position pos</p>
               
               <pre><code>func (s *state) temp(pos src.XPos, t *types.Type) (*ir.Name, *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="ternary">
               <h3>
                  ternary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ternary emits code to evaluate cond ? x : y.</p>
               
               <pre><code>func (s *state) ternary(cond *ssa.Value, x *ssa.Value, y *ssa.Value) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uint32Tofloat">
               <h3>
                  uint32Tofloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uint32Tofloat(cvttab *u322fcvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uint32Tofloat32">
               <h3>
                  uint32Tofloat32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uint32Tofloat32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uint32Tofloat64">
               <h3>
                  uint32Tofloat64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uint32Tofloat64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uint64Tofloat">
               <h3>
                  uint64Tofloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uint64Tofloat(cvttab *u642fcvtTab, n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uint64Tofloat32">
               <h3>
                  uint64Tofloat32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uint64Tofloat32(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uint64Tofloat64">
               <h3>
                  uint64Tofloat64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uint64Tofloat64(n ir.Node, x *ssa.Value, ft *types.Type, tt *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="uintptrConstant">
               <h3>
                  uintptrConstant 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) uintptrConstant(v uint64) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="updateUnsetPredPos">
               <h3>
                  updateUnsetPredPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>updateUnsetPredPos propagates the earliest-value position information for b
towards all of b's predecessors that need a position, and recurs on that
predecessor if its position is updated. B should have a non-empty position.</p>
               
               <pre><code>func (s *state) updateUnsetPredPos(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function" data-name="variable">
               <h3>
                  variable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>variable returns the value of a variable at the current location.</p>
               
               <pre><code>func (s *state) variable(n ir.Node, t *types.Type) *ssa.Value</code></pre>
            </article>
            
            <article class="function" data-name="wasmElemTypeAllowed">
               <h3>
                  wasmElemTypeAllowed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>wasmElemTypeAllowed reports whether t is allowed to be passed in memory
(as a pointer's element type, a field of it, etc.) between the Go wasm
module and the host.</p>
               
               <pre><code>func wasmElemTypeAllowed(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="weakenGlobalMapInitRelocs">
               <h3>
                  weakenGlobalMapInitRelocs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>weakenGlobalMapInitRelocs walks through all of the relocations on a
given a package init function "fn" and looks for relocs that target
outlined global map initializer functions; if it finds any such
relocs, it flags them as R_WEAK.</p>
               
               <pre><code>func weakenGlobalMapInitRelocs(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="zero">
               <h3>
                  zero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) zero(t *types.Type, dst *ssa.Value)</code></pre>
            </article>
            
            <article class="function" data-name="zeroResults">
               <h3>
                  zeroResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>zeroResults zeros the return values at the start of the function.
We need to do this very early in the function.  Defer might stop a
panic and show the return values as they exist at the time of
panic.  For precise stacks, the garbage collector assumes results
are always live, so we need to zero them before any allocations,
even allocations to move params/results to the heap.</p>
               
               <pre><code>func (s *state) zeroResults()</code></pre>
            </article>
            
            <article class="function" data-name="zeroVal">
               <h3>
                  zeroVal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>zeroVal returns the zero value for type t.</p>
               
               <pre><code>func (s *state) zeroVal(t *types.Type) *ssa.Value</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
