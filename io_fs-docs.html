<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - fs</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>fs</code>
         </h1>
         <hr />
         
         <article class="global" data-name="SkipDir">
            <h2>SkipDir</h2>
            <hr />
            
            <p>SkipDir is used as a return value from [WalkDirFunc] to indicate that
the directory named in the call is to be skipped. It is not returned
as an error by any function.</p>
            
            <pre><code>SkipDir</code></pre>
         </article>
         
         <article class="global" data-name="SkipAll">
            <h2>SkipAll</h2>
            <hr />
            
            <p>SkipAll is used as a return value from [WalkDirFunc] to indicate that
all remaining files and directories are to be skipped. It is not returned
as an error by any function.</p>
            
            <pre><code>SkipAll</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalid">
            <h2>ErrInvalid</h2>
            <hr />
            
            <p>Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
            
            <pre><code>ErrInvalid</code></pre>
         </article>
         
         <article class="global" data-name="ErrPermission">
            <h2>ErrPermission</h2>
            <hr />
            
            <p>Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
            
            <pre><code>ErrPermission</code></pre>
         </article>
         
         <article class="global" data-name="ErrExist">
            <h2>ErrExist</h2>
            <hr />
            
            <p>Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
            
            <pre><code>ErrExist</code></pre>
         </article>
         
         <article class="global" data-name="ErrNotExist">
            <h2>ErrNotExist</h2>
            <hr />
            
            <p>Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
            
            <pre><code>ErrNotExist</code></pre>
         </article>
         
         <article class="global" data-name="ErrClosed">
            <h2>ErrClosed</h2>
            <hr />
            
            <p>Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
            
            <pre><code>ErrClosed</code></pre>
         </article>
         
         <article class="global" data-name="ModeDir">
            <h2>ModeDir</h2>
            <hr />
            
            <p>The single letters are the abbreviations
used by the String method's formatting.</p>
            
            <pre><code>ModeDir FileMode</code></pre>
         </article>
         
         <article class="global" data-name="ModeAppend">
            <h2>ModeAppend</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeAppend</code></pre>
         </article>
         
         <article class="global" data-name="ModeExclusive">
            <h2>ModeExclusive</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeExclusive</code></pre>
         </article>
         
         <article class="global" data-name="ModeTemporary">
            <h2>ModeTemporary</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeTemporary</code></pre>
         </article>
         
         <article class="global" data-name="ModeSymlink">
            <h2>ModeSymlink</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSymlink</code></pre>
         </article>
         
         <article class="global" data-name="ModeDevice">
            <h2>ModeDevice</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeDevice</code></pre>
         </article>
         
         <article class="global" data-name="ModeNamedPipe">
            <h2>ModeNamedPipe</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeNamedPipe</code></pre>
         </article>
         
         <article class="global" data-name="ModeSocket">
            <h2>ModeSocket</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSocket</code></pre>
         </article>
         
         <article class="global" data-name="ModeSetuid">
            <h2>ModeSetuid</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSetuid</code></pre>
         </article>
         
         <article class="global" data-name="ModeSetgid">
            <h2>ModeSetgid</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSetgid</code></pre>
         </article>
         
         <article class="global" data-name="ModeCharDevice">
            <h2>ModeCharDevice</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeCharDevice</code></pre>
         </article>
         
         <article class="global" data-name="ModeSticky">
            <h2>ModeSticky</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSticky</code></pre>
         </article>
         
         <article class="global" data-name="ModeIrregular">
            <h2>ModeIrregular</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeIrregular</code></pre>
         </article>
         
         <article class="global" data-name="ModeType">
            <h2>ModeType</h2>
            <hr />
            
            <p>Mask for the type bits. For regular files, none will be set.</p>
            
            <pre><code>ModeType</code></pre>
         </article>
         
         <article class="global" data-name="ModePerm">
            <h2>ModePerm</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModePerm FileMode</code></pre>
         </article>
          
         <article class="struct" data-name="subFS">
            <h2>type subFS struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fsys FS
dir string</code></pre>
         </article>
         
         <article class="struct" data-name="PathError">
            <h2>type PathError struct</h2>
            <hr />
            
            <p>PathError records an error and the operation and file path that caused it.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Op string
Path string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="dirInfo">
            <h2>type dirInfo struct</h2>
            <hr />
            
            <p>dirInfo is a DirEntry based on a FileInfo.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fileInfo FileInfo</code></pre>
         </article>
          
         <article class="function" data-name="Sub">
            <h2>Sub</h2>
            <hr />
            
            <p>Sub returns an [FS] corresponding to the subtree rooted at fsys's dir.

If dir is ".", Sub returns fsys unchanged.
Otherwise, if fs implements [SubFS], Sub returns fsys.Sub(dir).
Otherwise, Sub returns a new [FS] implementation sub that,
in effect, implements sub.Open(name) as fsys.Open(path.Join(dir, name)).
The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately.

Note that Sub(os.DirFS("/"), "prefix") is equivalent to os.DirFS("/prefix")
and that neither of them guarantees to avoid operating system
accesses outside "/prefix", because the implementation of [os.DirFS]
does not check for symbolic links inside "/prefix" that point to
other directories. That is, [os.DirFS] is not a general substitute for a
chroot-style security mechanism, and Sub does not change that fact.</p>
            
            <pre><code>func Sub(fsys FS, dir string) (FS, error)</code></pre>
         </article>
         
         <article class="function" data-name="fullName">
            <h2>fullName</h2>
            <hr />
            
            <p>fullName maps name to the fully-qualified name dir/name.</p>
            
            <pre><code>func fullName(op string, name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="shorten">
            <h2>shorten</h2>
            <hr />
            
            <p>shorten maps name, which should start with f.dir, back to the suffix after f.dir.</p>
            
            <pre><code>func shorten(name string) (rel string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="fixErr">
            <h2>fixErr</h2>
            <hr />
            
            <p>fixErr shortens any reported names in PathErrors by stripping f.dir.</p>
            
            <pre><code>func fixErr(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(name string) (File, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadDir">
            <h2>ReadDir</h2>
            <hr />
            
            <pre><code>func ReadDir(name string) ([]DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFile">
            <h2>ReadFile</h2>
            <hr />
            
            <pre><code>func ReadFile(name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Glob">
            <h2>Glob</h2>
            <hr />
            
            <pre><code>func Glob(pattern string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Sub">
            <h2>Sub</h2>
            <hr />
            
            <pre><code>func Sub(dir string) (FS, error)</code></pre>
         </article>
         
         <article class="function" data-name="walkDir">
            <h2>walkDir</h2>
            <hr />
            
            <p>walkDir recursively descends path, calling walkDirFn.</p>
            
            <pre><code>func walkDir(fsys FS, name string, d DirEntry, walkDirFn WalkDirFunc) error</code></pre>
         </article>
         
         <article class="function" data-name="WalkDir">
            <h2>WalkDir</h2>
            <hr />
            
            <p>WalkDir walks the file tree rooted at root, calling fn for each file or
directory in the tree, including root.

All errors that arise visiting files and directories are filtered by fn:
see the [fs.WalkDirFunc] documentation for details.

The files are walked in lexical order, which makes the output deterministic
but requires WalkDir to read an entire directory into memory before proceeding
to walk that directory.

WalkDir does not follow symbolic links found in directories,
but if root itself is a symbolic link, its target will be walked.</p>
            
            <pre><code>func WalkDir(fsys FS, root string, fn WalkDirFunc) error</code></pre>
         </article>
         
         <article class="function" data-name="FormatFileInfo">
            <h2>FormatFileInfo</h2>
            <hr />
            
            <p>FormatFileInfo returns a formatted version of info for human readability.
Implementations of [FileInfo] can call this from a String method.
The output for a file named "hello.go", 100 bytes, mode 0o644, created
January 1, 1970 at noon is

	-rw-r--r-- 100 1970-01-01 12:00:00 hello.go</p>
            
            <pre><code>func FormatFileInfo(info FileInfo) string</code></pre>
         </article>
         
         <article class="function" data-name="FormatDirEntry">
            <h2>FormatDirEntry</h2>
            <hr />
            
            <p>FormatDirEntry returns a formatted version of dir for human readability.
Implementations of [DirEntry] can call this from a String method.
The outputs for a directory named subdir and a file named hello.go are:

	d subdir/
	- hello.go</p>
            
            <pre><code>func FormatDirEntry(dir DirEntry) string</code></pre>
         </article>
         
         <article class="function" data-name="ValidPath">
            <h2>ValidPath</h2>
            <hr />
            
            <p>ValidPath reports whether the given path name
is valid for use in a call to Open.

Path names passed to open are UTF-8-encoded,
unrooted, slash-separated sequences of path elements, like “x/y/z”.
Path names must not contain an element that is “.” or “..” or the empty string,
except for the special case that the name "." may be used for the root directory.
Paths must not start or end with a slash: “/x” and “x/” are invalid.

Note that paths are slash-separated on all systems, even Windows.
Paths containing other characters such as backslash and colon
are accepted as valid, but those characters must never be
interpreted by an [FS] implementation as path element separators.</p>
            
            <pre><code>func ValidPath(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="errInvalid">
            <h2>errInvalid</h2>
            <hr />
            
            <pre><code>func errInvalid() error</code></pre>
         </article>
         
         <article class="function" data-name="errPermission">
            <h2>errPermission</h2>
            <hr />
            
            <pre><code>func errPermission() error</code></pre>
         </article>
         
         <article class="function" data-name="errExist">
            <h2>errExist</h2>
            <hr />
            
            <pre><code>func errExist() error</code></pre>
         </article>
         
         <article class="function" data-name="errNotExist">
            <h2>errNotExist</h2>
            <hr />
            
            <pre><code>func errNotExist() error</code></pre>
         </article>
         
         <article class="function" data-name="errClosed">
            <h2>errClosed</h2>
            <hr />
            
            <pre><code>func errClosed() error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <p>IsDir reports whether m describes a directory.
That is, it tests for the [ModeDir] bit being set in m.</p>
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsRegular">
            <h2>IsRegular</h2>
            <hr />
            
            <p>IsRegular reports whether m describes a regular file.
That is, it tests that no mode type bits are set.</p>
            
            <pre><code>func IsRegular() bool</code></pre>
         </article>
         
         <article class="function" data-name="Perm">
            <h2>Perm</h2>
            <hr />
            
            <p>Perm returns the Unix permission bits in m (m & [ModePerm]).</p>
            
            <pre><code>func Perm() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <p>Type returns type bits in m (m & [ModeType]).</p>
            
            <pre><code>func Type() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="Timeout">
            <h2>Timeout</h2>
            <hr />
            
            <p>Timeout reports whether this error represents a timeout.</p>
            
            <pre><code>func Timeout() bool</code></pre>
         </article>
         
         <article class="function" data-name="Glob">
            <h2>Glob</h2>
            <hr />
            
            <p>Glob returns the names of all files matching pattern or nil
if there is no matching file. The syntax of patterns is the same
as in [path.Match]. The pattern may describe hierarchical names such as
usr/*/bin/ed.

Glob ignores file system errors such as I/O errors reading directories.
The only possible returned error is [path.ErrBadPattern], reporting that
the pattern is malformed.

If fs implements [GlobFS], Glob calls fs.Glob.
Otherwise, Glob uses [ReadDir] to traverse the directory tree
and look for matches for the pattern.</p>
            
            <pre><code>func Glob(fsys FS, pattern string) (matches []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="globWithLimit">
            <h2>globWithLimit</h2>
            <hr />
            
            <pre><code>func globWithLimit(fsys FS, pattern string, depth int) (matches []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanGlobPath">
            <h2>cleanGlobPath</h2>
            <hr />
            
            <p>cleanGlobPath prepares path for glob matching.</p>
            
            <pre><code>func cleanGlobPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="glob">
            <h2>glob</h2>
            <hr />
            
            <p>glob searches for files matching pattern in the directory dir
and appends them to matches, returning the updated slice.
If the directory cannot be opened, glob returns the existing matches.
New matches are added in lexicographical order.</p>
            
            <pre><code>func glob(fs FS, dir string, pattern string, matches []string) (m []string, e error)</code></pre>
         </article>
         
         <article class="function" data-name="hasMeta">
            <h2>hasMeta</h2>
            <hr />
            
            <p>hasMeta reports whether path contains any of the magic characters
recognized by path.Match.</p>
            
            <pre><code>func hasMeta(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="ReadDir">
            <h2>ReadDir</h2>
            <hr />
            
            <p>ReadDir reads the named directory
and returns a list of directory entries sorted by filename.

If fs implements [ReadDirFS], ReadDir calls fs.ReadDir.
Otherwise ReadDir calls fs.Open and uses ReadDir and Close
on the returned file.</p>
            
            <pre><code>func ReadDir(fsys FS, name string) ([]DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Info">
            <h2>Info</h2>
            <hr />
            
            <pre><code>func Info() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="FileInfoToDirEntry">
            <h2>FileInfoToDirEntry</h2>
            <hr />
            
            <p>FileInfoToDirEntry returns a [DirEntry] that returns information from info.
If info is nil, FileInfoToDirEntry returns nil.</p>
            
            <pre><code>func FileInfoToDirEntry(info FileInfo) DirEntry</code></pre>
         </article>
         
         <article class="function" data-name="ReadFile">
            <h2>ReadFile</h2>
            <hr />
            
            <p>ReadFile reads the named file from the file system fs and returns its contents.
A successful call returns a nil error, not [io.EOF].
(Because ReadFile reads the whole file, the expected EOF
from the final Read is not treated as an error to be reported.)

If fs implements [ReadFileFS], ReadFile calls fs.ReadFile.
Otherwise ReadFile calls fs.Open and uses Read and Close
on the returned [File].</p>
            
            <pre><code>func ReadFile(fsys FS, name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Stat returns a [FileInfo] describing the named file from the file system.

If fs implements [StatFS], Stat calls fs.Stat.
Otherwise, Stat opens the [File] to stat it.</p>
            
            <pre><code>func Stat(fsys FS, name string) (FileInfo, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
