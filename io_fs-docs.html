<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>fs - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>fs</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"errors"
"path"
"time"
"internal/oserror"
"time"
"unicode/utf8"
"path"
"errors"
"internal/bytealg"
"slices"
"io"
"errors"
"path"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrClosed" data-name="ErrClosed">
               <h3>
                  ErrClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrClosed" class="anchor" title="Link to ErrClosed">#</a>
               </h3>
               
                  <p class="doc-comment">Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
               
               <pre><code class="language-go">var ErrClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrExist" data-name="ErrExist">
               <h3>
                  ErrExist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrExist" class="anchor" title="Link to ErrExist">#</a>
               </h3>
               
                  <p class="doc-comment">Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
               
               <pre><code class="language-go">var ErrExist = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalid" data-name="ErrInvalid">
               <h3>
                  ErrInvalid 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrInvalid" class="anchor" title="Link to ErrInvalid">#</a>
               </h3>
               
                  <p class="doc-comment">Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
               
               <pre><code class="language-go">var ErrInvalid = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotExist" data-name="ErrNotExist">
               <h3>
                  ErrNotExist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotExist" class="anchor" title="Link to ErrNotExist">#</a>
               </h3>
               
                  <p class="doc-comment">Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
               
               <pre><code class="language-go">var ErrNotExist = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrPermission" data-name="ErrPermission">
               <h3>
                  ErrPermission 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrPermission" class="anchor" title="Link to ErrPermission">#</a>
               </h3>
               
                  <p class="doc-comment">Generic file system errors.
Errors returned by file systems can be tested against these errors
using [errors.Is].</p>
               
               <pre><code class="language-go">var ErrPermission = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeAppend" data-name="ModeAppend">
               <h3>
                  ModeAppend 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeAppend" class="anchor" title="Link to ModeAppend">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeAppend</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeCharDevice" data-name="ModeCharDevice">
               <h3>
                  ModeCharDevice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeCharDevice" class="anchor" title="Link to ModeCharDevice">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeCharDevice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeDevice" data-name="ModeDevice">
               <h3>
                  ModeDevice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeDevice" class="anchor" title="Link to ModeDevice">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeDevice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeDir" data-name="ModeDir">
               <h3>
                  ModeDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeDir" class="anchor" title="Link to ModeDir">#</a>
               </h3>
               
                  <p class="doc-comment">The single letters are the abbreviations
used by the String method's formatting.</p>
               
               <pre><code class="language-go">const ModeDir FileMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeExclusive" data-name="ModeExclusive">
               <h3>
                  ModeExclusive 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeExclusive" class="anchor" title="Link to ModeExclusive">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeExclusive</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeIrregular" data-name="ModeIrregular">
               <h3>
                  ModeIrregular 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeIrregular" class="anchor" title="Link to ModeIrregular">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeIrregular</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeNamedPipe" data-name="ModeNamedPipe">
               <h3>
                  ModeNamedPipe 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeNamedPipe" class="anchor" title="Link to ModeNamedPipe">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeNamedPipe</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModePerm" data-name="ModePerm">
               <h3>
                  ModePerm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModePerm" class="anchor" title="Link to ModePerm">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModePerm FileMode = 0777</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSetgid" data-name="ModeSetgid">
               <h3>
                  ModeSetgid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSetgid" class="anchor" title="Link to ModeSetgid">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeSetgid</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSetuid" data-name="ModeSetuid">
               <h3>
                  ModeSetuid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSetuid" class="anchor" title="Link to ModeSetuid">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeSetuid</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSocket" data-name="ModeSocket">
               <h3>
                  ModeSocket 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSocket" class="anchor" title="Link to ModeSocket">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeSocket</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSticky" data-name="ModeSticky">
               <h3>
                  ModeSticky 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSticky" class="anchor" title="Link to ModeSticky">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeSticky</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSymlink" data-name="ModeSymlink">
               <h3>
                  ModeSymlink 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSymlink" class="anchor" title="Link to ModeSymlink">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeSymlink</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeTemporary" data-name="ModeTemporary">
               <h3>
                  ModeTemporary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeTemporary" class="anchor" title="Link to ModeTemporary">#</a>
               </h3>
               
                  <p class="doc-comment">The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code class="language-go">const ModeTemporary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeType" data-name="ModeType">
               <h3>
                  ModeType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeType" class="anchor" title="Link to ModeType">#</a>
               </h3>
               
                  <p class="doc-comment">Mask for the type bits. For regular files, none will be set.</p>
               
               <pre><code class="language-go">const ModeType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SkipAll" data-name="SkipAll">
               <h3>
                  SkipAll 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#SkipAll" class="anchor" title="Link to SkipAll">#</a>
               </h3>
               
                  <p class="doc-comment">SkipAll is used as a return value from [WalkDirFunc] to indicate that
all remaining files and directories are to be skipped. It is not returned
as an error by any function.</p>
               
               <pre><code class="language-go">var SkipAll = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SkipDir" data-name="SkipDir">
               <h3>
                  SkipDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#SkipDir" class="anchor" title="Link to SkipDir">#</a>
               </h3>
               
                  <p class="doc-comment">SkipDir is used as a return value from [WalkDirFunc] to indicate that
the directory named in the call is to be skipped. It is not returned
as an error by any function.</p>
               
               <pre><code class="language-go">var SkipDir = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="FileMode" data-name="FileMode">
               <h3>
                  FileMode
                  <span class="badge type-badge">type</span>
                  <a href="#FileMode" class="anchor" title="Link to FileMode">#</a>
               </h3>
               
               <p>A FileMode represents a file's mode and permission bits.
The bits have the same definition on all systems, so that
information about files can be moved from one system
to another portably. Not all bits apply to all systems.
The only required bit is [ModeDir] for directories.</p>
               
               <pre><code class="language-go">type FileMode uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="WalkDirFunc" data-name="WalkDirFunc">
               <h3>
                  WalkDirFunc
                  <span class="badge type-badge">type</span>
                  <a href="#WalkDirFunc" class="anchor" title="Link to WalkDirFunc">#</a>
               </h3>
               
               <p>WalkDirFunc is the type of the function called by [WalkDir] to visit
each file or directory.
The path argument contains the argument to [WalkDir] as a prefix.
That is, if WalkDir is called with root argument "dir" and finds a file
named "a" in that directory, the walk function will be called with
argument "dir/a".
The d argument is the [DirEntry] for the named path.
The error result returned by the function controls how [WalkDir]
continues. If the function returns the special value [SkipDir], WalkDir
skips the current directory (path if d.IsDir() is true, otherwise
path's parent directory). If the function returns the special value
[SkipAll], WalkDir skips all remaining files and directories. Otherwise,
if the function returns a non-nil error, WalkDir stops entirely and
returns that error.
The err argument reports an error related to path, signaling that
[WalkDir] will not walk into that directory. The function can decide how
to handle that error; as described earlier, returning the error will
cause WalkDir to stop walking the entire tree.
[WalkDir] calls the function with a non-nil err argument in two cases.
First, if the initial [Stat] on the root directory fails, WalkDir
calls the function with path set to root, d set to nil, and err set to
the error from [fs.Stat].
Second, if a directory's ReadDir method (see [ReadDirFile]) fails, WalkDir calls the
function with path set to the directory's path, d set to an
[DirEntry] describing the directory, and err set to the error from
ReadDir. In this second case, the function is called twice with the
path of the directory: the first call is before the directory read is
attempted and has err set to nil, giving the function a chance to
return [SkipDir] or [SkipAll] and avoid the ReadDir entirely. The second call
is after a failed ReadDir and reports the error from ReadDir.
(If ReadDir succeeds, there is no second call.)
The differences between WalkDirFunc compared to [path/filepath.WalkFunc] are:
- The second argument has type [DirEntry] instead of [FileInfo].
- The function is called before reading a directory, to allow [SkipDir]
or [SkipAll] to bypass the directory read entirely or skip all remaining
files and directories respectively.
- If a directory read fails, the function is called a second time
for that directory to report the error.</p>
               
               <pre><code class="language-go">type WalkDirFunc func(path string, d DirEntry, err error) error</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="DirEntry" data-name="DirEntry">
               <h3>
                  DirEntry
                  <span class="badge interface-badge">interface</span>
                  <a href="#DirEntry" class="anchor" title="Link to DirEntry">#</a>
               </h3>
               
               <p>A DirEntry is an entry read from a directory
(using the [ReadDir] function or a [ReadDirFile]'s ReadDir method).</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type DirEntry interface {
Name() string
IsDir() bool
Type() FileMode
Info() (FileInfo, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="FS" data-name="FS">
               <h3>
                  FS
                  <span class="badge interface-badge">interface</span>
                  <a href="#FS" class="anchor" title="Link to FS">#</a>
               </h3>
               
               <p>An FS provides access to a hierarchical file system.
The FS interface is the minimum implementation required of the file system.
A file system may implement additional interfaces,
such as [ReadFileFS], to provide additional or optimized functionality.
[testing/fstest.TestFS] may be used to test implementations of an FS for
correctness.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type FS interface {
Open(name string) (File, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge interface-badge">interface</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>A File provides access to a single file.
The File interface is the minimum implementation required of the file.
Directory files should also implement [ReadDirFile].
A file may implement [io.ReaderAt] or [io.Seeker] as optimizations.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type File interface {
Stat() (FileInfo, error)
Read([]byte) (int, error)
Close() error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="FileInfo" data-name="FileInfo">
               <h3>
                  FileInfo
                  <span class="badge interface-badge">interface</span>
                  <a href="#FileInfo" class="anchor" title="Link to FileInfo">#</a>
               </h3>
               
               <p>A FileInfo describes a file and is returned by [Stat].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type FileInfo interface {
Name() string
Size() int64
Mode() FileMode
ModTime() time.Time
IsDir() bool
Sys() any
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="GlobFS" data-name="GlobFS">
               <h3>
                  GlobFS
                  <span class="badge interface-badge">interface</span>
                  <a href="#GlobFS" class="anchor" title="Link to GlobFS">#</a>
               </h3>
               
               <p>A GlobFS is a file system with a Glob method.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type GlobFS interface {
FS
Glob(pattern string) ([]string, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ReadDirFS" data-name="ReadDirFS">
               <h3>
                  ReadDirFS
                  <span class="badge interface-badge">interface</span>
                  <a href="#ReadDirFS" class="anchor" title="Link to ReadDirFS">#</a>
               </h3>
               
               <p>ReadDirFS is the interface implemented by a file system
that provides an optimized implementation of [ReadDir].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ReadDirFS interface {
FS
ReadDir(name string) ([]DirEntry, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ReadDirFile" data-name="ReadDirFile">
               <h3>
                  ReadDirFile
                  <span class="badge interface-badge">interface</span>
                  <a href="#ReadDirFile" class="anchor" title="Link to ReadDirFile">#</a>
               </h3>
               
               <p>A ReadDirFile is a directory file whose entries can be read with the ReadDir method.
Every directory file should implement this interface.
(It is permissible for any file to implement this interface,
but if so ReadDir should return an error for non-directories.)</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ReadDirFile interface {
File
ReadDir(n int) ([]DirEntry, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ReadFileFS" data-name="ReadFileFS">
               <h3>
                  ReadFileFS
                  <span class="badge interface-badge">interface</span>
                  <a href="#ReadFileFS" class="anchor" title="Link to ReadFileFS">#</a>
               </h3>
               
               <p>ReadFileFS is the interface implemented by a file system
that provides an optimized implementation of [ReadFile].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ReadFileFS interface {
FS
ReadFile(name string) ([]byte, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="StatFS" data-name="StatFS">
               <h3>
                  StatFS
                  <span class="badge interface-badge">interface</span>
                  <a href="#StatFS" class="anchor" title="Link to StatFS">#</a>
               </h3>
               
               <p>A StatFS is a file system with a Stat method.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type StatFS interface {
FS
Stat(name string) (FileInfo, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="SubFS" data-name="SubFS">
               <h3>
                  SubFS
                  <span class="badge interface-badge">interface</span>
                  <a href="#SubFS" class="anchor" title="Link to SubFS">#</a>
               </h3>
               
               <p>A SubFS is a file system with a Sub method.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type SubFS interface {
FS
Sub(dir string) (FS, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="PathError" data-name="PathError">
               <h3>
                  PathError
                  <span class="badge">struct</span>
                  <a href="#PathError" class="anchor" title="Link to PathError">#</a>
               </h3>
               
               <p>PathError records an error and the operation and file path that caused it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PathError struct {
Op string
Path string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirInfo" data-name="dirInfo">
               <h3>
                  dirInfo
                  <span class="badge">struct</span>
                  <a href="#dirInfo" class="anchor" title="Link to dirInfo">#</a>
               </h3>
               
               <p>dirInfo is a DirEntry based on a FileInfo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dirInfo struct {
fileInfo FileInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="subFS" data-name="subFS">
               <h3>
                  subFS
                  <span class="badge">struct</span>
                  <a href="#subFS" class="anchor" title="Link to subFS">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type subFS struct {
fsys FS
dir string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *PathError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileInfoToDirEntry" data-name="FileInfoToDirEntry">
               <h3>
                  FileInfoToDirEntry 
                  <span class="badge">function</span>
                  
                  <a href="#FileInfoToDirEntry" class="anchor" title="Link to FileInfoToDirEntry">#</a>
               </h3>
               
               <p>FileInfoToDirEntry returns a [DirEntry] that returns information from info.
If info is nil, FileInfoToDirEntry returns nil.</p>
               
               <pre><code class="language-go">func FileInfoToDirEntry(info FileInfo) DirEntry</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormatDirEntry" data-name="FormatDirEntry">
               <h3>
                  FormatDirEntry 
                  <span class="badge">function</span>
                  
                  <a href="#FormatDirEntry" class="anchor" title="Link to FormatDirEntry">#</a>
               </h3>
               
               <p>FormatDirEntry returns a formatted version of dir for human readability.
Implementations of [DirEntry] can call this from a String method.
The outputs for a directory named subdir and a file named hello.go are:
d subdir/
- hello.go</p>
               
               <pre><code class="language-go">func FormatDirEntry(dir DirEntry) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormatFileInfo" data-name="FormatFileInfo">
               <h3>
                  FormatFileInfo 
                  <span class="badge">function</span>
                  
                  <a href="#FormatFileInfo" class="anchor" title="Link to FormatFileInfo">#</a>
               </h3>
               
               <p>FormatFileInfo returns a formatted version of info for human readability.
Implementations of [FileInfo] can call this from a String method.
The output for a file named "hello.go", 100 bytes, mode 0o644, created
January 1, 1970 at noon is
-rw-r--r-- 100 1970-01-01 12:00:00 hello.go</p>
               
               <pre><code class="language-go">func FormatFileInfo(info FileInfo) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Glob" data-name="Glob">
               <h3>
                  Glob 
                  <span class="badge">function</span>
                  
                  <a href="#Glob" class="anchor" title="Link to Glob">#</a>
               </h3>
               
               <p>Glob returns the names of all files matching pattern or nil
if there is no matching file. The syntax of patterns is the same
as in [path.Match]. The pattern may describe hierarchical names such as
usr/*/bin/ed.
Glob ignores file system errors such as I/O errors reading directories.
The only possible returned error is [path.ErrBadPattern], reporting that
the pattern is malformed.
If fs implements [GlobFS], Glob calls fs.Glob.
Otherwise, Glob uses [ReadDir] to traverse the directory tree
and look for matches for the pattern.</p>
               
               <pre><code class="language-go">func Glob(fsys FS, pattern string) (matches []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Glob" data-name="Glob">
               <h3>
                  Glob 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Glob" class="anchor" title="Link to Glob">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *subFS) Glob(pattern string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <pre><code class="language-go">func (di dirInfo) Info() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code class="language-go">func (di dirInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <p>IsDir reports whether m describes a directory.
That is, it tests for the [ModeDir] bit being set in m.</p>
               
               <pre><code class="language-go">func (m FileMode) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsRegular" data-name="IsRegular">
               <h3>
                  IsRegular 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsRegular" class="anchor" title="Link to IsRegular">#</a>
               </h3>
               
               <p>IsRegular reports whether m describes a regular file.
That is, it tests that no mode type bits are set.</p>
               
               <pre><code class="language-go">func (m FileMode) IsRegular() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code class="language-go">func (di dirInfo) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *subFS) Open(name string) (File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Perm" data-name="Perm">
               <h3>
                  Perm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Perm" class="anchor" title="Link to Perm">#</a>
               </h3>
               
               <p>Perm returns the Unix permission bits in m (m & [ModePerm]).</p>
               
               <pre><code class="language-go">func (m FileMode) Perm() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *subFS) ReadDir(name string) ([]DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge">function</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <p>ReadDir reads the named directory
and returns a list of directory entries sorted by filename.
If fs implements [ReadDirFS], ReadDir calls fs.ReadDir.
Otherwise ReadDir calls fs.Open and uses ReadDir and Close
on the returned file.</p>
               
               <pre><code class="language-go">func ReadDir(fsys FS, name string) ([]DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *subFS) ReadFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge">function</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <p>ReadFile reads the named file from the file system fs and returns its contents.
A successful call returns a nil error, not [io.EOF].
(Because ReadFile reads the whole file, the expected EOF
from the final Read is not treated as an error to be reported.)
If fs implements [ReadFileFS], ReadFile calls fs.ReadFile.
Otherwise ReadFile calls fs.Open and uses Read and Close
on the returned [File].</p>
               
               <pre><code class="language-go">func ReadFile(fsys FS, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge">function</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <p>Stat returns a [FileInfo] describing the named file from the file system.
If fs implements [StatFS], Stat calls fs.Stat.
Otherwise, Stat opens the [File] to stat it.</p>
               
               <pre><code class="language-go">func Stat(fsys FS, name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (m FileMode) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (di dirInfo) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge">function</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <p>Sub returns an [FS] corresponding to the subtree rooted at fsys's dir.
If dir is ".", Sub returns fsys unchanged.
Otherwise, if fs implements [SubFS], Sub returns fsys.Sub(dir).
Otherwise, Sub returns a new [FS] implementation sub that,
in effect, implements sub.Open(name) as fsys.Open(path.Join(dir, name)).
The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately.
Note that Sub(os.DirFS("/"), "prefix") is equivalent to os.DirFS("/prefix")
and that neither of them guarantees to avoid operating system
accesses outside "/prefix", because the implementation of [os.DirFS]
does not check for symbolic links inside "/prefix" that point to
other directories. That is, [os.DirFS] is not a general substitute for a
chroot-style security mechanism, and Sub does not change that fact.</p>
               
               <pre><code class="language-go">func Sub(fsys FS, dir string) (FS, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *subFS) Sub(dir string) (FS, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Timeout" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Timeout" class="anchor" title="Link to Timeout">#</a>
               </h3>
               
               <p>Timeout reports whether this error represents a timeout.</p>
               
               <pre><code class="language-go">func (e *PathError) Timeout() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code class="language-go">func (di dirInfo) Type() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type returns type bits in m (m & [ModeType]).</p>
               
               <pre><code class="language-go">func (m FileMode) Type() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *PathError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ValidPath" data-name="ValidPath">
               <h3>
                  ValidPath 
                  <span class="badge">function</span>
                  
                  <a href="#ValidPath" class="anchor" title="Link to ValidPath">#</a>
               </h3>
               
               <p>ValidPath reports whether the given path name
is valid for use in a call to Open.
Path names passed to open are UTF-8-encoded,
unrooted, slash-separated sequences of path elements, like “x/y/z”.
Path names must not contain an element that is “.” or “..” or the empty string,
except for the special case that the name "." may be used for the root directory.
Paths must not start or end with a slash: “/x” and “x/” are invalid.
Note that paths are slash-separated on all systems, even Windows.
Paths containing other characters such as backslash and colon
are accepted as valid, but those characters must never be
interpreted by an [FS] implementation as path element separators.</p>
               
               <pre><code class="language-go">func ValidPath(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WalkDir" data-name="WalkDir">
               <h3>
                  WalkDir 
                  <span class="badge">function</span>
                  
                  <a href="#WalkDir" class="anchor" title="Link to WalkDir">#</a>
               </h3>
               
               <p>WalkDir walks the file tree rooted at root, calling fn for each file or
directory in the tree, including root.
All errors that arise visiting files and directories are filtered by fn:
see the [fs.WalkDirFunc] documentation for details.
The files are walked in lexical order, which makes the output deterministic
but requires WalkDir to read an entire directory into memory before proceeding
to walk that directory.
WalkDir does not follow symbolic links found in directories,
but if root itself is a symbolic link, its target will be walked.</p>
               
               <pre><code class="language-go">func WalkDir(fsys FS, root string, fn WalkDirFunc) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanGlobPath" data-name="cleanGlobPath">
               <h3>
                  cleanGlobPath 
                  <span class="badge">function</span>
                  
                  <a href="#cleanGlobPath" class="anchor" title="Link to cleanGlobPath">#</a>
               </h3>
               
               <p>cleanGlobPath prepares path for glob matching.</p>
               
               <pre><code class="language-go">func cleanGlobPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errClosed" data-name="errClosed">
               <h3>
                  errClosed 
                  <span class="badge">function</span>
                  
                  <a href="#errClosed" class="anchor" title="Link to errClosed">#</a>
               </h3>
               
               <pre><code class="language-go">func errClosed() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errExist" data-name="errExist">
               <h3>
                  errExist 
                  <span class="badge">function</span>
                  
                  <a href="#errExist" class="anchor" title="Link to errExist">#</a>
               </h3>
               
               <pre><code class="language-go">func errExist() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errInvalid" data-name="errInvalid">
               <h3>
                  errInvalid 
                  <span class="badge">function</span>
                  
                  <a href="#errInvalid" class="anchor" title="Link to errInvalid">#</a>
               </h3>
               
               <pre><code class="language-go">func errInvalid() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errNotExist" data-name="errNotExist">
               <h3>
                  errNotExist 
                  <span class="badge">function</span>
                  
                  <a href="#errNotExist" class="anchor" title="Link to errNotExist">#</a>
               </h3>
               
               <pre><code class="language-go">func errNotExist() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errPermission" data-name="errPermission">
               <h3>
                  errPermission 
                  <span class="badge">function</span>
                  
                  <a href="#errPermission" class="anchor" title="Link to errPermission">#</a>
               </h3>
               
               <pre><code class="language-go">func errPermission() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixErr" data-name="fixErr">
               <h3>
                  fixErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fixErr" class="anchor" title="Link to fixErr">#</a>
               </h3>
               
               <p>fixErr shortens any reported names in PathErrors by stripping f.dir.</p>
               
               <pre><code class="language-go">func (f *subFS) fixErr(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fullName" data-name="fullName">
               <h3>
                  fullName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fullName" class="anchor" title="Link to fullName">#</a>
               </h3>
               
               <p>fullName maps name to the fully-qualified name dir/name.</p>
               
               <pre><code class="language-go">func (f *subFS) fullName(op string, name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="glob" data-name="glob">
               <h3>
                  glob 
                  <span class="badge">function</span>
                  
                  <a href="#glob" class="anchor" title="Link to glob">#</a>
               </h3>
               
               <p>glob searches for files matching pattern in the directory dir
and appends them to matches, returning the updated slice.
If the directory cannot be opened, glob returns the existing matches.
New matches are added in lexicographical order.</p>
               
               <pre><code class="language-go">func glob(fs FS, dir string, pattern string, matches []string) (m []string, e error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="globWithLimit" data-name="globWithLimit">
               <h3>
                  globWithLimit 
                  <span class="badge">function</span>
                  
                  <a href="#globWithLimit" class="anchor" title="Link to globWithLimit">#</a>
               </h3>
               
               <pre><code class="language-go">func globWithLimit(fsys FS, pattern string, depth int) (matches []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasMeta" data-name="hasMeta">
               <h3>
                  hasMeta 
                  <span class="badge">function</span>
                  
                  <a href="#hasMeta" class="anchor" title="Link to hasMeta">#</a>
               </h3>
               
               <p>hasMeta reports whether path contains any of the magic characters
recognized by path.Match.</p>
               
               <pre><code class="language-go">func hasMeta(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shorten" data-name="shorten">
               <h3>
                  shorten 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shorten" class="anchor" title="Link to shorten">#</a>
               </h3>
               
               <p>shorten maps name, which should start with f.dir, back to the suffix after f.dir.</p>
               
               <pre><code class="language-go">func (f *subFS) shorten(name string) (rel string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDir" data-name="walkDir">
               <h3>
                  walkDir 
                  <span class="badge">function</span>
                  
                  <a href="#walkDir" class="anchor" title="Link to walkDir">#</a>
               </h3>
               
               <p>walkDir recursively descends path, calling walkDirFn.</p>
               
               <pre><code class="language-go">func walkDir(fsys FS, name string, d DirEntry, walkDirFn WalkDirFunc) error</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>