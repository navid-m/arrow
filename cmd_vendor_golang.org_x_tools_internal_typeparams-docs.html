<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - typeparams</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">‚åÇ</a>
         |
         <a href="#" onclick="history.back()">‚Üê</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>typeparams</code>
         </h1>
         <hr />
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <pre><code>debug</code></pre>
         </article>
         
         <article class="global" data-name="ErrEmptyTypeSet">
            <h2>ErrEmptyTypeSet</h2>
            <hr />
            
            <pre><code>ErrEmptyTypeSet</code></pre>
         </article>
         
         <article class="global" data-name="allTermlist">
            <h2>allTermlist</h2>
            <hr />
            
            <p>allTermlist represents the set of all types.
It is in normal form.</p>
            
            <pre><code>allTermlist</code></pre>
         </article>
          
         <article class="struct" data-name="Free">
            <h2>type Free struct</h2>
            <hr />
            
            <p>Free is a memoization of the set of free type parameters within a
type. It makes a sequence of calls to [Free.Has] for overlapping
types more efficient. The zero value is ready for use.

NOTE: Adapted from go/types/infer.go. If it is later exported, factor.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">seen *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="termSet">
            <h2>type termSet struct</h2>
            <hr />
            
            <p>A termSet holds the normalized set of terms for a given type.

The name termSet is intentionally distinct from 'type set': a type set is
all types that implement a type (and includes method restrictions), whereas
a term set just represents the structural restrictions on a type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">complete bool
terms termlist</code></pre>
         </article>
         
         <article class="struct" data-name="term">
            <h2>type term struct</h2>
            <hr />
            
            <p>A term describes elementary type sets:

	 ‚àÖ:  (*term)(nil)     == ‚àÖ                      // set of no types (empty set)
	 ùì§:  &term{}          == ùì§                      // set of all types (ùì§niverse)
	 T:  &term{false, T}  == {T}                    // set of type T
	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tilde bool
typ types.Type</code></pre>
         </article>
          
         <article class="function" data-name="UnpackIndexExpr">
            <h2>UnpackIndexExpr</h2>
            <hr />
            
            <p>UnpackIndexExpr extracts data from AST nodes that represent index
expressions.

For an ast.IndexExpr, the resulting indices slice will contain exactly one
index expression. For an ast.IndexListExpr (go1.18+), it may have a variable
number of index expressions.

For nodes that don't represent index expressions, the first return value of
UnpackIndexExpr will be nil.</p>
            
            <pre><code>func UnpackIndexExpr(n ast.Node) (x ast.Expr, lbrack token.Pos, indices []ast.Expr, rbrack token.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="PackIndexExpr">
            <h2>PackIndexExpr</h2>
            <hr />
            
            <p>PackIndexExpr returns an *ast.IndexExpr or *ast.IndexListExpr, depending on
the cardinality of indices. Calling PackIndexExpr with len(indices) == 0
will panic.</p>
            
            <pre><code>func PackIndexExpr(x ast.Expr, lbrack token.Pos, indices []ast.Expr, rbrack token.Pos) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="IsTypeParam">
            <h2>IsTypeParam</h2>
            <hr />
            
            <p>IsTypeParam reports whether t is a type parameter (or an alias of one).</p>
            
            <pre><code>func IsTypeParam(t types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="GenericAssignableTo">
            <h2>GenericAssignableTo</h2>
            <hr />
            
            <p>GenericAssignableTo is a generalization of types.AssignableTo that
implements the following rule for uninstantiated generic types:

If V and T are generic named types, then V is considered assignable to T if,
for every possible instantiation of V[A_1, ..., A_N], the instantiation
T[A_1, ..., A_N] is valid and V[A_1, ..., A_N] implements T[A_1, ..., A_N].

If T has structural constraints, they must be satisfied by V.

For example, consider the following type declarations:

	type Interface[T any] interface {
		Accept(T)
	}

	type Container[T any] struct {
		Element T
	}

	func (c Container[T]) Accept(t T) { c.Element = t }

In this case, GenericAssignableTo reports that instantiations of Container
are assignable to the corresponding instantiation of Interface.</p>
            
            <pre><code>func GenericAssignableTo(ctxt *types.Context, V types.Type, T types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="CoreType">
            <h2>CoreType</h2>
            <hr />
            
            <p>CoreType returns the core type of T or nil if T does not have a core type.

See https://go.dev/ref/spec#Core_types for the definition of a core type.</p>
            
            <pre><code>func CoreType(T types.Type) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="NormalTerms">
            <h2>NormalTerms</h2>
            <hr />
            
            <p>NormalTerms returns a slice of terms representing the normalized structural
type restrictions of a type, if any.

For all types other than *types.TypeParam, *types.Interface, and
*types.Union, this is just a single term with Tilde() == false and
Type() == typ. For *types.TypeParam, *types.Interface, and *types.Union, see
below.

Structural type restrictions of a type parameter are created via
non-interface types embedded in its constraint interface (directly, or via a
chain of interface embeddings). For example, in the declaration type
T[P interface{~int; m()}] int the structural restriction of the type
parameter P is ~int.

With interface embedding and unions, the specification of structural type
restrictions may be arbitrarily complex. For example, consider the
following:

	type A interface{ ~string|~[]byte }

	type B interface{ int|string }

	type C interface { ~string|~int }

	type T[P interface{ A|B; C }] int

In this example, the structural type restriction of P is ~string|int: A|B
expands to ~string|~[]byte|int|string, which reduces to ~string|~[]byte|int,
which when intersected with C (~string|~int) yields ~string|int.

NormalTerms computes these expansions and reductions, producing a
"normalized" form of the embeddings. A structural restriction is normalized
if it is a single union containing no interface terms, and is minimal in the
sense that removing any term changes the set of types satisfying the
constraint. It is left as a proof for the reader that, modulo sorting, there
is exactly one such normalized form.

Because the minimal representation always takes this form, NormalTerms
returns a slice of tilde terms corresponding to the terms of the union in
the normalized structural restriction. An error is returned if the type is
invalid, exceeds complexity bounds, or has an empty type set. In the latter
case, NormalTerms returns ErrEmptyTypeSet.

NormalTerms makes no guarantees about the order of terms, except that it
is deterministic.</p>
            
            <pre><code>func NormalTerms(typ types.Type) ([]*types.Term, error)</code></pre>
         </article>
         
         <article class="function" data-name="Deref">
            <h2>Deref</h2>
            <hr />
            
            <p>Deref returns the type of the variable pointed to by t,
if t's core type is a pointer; otherwise it returns t.

Do not assume that Deref(T)==T implies T is not a pointer:
consider "type T *T", for example.

TODO(adonovan): ideally this would live in typesinternal, but that
creates an import cycle. Move there when we melt this package down.</p>
            
            <pre><code>func Deref(t types.Type) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="MustDeref">
            <h2>MustDeref</h2>
            <hr />
            
            <p>MustDeref returns the type of the variable pointed to by t.
It panics if t's core type is not a pointer.

TODO(adonovan): ideally this would live in typesinternal, but that
creates an import cycle. Move there when we melt this package down.</p>
            
            <pre><code>func MustDeref(t types.Type) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="Has">
            <h2>Has</h2>
            <hr />
            
            <p>Has reports whether the specified type has a free type parameter.</p>
            
            <pre><code>func Has(typ types.Type) res bool</code></pre>
         </article>
         
         <article class="function" data-name="StructuralTerms">
            <h2>StructuralTerms</h2>
            <hr />
            
            <p>StructuralTerms returns a slice of terms representing the normalized
structural type restrictions of a type parameter, if any.

Structural type restrictions of a type parameter are created via
non-interface types embedded in its constraint interface (directly, or via a
chain of interface embeddings). For example, in the declaration

	type T[P interface{~int; m()}] int

the structural restriction of the type parameter P is ~int.

With interface embedding and unions, the specification of structural type
restrictions may be arbitrarily complex. For example, consider the
following:

	type A interface{ ~string|~[]byte }

	type B interface{ int|string }

	type C interface { ~string|~int }

	type T[P interface{ A|B; C }] int

In this example, the structural type restriction of P is ~string|int: A|B
expands to ~string|~[]byte|int|string, which reduces to ~string|~[]byte|int,
which when intersected with C (~string|~int) yields ~string|int.

StructuralTerms computes these expansions and reductions, producing a
"normalized" form of the embeddings. A structural restriction is normalized
if it is a single union containing no interface terms, and is minimal in the
sense that removing any term changes the set of types satisfying the
constraint. It is left as a proof for the reader that, modulo sorting, there
is exactly one such normalized form.

Because the minimal representation always takes this form, StructuralTerms
returns a slice of tilde terms corresponding to the terms of the union in
the normalized structural restriction. An error is returned if the
constraint interface is invalid, exceeds complexity bounds, or has an empty
type set. In the latter case, StructuralTerms returns ErrEmptyTypeSet.

StructuralTerms makes no guarantees about the order of terms, except that it
is deterministic.</p>
            
            <pre><code>func StructuralTerms(tparam *types.TypeParam) ([]*types.Term, error)</code></pre>
         </article>
         
         <article class="function" data-name="InterfaceTermSet">
            <h2>InterfaceTermSet</h2>
            <hr />
            
            <p>InterfaceTermSet computes the normalized terms for a constraint interface,
returning an error if the term set cannot be computed or is empty. In the
latter case, the error will be ErrEmptyTypeSet.

See the documentation of StructuralTerms for more information on
normalization.</p>
            
            <pre><code>func InterfaceTermSet(iface *types.Interface) ([]*types.Term, error)</code></pre>
         </article>
         
         <article class="function" data-name="UnionTermSet">
            <h2>UnionTermSet</h2>
            <hr />
            
            <p>UnionTermSet computes the normalized terms for a union, returning an error
if the term set cannot be computed or is empty. In the latter case, the
error will be ErrEmptyTypeSet.

See the documentation of StructuralTerms for more information on
normalization.</p>
            
            <pre><code>func UnionTermSet(union *types.Union) ([]*types.Term, error)</code></pre>
         </article>
         
         <article class="function" data-name="computeTermSet">
            <h2>computeTermSet</h2>
            <hr />
            
            <pre><code>func computeTermSet(typ types.Type) ([]*types.Term, error)</code></pre>
         </article>
         
         <article class="function" data-name="indentf">
            <h2>indentf</h2>
            <hr />
            
            <pre><code>func indentf(depth int, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="computeTermSetInternal">
            <h2>computeTermSetInternal</h2>
            <hr />
            
            <pre><code>func computeTermSetInternal(t types.Type, seen *ast.MapType, depth int) (res *termSet, err error)</code></pre>
         </article>
         
         <article class="function" data-name="under">
            <h2>under</h2>
            <hr />
            
            <p>under is a facade for the go/types internal function of the same name. It is
used by typeterm.go.</p>
            
            <pre><code>func under(t types.Type) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String prints the termlist exactly (without normalization).</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="isEmpty">
            <h2>isEmpty</h2>
            <hr />
            
            <p>isEmpty reports whether the termlist xl represents the empty set of types.</p>
            
            <pre><code>func isEmpty() bool</code></pre>
         </article>
         
         <article class="function" data-name="isAll">
            <h2>isAll</h2>
            <hr />
            
            <p>isAll reports whether the termlist xl represents the set of all types.</p>
            
            <pre><code>func isAll() bool</code></pre>
         </article>
         
         <article class="function" data-name="norm">
            <h2>norm</h2>
            <hr />
            
            <p>norm returns the normal form of xl.</p>
            
            <pre><code>func norm() termlist</code></pre>
         </article>
         
         <article class="function" data-name="union">
            <h2>union</h2>
            <hr />
            
            <p>union returns the union xl ‚à™ yl.</p>
            
            <pre><code>func union(yl termlist) termlist</code></pre>
         </article>
         
         <article class="function" data-name="intersect">
            <h2>intersect</h2>
            <hr />
            
            <p>intersect returns the intersection xl ‚à© yl.</p>
            
            <pre><code>func intersect(yl termlist) termlist</code></pre>
         </article>
         
         <article class="function" data-name="equal">
            <h2>equal</h2>
            <hr />
            
            <p>equal reports whether xl and yl represent the same type set.</p>
            
            <pre><code>func equal(yl termlist) bool</code></pre>
         </article>
         
         <article class="function" data-name="includes">
            <h2>includes</h2>
            <hr />
            
            <p>includes reports whether t ‚àà xl.</p>
            
            <pre><code>func includes(t types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="supersetOf">
            <h2>supersetOf</h2>
            <hr />
            
            <p>supersetOf reports whether y ‚äÜ xl.</p>
            
            <pre><code>func supersetOf(y *term) bool</code></pre>
         </article>
         
         <article class="function" data-name="subsetOf">
            <h2>subsetOf</h2>
            <hr />
            
            <p>subsetOf reports whether xl ‚äÜ yl.</p>
            
            <pre><code>func subsetOf(yl termlist) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="equal">
            <h2>equal</h2>
            <hr />
            
            <p>equal reports whether x and y represent the same type set.</p>
            
            <pre><code>func equal(y *term) bool</code></pre>
         </article>
         
         <article class="function" data-name="union">
            <h2>union</h2>
            <hr />
            
            <p>union returns the union x ‚à™ y: zero, one, or two non-nil terms.</p>
            
            <pre><code>func union(y *term) (_ *term, _ *term)</code></pre>
         </article>
         
         <article class="function" data-name="intersect">
            <h2>intersect</h2>
            <hr />
            
            <p>intersect returns the intersection x ‚à© y.</p>
            
            <pre><code>func intersect(y *term) *term</code></pre>
         </article>
         
         <article class="function" data-name="includes">
            <h2>includes</h2>
            <hr />
            
            <p>includes reports whether t ‚àà x.</p>
            
            <pre><code>func includes(t types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="subsetOf">
            <h2>subsetOf</h2>
            <hr />
            
            <p>subsetOf reports whether x ‚äÜ y.</p>
            
            <pre><code>func subsetOf(y *term) bool</code></pre>
         </article>
         
         <article class="function" data-name="disjoint">
            <h2>disjoint</h2>
            <hr />
            
            <p>disjoint reports whether x ‚à© y == ‚àÖ.
x.typ and y.typ must not be nil.</p>
            
            <pre><code>func disjoint(y *term) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
