<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>big - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>big</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"errors"
"fmt"
"io"
"errors"
"fmt"
"io"
"math"
"math/bits"
"sync"
"math/rand"
"math"
"sync"
"strconv"
_ "unsafe"
"fmt"
"io"
"math/rand"
"strings"
"math/bits"
"fmt"
"math"
"errors"
"fmt"
"io"
"strconv"
"strings"
"math/bits"
"fmt"
"io"
"strings"
"bytes"
"fmt"
"strconv"
"strconv"
"internal/cpu"
"bytes"
"fmt"
"internal/byteorder"
"math/bits"
"math/rand"
"sync"
"errors"
"fmt"
"internal/byteorder"
"math"
"internal/cpu"
"fmt"
"math"
"math/bits"
"errors"
"fmt"
"internal/byteorder"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Above" data-name="Above">
               <h3>
                  Above 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Above" class="anchor" title="Link to Above">#</a>
               </h3>
               
                  <p class="doc-comment">Constants describing the [Accuracy] of a [Float].</p>
               
               <pre><code class="language-go">const Above Accuracy = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AwayFromZero" data-name="AwayFromZero">
               <h3>
                  AwayFromZero 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AwayFromZero" class="anchor" title="Link to AwayFromZero">#</a>
               </h3>
               
                  <p class="doc-comment">These constants define supported rounding modes.</p>
               
               <pre><code class="language-go">const AwayFromZero</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Below" data-name="Below">
               <h3>
                  Below 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Below" class="anchor" title="Link to Below">#</a>
               </h3>
               
                  <p class="doc-comment">Constants describing the [Accuracy] of a [Float].</p>
               
               <pre><code class="language-go">const Below Accuracy = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Exact" data-name="Exact">
               <h3>
                  Exact 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Exact" class="anchor" title="Link to Exact">#</a>
               </h3>
               
                  <p class="doc-comment">Constants describing the [Accuracy] of a [Float].</p>
               
               <pre><code class="language-go">const Exact Accuracy = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxBase" data-name="MaxBase">
               <h3>
                  MaxBase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxBase" class="anchor" title="Link to MaxBase">#</a>
               </h3>
               
                  <p class="doc-comment">MaxBase is the largest number base accepted for string conversions.</p>
               
               <pre><code class="language-go">const MaxBase = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxExp" data-name="MaxExp">
               <h3>
                  MaxExp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxExp" class="anchor" title="Link to MaxExp">#</a>
               </h3>
               
                  <p class="doc-comment">Exponent and precision limits.</p>
               
               <pre><code class="language-go">const MaxExp = math.MaxInt32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxPrec" data-name="MaxPrec">
               <h3>
                  MaxPrec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxPrec" class="anchor" title="Link to MaxPrec">#</a>
               </h3>
               
                  <p class="doc-comment">Exponent and precision limits.</p>
               
               <pre><code class="language-go">const MaxPrec = math.MaxUint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MinExp" data-name="MinExp">
               <h3>
                  MinExp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MinExp" class="anchor" title="Link to MinExp">#</a>
               </h3>
               
                  <p class="doc-comment">Exponent and precision limits.</p>
               
               <pre><code class="language-go">const MinExp = math.MinInt32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToNearestAway" data-name="ToNearestAway">
               <h3>
                  ToNearestAway 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToNearestAway" class="anchor" title="Link to ToNearestAway">#</a>
               </h3>
               
                  <p class="doc-comment">These constants define supported rounding modes.</p>
               
               <pre><code class="language-go">const ToNearestAway</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToNearestEven" data-name="ToNearestEven">
               <h3>
                  ToNearestEven 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToNearestEven" class="anchor" title="Link to ToNearestEven">#</a>
               </h3>
               
                  <p class="doc-comment">These constants define supported rounding modes.</p>
               
               <pre><code class="language-go">const ToNearestEven RoundingMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToNegativeInf" data-name="ToNegativeInf">
               <h3>
                  ToNegativeInf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToNegativeInf" class="anchor" title="Link to ToNegativeInf">#</a>
               </h3>
               
                  <p class="doc-comment">These constants define supported rounding modes.</p>
               
               <pre><code class="language-go">const ToNegativeInf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToPositiveInf" data-name="ToPositiveInf">
               <h3>
                  ToPositiveInf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToPositiveInf" class="anchor" title="Link to ToPositiveInf">#</a>
               </h3>
               
                  <p class="doc-comment">These constants define supported rounding modes.</p>
               
               <pre><code class="language-go">const ToPositiveInf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToZero" data-name="ToZero">
               <h3>
                  ToZero 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToZero" class="anchor" title="Link to ToZero">#</a>
               </h3>
               
                  <p class="doc-comment">These constants define supported rounding modes.</p>
               
               <pre><code class="language-go">const ToZero</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ fmt.Formatter = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ fmt.Formatter = intOne</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ fmt.Scanner = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ fmt.Scanner = intOne</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ fmt.Scanner = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Accuracy_index" data-name="_Accuracy_index">
               <h3>
                  _Accuracy_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_Accuracy_index" class="anchor" title="Link to _Accuracy_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _Accuracy_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Accuracy_name" data-name="_Accuracy_name">
               <h3>
                  _Accuracy_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Accuracy_name" class="anchor" title="Link to _Accuracy_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _Accuracy_name = "BelowExactAbove"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_B" data-name="_B">
               <h3>
                  _B 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_B" class="anchor" title="Link to _B">#</a>
               </h3>
               
               <pre><code class="language-go">const _B = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_M" data-name="_M">
               <h3>
                  _M 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_M" class="anchor" title="Link to _M">#</a>
               </h3>
               
               <pre><code class="language-go">const _M = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_RoundingMode_index" data-name="_RoundingMode_index">
               <h3>
                  _RoundingMode_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_RoundingMode_index" class="anchor" title="Link to _RoundingMode_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _RoundingMode_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_RoundingMode_name" data-name="_RoundingMode_name">
               <h3>
                  _RoundingMode_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_RoundingMode_name" class="anchor" title="Link to _RoundingMode_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _RoundingMode_name = "ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_S" data-name="_S">
               <h3>
                  _S 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_S" class="anchor" title="Link to _S">#</a>
               </h3>
               
               <pre><code class="language-go">const _S = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_W" data-name="_W">
               <h3>
                  _W 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_W" class="anchor" title="Link to _W">#</a>
               </h3>
               
               <pre><code class="language-go">const _W = bits.UintSize</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="basicSqrThreshold" data-name="basicSqrThreshold">
               <h3>
                  basicSqrThreshold 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#basicSqrThreshold" class="anchor" title="Link to basicSqrThreshold">#</a>
               </h3>
               
                  <p class="doc-comment">Operands that are shorter than basicSqrThreshold are squared using
"grade school" multiplication; for operands longer than karatsubaSqrThreshold
we use the Karatsuba algorithm optimized for x == y.</p>
               
               <pre><code class="language-go">var basicSqrThreshold = 20</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cacheBase10" data-name="cacheBase10">
               <h3>
                  cacheBase10 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cacheBase10" class="anchor" title="Link to cacheBase10">#</a>
               </h3>
               
               <pre><code class="language-go">var cacheBase10 struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugFloat" data-name="debugFloat">
               <h3>
                  debugFloat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugFloat" class="anchor" title="Link to debugFloat">#</a>
               </h3>
               
               <pre><code class="language-go">const debugFloat = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="digits" data-name="digits">
               <h3>
                  digits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#digits" class="anchor" title="Link to digits">#</a>
               </h3>
               
               <pre><code class="language-go">const digits = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="divRecursiveThreshold" data-name="divRecursiveThreshold">
               <h3>
                  divRecursiveThreshold 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#divRecursiveThreshold" class="anchor" title="Link to divRecursiveThreshold">#</a>
               </h3>
               
                  <p class="doc-comment">divRecursiveThreshold is the number of divisor digits
at which point divRecursive is faster than divBasic.</p>
               
               <pre><code class="language-go">const divRecursiveThreshold = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errInvalSep" data-name="errInvalSep">
               <h3>
                  errInvalSep 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errInvalSep" class="anchor" title="Link to errInvalSep">#</a>
               </h3>
               
                  <p class="doc-comment">scan errors</p>
               
               <pre><code class="language-go">var errInvalSep = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoDigits" data-name="errNoDigits">
               <h3>
                  errNoDigits 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoDigits" class="anchor" title="Link to errNoDigits">#</a>
               </h3>
               
                  <p class="doc-comment">scan errors</p>
               
               <pre><code class="language-go">var errNoDigits = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="finite" data-name="finite">
               <h3>
                  finite 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#finite" class="anchor" title="Link to finite">#</a>
               </h3>
               
                  <p class="doc-comment">The form value order is relevant - do not change!</p>
               
               <pre><code class="language-go">const finite</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="floatGobVersion" data-name="floatGobVersion">
               <h3>
                  floatGobVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#floatGobVersion" class="anchor" title="Link to floatGobVersion">#</a>
               </h3>
               
                  <p class="doc-comment">Gob codec version. Permits backward-compatible changes to the encoding.</p>
               
               <pre><code class="language-go">const floatGobVersion byte = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="floatZero" data-name="floatZero">
               <h3>
                  floatZero 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#floatZero" class="anchor" title="Link to floatZero">#</a>
               </h3>
               
               <pre><code class="language-go">var floatZero Float</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hasVX" data-name="hasVX">
               <h3>
                  hasVX 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hasVX" class="anchor" title="Link to hasVX">#</a>
               </h3>
               
               <pre><code class="language-go">var hasVX = cpu.S390X.HasVX</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inf" data-name="inf">
               <h3>
                  inf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inf" class="anchor" title="Link to inf">#</a>
               </h3>
               
                  <p class="doc-comment">The form value order is relevant - do not change!</p>
               
               <pre><code class="language-go">const inf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intGobVersion" data-name="intGobVersion">
               <h3>
                  intGobVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#intGobVersion" class="anchor" title="Link to intGobVersion">#</a>
               </h3>
               
                  <p class="doc-comment">Gob codec version. Permits backward-compatible changes to the encoding.</p>
               
               <pre><code class="language-go">const intGobVersion byte = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intOne" data-name="intOne">
               <h3>
                  intOne 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#intOne" class="anchor" title="Link to intOne">#</a>
               </h3>
               
               <pre><code class="language-go">var intOne = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="karatsubaSqrThreshold" data-name="karatsubaSqrThreshold">
               <h3>
                  karatsubaSqrThreshold 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#karatsubaSqrThreshold" class="anchor" title="Link to karatsubaSqrThreshold">#</a>
               </h3>
               
               <pre><code class="language-go">var karatsubaSqrThreshold = 260</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="karatsubaThreshold" data-name="karatsubaThreshold">
               <h3>
                  karatsubaThreshold 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#karatsubaThreshold" class="anchor" title="Link to karatsubaThreshold">#</a>
               </h3>
               
                  <p class="doc-comment">Operands that are shorter than karatsubaThreshold are multiplied using
"grade school" multiplication; for longer operands the Karatsuba algorithm
is used.</p>
               
               <pre><code class="language-go">var karatsubaThreshold = 40</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="leafSize" data-name="leafSize">
               <h3>
                  leafSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#leafSize" class="anchor" title="Link to leafSize">#</a>
               </h3>
               
                  <p class="doc-comment">Split blocks greater than leafSize Words (or set to 0 to disable recursive conversion)
Benchmark and configure leafSize using: go test -bench="Leaf"
8 and 16 effective on 3.0 GHz Xeon "Clovertown" CPU (128 byte cache lines)
8 and 16 effective on 2.66 GHz Core 2 Duo "Penryn" CPU</p>
               
               <pre><code class="language-go">var leafSize int = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxBaseSmall" data-name="maxBaseSmall">
               <h3>
                  maxBaseSmall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxBaseSmall" class="anchor" title="Link to maxBaseSmall">#</a>
               </h3>
               
               <pre><code class="language-go">const maxBaseSmall = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxShift" data-name="maxShift">
               <h3>
                  maxShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxShift" class="anchor" title="Link to maxShift">#</a>
               </h3>
               
                  <p class="doc-comment">Maximum shift amount that can be done in one pass without overflow.
A Word has _W bits and (1<<maxShift - 1)*10 + 9 must fit into Word.</p>
               
               <pre><code class="language-go">const maxShift = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="natFive" data-name="natFive">
               <h3>
                  natFive 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#natFive" class="anchor" title="Link to natFive">#</a>
               </h3>
               
               <pre><code class="language-go">var natFive = nat{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="natOne" data-name="natOne">
               <h3>
                  natOne 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#natOne" class="anchor" title="Link to natOne">#</a>
               </h3>
               
               <pre><code class="language-go">var natOne = nat{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="natPool" data-name="natPool">
               <h3>
                  natPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#natPool" class="anchor" title="Link to natPool">#</a>
               </h3>
               
               <pre><code class="language-go">var natPool sync.Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="natTen" data-name="natTen">
               <h3>
                  natTen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#natTen" class="anchor" title="Link to natTen">#</a>
               </h3>
               
               <pre><code class="language-go">var natTen = nat{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="natTwo" data-name="natTwo">
               <h3>
                  natTwo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#natTwo" class="anchor" title="Link to natTwo">#</a>
               </h3>
               
               <pre><code class="language-go">var natTwo = nat{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pow5tab" data-name="pow5tab">
               <h3>
                  pow5tab 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pow5tab" class="anchor" title="Link to pow5tab">#</a>
               </h3>
               
                  <p class="doc-comment">These powers of 5 fit into a uint64.
for p, q := uint64(0), uint64(1); p < q; p, q = q, q*5 {
fmt.Println(q)
}</p>
               
               <pre><code class="language-go">var pow5tab = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ratGobVersion" data-name="ratGobVersion">
               <h3>
                  ratGobVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ratGobVersion" class="anchor" title="Link to ratGobVersion">#</a>
               </h3>
               
                  <p class="doc-comment">Gob codec version. Permits backward-compatible changes to the encoding.</p>
               
               <pre><code class="language-go">const ratGobVersion byte = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ratZero" data-name="ratZero">
               <h3>
                  ratZero 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ratZero" class="anchor" title="Link to ratZero">#</a>
               </h3>
               
               <pre><code class="language-go">var ratZero Rat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="support_adx" data-name="support_adx">
               <h3>
                  support_adx 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#support_adx" class="anchor" title="Link to support_adx">#</a>
               </h3>
               
               <pre><code class="language-go">var support_adx = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="threeOnce" data-name="threeOnce">
               <h3>
                  threeOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#threeOnce" class="anchor" title="Link to threeOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var threeOnce struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zero" data-name="zero">
               <h3>
                  zero 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#zero" class="anchor" title="Link to zero">#</a>
               </h3>
               
                  <p class="doc-comment">The form value order is relevant - do not change!</p>
               
               <pre><code class="language-go">const zero form = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Accuracy" data-name="Accuracy">
               <h3>
                  Accuracy
                  <span class="badge type-badge">type</span>
                  <a href="#Accuracy" class="anchor" title="Link to Accuracy">#</a>
               </h3>
               
               <p>Accuracy describes the rounding error produced by the most recent
operation that generated a [Float] value, relative to the exact value.</p>
               
               <pre><code class="language-go">type Accuracy int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="RoundingMode" data-name="RoundingMode">
               <h3>
                  RoundingMode
                  <span class="badge type-badge">type</span>
                  <a href="#RoundingMode" class="anchor" title="Link to RoundingMode">#</a>
               </h3>
               
               <p>RoundingMode determines how a [Float] value is rounded to the
desired precision. Rounding may change the [Float] value; the
rounding error is described by the [Float]'s [Accuracy].</p>
               
               <pre><code class="language-go">type RoundingMode byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Word" data-name="Word">
               <h3>
                  Word
                  <span class="badge type-badge">type</span>
                  <a href="#Word" class="anchor" title="Link to Word">#</a>
               </h3>
               
               <p>A Word represents a single digit of a multi-precision unsigned integer.</p>
               
               <pre><code class="language-go">type Word uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="form" data-name="form">
               <h3>
                  form
                  <span class="badge type-badge">type</span>
                  <a href="#form" class="anchor" title="Link to form">#</a>
               </h3>
               
               <p>A form value describes the internal representation.</p>
               
               <pre><code class="language-go">type form byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="nat" data-name="nat">
               <h3>
                  nat
                  <span class="badge type-badge">type</span>
                  <a href="#nat" class="anchor" title="Link to nat">#</a>
               </h3>
               
               <p>An unsigned integer x of the form
x = x[n-1]*_B^(n-1) + x[n-2]*_B^(n-2) + ... + x[1]*_B + x[0]
with 0 <= x[i] < _B and 0 <= i < n is stored in a slice of length n,
with the digits x[i] as the slice elements.
A number is normalized if the slice contains no leading 0 digits.
During arithmetic operations, denormalized values may occur but are
always normalized before returning the final result. The normalized
representation of 0 is the empty or nil slice (length = 0).</p>
               
               <pre><code class="language-go">type nat []Word</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ErrNaN" data-name="ErrNaN">
               <h3>
                  ErrNaN
                  <span class="badge">struct</span>
                  <a href="#ErrNaN" class="anchor" title="Link to ErrNaN">#</a>
               </h3>
               
               <p>An ErrNaN panic is raised by a [Float] operation that would lead to
a NaN under IEEE 754 rules. An ErrNaN implements the error interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ErrNaN struct {
msg string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Float" data-name="Float">
               <h3>
                  Float
                  <span class="badge">struct</span>
                  <a href="#Float" class="anchor" title="Link to Float">#</a>
               </h3>
               
               <p>A nonzero finite Float represents a multi-precision floating point number
sign × mantissa × 2**exponent
with 0.5 <= mantissa < 1.0, and MinExp <= exponent <= MaxExp.
A Float may also be zero (+0, -0) or infinite (+Inf, -Inf).
All Floats are ordered, and the ordering of two Floats x and y
is defined by x.Cmp(y).
Each Float value also has a precision, rounding mode, and accuracy.
The precision is the maximum number of mantissa bits available to
represent the value. The rounding mode specifies how a result should
be rounded to fit into the mantissa bits, and accuracy describes the
rounding error with respect to the exact result.
Unless specified otherwise, all operations (including setters) that
specify a *Float variable for the result (usually via the receiver
with the exception of [Float.MantExp]), round the numeric result according
to the precision and rounding mode of the result variable.
If the provided result precision is 0 (see below), it is set to the
precision of the argument with the largest precision value before any
rounding takes place, and the rounding mode remains unchanged. Thus,
uninitialized Floats provided as result arguments will have their
precision set to a reasonable value determined by the operands, and
their mode is the zero value for RoundingMode (ToNearestEven).
By setting the desired precision to 24 or 53 and using matching rounding
mode (typically [ToNearestEven]), Float operations produce the same results
as the corresponding float32 or float64 IEEE 754 arithmetic for operands
that correspond to normal (i.e., not denormal) float32 or float64 numbers.
Exponent underflow and overflow lead to a 0 or an Infinity for different
values than IEEE 754 because Float exponents have a much larger range.
The zero (uninitialized) value for a Float is ready to use and represents
the number +0.0 exactly, with precision 0 and rounding mode [ToNearestEven].
Operations always take pointer arguments (*Float) rather
than Float values, and each unique Float value requires
its own unique *Float pointer. To "copy" a Float value,
an existing (or newly allocated) Float must be set to
a new value using the [Float.Set] method; shallow copies
of Floats are not supported and may lead to errors.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Float struct {
prec uint32
mode RoundingMode
acc Accuracy
form form
neg bool
mant nat
exp int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int
                  <span class="badge">struct</span>
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <p>An Int represents a signed multi-precision integer.
The zero value for an Int represents the value 0.
Operations always take pointer arguments (*Int) rather
than Int values, and each unique Int value requires
its own unique *Int pointer. To "copy" an Int value,
an existing (or newly allocated) Int must be set to
a new value using the [Int.Set] method; shallow copies
of Ints are not supported and may lead to errors.
Note that methods may leak the Int's value through timing side-channels.
Because of this and because of the scope and complexity of the
implementation, Int is not well-suited to implement cryptographic operations.
The standard library avoids exposing non-trivial Int methods to
attacker-controlled inputs and the determination of whether a bug in math/big
is considered a security vulnerability might depend on the impact on the
standard library.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Int struct {
neg bool
abs nat
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Rat" data-name="Rat">
               <h3>
                  Rat
                  <span class="badge">struct</span>
                  <a href="#Rat" class="anchor" title="Link to Rat">#</a>
               </h3>
               
               <p>A Rat represents a quotient a/b of arbitrary precision.
The zero value for a Rat represents the value 0.
Operations always take pointer arguments (*Rat) rather
than Rat values, and each unique Rat value requires
its own unique *Rat pointer. To "copy" a Rat value,
an existing (or newly allocated) Rat must be set to
a new value using the [Rat.Set] method; shallow copies
of Rats are not supported and may lead to errors.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Rat struct {
a Int
b Int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="byteReader" data-name="byteReader">
               <h3>
                  byteReader
                  <span class="badge">struct</span>
                  <a href="#byteReader" class="anchor" title="Link to byteReader">#</a>
               </h3>
               
               <p>byteReader is a local wrapper around fmt.ScanState;
it implements the ByteReader interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type byteReader struct {
fmt.ScanState
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="decimal" data-name="decimal">
               <h3>
                  decimal
                  <span class="badge">struct</span>
                  <a href="#decimal" class="anchor" title="Link to decimal">#</a>
               </h3>
               
               <p>A decimal represents an unsigned floating-point number in decimal representation.
The value of a non-zero decimal d is d.mant * 10**d.exp with 0.1 <= d.mant < 1,
with the most-significant mantissa digit at index 0. For the zero decimal, the
mantissa length and exponent are 0.
The zero value for decimal represents a ready-to-use 0.0.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type decimal struct {
mant []byte
exp int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="divisor" data-name="divisor">
               <h3>
                  divisor
                  <span class="badge">struct</span>
                  <a href="#divisor" class="anchor" title="Link to divisor">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type divisor struct {
bbb nat
nbits int
ndigits int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Abs" data-name="Abs">
               <h3>
                  Abs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Abs" class="anchor" title="Link to Abs">#</a>
               </h3>
               
               <p>Abs sets z to |x| (the absolute value of x) and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Abs(x *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Abs" data-name="Abs">
               <h3>
                  Abs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Abs" class="anchor" title="Link to Abs">#</a>
               </h3>
               
               <p>Abs sets z to the (possibly rounded) value |x| (the absolute value of x)
and returns z.</p>
               
               <pre><code class="language-go">func (z *Float) Abs(x *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Abs" data-name="Abs">
               <h3>
                  Abs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Abs" class="anchor" title="Link to Abs">#</a>
               </h3>
               
               <p>Abs sets z to |x| (the absolute value of x) and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) Abs(x *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Acc" data-name="Acc">
               <h3>
                  Acc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Acc" class="anchor" title="Link to Acc">#</a>
               </h3>
               
               <p>Acc returns the accuracy of x produced by the most recent
operation, unless explicitly documented otherwise by that
operation.</p>
               
               <pre><code class="language-go">func (x *Float) Acc() Accuracy</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets z to the sum x+y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Add(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets z to the sum x+y and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) Add(x *Rat, y *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets z to the rounded sum x+y and returns z. If z's precision is 0,
it is changed to the larger of x's or y's precision before the operation.
Rounding is performed according to z's precision and rounding mode; and
z's accuracy reports the result error relative to the exact (not rounded)
result. Add panics with [ErrNaN] if x and y are infinities with opposite
signs. The value of z is undefined in that case.</p>
               
               <pre><code class="language-go">func (z *Float) Add(x *Float, y *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="And" data-name="And">
               <h3>
                  And 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#And" class="anchor" title="Link to And">#</a>
               </h3>
               
               <p>And sets z = x & y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) And(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AndNot" data-name="AndNot">
               <h3>
                  AndNot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AndNot" class="anchor" title="Link to AndNot">#</a>
               </h3>
               
               <p>AndNot sets z = x &^ y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) AndNot(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Append" data-name="Append">
               <h3>
                  Append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Append" class="anchor" title="Link to Append">#</a>
               </h3>
               
               <p>Append appends to buf the string form of the floating-point number x,
as generated by x.Text, and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (x *Float) Append(buf []byte, fmt byte, prec int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Append" data-name="Append">
               <h3>
                  Append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Append" class="anchor" title="Link to Append">#</a>
               </h3>
               
               <p>Append appends the string representation of x, as generated by
x.Text(base), to buf and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (x *Int) Append(buf []byte, base int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.</p>
               
               <pre><code class="language-go">func (x *Int) AppendText(b []byte) (text []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.
Only the [Float] value is marshaled (in full precision), other
attributes such as precision or accuracy are ignored.</p>
               
               <pre><code class="language-go">func (x *Float) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.</p>
               
               <pre><code class="language-go">func (x *Rat) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Binomial" data-name="Binomial">
               <h3>
                  Binomial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Binomial" class="anchor" title="Link to Binomial">#</a>
               </h3>
               
               <p>Binomial sets z to the binomial coefficient C(n, k) and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Binomial(n int64, k int64) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bit" data-name="Bit">
               <h3>
                  Bit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bit" class="anchor" title="Link to Bit">#</a>
               </h3>
               
               <p>Bit returns the value of the i'th bit of x. That is, it
returns (x>>i)&1. The bit index i must be >= 0.</p>
               
               <pre><code class="language-go">func (x *Int) Bit(i int) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BitLen" data-name="BitLen">
               <h3>
                  BitLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BitLen" class="anchor" title="Link to BitLen">#</a>
               </h3>
               
               <p>BitLen returns the length of the absolute value of x in bits.
The bit length of 0 is 0.</p>
               
               <pre><code class="language-go">func (x *Int) BitLen() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bits" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bits" class="anchor" title="Link to Bits">#</a>
               </h3>
               
               <p>Bits provides raw (unchecked but fast) access to x by returning its
absolute value as a little-endian [Word] slice. The result and x share
the same underlying array.
Bits is intended to support implementation of missing low-level [Int]
functionality outside this package; it should be avoided otherwise.</p>
               
               <pre><code class="language-go">func (x *Int) Bits() []Word</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the absolute value of x as a big-endian byte slice.
To use a fixed length slice, or a preallocated one, use [Int.FillBytes].</p>
               
               <pre><code class="language-go">func (x *Int) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cmp" data-name="Cmp">
               <h3>
                  Cmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cmp" class="anchor" title="Link to Cmp">#</a>
               </h3>
               
               <p>Cmp compares x and y and returns:
- -1 if x < y;
- 0 if x == y;
- +1 if x > y.</p>
               
               <pre><code class="language-go">func (x *Rat) Cmp(y *Rat) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cmp" data-name="Cmp">
               <h3>
                  Cmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cmp" class="anchor" title="Link to Cmp">#</a>
               </h3>
               
               <p>Cmp compares x and y and returns:
- -1 if x < y;
- 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf);
- +1 if x > y.</p>
               
               <pre><code class="language-go">func (x *Float) Cmp(y *Float) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cmp" data-name="Cmp">
               <h3>
                  Cmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cmp" class="anchor" title="Link to Cmp">#</a>
               </h3>
               
               <p>Cmp compares x and y and returns:
- -1 if x < y;
- 0 if x == y;
- +1 if x > y.</p>
               
               <pre><code class="language-go">func (x *Int) Cmp(y *Int) (r int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CmpAbs" data-name="CmpAbs">
               <h3>
                  CmpAbs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CmpAbs" class="anchor" title="Link to CmpAbs">#</a>
               </h3>
               
               <p>CmpAbs compares the absolute values of x and y and returns:
- -1 if |x| < |y|;
- 0 if |x| == |y|;
- +1 if |x| > |y|.</p>
               
               <pre><code class="language-go">func (x *Int) CmpAbs(y *Int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy sets z to x, with the same precision, rounding mode, and accuracy as x.
Copy returns z. If x and z are identical, Copy is a no-op.</p>
               
               <pre><code class="language-go">func (z *Float) Copy(x *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Denom" data-name="Denom">
               <h3>
                  Denom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Denom" class="anchor" title="Link to Denom">#</a>
               </h3>
               
               <p>Denom returns the denominator of x; it is always > 0.
The result is a reference to x's denominator, unless
x is an uninitialized (zero value) [Rat], in which case
the result is a new [Int] of value 1. (To initialize x,
any operation that sets x will do, including x.Set(x).)
If the result is a reference to x's denominator it
may change if a new value is assigned to x, and vice versa.</p>
               
               <pre><code class="language-go">func (x *Rat) Denom() *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Div" data-name="Div">
               <h3>
                  Div 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Div" class="anchor" title="Link to Div">#</a>
               </h3>
               
               <p>Div sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Div implements Euclidean division (unlike Go); see [Int.DivMod] for more details.</p>
               
               <pre><code class="language-go">func (z *Int) Div(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DivMod" data-name="DivMod">
               <h3>
                  DivMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DivMod" class="anchor" title="Link to DivMod">#</a>
               </h3>
               
               <p>DivMod sets z to the quotient x div y and m to the modulus x mod y
and returns the pair (z, m) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
DivMod implements Euclidean division and modulus (unlike Go):
q = x div y  such that
m = x - y*q  with 0 <= m < |y|
(See Raymond T. Boute, “The Euclidean definition of the functions
div and mod”. ACM Transactions on Programming Languages and
Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
ACM press.)
See [Int.QuoRem] for T-division and modulus (like Go).</p>
               
               <pre><code class="language-go">func (z *Int) DivMod(x *Int, y *Int, m *Int) (*Int, *Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (err ErrNaN) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exp" data-name="Exp">
               <h3>
                  Exp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Exp" class="anchor" title="Link to Exp">#</a>
               </h3>
               
               <p>Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.
If m == nil or m == 0, z = x**y unless y <= 0 then z = 1. If m != 0, y < 0,
and x and m are not relatively prime, z is unchanged and nil is returned.
Modular exponentiation of inputs of a particular size is not a
cryptographically constant-time operation.</p>
               
               <pre><code class="language-go">func (z *Int) Exp(x *Int, y *Int, m *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FillBytes" data-name="FillBytes">
               <h3>
                  FillBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FillBytes" class="anchor" title="Link to FillBytes">#</a>
               </h3>
               
               <p>FillBytes sets buf to the absolute value of x, storing it as a zero-extended
big-endian byte slice, and returns buf.
If the absolute value of x doesn't fit in buf, FillBytes will panic.</p>
               
               <pre><code class="language-go">func (x *Int) FillBytes(buf []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float32" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float32" class="anchor" title="Link to Float32">#</a>
               </h3>
               
               <p>Float32 returns the nearest float32 value for x and a bool indicating
whether f represents x exactly. If the magnitude of x is too large to
be represented by a float32, f is an infinity and exact is false.
The sign of f always matches the sign of x, even if f == 0.</p>
               
               <pre><code class="language-go">func (x *Rat) Float32() (f float32, exact bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float32" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float32" class="anchor" title="Link to Float32">#</a>
               </h3>
               
               <p>Float32 returns the float32 value nearest to x. If x is too small to be
represented by a float32 (|x| < [math.SmallestNonzeroFloat32]), the result
is (0, [Below]) or (-0, [Above]), respectively, depending on the sign of x.
If x is too large to be represented by a float32 (|x| > [math.MaxFloat32]),
the result is (+Inf, [Above]) or (-Inf, [Below]), depending on the sign of x.</p>
               
               <pre><code class="language-go">func (x *Float) Float32() (float32, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float64" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float64" class="anchor" title="Link to Float64">#</a>
               </h3>
               
               <p>Float64 returns the float64 value nearest x,
and an indication of any rounding that occurred.</p>
               
               <pre><code class="language-go">func (x *Int) Float64() (float64, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float64" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float64" class="anchor" title="Link to Float64">#</a>
               </h3>
               
               <p>Float64 returns the float64 value nearest to x. If x is too small to be
represented by a float64 (|x| < [math.SmallestNonzeroFloat64]), the result
is (0, [Below]) or (-0, [Above]), respectively, depending on the sign of x.
If x is too large to be represented by a float64 (|x| > [math.MaxFloat64]),
the result is (+Inf, [Above]) or (-Inf, [Below]), depending on the sign of x.</p>
               
               <pre><code class="language-go">func (x *Float) Float64() (float64, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float64" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float64" class="anchor" title="Link to Float64">#</a>
               </h3>
               
               <p>Float64 returns the nearest float64 value for x and a bool indicating
whether f represents x exactly. If the magnitude of x is too large to
be represented by a float64, f is an infinity and exact is false.
The sign of f always matches the sign of x, even if f == 0.</p>
               
               <pre><code class="language-go">func (x *Rat) Float64() (f float64, exact bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FloatPrec" data-name="FloatPrec">
               <h3>
                  FloatPrec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FloatPrec" class="anchor" title="Link to FloatPrec">#</a>
               </h3>
               
               <p>FloatPrec returns the number n of non-repeating digits immediately
following the decimal point of the decimal representation of x.
The boolean result indicates whether a decimal representation of x
with that many fractional digits is exact or rounded.
Examples:
x      n    exact    decimal representation n fractional digits
0      0    true     0
1      0    true     1
1/2    1    true     0.5
1/3    0    false    0       (0.333... rounded)
1/4    2    true     0.25
1/6    1    false    0.2     (0.166... rounded)</p>
               
               <pre><code class="language-go">func (x *Rat) FloatPrec() (n int, exact bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FloatString" data-name="FloatString">
               <h3>
                  FloatString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FloatString" class="anchor" title="Link to FloatString">#</a>
               </h3>
               
               <p>FloatString returns a string representation of x in decimal form with prec
digits of precision after the radix point. The last digit is rounded to
nearest, with halves rounded away from zero.</p>
               
               <pre><code class="language-go">func (x *Rat) FloatString(prec int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format implements [fmt.Formatter]. It accepts all the regular
formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the
interpretation of 'p'. The 'v' format is handled like 'g'.
Format also supports specification of the minimum precision
in digits, the output field width, as well as the format flags
'+' and ' ' for sign control, '0' for space or zero padding,
and '-' for left or right justification. See the fmt package
for details.</p>
               
               <pre><code class="language-go">func (x *Float) Format(s fmt.State, format rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format implements [fmt.Formatter]. It accepts the formats
'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix),
'd' (decimal), 'x' (lowercase hexadecimal), and
'X' (uppercase hexadecimal).
Also supported are the full suite of package fmt's format
flags for integral types, including '+' and ' ' for sign
control, '#' for leading zero in octal and for hexadecimal,
a leading "0x" or "0X" for "%#x" and "%#X" respectively,
specification of minimum digits precision, output field
width, space or zero padding, and '-' for left or right
justification.</p>
               
               <pre><code class="language-go">func (x *Int) Format(s fmt.State, ch rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GCD" data-name="GCD">
               <h3>
                  GCD 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GCD" class="anchor" title="Link to GCD">#</a>
               </h3>
               
               <p>GCD sets z to the greatest common divisor of a and b and returns z.
If x or y are not nil, GCD sets their value such that z = a*x + b*y.
a and b may be positive, zero or negative. (Before Go 1.14 both had
to be > 0.) Regardless of the signs of a and b, z is always >= 0.
If a == b == 0, GCD sets z = x = y = 0.
If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.
If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.</p>
               
               <pre><code class="language-go">func (z *Int) GCD(x *Int, y *Int, a *Int, b *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobDecode" data-name="GobDecode">
               <h3>
                  GobDecode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobDecode" class="anchor" title="Link to GobDecode">#</a>
               </h3>
               
               <p>GobDecode implements the [encoding/gob.GobDecoder] interface.</p>
               
               <pre><code class="language-go">func (z *Rat) GobDecode(buf []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobDecode" data-name="GobDecode">
               <h3>
                  GobDecode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobDecode" class="anchor" title="Link to GobDecode">#</a>
               </h3>
               
               <p>GobDecode implements the [encoding/gob.GobDecoder] interface.
The result is rounded per the precision and rounding mode of
z unless z's precision is 0, in which case z is set exactly
to the decoded value.</p>
               
               <pre><code class="language-go">func (z *Float) GobDecode(buf []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobDecode" data-name="GobDecode">
               <h3>
                  GobDecode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobDecode" class="anchor" title="Link to GobDecode">#</a>
               </h3>
               
               <p>GobDecode implements the [encoding/gob.GobDecoder] interface.</p>
               
               <pre><code class="language-go">func (z *Int) GobDecode(buf []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobEncode" data-name="GobEncode">
               <h3>
                  GobEncode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobEncode" class="anchor" title="Link to GobEncode">#</a>
               </h3>
               
               <p>GobEncode implements the [encoding/gob.GobEncoder] interface.</p>
               
               <pre><code class="language-go">func (x *Rat) GobEncode() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobEncode" data-name="GobEncode">
               <h3>
                  GobEncode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobEncode" class="anchor" title="Link to GobEncode">#</a>
               </h3>
               
               <p>GobEncode implements the [encoding/gob.GobEncoder] interface.
The [Float] value and all its attributes (precision,
rounding mode, accuracy) are marshaled.</p>
               
               <pre><code class="language-go">func (x *Float) GobEncode() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobEncode" data-name="GobEncode">
               <h3>
                  GobEncode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobEncode" class="anchor" title="Link to GobEncode">#</a>
               </h3>
               
               <p>GobEncode implements the [encoding/gob.GobEncoder] interface.</p>
               
               <pre><code class="language-go">func (x *Int) GobEncode() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <p>Int returns the result of truncating x towards zero;
or nil if x is an infinity.
The result is [Exact] if x.IsInt(); otherwise it is [Below]
for x > 0, and [Above] for x < 0.
If a non-nil *[Int] argument z is provided, [Int] stores
the result in z instead of allocating a new [Int].</p>
               
               <pre><code class="language-go">func (x *Float) Int(z *Int) (*Int, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int64" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int64" class="anchor" title="Link to Int64">#</a>
               </h3>
               
               <p>Int64 returns the int64 representation of x.
If x cannot be represented in an int64, the result is undefined.</p>
               
               <pre><code class="language-go">func (x *Int) Int64() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int64" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int64" class="anchor" title="Link to Int64">#</a>
               </h3>
               
               <p>Int64 returns the integer resulting from truncating x towards zero.
If [math.MinInt64] <= x <= [math.MaxInt64], the result is [Exact] if x is
an integer, and [Above] (x < 0) or [Below] (x > 0) otherwise.
The result is ([math.MinInt64], [Above]) for x < [math.MinInt64],
and ([math.MaxInt64], [Below]) for x > [math.MaxInt64].</p>
               
               <pre><code class="language-go">func (x *Float) Int64() (int64, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Inv" data-name="Inv">
               <h3>
                  Inv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Inv" class="anchor" title="Link to Inv">#</a>
               </h3>
               
               <p>Inv sets z to 1/x and returns z.
If x == 0, Inv panics.</p>
               
               <pre><code class="language-go">func (z *Rat) Inv(x *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsInf" data-name="IsInf">
               <h3>
                  IsInf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsInf" class="anchor" title="Link to IsInf">#</a>
               </h3>
               
               <p>IsInf reports whether x is +Inf or -Inf.</p>
               
               <pre><code class="language-go">func (x *Float) IsInf() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsInt" data-name="IsInt">
               <h3>
                  IsInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsInt" class="anchor" title="Link to IsInt">#</a>
               </h3>
               
               <p>IsInt reports whether the denominator of x is 1.</p>
               
               <pre><code class="language-go">func (x *Rat) IsInt() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsInt" data-name="IsInt">
               <h3>
                  IsInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsInt" class="anchor" title="Link to IsInt">#</a>
               </h3>
               
               <p>IsInt reports whether x is an integer.
±Inf values are not integers.</p>
               
               <pre><code class="language-go">func (x *Float) IsInt() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsInt64" data-name="IsInt64">
               <h3>
                  IsInt64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsInt64" class="anchor" title="Link to IsInt64">#</a>
               </h3>
               
               <p>IsInt64 reports whether x can be represented as an int64.</p>
               
               <pre><code class="language-go">func (x *Int) IsInt64() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsUint64" data-name="IsUint64">
               <h3>
                  IsUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsUint64" class="anchor" title="Link to IsUint64">#</a>
               </h3>
               
               <p>IsUint64 reports whether x can be represented as a uint64.</p>
               
               <pre><code class="language-go">func (x *Int) IsUint64() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Jacobi" data-name="Jacobi">
               <h3>
                  Jacobi 
                  <span class="badge">function</span>
                  
                  <a href="#Jacobi" class="anchor" title="Link to Jacobi">#</a>
               </h3>
               
               <p>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.
The y argument must be an odd integer.</p>
               
               <pre><code class="language-go">func Jacobi(x *Int, y *Int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lsh" data-name="Lsh">
               <h3>
                  Lsh 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lsh" class="anchor" title="Link to Lsh">#</a>
               </h3>
               
               <p>Lsh sets z = x << n and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Lsh(x *Int, n uint) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MantExp" data-name="MantExp">
               <h3>
                  MantExp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MantExp" class="anchor" title="Link to MantExp">#</a>
               </h3>
               
               <p>MantExp breaks x into its mantissa and exponent components
and returns the exponent. If a non-nil mant argument is
provided its value is set to the mantissa of x, with the
same precision and rounding mode as x. The components
satisfy x == mant × 2**exp, with 0.5 <= |mant| < 1.0.
Calling MantExp with a nil argument is an efficient way to
get the exponent of the receiver.
Special cases are:
(  ±0).MantExp(mant) = 0, with mant set to   ±0
(±Inf).MantExp(mant) = 0, with mant set to ±Inf
x and mant may be the same in which case x is set to its
mantissa value.</p>
               
               <pre><code class="language-go">func (x *Float) MantExp(mant *Float) (exp int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalJSON" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalJSON" class="anchor" title="Link to MarshalJSON">#</a>
               </h3>
               
               <p>MarshalJSON implements the [encoding/json.Marshaler] interface.</p>
               
               <pre><code class="language-go">func (x *Int) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface.</p>
               
               <pre><code class="language-go">func (x *Int) MarshalText() (text []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface.</p>
               
               <pre><code class="language-go">func (x *Rat) MarshalText() (text []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface.
Only the [Float] value is marshaled (in full precision), other
attributes such as precision or accuracy are ignored.</p>
               
               <pre><code class="language-go">func (x *Float) MarshalText() (text []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MinPrec" data-name="MinPrec">
               <h3>
                  MinPrec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MinPrec" class="anchor" title="Link to MinPrec">#</a>
               </h3>
               
               <p>MinPrec returns the minimum precision required to represent x exactly
(i.e., the smallest prec before x.SetPrec(prec) would start rounding x).
The result is 0 for |x| == 0 and |x| == Inf.</p>
               
               <pre><code class="language-go">func (x *Float) MinPrec() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mod" data-name="Mod">
               <h3>
                  Mod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mod" class="anchor" title="Link to Mod">#</a>
               </h3>
               
               <p>Mod sets z to the modulus x%y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Mod implements Euclidean modulus (unlike Go); see [Int.DivMod] for more details.</p>
               
               <pre><code class="language-go">func (z *Int) Mod(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModInverse" data-name="ModInverse">
               <h3>
                  ModInverse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModInverse" class="anchor" title="Link to ModInverse">#</a>
               </h3>
               
               <p>ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ
and returns z. If g and n are not relatively prime, g has no multiplicative
inverse in the ring ℤ/nℤ.  In this case, z is unchanged and the return value
is nil. If n == 0, a division-by-zero run-time panic occurs.</p>
               
               <pre><code class="language-go">func (z *Int) ModInverse(g *Int, n *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModSqrt" data-name="ModSqrt">
               <h3>
                  ModSqrt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModSqrt" class="anchor" title="Link to ModSqrt">#</a>
               </h3>
               
               <p>ModSqrt sets z to a square root of x mod p if such a square root exists, and
returns z. The modulus p must be an odd prime. If x is not a square mod p,
ModSqrt leaves z unchanged and returns nil. This function panics if p is
not an odd integer, its behavior is undefined if p is odd but not prime.</p>
               
               <pre><code class="language-go">func (z *Int) ModSqrt(x *Int, p *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <p>Mode returns the rounding mode of x.</p>
               
               <pre><code class="language-go">func (x *Float) Mode() RoundingMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mul" data-name="Mul">
               <h3>
                  Mul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mul" class="anchor" title="Link to Mul">#</a>
               </h3>
               
               <p>Mul sets z to the rounded product x*y and returns z.
Precision, rounding, and accuracy reporting are as for [Float.Add].
Mul panics with [ErrNaN] if one operand is zero and the other
operand an infinity. The value of z is undefined in that case.</p>
               
               <pre><code class="language-go">func (z *Float) Mul(x *Float, y *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mul" data-name="Mul">
               <h3>
                  Mul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mul" class="anchor" title="Link to Mul">#</a>
               </h3>
               
               <p>Mul sets z to the product x*y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Mul(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mul" data-name="Mul">
               <h3>
                  Mul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mul" class="anchor" title="Link to Mul">#</a>
               </h3>
               
               <p>Mul sets z to the product x*y and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) Mul(x *Rat, y *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MulRange" data-name="MulRange">
               <h3>
                  MulRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MulRange" class="anchor" title="Link to MulRange">#</a>
               </h3>
               
               <p>MulRange sets z to the product of all integers
in the range [a, b] inclusively and returns z.
If a > b (empty range), the result is 1.</p>
               
               <pre><code class="language-go">func (z *Int) MulRange(a int64, b int64) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Neg" data-name="Neg">
               <h3>
                  Neg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Neg" class="anchor" title="Link to Neg">#</a>
               </h3>
               
               <p>Neg sets z to -x and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Neg(x *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Neg" data-name="Neg">
               <h3>
                  Neg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Neg" class="anchor" title="Link to Neg">#</a>
               </h3>
               
               <p>Neg sets z to the (possibly rounded) value of x with its sign negated,
and returns z.</p>
               
               <pre><code class="language-go">func (z *Float) Neg(x *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Neg" data-name="Neg">
               <h3>
                  Neg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Neg" class="anchor" title="Link to Neg">#</a>
               </h3>
               
               <p>Neg sets z to -x and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) Neg(x *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFloat" data-name="NewFloat">
               <h3>
                  NewFloat 
                  <span class="badge">function</span>
                  
                  <a href="#NewFloat" class="anchor" title="Link to NewFloat">#</a>
               </h3>
               
               <p>NewFloat allocates and returns a new [Float] set to x,
with precision 53 and rounding mode [ToNearestEven].
NewFloat panics with [ErrNaN] if x is a NaN.</p>
               
               <pre><code class="language-go">func NewFloat(x float64) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewInt" data-name="NewInt">
               <h3>
                  NewInt 
                  <span class="badge">function</span>
                  
                  <a href="#NewInt" class="anchor" title="Link to NewInt">#</a>
               </h3>
               
               <p>NewInt allocates and returns a new [Int] set to x.</p>
               
               <pre><code class="language-go">func NewInt(x int64) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewRat" data-name="NewRat">
               <h3>
                  NewRat 
                  <span class="badge">function</span>
                  
                  <a href="#NewRat" class="anchor" title="Link to NewRat">#</a>
               </h3>
               
               <p>NewRat creates a new [Rat] with numerator a and denominator b.</p>
               
               <pre><code class="language-go">func NewRat(a int64, b int64) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Not" data-name="Not">
               <h3>
                  Not 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Not" class="anchor" title="Link to Not">#</a>
               </h3>
               
               <p>Not sets z = ^x and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Not(x *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Num" data-name="Num">
               <h3>
                  Num 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Num" class="anchor" title="Link to Num">#</a>
               </h3>
               
               <p>Num returns the numerator of x; it may be <= 0.
The result is a reference to x's numerator; it
may change if a new value is assigned to x, and vice versa.
The sign of the numerator corresponds to the sign of x.</p>
               
               <pre><code class="language-go">func (x *Rat) Num() *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Or" data-name="Or">
               <h3>
                  Or 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Or" class="anchor" title="Link to Or">#</a>
               </h3>
               
               <p>Or sets z = x | y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Or(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses s which must contain a text representation of a floating-
point number with a mantissa in the given conversion base (the exponent
is always a decimal number), or a string representing an infinite value.
For base 0, an underscore character “_” may appear between a base
prefix and an adjacent digit, and between successive digits; such
underscores do not change the value of the number, or the returned
digit count. Incorrect placement of underscores is reported as an
error if there are no other errors. If base != 0, underscores are
not recognized and thus terminate scanning like any other character
that is not a valid radix point or digit.
It sets z to the (possibly rounded) value of the corresponding floating-
point value, and returns z, the actual base b, and an error err, if any.
The entire string (not just a prefix) must be consumed for success.
If z's precision is 0, it is changed to 64 before rounding takes effect.
The number must be of the form:
number    = [ sign ] ( float | "inf" | "Inf" ) .
sign      = "+" | "-" .
float     = ( mantissa | prefix pmantissa ) [ exponent ] .
prefix    = "0" [ "b" | "B" | "o" | "O" | "x" | "X" ] .
mantissa  = digits "." [ digits ] | digits | "." digits .
pmantissa = [ "_" ] digits "." [ digits ] | [ "_" ] digits | "." digits .
exponent  = ( "e" | "E" | "p" | "P" ) [ sign ] digits .
digits    = digit { [ "_" ] digit } .
digit     = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base
argument will lead to a run-time panic.
For base 0, the number prefix determines the actual base: A prefix of
“0b” or “0B” selects base 2, “0o” or “0O” selects base 8, and
“0x” or “0X” selects base 16. Otherwise, the actual base is 10 and
no prefix is accepted. The octal prefix "0" is not supported (a leading
"0" is simply considered a "0").
A "p" or "P" exponent indicates a base 2 (rather than base 10) exponent;
for instance, "0x1.fffffffffffffp1023" (using base 0) represents the
maximum float64 value. For hexadecimal mantissae, the exponent character
must be one of 'p' or 'P', if present (an "e" or "E" exponent indicator
cannot be distinguished from a mantissa digit).
The returned *Float f is nil and the value of z is valid but not
defined if an error is reported.</p>
               
               <pre><code class="language-go">func (z *Float) Parse(s string, base int) (f *Float, b int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseFloat" data-name="ParseFloat">
               <h3>
                  ParseFloat 
                  <span class="badge">function</span>
                  
                  <a href="#ParseFloat" class="anchor" title="Link to ParseFloat">#</a>
               </h3>
               
               <p>ParseFloat is like f.Parse(s, base) with f set to the given precision
and rounding mode.</p>
               
               <pre><code class="language-go">func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prec" data-name="Prec">
               <h3>
                  Prec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Prec" class="anchor" title="Link to Prec">#</a>
               </h3>
               
               <p>Prec returns the mantissa precision of x in bits.
The result may be 0 for |x| == 0 and |x| == Inf.</p>
               
               <pre><code class="language-go">func (x *Float) Prec() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProbablyPrime" data-name="ProbablyPrime">
               <h3>
                  ProbablyPrime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProbablyPrime" class="anchor" title="Link to ProbablyPrime">#</a>
               </h3>
               
               <p>ProbablyPrime reports whether x is probably prime,
applying the Miller-Rabin test with n pseudorandomly chosen bases
as well as a Baillie-PSW test.
If x is prime, ProbablyPrime returns true.
If x is chosen randomly and not prime, ProbablyPrime probably returns false.
The probability of returning true for a randomly chosen non-prime is at most ¼ⁿ.
ProbablyPrime is 100% accurate for inputs less than 2⁶⁴.
See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149,
and FIPS 186-4 Appendix F for further discussion of the error probabilities.
ProbablyPrime is not suitable for judging primes that an adversary may
have crafted to fool the test.
As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test.
Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked.</p>
               
               <pre><code class="language-go">func (x *Int) ProbablyPrime(n int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Quo" data-name="Quo">
               <h3>
                  Quo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Quo" class="anchor" title="Link to Quo">#</a>
               </h3>
               
               <p>Quo sets z to the quotient x/y and returns z.
If y == 0, Quo panics.</p>
               
               <pre><code class="language-go">func (z *Rat) Quo(x *Rat, y *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Quo" data-name="Quo">
               <h3>
                  Quo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Quo" class="anchor" title="Link to Quo">#</a>
               </h3>
               
               <p>Quo sets z to the rounded quotient x/y and returns z.
Precision, rounding, and accuracy reporting are as for [Float.Add].
Quo panics with [ErrNaN] if both operands are zero or infinities.
The value of z is undefined in that case.</p>
               
               <pre><code class="language-go">func (z *Float) Quo(x *Float, y *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Quo" data-name="Quo">
               <h3>
                  Quo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Quo" class="anchor" title="Link to Quo">#</a>
               </h3>
               
               <p>Quo sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Quo implements truncated division (like Go); see [Int.QuoRem] for more details.</p>
               
               <pre><code class="language-go">func (z *Int) Quo(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="QuoRem" data-name="QuoRem">
               <h3>
                  QuoRem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#QuoRem" class="anchor" title="Link to QuoRem">#</a>
               </h3>
               
               <p>QuoRem sets z to the quotient x/y and r to the remainder x%y
and returns the pair (z, r) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
QuoRem implements T-division and modulus (like Go):
q = x/y      with the result truncated to zero
r = x - y*q
(See Daan Leijen, “Division and Modulus for Computer Scientists”.)
See [Int.DivMod] for Euclidean division and modulus (unlike Go).</p>
               
               <pre><code class="language-go">func (z *Int) QuoRem(x *Int, y *Int, r *Int) (*Int, *Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rand" data-name="Rand">
               <h3>
                  Rand 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rand" class="anchor" title="Link to Rand">#</a>
               </h3>
               
               <p>Rand sets z to a pseudo-random number in [0, n) and returns z.
As this uses the [math/rand] package, it must not be used for
security-sensitive work. Use [crypto/rand.Int] instead.</p>
               
               <pre><code class="language-go">func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rat" data-name="Rat">
               <h3>
                  Rat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rat" class="anchor" title="Link to Rat">#</a>
               </h3>
               
               <p>Rat returns the rational number corresponding to x;
or nil if x is an infinity.
The result is [Exact] if x is not an Inf.
If a non-nil *[Rat] argument z is provided, [Rat] stores
the result in z instead of allocating a new [Rat].</p>
               
               <pre><code class="language-go">func (x *Float) Rat(z *Rat) (*Rat, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RatString" data-name="RatString">
               <h3>
                  RatString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RatString" class="anchor" title="Link to RatString">#</a>
               </h3>
               
               <p>RatString returns a string representation of x in the form "a/b" if b != 1,
and in the form "a" if b == 1.</p>
               
               <pre><code class="language-go">func (x *Rat) RatString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadByte" data-name="ReadByte">
               <h3>
                  ReadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadByte" class="anchor" title="Link to ReadByte">#</a>
               </h3>
               
               <pre><code class="language-go">func (r byteReader) ReadByte() (byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rem" data-name="Rem">
               <h3>
                  Rem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rem" class="anchor" title="Link to Rem">#</a>
               </h3>
               
               <p>Rem sets z to the remainder x%y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Rem implements truncated modulus (like Go); see [Int.QuoRem] for more details.</p>
               
               <pre><code class="language-go">func (z *Int) Rem(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rsh" data-name="Rsh">
               <h3>
                  Rsh 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rsh" class="anchor" title="Link to Rsh">#</a>
               </h3>
               
               <p>Rsh sets z = x >> n and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Rsh(x *Int, n uint) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scan" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scan" class="anchor" title="Link to Scan">#</a>
               </h3>
               
               <p>Scan is a support routine for [fmt.Scanner]; it sets z to the value of
the scanned number. It accepts formats whose verbs are supported by
[fmt.Scan] for floating point values, which are:
'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'.
Scan doesn't handle ±Inf.</p>
               
               <pre><code class="language-go">func (z *Float) Scan(s fmt.ScanState, ch rune) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scan" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scan" class="anchor" title="Link to Scan">#</a>
               </h3>
               
               <p>Scan is a support routine for [fmt.Scanner]; it sets z to the value of
the scanned number. It accepts the formats 'b' (binary), 'o' (octal),
'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).</p>
               
               <pre><code class="language-go">func (z *Int) Scan(s fmt.ScanState, ch rune) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scan" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scan" class="anchor" title="Link to Scan">#</a>
               </h3>
               
               <p>Scan is a support routine for fmt.Scanner. It accepts the formats
'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.</p>
               
               <pre><code class="language-go">func (z *Rat) Scan(s fmt.ScanState, ch rune) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets z to x (by making a copy of x) and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) Set(x *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to the precision of x
before setting z (and rounding will have no effect).
Rounding is performed according to z's precision and rounding
mode; and z's accuracy reports the result error relative to the
exact (not rounded) result.</p>
               
               <pre><code class="language-go">func (z *Float) Set(x *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets z to x and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Set(x *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBit" data-name="SetBit">
               <h3>
                  SetBit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBit" class="anchor" title="Link to SetBit">#</a>
               </h3>
               
               <p>SetBit sets z to x, with x's i'th bit set to b (0 or 1).
That is,
- if b is 1, SetBit sets z = x | (1 << i);
- if b is 0, SetBit sets z = x &^ (1 << i);
- if b is not 0 or 1, SetBit will panic.</p>
               
               <pre><code class="language-go">func (z *Int) SetBit(x *Int, i int, b uint) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBits" data-name="SetBits">
               <h3>
                  SetBits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBits" class="anchor" title="Link to SetBits">#</a>
               </h3>
               
               <p>SetBits provides raw (unchecked but fast) access to z by setting its
value to abs, interpreted as a little-endian [Word] slice, and returning
z. The result and abs share the same underlying array.
SetBits is intended to support implementation of missing low-level [Int]
functionality outside this package; it should be avoided otherwise.</p>
               
               <pre><code class="language-go">func (z *Int) SetBits(abs []Word) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes interprets buf as the bytes of a big-endian unsigned
integer, sets z to that value, and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) SetBytes(buf []byte) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFloat64" data-name="SetFloat64">
               <h3>
                  SetFloat64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFloat64" class="anchor" title="Link to SetFloat64">#</a>
               </h3>
               
               <p>SetFloat64 sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to 53 (and rounding will have
no effect). SetFloat64 panics with [ErrNaN] if x is a NaN.</p>
               
               <pre><code class="language-go">func (z *Float) SetFloat64(x float64) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFloat64" data-name="SetFloat64">
               <h3>
                  SetFloat64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFloat64" class="anchor" title="Link to SetFloat64">#</a>
               </h3>
               
               <p>SetFloat64 sets z to exactly f and returns z.
If f is not finite, SetFloat returns nil.</p>
               
               <pre><code class="language-go">func (z *Rat) SetFloat64(f float64) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFrac" data-name="SetFrac">
               <h3>
                  SetFrac 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFrac" class="anchor" title="Link to SetFrac">#</a>
               </h3>
               
               <p>SetFrac sets z to a/b and returns z.
If b == 0, SetFrac panics.</p>
               
               <pre><code class="language-go">func (z *Rat) SetFrac(a *Int, b *Int) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFrac64" data-name="SetFrac64">
               <h3>
                  SetFrac64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFrac64" class="anchor" title="Link to SetFrac64">#</a>
               </h3>
               
               <p>SetFrac64 sets z to a/b and returns z.
If b == 0, SetFrac64 panics.</p>
               
               <pre><code class="language-go">func (z *Rat) SetFrac64(a int64, b int64) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInf" data-name="SetInf">
               <h3>
                  SetInf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInf" class="anchor" title="Link to SetInf">#</a>
               </h3>
               
               <p>SetInf sets z to the infinite Float -Inf if signbit is
set, or +Inf if signbit is not set, and returns z. The
precision of z is unchanged and the result is always
[Exact].</p>
               
               <pre><code class="language-go">func (z *Float) SetInf(signbit bool) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInt" data-name="SetInt">
               <h3>
                  SetInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInt" class="anchor" title="Link to SetInt">#</a>
               </h3>
               
               <p>SetInt sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to the larger of x.BitLen()
or 64 (and rounding will have no effect).</p>
               
               <pre><code class="language-go">func (z *Float) SetInt(x *Int) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInt" data-name="SetInt">
               <h3>
                  SetInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInt" class="anchor" title="Link to SetInt">#</a>
               </h3>
               
               <p>SetInt sets z to x (by making a copy of x) and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) SetInt(x *Int) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInt64" data-name="SetInt64">
               <h3>
                  SetInt64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInt64" class="anchor" title="Link to SetInt64">#</a>
               </h3>
               
               <p>SetInt64 sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to 64 (and rounding will have
no effect).</p>
               
               <pre><code class="language-go">func (z *Float) SetInt64(x int64) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInt64" data-name="SetInt64">
               <h3>
                  SetInt64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInt64" class="anchor" title="Link to SetInt64">#</a>
               </h3>
               
               <p>SetInt64 sets z to x and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) SetInt64(x int64) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInt64" data-name="SetInt64">
               <h3>
                  SetInt64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInt64" class="anchor" title="Link to SetInt64">#</a>
               </h3>
               
               <p>SetInt64 sets z to x and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) SetInt64(x int64) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMantExp" data-name="SetMantExp">
               <h3>
                  SetMantExp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMantExp" class="anchor" title="Link to SetMantExp">#</a>
               </h3>
               
               <p>SetMantExp sets z to mant × 2**exp and returns z.
The result z has the same precision and rounding mode
as mant. SetMantExp is an inverse of [Float.MantExp] but does
not require 0.5 <= |mant| < 1.0. Specifically, for a
given x of type *[Float], SetMantExp relates to [Float.MantExp]
as follows:
mant := new(Float)
new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0
Special cases are:
z.SetMantExp(  ±0, exp) =   ±0
z.SetMantExp(±Inf, exp) = ±Inf
z and mant may be the same in which case z's exponent
is set to exp.</p>
               
               <pre><code class="language-go">func (z *Float) SetMantExp(mant *Float, exp int) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMode" data-name="SetMode">
               <h3>
                  SetMode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMode" class="anchor" title="Link to SetMode">#</a>
               </h3>
               
               <p>SetMode sets z's rounding mode to mode and returns an exact z.
z remains unchanged otherwise.
z.SetMode(z.Mode()) is a cheap way to set z's accuracy to [Exact].</p>
               
               <pre><code class="language-go">func (z *Float) SetMode(mode RoundingMode) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPrec" data-name="SetPrec">
               <h3>
                  SetPrec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPrec" class="anchor" title="Link to SetPrec">#</a>
               </h3>
               
               <p>SetPrec sets z's precision to prec and returns the (possibly) rounded
value of z. Rounding occurs according to z's rounding mode if the mantissa
cannot be represented in prec bits without loss of precision.
SetPrec(0) maps all finite values to ±0; infinite values remain unchanged.
If prec > [MaxPrec], it is set to [MaxPrec].</p>
               
               <pre><code class="language-go">func (z *Float) SetPrec(prec uint) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetRat" data-name="SetRat">
               <h3>
                  SetRat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetRat" class="anchor" title="Link to SetRat">#</a>
               </h3>
               
               <p>SetRat sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to the largest of a.BitLen(),
b.BitLen(), or 64; with x = a/b.</p>
               
               <pre><code class="language-go">func (z *Float) SetRat(x *Rat) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetString" data-name="SetString">
               <h3>
                  SetString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetString" class="anchor" title="Link to SetString">#</a>
               </h3>
               
               <p>SetString sets z to the value of s and returns z and a boolean indicating
success. s must be a floating-point number of the same format as accepted
by [Float.Parse], with base argument 0. The entire string (not just a prefix) must
be valid for success. If the operation failed, the value of z is undefined
but the returned value is nil.</p>
               
               <pre><code class="language-go">func (z *Float) SetString(s string) (*Float, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetString" data-name="SetString">
               <h3>
                  SetString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetString" class="anchor" title="Link to SetString">#</a>
               </h3>
               
               <p>SetString sets z to the value of s, interpreted in the given base,
and returns z and a boolean indicating success. The entire string
(not just a prefix) must be valid for success. If SetString fails,
the value of z is undefined but the returned value is nil.
The base argument must be 0 or a value between 2 and [MaxBase].
For base 0, the number prefix determines the actual base: A prefix of
“0b” or “0B” selects base 2, “0”, “0o” or “0O” selects base 8,
and “0x” or “0X” selects base 16. Otherwise, the selected base is 10
and no prefix is accepted.
For bases <= 36, lower and upper case letters are considered the same:
The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
For bases > 36, the upper case letters 'A' to 'Z' represent the digit
values 36 to 61.
For base 0, an underscore character “_” may appear between a base
prefix and an adjacent digit, and between successive digits; such
underscores do not change the value of the number.
Incorrect placement of underscores is reported as an error if there
are no other errors. If base != 0, underscores are not recognized
and act like any other character that is not a valid digit.</p>
               
               <pre><code class="language-go">func (z *Int) SetString(s string, base int) (*Int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetString" data-name="SetString">
               <h3>
                  SetString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetString" class="anchor" title="Link to SetString">#</a>
               </h3>
               
               <p>SetString sets z to the value of s and returns z and a boolean indicating
success. s can be given as a (possibly signed) fraction "a/b", or as a
floating-point number optionally followed by an exponent.
If a fraction is provided, both the dividend and the divisor may be a
decimal integer or independently use a prefix of “0b”, “0” or “0o”,
or “0x” (or their upper-case variants) to denote a binary, octal, or
hexadecimal integer, respectively. The divisor may not be signed.
If a floating-point number is provided, it may be in decimal form or
use any of the same prefixes as above but for “0” to denote a non-decimal
mantissa. A leading “0” is considered a decimal leading 0; it does not
indicate octal representation in this case.
An optional base-10 “e” or base-2 “p” (or their upper-case variants)
exponent may be provided as well, except for hexadecimal floats which
only accept an (optional) “p” exponent (because an “e” or “E” cannot
be distinguished from a mantissa digit). If the exponent's absolute value
is too large, the operation may fail.
The entire string, not just a prefix, must be valid for success. If the
operation failed, the value of z is undefined but the returned value is nil.</p>
               
               <pre><code class="language-go">func (z *Rat) SetString(s string) (*Rat, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUint64" data-name="SetUint64">
               <h3>
                  SetUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUint64" class="anchor" title="Link to SetUint64">#</a>
               </h3>
               
               <p>SetUint64 sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to 64 (and rounding will have
no effect).</p>
               
               <pre><code class="language-go">func (z *Float) SetUint64(x uint64) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUint64" data-name="SetUint64">
               <h3>
                  SetUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUint64" class="anchor" title="Link to SetUint64">#</a>
               </h3>
               
               <p>SetUint64 sets z to x and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) SetUint64(x uint64) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUint64" data-name="SetUint64">
               <h3>
                  SetUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUint64" class="anchor" title="Link to SetUint64">#</a>
               </h3>
               
               <p>SetUint64 sets z to x and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) SetUint64(x uint64) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sign" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sign" class="anchor" title="Link to Sign">#</a>
               </h3>
               
               <p>Sign returns:
- -1 if x < 0;
- 0 if x == 0;
- +1 if x > 0.</p>
               
               <pre><code class="language-go">func (x *Int) Sign() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sign" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sign" class="anchor" title="Link to Sign">#</a>
               </h3>
               
               <p>Sign returns:
- -1 if x < 0;
- 0 if x == 0;
- +1 if x > 0.</p>
               
               <pre><code class="language-go">func (x *Rat) Sign() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sign" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sign" class="anchor" title="Link to Sign">#</a>
               </h3>
               
               <p>Sign returns:
- -1 if x < 0;
- 0 if x is ±0;
- +1 if x > 0.</p>
               
               <pre><code class="language-go">func (x *Float) Sign() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Signbit" data-name="Signbit">
               <h3>
                  Signbit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Signbit" class="anchor" title="Link to Signbit">#</a>
               </h3>
               
               <p>Signbit reports whether x is negative or negative zero.</p>
               
               <pre><code class="language-go">func (x *Float) Signbit() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sqrt" data-name="Sqrt">
               <h3>
                  Sqrt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sqrt" class="anchor" title="Link to Sqrt">#</a>
               </h3>
               
               <p>Sqrt sets z to ⌊√x⌋, the largest integer such that z² ≤ x, and returns z.
It panics if x is negative.</p>
               
               <pre><code class="language-go">func (z *Int) Sqrt(x *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sqrt" data-name="Sqrt">
               <h3>
                  Sqrt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sqrt" class="anchor" title="Link to Sqrt">#</a>
               </h3>
               
               <p>Sqrt sets z to the rounded square root of x, and returns it.
If z's precision is 0, it is changed to x's precision before the
operation. Rounding is performed according to z's precision and
rounding mode, but z's accuracy is not computed. Specifically, the
result of z.Acc() is undefined.
The function panics if z < 0. The value of z is undefined in that
case.</p>
               
               <pre><code class="language-go">func (z *Float) Sqrt(x *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the decimal representation of x as generated by
x.Text(10).</p>
               
               <pre><code class="language-go">func (x *Int) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *decimal) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String formats x like x.Text('g', 10).
(String must be called explicitly, [Float.Format] does not support %s verb.)</p>
               
               <pre><code class="language-go">func (x *Float) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string representation of x in the form "a/b" (even if b == 1).</p>
               
               <pre><code class="language-go">func (x *Rat) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i RoundingMode) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i Accuracy) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <p>Sub sets z to the rounded difference x-y and returns z.
Precision, rounding, and accuracy reporting are as for [Float.Add].
Sub panics with [ErrNaN] if x and y are infinities with equal
signs. The value of z is undefined in that case.</p>
               
               <pre><code class="language-go">func (z *Float) Sub(x *Float, y *Float) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <p>Sub sets z to the difference x-y and returns z.</p>
               
               <pre><code class="language-go">func (z *Rat) Sub(x *Rat, y *Rat) *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <p>Sub sets z to the difference x-y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Sub(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Text" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Text" class="anchor" title="Link to Text">#</a>
               </h3>
               
               <p>Text returns the string representation of x in the given base.
Base must be between 2 and 62, inclusive. The result uses the
lower-case letters 'a' to 'z' for digit values 10 to 35, and
the upper-case letters 'A' to 'Z' for digit values 36 to 61.
No prefix (such as "0x") is added to the string. If x is a nil
pointer it returns "<nil>".</p>
               
               <pre><code class="language-go">func (x *Int) Text(base int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Text" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Text" class="anchor" title="Link to Text">#</a>
               </h3>
               
               <p>Text converts the floating-point number x to a string according
to the given format and precision prec. The format is one of:
'e'	-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits
'E'	-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits
'f'	-ddddd.dddd, no exponent
'g'	like 'e' for large exponents, like 'f' otherwise
'G'	like 'E' for large exponents, like 'f' otherwise
'x'	-0xd.dddddp±dd, hexadecimal mantissa, decimal power of two exponent
'p'	-0x.dddp±dd, hexadecimal mantissa, decimal power of two exponent (non-standard)
'b'	-ddddddp±dd, decimal mantissa, decimal power of two exponent (non-standard)
For the power-of-two exponent formats, the mantissa is printed in normalized form:
'x'	hexadecimal mantissa in [1, 2), or 0
'p'	hexadecimal mantissa in [½, 1), or 0
'b'	decimal integer mantissa using x.Prec() bits, or 0
Note that the 'x' form is the one used by most other languages and libraries.
If format is a different character, Text returns a "%" followed by the
unrecognized format character.
The precision prec controls the number of digits (excluding the exponent)
printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats.
For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point.
For 'g' and 'G' it is the total number of digits. A negative precision selects
the smallest number of decimal digits necessary to identify the value x uniquely
using x.Prec() mantissa bits.
The prec value is ignored for the 'b' and 'p' formats.</p>
               
               <pre><code class="language-go">func (x *Float) Text(format byte, prec int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrailingZeroBits" data-name="TrailingZeroBits">
               <h3>
                  TrailingZeroBits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TrailingZeroBits" class="anchor" title="Link to TrailingZeroBits">#</a>
               </h3>
               
               <p>TrailingZeroBits returns the number of consecutive least significant zero
bits of |x|.</p>
               
               <pre><code class="language-go">func (x *Int) TrailingZeroBits() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Uint64" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Uint64" class="anchor" title="Link to Uint64">#</a>
               </h3>
               
               <p>Uint64 returns the unsigned integer resulting from truncating x
towards zero. If 0 <= x <= [math.MaxUint64], the result is [Exact]
if x is an integer and [Below] otherwise.
The result is (0, [Above]) for x < 0, and ([math.MaxUint64], [Below])
for x > [math.MaxUint64].</p>
               
               <pre><code class="language-go">func (x *Float) Uint64() (uint64, Accuracy)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Uint64" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Uint64" class="anchor" title="Link to Uint64">#</a>
               </h3>
               
               <p>Uint64 returns the uint64 representation of x.
If x cannot be represented in a uint64, the result is undefined.</p>
               
               <pre><code class="language-go">func (x *Int) Uint64() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalJSON" data-name="UnmarshalJSON">
               <h3>
                  UnmarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalJSON" class="anchor" title="Link to UnmarshalJSON">#</a>
               </h3>
               
               <p>UnmarshalJSON implements the [encoding/json.Unmarshaler] interface.</p>
               
               <pre><code class="language-go">func (z *Int) UnmarshalJSON(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the [encoding.TextUnmarshaler] interface.
The result is rounded per the precision and rounding mode of z.
If z's precision is 0, it is changed to 64 before rounding takes
effect.</p>
               
               <pre><code class="language-go">func (z *Float) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the [encoding.TextUnmarshaler] interface.</p>
               
               <pre><code class="language-go">func (z *Rat) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the [encoding.TextUnmarshaler] interface.</p>
               
               <pre><code class="language-go">func (z *Int) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadByte" data-name="UnreadByte">
               <h3>
                  UnreadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadByte" class="anchor" title="Link to UnreadByte">#</a>
               </h3>
               
               <pre><code class="language-go">func (r byteReader) UnreadByte() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Xor" data-name="Xor">
               <h3>
                  Xor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Xor" class="anchor" title="Link to Xor">#</a>
               </h3>
               
               <p>Xor sets z = x ^ y and returns z.</p>
               
               <pre><code class="language-go">func (z *Int) Xor(x *Int, y *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) add(x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addAt" data-name="addAt">
               <h3>
                  addAt 
                  <span class="badge">function</span>
                  
                  <a href="#addAt" class="anchor" title="Link to addAt">#</a>
               </h3>
               
               <p>addAt implements z += x<<(_W*i); z must be long enough.
(we don't use nat.add because we need z to stay the same
slice, and we don't need to normalize z after each addition)</p>
               
               <pre><code class="language-go">func addAt(z nat, x nat, i int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW" data-name="addMulVVW">
               <h3>
                  addMulVVW 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW" class="anchor" title="Link to addMulVVW">#</a>
               </h3>
               
               <p>addMulVVW should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname addMulVVW
go:noescape</p>
               
               <pre><code class="language-go">func addMulVVW(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW" data-name="addMulVVW">
               <h3>
                  addMulVVW 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW" class="anchor" title="Link to addMulVVW">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW_g" data-name="addMulVVW_g">
               <h3>
                  addMulVVW_g 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW_g" class="anchor" title="Link to addMulVVW_g">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW_g(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVV" data-name="addVV">
               <h3>
                  addVV 
                  <span class="badge">function</span>
                  
                  <a href="#addVV" class="anchor" title="Link to addVV">#</a>
               </h3>
               
               <p>addVV should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname addVV
go:noescape</p>
               
               <pre><code class="language-go">func addVV(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVV" data-name="addVV">
               <h3>
                  addVV 
                  <span class="badge">function</span>
                  
                  <a href="#addVV" class="anchor" title="Link to addVV">#</a>
               </h3>
               
               <pre><code class="language-go">func addVV(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVV_check" data-name="addVV_check">
               <h3>
                  addVV_check 
                  <span class="badge">function</span>
                  
                  <a href="#addVV_check" class="anchor" title="Link to addVV_check">#</a>
               </h3>
               
               <pre><code class="language-go">func addVV_check(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVV_g" data-name="addVV_g">
               <h3>
                  addVV_g 
                  <span class="badge">function</span>
                  
                  <a href="#addVV_g" class="anchor" title="Link to addVV_g">#</a>
               </h3>
               
               <p>The resulting carry c is either 0 or 1.</p>
               
               <pre><code class="language-go">func addVV_g(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVV_novec" data-name="addVV_novec">
               <h3>
                  addVV_novec 
                  <span class="badge">function</span>
                  
                  <a href="#addVV_novec" class="anchor" title="Link to addVV_novec">#</a>
               </h3>
               
               <pre><code class="language-go">func addVV_novec(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVV_vec" data-name="addVV_vec">
               <h3>
                  addVV_vec 
                  <span class="badge">function</span>
                  
                  <a href="#addVV_vec" class="anchor" title="Link to addVV_vec">#</a>
               </h3>
               
               <pre><code class="language-go">func addVV_vec(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVW" data-name="addVW">
               <h3>
                  addVW 
                  <span class="badge">function</span>
                  
                  <a href="#addVW" class="anchor" title="Link to addVW">#</a>
               </h3>
               
               <pre><code class="language-go">func addVW(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVW" data-name="addVW">
               <h3>
                  addVW 
                  <span class="badge">function</span>
                  
                  <a href="#addVW" class="anchor" title="Link to addVW">#</a>
               </h3>
               
               <p>addVW should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname addVW
go:noescape</p>
               
               <pre><code class="language-go">func addVW(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVW_g" data-name="addVW_g">
               <h3>
                  addVW_g 
                  <span class="badge">function</span>
                  
                  <a href="#addVW_g" class="anchor" title="Link to addVW_g">#</a>
               </h3>
               
               <p>The resulting carry c is either 0 or 1.</p>
               
               <pre><code class="language-go">func addVW_g(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addVWlarge" data-name="addVWlarge">
               <h3>
                  addVWlarge 
                  <span class="badge">function</span>
                  
                  <a href="#addVWlarge" class="anchor" title="Link to addVWlarge">#</a>
               </h3>
               
               <p>addVWlarge is addVW, but intended for large z.
The only difference is that we check on every iteration
whether we are done with carries,
and if so, switch to a much faster copy instead.
This is only a good idea for large z,
because the overhead of the check and the function call
outweigh the benefits when z is small.</p>
               
               <pre><code class="language-go">func addVWlarge(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alias" data-name="alias">
               <h3>
                  alias 
                  <span class="badge">function</span>
                  
                  <a href="#alias" class="anchor" title="Link to alias">#</a>
               </h3>
               
               <p>alias reports whether x and y share the same base array.
Note: alias assumes that the capacity of underlying arrays
is never changed for nat values; i.e. that there are
no 3-operand slice expressions in this code (or worse,
reflect-based operations to the same effect).</p>
               
               <pre><code class="language-go">func alias(x nat, y nat) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="and" data-name="and">
               <h3>
                  and 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#and" class="anchor" title="Link to and">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) and(x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="andNot" data-name="andNot">
               <h3>
                  andNot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#andNot" class="anchor" title="Link to andNot">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) andNot(x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendZeros" data-name="appendZeros">
               <h3>
                  appendZeros 
                  <span class="badge">function</span>
                  
                  <a href="#appendZeros" class="anchor" title="Link to appendZeros">#</a>
               </h3>
               
               <p>appendZeros appends n 0 digits to buf and returns buf.</p>
               
               <pre><code class="language-go">func appendZeros(buf []byte, n int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="at" data-name="at">
               <h3>
                  at 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#at" class="anchor" title="Link to at">#</a>
               </h3>
               
               <p>at returns the i'th mantissa digit, starting with the most significant digit at 0.</p>
               
               <pre><code class="language-go">func (d *decimal) at(i int) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="basicMul" data-name="basicMul">
               <h3>
                  basicMul 
                  <span class="badge">function</span>
                  
                  <a href="#basicMul" class="anchor" title="Link to basicMul">#</a>
               </h3>
               
               <p>basicMul multiplies x and y and leaves the result in z.
The (non-normalized) result is placed in z[0 : len(x) + len(y)].</p>
               
               <pre><code class="language-go">func basicMul(z nat, x nat, y nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="basicSqr" data-name="basicSqr">
               <h3>
                  basicSqr 
                  <span class="badge">function</span>
                  
                  <a href="#basicSqr" class="anchor" title="Link to basicSqr">#</a>
               </h3>
               
               <p>basicSqr sets z = x*x and is asymptotically faster than basicMul
by about a factor of 2, but slower for small arguments due to overhead.
Requirements: len(x) > 0, len(z) == 2*len(x)
The (non-normalized) result is placed in z.</p>
               
               <pre><code class="language-go">func basicSqr(z nat, x nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bigEndianWord" data-name="bigEndianWord">
               <h3>
                  bigEndianWord 
                  <span class="badge">function</span>
                  
                  <a href="#bigEndianWord" class="anchor" title="Link to bigEndianWord">#</a>
               </h3>
               
               <p>bigEndianWord returns the contents of buf interpreted as a big-endian encoded Word value.</p>
               
               <pre><code class="language-go">func bigEndianWord(buf []byte) Word</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bit" data-name="bit">
               <h3>
                  bit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bit" class="anchor" title="Link to bit">#</a>
               </h3>
               
               <p>bit returns the value of the i'th bit, with lsb == bit 0.</p>
               
               <pre><code class="language-go">func (x nat) bit(i uint) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitLen" data-name="bitLen">
               <h3>
                  bitLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bitLen" class="anchor" title="Link to bitLen">#</a>
               </h3>
               
               <p>bitLen returns the length of x in bits.
Unlike most methods, it works even if x is not normalized.</p>
               
               <pre><code class="language-go">func (x nat) bitLen() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytes" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytes" class="anchor" title="Link to bytes">#</a>
               </h3>
               
               <p>bytes writes the value of z into buf using big-endian encoding.
The value of z is encoded in the slice buf[i:]. If the value of z
cannot be represented in buf, bytes panics. The number i of unused
bytes at the beginning of buf is returned as result.</p>
               
               <pre><code class="language-go">func (z nat) bytes(buf []byte) (i int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmp" data-name="cmp">
               <h3>
                  cmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cmp" class="anchor" title="Link to cmp">#</a>
               </h3>
               
               <pre><code class="language-go">func (x nat) cmp(y nat) (r int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertWords" data-name="convertWords">
               <h3>
                  convertWords 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convertWords" class="anchor" title="Link to convertWords">#</a>
               </h3>
               
               <p>Convert words of q to base b digits in s. If q is large, it is recursively "split in half"
by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using
repeated nat/Word division.
The iterative method processes n Words by n divW() calls, each of which visits every Word in the
incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s.
Recursive conversion divides q by its approximate square root, yielding two parts, each half
the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s
plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and
is made better by splitting the subblocks recursively. Best is to split blocks until one more
split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the
iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the
range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and
~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for
specific hardware.</p>
               
               <pre><code class="language-go">func (q nat) convertWords(s []byte, b Word, ndigits int, bb Word, table []divisor)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="div" data-name="div">
               <h3>
                  div 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#div" class="anchor" title="Link to div">#</a>
               </h3>
               
               <p>div returns q, r such that q = ⌊u/v⌋ and r = u%v = u - q·v.
It uses z and z2 as the storage for q and r.</p>
               
               <pre><code class="language-go">func (z nat) div(z2 nat, u nat, v nat) (q nat, r nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divBasic" data-name="divBasic">
               <h3>
                  divBasic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#divBasic" class="anchor" title="Link to divBasic">#</a>
               </h3>
               
               <p>divBasic implements long division as described above.
It overwrites q with ⌊u/v⌋ and overwrites u with the remainder r.
q must be large enough to hold ⌊u/v⌋.</p>
               
               <pre><code class="language-go">func (q nat) divBasic(u nat, v nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divLarge" data-name="divLarge">
               <h3>
                  divLarge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#divLarge" class="anchor" title="Link to divLarge">#</a>
               </h3>
               
               <p>div returns q, r such that q = ⌊uIn/vIn⌋ and r = uIn%vIn = uIn - q·vIn.
It uses z and u as the storage for q and r.
The caller must ensure that len(vIn) ≥ 2 (use divW otherwise)
and that len(uIn) ≥ len(vIn) (the answer is 0, uIn otherwise).</p>
               
               <pre><code class="language-go">func (z nat) divLarge(u nat, uIn nat, vIn nat) (q nat, r nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divRecursive" data-name="divRecursive">
               <h3>
                  divRecursive 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#divRecursive" class="anchor" title="Link to divRecursive">#</a>
               </h3>
               
               <p>divRecursive implements recursive division as described above.
It overwrites z with ⌊u/v⌋ and overwrites u with the remainder r.
z must be large enough to hold ⌊u/v⌋.
This function is just for allocating and freeing temporaries
around divRecursiveStep, the real implementation.</p>
               
               <pre><code class="language-go">func (z nat) divRecursive(u nat, v nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divRecursiveStep" data-name="divRecursiveStep">
               <h3>
                  divRecursiveStep 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#divRecursiveStep" class="anchor" title="Link to divRecursiveStep">#</a>
               </h3>
               
               <p>divRecursiveStep is the actual implementation of recursive division.
It adds ⌊u/v⌋ to z and overwrites u with the remainder r.
z must be large enough to hold ⌊u/v⌋.
It uses temps[depth] (allocating if needed) as a temporary live across
the recursive call. It also uses tmp, but not live across the recursion.</p>
               
               <pre><code class="language-go">func (z nat) divRecursiveStep(u nat, v nat, depth int, tmp *nat, temps []*nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divW" data-name="divW">
               <h3>
                  divW 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#divW" class="anchor" title="Link to divW">#</a>
               </h3>
               
               <p>divW returns q, r such that q = ⌊x/y⌋ and r = x%y = x - q·y.
It uses z as the storage for q.
Note that y is a single digit (Word), not a big number.</p>
               
               <pre><code class="language-go">func (z nat) divW(x nat, y Word) (q nat, r Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divWVW" data-name="divWVW">
               <h3>
                  divWVW 
                  <span class="badge">function</span>
                  
                  <a href="#divWVW" class="anchor" title="Link to divWVW">#</a>
               </h3>
               
               <p>divWVW overwrites z with ⌊x/y⌋, returning the remainder r.
The caller must ensure that len(z) = len(x).</p>
               
               <pre><code class="language-go">func divWVW(z []Word, xn Word, x []Word, y Word) (r Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divWW" data-name="divWW">
               <h3>
                  divWW 
                  <span class="badge">function</span>
                  
                  <a href="#divWW" class="anchor" title="Link to divWW">#</a>
               </h3>
               
               <p>q = ( x1 << _W + x0 - r)/y. m = floor(( _B^2 - 1 ) / d - _B). Requiring x1<y.
An approximate reciprocal with a reference to "Improved Division by Invariant Integers
(IEEE Transactions on Computers, 11 Jun. 2010)"</p>
               
               <pre><code class="language-go">func divWW(x1 Word, x0 Word, y Word, m Word) (q Word, r Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="divisors" data-name="divisors">
               <h3>
                  divisors 
                  <span class="badge">function</span>
                  
                  <a href="#divisors" class="anchor" title="Link to divisors">#</a>
               </h3>
               
               <p>construct table of powers of bb*leafSize to use in subdivisions.</p>
               
               <pre><code class="language-go">func divisors(m int, b Word, ndigits int, bb Word) []divisor</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="euclidUpdate" data-name="euclidUpdate">
               <h3>
                  euclidUpdate 
                  <span class="badge">function</span>
                  
                  <a href="#euclidUpdate" class="anchor" title="Link to euclidUpdate">#</a>
               </h3>
               
               <p>euclidUpdate performs a single step of the Euclidean GCD algorithm
if extended is true, it also updates the cosequence Ua, Ub.</p>
               
               <pre><code class="language-go">func euclidUpdate(A *Int, B *Int, Ua *Int, Ub *Int, q *Int, r *Int, s *Int, t *Int, extended bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exp" data-name="exp">
               <h3>
                  exp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exp" class="anchor" title="Link to exp">#</a>
               </h3>
               
               <pre><code class="language-go">func (z *Int) exp(x *Int, y *Int, m *Int, slow bool) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expNN" data-name="expNN">
               <h3>
                  expNN 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expNN" class="anchor" title="Link to expNN">#</a>
               </h3>
               
               <p>If m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m;
otherwise it sets z to x**y. The result is the value of z.</p>
               
               <pre><code class="language-go">func (z nat) expNN(x nat, y nat, m nat, slow bool) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expNNMontgomery" data-name="expNNMontgomery">
               <h3>
                  expNNMontgomery 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expNNMontgomery" class="anchor" title="Link to expNNMontgomery">#</a>
               </h3>
               
               <p>expNNMontgomery calculates x**y mod m using a fixed, 4-bit window.
Uses Montgomery representation.</p>
               
               <pre><code class="language-go">func (z nat) expNNMontgomery(x nat, y nat, m nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expNNMontgomeryEven" data-name="expNNMontgomeryEven">
               <h3>
                  expNNMontgomeryEven 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expNNMontgomeryEven" class="anchor" title="Link to expNNMontgomeryEven">#</a>
               </h3>
               
               <p>expNNMontgomeryEven calculates x**y mod m where m = m1 × m2 for m1 = 2ⁿ and m2 odd.
It uses two recursive calls to expNN for x**y mod m1 and x**y mod m2
and then uses the Chinese Remainder Theorem to combine the results.
The recursive call using m1 will use expNNWindowed,
while the recursive call using m2 will use expNNMontgomery.
For more details, see Ç. K. Koç, “Montgomery Reduction with Even Modulus”,
IEE Proceedings: Computers and Digital Techniques, 141(5) 314-316, September 1994.
http://www.people.vcu.edu/~jwang3/CMSC691/j34monex.pdf</p>
               
               <pre><code class="language-go">func (z nat) expNNMontgomeryEven(x nat, y nat, m nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expNNWindowed" data-name="expNNWindowed">
               <h3>
                  expNNWindowed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expNNWindowed" class="anchor" title="Link to expNNWindowed">#</a>
               </h3>
               
               <p>expNNWindowed calculates x**y mod m using a fixed, 4-bit window,
where m = 2**logM.</p>
               
               <pre><code class="language-go">func (z nat) expNNWindowed(x nat, y nat, logM uint) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expSlow" data-name="expSlow">
               <h3>
                  expSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expSlow" class="anchor" title="Link to expSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (z *Int) expSlow(x *Int, y *Int, m *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expWW" data-name="expWW">
               <h3>
                  expWW 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expWW" class="anchor" title="Link to expWW">#</a>
               </h3>
               
               <p>expWW computes x**y</p>
               
               <pre><code class="language-go">func (z nat) expWW(x Word, y Word) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtB" data-name="fmtB">
               <h3>
                  fmtB 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtB" class="anchor" title="Link to fmtB">#</a>
               </h3>
               
               <p>fmtB appends the string of x in the format mantissa "p" exponent
with a decimal mantissa and a binary exponent, or "0" if x is zero,
and returns the extended buffer.
The mantissa is normalized such that is uses x.Prec() bits in binary
representation.
The sign of x is ignored, and x must not be an Inf.
(The caller handles Inf before invoking fmtB.)</p>
               
               <pre><code class="language-go">func (x *Float) fmtB(buf []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtE" data-name="fmtE">
               <h3>
                  fmtE 
                  <span class="badge">function</span>
                  
                  <a href="#fmtE" class="anchor" title="Link to fmtE">#</a>
               </h3>
               
               <p>%e: d.ddddde±dd</p>
               
               <pre><code class="language-go">func fmtE(buf []byte, fmt byte, prec int, d decimal) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtF" data-name="fmtF">
               <h3>
                  fmtF 
                  <span class="badge">function</span>
                  
                  <a href="#fmtF" class="anchor" title="Link to fmtF">#</a>
               </h3>
               
               <p>%f: ddddddd.ddddd</p>
               
               <pre><code class="language-go">func fmtF(buf []byte, prec int, d decimal) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtP" data-name="fmtP">
               <h3>
                  fmtP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtP" class="anchor" title="Link to fmtP">#</a>
               </h3>
               
               <p>fmtP appends the string of x in the format "0x." mantissa "p" exponent
with a hexadecimal mantissa and a binary exponent, or "0" if x is zero,
and returns the extended buffer.
The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0.
The sign of x is ignored, and x must not be an Inf.
(The caller handles Inf before invoking fmtP.)</p>
               
               <pre><code class="language-go">func (x *Float) fmtP(buf []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtX" data-name="fmtX">
               <h3>
                  fmtX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtX" class="anchor" title="Link to fmtX">#</a>
               </h3>
               
               <p>fmtX appends the string of x in the format "0x1." mantissa "p" exponent
with a hexadecimal mantissa and a binary exponent, or "0x0p0" if x is zero,
and returns the extended buffer.
A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0.
The sign of x is ignored, and x must not be an Inf.
(The caller handles Inf before invoking fmtX.)</p>
               
               <pre><code class="language-go">func (x *Float) fmtX(buf []byte, prec int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fnorm" data-name="fnorm">
               <h3>
                  fnorm 
                  <span class="badge">function</span>
                  
                  <a href="#fnorm" class="anchor" title="Link to fnorm">#</a>
               </h3>
               
               <p>fnorm normalizes mantissa m by shifting it to the left
such that the msb of the most-significant word (msw) is 1.
It returns the shift amount. It assumes that len(m) != 0.</p>
               
               <pre><code class="language-go">func fnorm(m nat) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getNat" data-name="getNat">
               <h3>
                  getNat 
                  <span class="badge">function</span>
                  
                  <a href="#getNat" class="anchor" title="Link to getNat">#</a>
               </h3>
               
               <p>getNat returns a *nat of len n. The contents may not be zero.
The pool holds *nat to avoid allocation when converting to interface{}.</p>
               
               <pre><code class="language-go">func getNat(n int) *nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="greaterThan" data-name="greaterThan">
               <h3>
                  greaterThan 
                  <span class="badge">function</span>
                  
                  <a href="#greaterThan" class="anchor" title="Link to greaterThan">#</a>
               </h3>
               
               <p>greaterThan reports whether the two digit numbers x1 x2 > y1 y2.
TODO(rsc): In contradiction to most of this file, x1 is the high
digit and x2 is the low digit. This should be fixed.</p>
               
               <pre><code class="language-go">func greaterThan(x1 Word, x2 Word, y1 Word, y2 Word) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>Init initializes x to the decimal representation of m << shift (for
shift >= 0), or m >> -shift (for shift < 0).</p>
               
               <pre><code class="language-go">func (x *decimal) init(m nat, shift int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPow2" data-name="isPow2">
               <h3>
                  isPow2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isPow2" class="anchor" title="Link to isPow2">#</a>
               </h3>
               
               <p>isPow2 returns i, true when x == 2**i and 0, false otherwise.</p>
               
               <pre><code class="language-go">func (x nat) isPow2() (uint, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itoa" data-name="itoa">
               <h3>
                  itoa 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#itoa" class="anchor" title="Link to itoa">#</a>
               </h3>
               
               <p>itoa is like utoa but it prepends a '-' if neg && x != 0.</p>
               
               <pre><code class="language-go">func (x nat) itoa(neg bool, base int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="karatsuba" data-name="karatsuba">
               <h3>
                  karatsuba 
                  <span class="badge">function</span>
                  
                  <a href="#karatsuba" class="anchor" title="Link to karatsuba">#</a>
               </h3>
               
               <p>karatsuba multiplies x and y and leaves the result in z.
Both x and y must have the same length n and n must be a
power of 2. The result vector z must have len(z) >= 6*n.
The (non-normalized) result is placed in z[0 : 2*n].</p>
               
               <pre><code class="language-go">func karatsuba(z nat, x nat, y nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="karatsubaAdd" data-name="karatsubaAdd">
               <h3>
                  karatsubaAdd 
                  <span class="badge">function</span>
                  
                  <a href="#karatsubaAdd" class="anchor" title="Link to karatsubaAdd">#</a>
               </h3>
               
               <p>Fast version of z[0:n+n>>1].add(z[0:n+n>>1], x[0:n]) w/o bounds checks.
Factored out for readability - do not use outside karatsuba.</p>
               
               <pre><code class="language-go">func karatsubaAdd(z nat, x nat, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="karatsubaLen" data-name="karatsubaLen">
               <h3>
                  karatsubaLen 
                  <span class="badge">function</span>
                  
                  <a href="#karatsubaLen" class="anchor" title="Link to karatsubaLen">#</a>
               </h3>
               
               <p>karatsubaLen computes an approximation to the maximum k <= n such that
k = p<<i for a number p <= threshold and an i >= 0. Thus, the
result is the largest number that can be divided repeatedly by 2 before
becoming about the value of threshold.</p>
               
               <pre><code class="language-go">func karatsubaLen(n int, threshold int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="karatsubaSqr" data-name="karatsubaSqr">
               <h3>
                  karatsubaSqr 
                  <span class="badge">function</span>
                  
                  <a href="#karatsubaSqr" class="anchor" title="Link to karatsubaSqr">#</a>
               </h3>
               
               <p>karatsubaSqr squares x and leaves the result in z.
len(x) must be a power of 2 and len(z) >= 6*len(x).
The (non-normalized) result is placed in z[0 : 2*len(x)].
The algorithm and the layout of z are the same as for karatsuba.</p>
               
               <pre><code class="language-go">func karatsubaSqr(z nat, x nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="karatsubaSub" data-name="karatsubaSub">
               <h3>
                  karatsubaSub 
                  <span class="badge">function</span>
                  
                  <a href="#karatsubaSub" class="anchor" title="Link to karatsubaSub">#</a>
               </h3>
               
               <p>Like karatsubaAdd, but does subtract.</p>
               
               <pre><code class="language-go">func karatsubaSub(z nat, x nat, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lehmerGCD" data-name="lehmerGCD">
               <h3>
                  lehmerGCD 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lehmerGCD" class="anchor" title="Link to lehmerGCD">#</a>
               </h3>
               
               <p>lehmerGCD sets z to the greatest common divisor of a and b,
which both must be != 0, and returns z.
If x or y are not nil, their values are set such that z = a*x + b*y.
See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L.
This implementation uses the improved condition by Collins requiring only one
quotient and avoiding the possibility of single Word overflow.
See Jebelean, "Improving the multiprecision Euclidean algorithm",
Design and Implementation of Symbolic Computation Systems, pp 45-58.
The cosequences are updated according to Algorithm 10.45 from
Cohen et al. "Handbook of Elliptic and Hyperelliptic Curve Cryptography" pp 192.</p>
               
               <pre><code class="language-go">func (z *Int) lehmerGCD(x *Int, y *Int, a *Int, b *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lehmerSimulate" data-name="lehmerSimulate">
               <h3>
                  lehmerSimulate 
                  <span class="badge">function</span>
                  
                  <a href="#lehmerSimulate" class="anchor" title="Link to lehmerSimulate">#</a>
               </h3>
               
               <p>lehmerSimulate attempts to simulate several Euclidean update steps
using the leading digits of A and B.  It returns u0, u1, v0, v1
such that A and B can be updated as:
A = u0*A + v0*B
B = u1*A + v1*B
Requirements: A >= B and len(B.abs) >= 2
Since we are calculating with full words to avoid overflow,
we use 'even' to track the sign of the cosequences.
For even iterations: u0, v1 >= 0 && u1, v0 <= 0
For odd  iterations: u0, v1 <= 0 && u1, v0 >= 0</p>
               
               <pre><code class="language-go">func lehmerSimulate(A *Int, B *Int) (u0 Word, u1 Word, v0 Word, v1 Word, even bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lehmerUpdate" data-name="lehmerUpdate">
               <h3>
                  lehmerUpdate 
                  <span class="badge">function</span>
                  
                  <a href="#lehmerUpdate" class="anchor" title="Link to lehmerUpdate">#</a>
               </h3>
               
               <p>lehmerUpdate updates the inputs A and B such that:
A = u0*A + v0*B
B = u1*A + v1*B
where the signs of u0, u1, v0, v1 are given by even
For even == true: u0, v1 >= 0 && u1, v0 <= 0
For even == false: u0, v1 <= 0 && u1, v0 >= 0
q, r, s, t are temporary variables to avoid allocations in the multiplication.</p>
               
               <pre><code class="language-go">func lehmerUpdate(A *Int, B *Int, q *Int, r *Int, s *Int, t *Int, u0 Word, u1 Word, v0 Word, v1 Word, even bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="low32" data-name="low32">
               <h3>
                  low32 
                  <span class="badge">function</span>
                  
                  <a href="#low32" class="anchor" title="Link to low32">#</a>
               </h3>
               
               <p>low32 returns the least significant 32 bits of x.</p>
               
               <pre><code class="language-go">func low32(x nat) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="low64" data-name="low64">
               <h3>
                  low64 
                  <span class="badge">function</span>
                  
                  <a href="#low64" class="anchor" title="Link to low64">#</a>
               </h3>
               
               <p>low64 returns the least significant 64 bits of x.</p>
               
               <pre><code class="language-go">func low64(x nat) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="make" data-name="make">
               <h3>
                  make 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#make" class="anchor" title="Link to make">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) make(n int) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeAcc" data-name="makeAcc">
               <h3>
                  makeAcc 
                  <span class="badge">function</span>
                  
                  <a href="#makeAcc" class="anchor" title="Link to makeAcc">#</a>
               </h3>
               
               <pre><code class="language-go">func makeAcc(above bool) Accuracy</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshal" data-name="marshal">
               <h3>
                  marshal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshal" class="anchor" title="Link to marshal">#</a>
               </h3>
               
               <p>marshal implements [Rat.String] returning a slice of bytes.
It appends the string representation of x in the form "a/b" (even if b == 1) to buf,
and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (x *Rat) marshal(buf []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxPow" data-name="maxPow">
               <h3>
                  maxPow 
                  <span class="badge">function</span>
                  
                  <a href="#maxPow" class="anchor" title="Link to maxPow">#</a>
               </h3>
               
               <p>maxPow returns (b**n, n) such that b**n is the largest power b**n <= _M.
For instance maxPow(10) == (1e19, 19) for 19 decimal digits in a 64bit Word.
In other words, at most n digits in base b fit into a Word.
TODO(gri) replace this with a table, generated at build time.</p>
               
               <pre><code class="language-go">func maxPow(b Word) (p Word, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modInverse" data-name="modInverse">
               <h3>
                  modInverse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modInverse" class="anchor" title="Link to modInverse">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) modInverse(g nat, n nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modSqrt3Mod4Prime" data-name="modSqrt3Mod4Prime">
               <h3>
                  modSqrt3Mod4Prime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modSqrt3Mod4Prime" class="anchor" title="Link to modSqrt3Mod4Prime">#</a>
               </h3>
               
               <p>modSqrt3Mod4 uses the identity
(a^((p+1)/4))^2  mod p
== u^(p+1)          mod p
== u^2              mod p
to calculate the square root of any quadratic residue mod p quickly for 3
mod 4 primes.</p>
               
               <pre><code class="language-go">func (z *Int) modSqrt3Mod4Prime(x *Int, p *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modSqrt5Mod8Prime" data-name="modSqrt5Mod8Prime">
               <h3>
                  modSqrt5Mod8Prime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modSqrt5Mod8Prime" class="anchor" title="Link to modSqrt5Mod8Prime">#</a>
               </h3>
               
               <p>modSqrt5Mod8Prime uses Atkin's observation that 2 is not a square mod p
alpha ==  (2*a)^((p-5)/8)    mod p
beta  ==  2*a*alpha^2        mod p  is a square root of -1
b     ==  a*alpha*(beta-1)   mod p  is a square root of a
to calculate the square root of any quadratic residue mod p quickly for 5
mod 8 primes.</p>
               
               <pre><code class="language-go">func (z *Int) modSqrt5Mod8Prime(x *Int, p *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modSqrtTonelliShanks" data-name="modSqrtTonelliShanks">
               <h3>
                  modSqrtTonelliShanks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modSqrtTonelliShanks" class="anchor" title="Link to modSqrtTonelliShanks">#</a>
               </h3>
               
               <p>modSqrtTonelliShanks uses the Tonelli-Shanks algorithm to find the square
root of a quadratic residue modulo any prime.</p>
               
               <pre><code class="language-go">func (z *Int) modSqrtTonelliShanks(x *Int, p *Int) *Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modW" data-name="modW">
               <h3>
                  modW 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modW" class="anchor" title="Link to modW">#</a>
               </h3>
               
               <p>modW returns x % d.</p>
               
               <pre><code class="language-go">func (x nat) modW(d Word) (r Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="montgomery" data-name="montgomery">
               <h3>
                  montgomery 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#montgomery" class="anchor" title="Link to montgomery">#</a>
               </h3>
               
               <p>montgomery computes z mod m = x*y*2**(-n*_W) mod m,
assuming k = -1/m mod 2**_W.
z is used for storing the result which is returned;
z must not alias x, y or m.
See Gueron, "Efficient Software Implementations of Modular Exponentiation".
https://eprint.iacr.org/2011/239.pdf
In the terminology of that paper, this is an "Almost Montgomery Multiplication":
x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.</p>
               
               <pre><code class="language-go">func (z nat) montgomery(x nat, y nat, m nat, k Word, n int) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="msb32" data-name="msb32">
               <h3>
                  msb32 
                  <span class="badge">function</span>
                  
                  <a href="#msb32" class="anchor" title="Link to msb32">#</a>
               </h3>
               
               <p>msb32 returns the 32 most significant bits of x.</p>
               
               <pre><code class="language-go">func msb32(x nat) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="msb64" data-name="msb64">
               <h3>
                  msb64 
                  <span class="badge">function</span>
                  
                  <a href="#msb64" class="anchor" title="Link to msb64">#</a>
               </h3>
               
               <p>msb64 returns the 64 most significant bits of x.</p>
               
               <pre><code class="language-go">func msb64(x nat) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mul" data-name="mul">
               <h3>
                  mul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mul" class="anchor" title="Link to mul">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) mul(x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulAddVWW" data-name="mulAddVWW">
               <h3>
                  mulAddVWW 
                  <span class="badge">function</span>
                  
                  <a href="#mulAddVWW" class="anchor" title="Link to mulAddVWW">#</a>
               </h3>
               
               <p>mulAddVWW should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname mulAddVWW
go:noescape</p>
               
               <pre><code class="language-go">func mulAddVWW(z []Word, x []Word, y Word, r Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulAddVWW" data-name="mulAddVWW">
               <h3>
                  mulAddVWW 
                  <span class="badge">function</span>
                  
                  <a href="#mulAddVWW" class="anchor" title="Link to mulAddVWW">#</a>
               </h3>
               
               <pre><code class="language-go">func mulAddVWW(z []Word, x []Word, y Word, r Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulAddVWW_g" data-name="mulAddVWW_g">
               <h3>
                  mulAddVWW_g 
                  <span class="badge">function</span>
                  
                  <a href="#mulAddVWW_g" class="anchor" title="Link to mulAddVWW_g">#</a>
               </h3>
               
               <pre><code class="language-go">func mulAddVWW_g(z []Word, x []Word, y Word, r Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulAddWW" data-name="mulAddWW">
               <h3>
                  mulAddWW 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mulAddWW" class="anchor" title="Link to mulAddWW">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) mulAddWW(x nat, y Word, r Word) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulAddWWW_g" data-name="mulAddWWW_g">
               <h3>
                  mulAddWWW_g 
                  <span class="badge">function</span>
                  
                  <a href="#mulAddWWW_g" class="anchor" title="Link to mulAddWWW_g">#</a>
               </h3>
               
               <p>z1<<_W + z0 = x*y + c</p>
               
               <pre><code class="language-go">func mulAddWWW_g(x Word, y Word, c Word) (z1 Word, z0 Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulDenom" data-name="mulDenom">
               <h3>
                  mulDenom 
                  <span class="badge">function</span>
                  
                  <a href="#mulDenom" class="anchor" title="Link to mulDenom">#</a>
               </h3>
               
               <p>mulDenom sets z to the denominator product x*y (by taking into
account that 0 values for x or y must be interpreted as 1) and
returns z.</p>
               
               <pre><code class="language-go">func mulDenom(z nat, x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulRange" data-name="mulRange">
               <h3>
                  mulRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mulRange" class="anchor" title="Link to mulRange">#</a>
               </h3>
               
               <p>mulRange computes the product of all the unsigned integers in the
range [a, b] inclusively. If a > b (empty range), the result is 1.</p>
               
               <pre><code class="language-go">func (z nat) mulRange(a uint64, b uint64) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mulWW" data-name="mulWW">
               <h3>
                  mulWW 
                  <span class="badge">function</span>
                  
                  <a href="#mulWW" class="anchor" title="Link to mulWW">#</a>
               </h3>
               
               <p>z1<<_W + z0 = x*y</p>
               
               <pre><code class="language-go">func mulWW(x Word, y Word) (z1 Word, z0 Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFloat" data-name="newFloat">
               <h3>
                  newFloat 
                  <span class="badge">function</span>
                  
                  <a href="#newFloat" class="anchor" title="Link to newFloat">#</a>
               </h3>
               
               <p>newFloat returns a new *Float with space for twice the given
precision.</p>
               
               <pre><code class="language-go">func newFloat(prec2 uint32) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nlz" data-name="nlz">
               <h3>
                  nlz 
                  <span class="badge">function</span>
                  
                  <a href="#nlz" class="anchor" title="Link to nlz">#</a>
               </h3>
               
               <p>nlz returns the number of leading zeros in x.
Wraps bits.LeadingZeros call for convenience.</p>
               
               <pre><code class="language-go">func nlz(x Word) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="norm" data-name="norm">
               <h3>
                  norm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#norm" class="anchor" title="Link to norm">#</a>
               </h3>
               
               <pre><code class="language-go">func (z *Rat) norm() *Rat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="norm" data-name="norm">
               <h3>
                  norm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#norm" class="anchor" title="Link to norm">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) norm() nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="or" data-name="or">
               <h3>
                  or 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#or" class="anchor" title="Link to or">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) or(x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ord" data-name="ord">
               <h3>
                  ord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ord" class="anchor" title="Link to ord">#</a>
               </h3>
               
               <p>ord classifies x and returns:
-2 if -Inf == x
-1 if -Inf < x < 0
0 if x == 0 (signed or unsigned)
+1 if 0 < x < +Inf
+2 if x == +Inf</p>
               
               <pre><code class="language-go">func (x *Float) ord() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pow" data-name="pow">
               <h3>
                  pow 
                  <span class="badge">function</span>
                  
                  <a href="#pow" class="anchor" title="Link to pow">#</a>
               </h3>
               
               <p>pow returns x**n for n > 0, and 1 otherwise.</p>
               
               <pre><code class="language-go">func pow(x Word, n int) (p Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pow5" data-name="pow5">
               <h3>
                  pow5 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pow5" class="anchor" title="Link to pow5">#</a>
               </h3>
               
               <p>pow5 sets z to 5**n and returns z.
n must not be negative.</p>
               
               <pre><code class="language-go">func (z *Float) pow5(n uint64) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="probablyPrimeLucas" data-name="probablyPrimeLucas">
               <h3>
                  probablyPrimeLucas 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#probablyPrimeLucas" class="anchor" title="Link to probablyPrimeLucas">#</a>
               </h3>
               
               <p>probablyPrimeLucas reports whether n passes the "almost extra strong" Lucas probable prime test,
using Baillie-OEIS parameter selection. This corresponds to "AESLPSP" on Jacobsen's tables (link below).
The combination of this test and a Miller-Rabin/Fermat test with base 2 gives a Baillie-PSW test.
References:
Baillie and Wagstaff, "Lucas Pseudoprimes", Mathematics of Computation 35(152),
October 1980, pp. 1391-1417, especially page 1401.
https://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf
Grantham, "Frobenius Pseudoprimes", Mathematics of Computation 70(234),
March 2000, pp. 873-891.
https://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf
Baillie, "Extra strong Lucas pseudoprimes", OEIS A217719, https://oeis.org/A217719.
Jacobsen, "Pseudoprime Statistics, Tables, and Data", http://ntheory.org/pseudoprimes.html.
Nicely, "The Baillie-PSW Primality Test", https://web.archive.org/web/20191121062007/http://www.trnicely.net/misc/bpsw.html.
(Note that Nicely's definition of the "extra strong" test gives the wrong Jacobi condition,
as pointed out by Jacobsen.)
Crandall and Pomerance, Prime Numbers: A Computational Perspective, 2nd ed.
Springer, 2005.</p>
               
               <pre><code class="language-go">func (n nat) probablyPrimeLucas() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="probablyPrimeMillerRabin" data-name="probablyPrimeMillerRabin">
               <h3>
                  probablyPrimeMillerRabin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#probablyPrimeMillerRabin" class="anchor" title="Link to probablyPrimeMillerRabin">#</a>
               </h3>
               
               <p>probablyPrimeMillerRabin reports whether n passes reps rounds of the
Miller-Rabin primality test, using pseudo-randomly chosen bases.
If force2 is true, one of the rounds is forced to use base 2.
See Handbook of Applied Cryptography, p. 139, Algorithm 4.24.
The number n is known to be non-zero.</p>
               
               <pre><code class="language-go">func (n nat) probablyPrimeMillerRabin(reps int, force2 bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putNat" data-name="putNat">
               <h3>
                  putNat 
                  <span class="badge">function</span>
                  
                  <a href="#putNat" class="anchor" title="Link to putNat">#</a>
               </h3>
               
               <pre><code class="language-go">func putNat(x *nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="quotToFloat32" data-name="quotToFloat32">
               <h3>
                  quotToFloat32 
                  <span class="badge">function</span>
                  
                  <a href="#quotToFloat32" class="anchor" title="Link to quotToFloat32">#</a>
               </h3>
               
               <p>quotToFloat32 returns the non-negative float32 value
nearest to the quotient a/b, using round-to-even in
halfway cases. It does not mutate its arguments.
Preconditions: b is non-zero; a and b have no common factors.</p>
               
               <pre><code class="language-go">func quotToFloat32(a nat, b nat) (f float32, exact bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="quotToFloat64" data-name="quotToFloat64">
               <h3>
                  quotToFloat64 
                  <span class="badge">function</span>
                  
                  <a href="#quotToFloat64" class="anchor" title="Link to quotToFloat64">#</a>
               </h3>
               
               <p>quotToFloat64 returns the non-negative float64 value
nearest to the quotient a/b, using round-to-even in
halfway cases. It does not mutate its arguments.
Preconditions: b is non-zero; a and b have no common factors.</p>
               
               <pre><code class="language-go">func quotToFloat64(a nat, b nat) (f float64, exact bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="random" data-name="random">
               <h3>
                  random 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#random" class="anchor" title="Link to random">#</a>
               </h3>
               
               <p>random creates a random integer in [0..limit), using the space in z if
possible. n is the bit length of limit.</p>
               
               <pre><code class="language-go">func (z nat) random(rand *rand.Rand, limit nat, n int) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ratTok" data-name="ratTok">
               <h3>
                  ratTok 
                  <span class="badge">function</span>
                  
                  <a href="#ratTok" class="anchor" title="Link to ratTok">#</a>
               </h3>
               
               <pre><code class="language-go">func ratTok(ch rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reciprocalWord" data-name="reciprocalWord">
               <h3>
                  reciprocalWord 
                  <span class="badge">function</span>
                  
                  <a href="#reciprocalWord" class="anchor" title="Link to reciprocalWord">#</a>
               </h3>
               
               <p>reciprocalWord return the reciprocal of the divisor. rec = floor(( _B^2 - 1 ) / u - _B). u = d1 << nlz(d1).</p>
               
               <pre><code class="language-go">func reciprocalWord(d1 Word) Word</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rem" data-name="rem">
               <h3>
                  rem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rem" class="anchor" title="Link to rem">#</a>
               </h3>
               
               <p>rem returns r such that r = u%v.
It uses z as the storage for r.</p>
               
               <pre><code class="language-go">func (z nat) rem(u nat, v nat) (r nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="round" data-name="round">
               <h3>
                  round 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#round" class="anchor" title="Link to round">#</a>
               </h3>
               
               <p>round rounds z according to z.mode to z.prec bits and sets z.acc accordingly.
sbit must be 0 or 1 and summarizes any "sticky bit" information one might
have before calling round. z's mantissa must be normalized (with the msb set)
or empty.
CAUTION: The rounding modes [ToNegativeInf], [ToPositiveInf] are affected by the
sign of z. For correct rounding, the sign of z must be set correctly before
calling round.</p>
               
               <pre><code class="language-go">func (z *Float) round(sbit uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="round" data-name="round">
               <h3>
                  round 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#round" class="anchor" title="Link to round">#</a>
               </h3>
               
               <p>round sets x to (at most) n mantissa digits by rounding it
to the nearest even value with n (or fever) mantissa digits.
If n < 0, x remains unchanged.</p>
               
               <pre><code class="language-go">func (x *decimal) round(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundDown" data-name="roundDown">
               <h3>
                  roundDown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#roundDown" class="anchor" title="Link to roundDown">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *decimal) roundDown(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundShortest" data-name="roundShortest">
               <h3>
                  roundShortest 
                  <span class="badge">function</span>
                  
                  <a href="#roundShortest" class="anchor" title="Link to roundShortest">#</a>
               </h3>
               
               <pre><code class="language-go">func roundShortest(d *decimal, x *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundUp" data-name="roundUp">
               <h3>
                  roundUp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#roundUp" class="anchor" title="Link to roundUp">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *decimal) roundUp(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="same" data-name="same">
               <h3>
                  same 
                  <span class="badge">function</span>
                  
                  <a href="#same" class="anchor" title="Link to same">#</a>
               </h3>
               
               <pre><code class="language-go">func same(x nat, y nat) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scaleDenom" data-name="scaleDenom">
               <h3>
                  scaleDenom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scaleDenom" class="anchor" title="Link to scaleDenom">#</a>
               </h3>
               
               <p>scaleDenom sets z to the product x*f.
If f == 0 (zero value of denominator), z is set to (a copy of) x.</p>
               
               <pre><code class="language-go">func (z *Int) scaleDenom(x *Int, f nat)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scan" data-name="scan">
               <h3>
                  scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scan" class="anchor" title="Link to scan">#</a>
               </h3>
               
               <p>scan scans the number corresponding to the longest possible prefix
from r representing an unsigned number in a given conversion base.
scan returns the corresponding natural number res, the actual base b,
a digit count, and a read or syntax error err, if any.
For base 0, an underscore character “_” may appear between a base
prefix and an adjacent digit, and between successive digits; such
underscores do not change the value of the number, or the returned
digit count. Incorrect placement of underscores is reported as an
error if there are no other errors. If base != 0, underscores are
not recognized and thus terminate scanning like any other character
that is not a valid radix point or digit.
number    = mantissa | prefix pmantissa .
prefix    = "0" [ "b" | "B" | "o" | "O" | "x" | "X" ] .
mantissa  = digits "." [ digits ] | digits | "." digits .
pmantissa = [ "_" ] digits "." [ digits ] | [ "_" ] digits | "." digits .
digits    = digit { [ "_" ] digit } .
digit     = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
Unless fracOk is set, the base argument must be 0 or a value between
2 and MaxBase. If fracOk is set, the base argument must be one of
0, 2, 8, 10, or 16. Providing an invalid base argument leads to a run-
time panic.
For base 0, the number prefix determines the actual base: A prefix of
“0b” or “0B” selects base 2, “0o” or “0O” selects base 8, and
“0x” or “0X” selects base 16. If fracOk is false, a “0” prefix
(immediately followed by digits) selects base 8 as well. Otherwise,
the selected base is 10 and no prefix is accepted.
If fracOk is set, a period followed by a fractional part is permitted.
The result value is computed as if there were no period present; and
the count value is used to determine the fractional part.
For bases <= 36, lower and upper case letters are considered the same:
The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
For bases > 36, the upper case letters 'A' to 'Z' represent the digit
values 36 to 61.
A result digit count > 0 corresponds to the number of (non-prefix) digits
parsed. A digit count <= 0 indicates the presence of a period (if fracOk
is set, only), and -count is the number of fractional digits found.
In this case, the actual value of the scanned number is res * b**count.</p>
               
               <pre><code class="language-go">func (z nat) scan(r io.ByteScanner, base int, fracOk bool) (res nat, b int, count int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scan" data-name="scan">
               <h3>
                  scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scan" class="anchor" title="Link to scan">#</a>
               </h3>
               
               <p>scan is like Parse but reads the longest possible prefix representing a valid
floating point number from an io.ByteScanner rather than a string. It serves
as the implementation of Parse. It does not recognize ±Inf and does not expect
EOF at the end.</p>
               
               <pre><code class="language-go">func (z *Float) scan(r io.ByteScanner, base int) (f *Float, b int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scan" data-name="scan">
               <h3>
                  scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scan" class="anchor" title="Link to scan">#</a>
               </h3>
               
               <p>scan sets z to the integer value corresponding to the longest possible prefix
read from r representing a signed integer number in a given conversion base.
It returns z, the actual conversion base used, and an error, if any. In the
error case, the value of z is undefined but the returned value is nil. The
syntax follows the syntax of integer literals in Go.
The base argument must be 0 or a value from 2 through MaxBase. If the base
is 0, the string prefix determines the actual conversion base. A prefix of
“0b” or “0B” selects base 2; a “0”, “0o”, or “0O” prefix selects
base 8, and a “0x” or “0X” prefix selects base 16. Otherwise the selected
base is 10.</p>
               
               <pre><code class="language-go">func (z *Int) scan(r io.ByteScanner, base int) (*Int, int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanExponent" data-name="scanExponent">
               <h3>
                  scanExponent 
                  <span class="badge">function</span>
                  
                  <a href="#scanExponent" class="anchor" title="Link to scanExponent">#</a>
               </h3>
               
               <p>scanExponent scans the longest possible prefix of r representing a base 10
(“e”, “E”) or a base 2 (“p”, “P”) exponent, if any. It returns the
exponent, the exponent base (10 or 2), or a read or syntax error, if any.
If sepOk is set, an underscore character “_” may appear between successive
exponent digits; such underscores do not change the value of the exponent.
Incorrect placement of underscores is reported as an error if there are no
other errors. If sepOk is not set, underscores are not recognized and thus
terminate scanning like any other character that is not a valid digit.
exponent = ( "e" | "E" | "p" | "P" ) [ sign ] digits .
sign     = "+" | "-" .
digits   = digit { [ '_' ] digit } .
digit    = "0" ... "9" .
A base 2 exponent is only permitted if base2ok is set.</p>
               
               <pre><code class="language-go">func scanExponent(r io.ByteScanner, base2ok bool, sepOk bool) (exp int64, base int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanSign" data-name="scanSign">
               <h3>
                  scanSign 
                  <span class="badge">function</span>
                  
                  <a href="#scanSign" class="anchor" title="Link to scanSign">#</a>
               </h3>
               
               <pre><code class="language-go">func scanSign(r io.ByteScanner) (neg bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) set(x nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBit" data-name="setBit">
               <h3>
                  setBit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBit" class="anchor" title="Link to setBit">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) setBit(x nat, i uint, b uint) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBits64" data-name="setBits64">
               <h3>
                  setBits64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBits64" class="anchor" title="Link to setBits64">#</a>
               </h3>
               
               <pre><code class="language-go">func (z *Float) setBits64(neg bool, x uint64) *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBytes" data-name="setBytes">
               <h3>
                  setBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBytes" class="anchor" title="Link to setBytes">#</a>
               </h3>
               
               <p>setBytes interprets buf as the bytes of a big-endian unsigned
integer, sets z to that value, and returns z.</p>
               
               <pre><code class="language-go">func (z nat) setBytes(buf []byte) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setExpAndRound" data-name="setExpAndRound">
               <h3>
                  setExpAndRound 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setExpAndRound" class="anchor" title="Link to setExpAndRound">#</a>
               </h3>
               
               <pre><code class="language-go">func (z *Float) setExpAndRound(exp int64, sbit uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setFromScanner" data-name="setFromScanner">
               <h3>
                  setFromScanner 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setFromScanner" class="anchor" title="Link to setFromScanner">#</a>
               </h3>
               
               <p>setFromScanner implements SetString given an io.ByteScanner.
For documentation see comments of SetString.</p>
               
               <pre><code class="language-go">func (z *Int) setFromScanner(r io.ByteScanner, base int) (*Int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setUint64" data-name="setUint64">
               <h3>
                  setUint64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setUint64" class="anchor" title="Link to setUint64">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) setUint64(x uint64) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setWord" data-name="setWord">
               <h3>
                  setWord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setWord" class="anchor" title="Link to setWord">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) setWord(x Word) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shl" data-name="shl">
               <h3>
                  shl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shl" class="anchor" title="Link to shl">#</a>
               </h3>
               
               <p>z = x << s</p>
               
               <pre><code class="language-go">func (z nat) shl(x nat, s uint) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shlVU" data-name="shlVU">
               <h3>
                  shlVU 
                  <span class="badge">function</span>
                  
                  <a href="#shlVU" class="anchor" title="Link to shlVU">#</a>
               </h3>
               
               <pre><code class="language-go">func shlVU(z []Word, x []Word, s uint) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shlVU" data-name="shlVU">
               <h3>
                  shlVU 
                  <span class="badge">function</span>
                  
                  <a href="#shlVU" class="anchor" title="Link to shlVU">#</a>
               </h3>
               
               <p>shlVU should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname shlVU
go:noescape</p>
               
               <pre><code class="language-go">func shlVU(z []Word, x []Word, s uint) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shlVU_g" data-name="shlVU_g">
               <h3>
                  shlVU_g 
                  <span class="badge">function</span>
                  
                  <a href="#shlVU_g" class="anchor" title="Link to shlVU_g">#</a>
               </h3>
               
               <pre><code class="language-go">func shlVU_g(z []Word, x []Word, s uint) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldRoundUp" data-name="shouldRoundUp">
               <h3>
                  shouldRoundUp 
                  <span class="badge">function</span>
                  
                  <a href="#shouldRoundUp" class="anchor" title="Link to shouldRoundUp">#</a>
               </h3>
               
               <p>shouldRoundUp reports if x should be rounded up
if shortened to n digits. n must be a valid index
for x.mant.</p>
               
               <pre><code class="language-go">func shouldRoundUp(x *decimal, n int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shr" data-name="shr">
               <h3>
                  shr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shr" class="anchor" title="Link to shr">#</a>
               </h3>
               
               <p>z = x >> s</p>
               
               <pre><code class="language-go">func (z nat) shr(x nat, s uint) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shr" data-name="shr">
               <h3>
                  shr 
                  <span class="badge">function</span>
                  
                  <a href="#shr" class="anchor" title="Link to shr">#</a>
               </h3>
               
               <p>shr implements x >> s, for s <= maxShift.</p>
               
               <pre><code class="language-go">func shr(x *decimal, s uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shrVU" data-name="shrVU">
               <h3>
                  shrVU 
                  <span class="badge">function</span>
                  
                  <a href="#shrVU" class="anchor" title="Link to shrVU">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func shrVU(z []Word, x []Word, s uint) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shrVU" data-name="shrVU">
               <h3>
                  shrVU 
                  <span class="badge">function</span>
                  
                  <a href="#shrVU" class="anchor" title="Link to shrVU">#</a>
               </h3>
               
               <pre><code class="language-go">func shrVU(z []Word, x []Word, s uint) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shrVU_g" data-name="shrVU_g">
               <h3>
                  shrVU_g 
                  <span class="badge">function</span>
                  
                  <a href="#shrVU_g" class="anchor" title="Link to shrVU_g">#</a>
               </h3>
               
               <pre><code class="language-go">func shrVU_g(z []Word, x []Word, s uint) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sqr" data-name="sqr">
               <h3>
                  sqr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sqr" class="anchor" title="Link to sqr">#</a>
               </h3>
               
               <p>z = x*x</p>
               
               <pre><code class="language-go">func (z nat) sqr(x nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sqrt" data-name="sqrt">
               <h3>
                  sqrt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sqrt" class="anchor" title="Link to sqrt">#</a>
               </h3>
               
               <p>sqrt sets z = ⌊√x⌋</p>
               
               <pre><code class="language-go">func (z nat) sqrt(x nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sqrtInverse" data-name="sqrtInverse">
               <h3>
                  sqrtInverse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sqrtInverse" class="anchor" title="Link to sqrtInverse">#</a>
               </h3>
               
               <p>Compute √x (to z.prec precision) by solving
1/t² - x = 0
for t (using Newton's method), and then inverting.</p>
               
               <pre><code class="language-go">func (z *Float) sqrtInverse(x *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sticky" data-name="sticky">
               <h3>
                  sticky 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sticky" class="anchor" title="Link to sticky">#</a>
               </h3>
               
               <p>sticky returns 1 if there's a 1 bit within the
i least significant bits, otherwise it returns 0.</p>
               
               <pre><code class="language-go">func (x nat) sticky(i uint) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sub" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sub" class="anchor" title="Link to sub">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) sub(x nat, y nat) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subMod2N" data-name="subMod2N">
               <h3>
                  subMod2N 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subMod2N" class="anchor" title="Link to subMod2N">#</a>
               </h3>
               
               <p>subMod2N returns z = (x - y) mod 2ⁿ.</p>
               
               <pre><code class="language-go">func (z nat) subMod2N(x nat, y nat, n uint) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVV" data-name="subVV">
               <h3>
                  subVV 
                  <span class="badge">function</span>
                  
                  <a href="#subVV" class="anchor" title="Link to subVV">#</a>
               </h3>
               
               <pre><code class="language-go">func subVV(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVV" data-name="subVV">
               <h3>
                  subVV 
                  <span class="badge">function</span>
                  
                  <a href="#subVV" class="anchor" title="Link to subVV">#</a>
               </h3>
               
               <p>subVV should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname subVV
go:noescape</p>
               
               <pre><code class="language-go">func subVV(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVV_check" data-name="subVV_check">
               <h3>
                  subVV_check 
                  <span class="badge">function</span>
                  
                  <a href="#subVV_check" class="anchor" title="Link to subVV_check">#</a>
               </h3>
               
               <pre><code class="language-go">func subVV_check(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVV_g" data-name="subVV_g">
               <h3>
                  subVV_g 
                  <span class="badge">function</span>
                  
                  <a href="#subVV_g" class="anchor" title="Link to subVV_g">#</a>
               </h3>
               
               <p>The resulting carry c is either 0 or 1.</p>
               
               <pre><code class="language-go">func subVV_g(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVV_novec" data-name="subVV_novec">
               <h3>
                  subVV_novec 
                  <span class="badge">function</span>
                  
                  <a href="#subVV_novec" class="anchor" title="Link to subVV_novec">#</a>
               </h3>
               
               <pre><code class="language-go">func subVV_novec(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVV_vec" data-name="subVV_vec">
               <h3>
                  subVV_vec 
                  <span class="badge">function</span>
                  
                  <a href="#subVV_vec" class="anchor" title="Link to subVV_vec">#</a>
               </h3>
               
               <pre><code class="language-go">func subVV_vec(z []Word, x []Word, y []Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVW" data-name="subVW">
               <h3>
                  subVW 
                  <span class="badge">function</span>
                  
                  <a href="#subVW" class="anchor" title="Link to subVW">#</a>
               </h3>
               
               <pre><code class="language-go">func subVW(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVW" data-name="subVW">
               <h3>
                  subVW 
                  <span class="badge">function</span>
                  
                  <a href="#subVW" class="anchor" title="Link to subVW">#</a>
               </h3>
               
               <p>subVW should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/remyoudompheng/bigfft
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname subVW
go:noescape</p>
               
               <pre><code class="language-go">func subVW(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVW_g" data-name="subVW_g">
               <h3>
                  subVW_g 
                  <span class="badge">function</span>
                  
                  <a href="#subVW_g" class="anchor" title="Link to subVW_g">#</a>
               </h3>
               
               <pre><code class="language-go">func subVW_g(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subVWlarge" data-name="subVWlarge">
               <h3>
                  subVWlarge 
                  <span class="badge">function</span>
                  
                  <a href="#subVWlarge" class="anchor" title="Link to subVWlarge">#</a>
               </h3>
               
               <p>subVWlarge is to subVW as addVWlarge is to addVW.</p>
               
               <pre><code class="language-go">func subVWlarge(z []Word, x []Word, y Word) (c Word)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="three" data-name="three">
               <h3>
                  three 
                  <span class="badge">function</span>
                  
                  <a href="#three" class="anchor" title="Link to three">#</a>
               </h3>
               
               <pre><code class="language-go">func three() *Float</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trailingZeroBits" data-name="trailingZeroBits">
               <h3>
                  trailingZeroBits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trailingZeroBits" class="anchor" title="Link to trailingZeroBits">#</a>
               </h3>
               
               <p>trailingZeroBits returns the number of consecutive least significant zero
bits of x.</p>
               
               <pre><code class="language-go">func (x nat) trailingZeroBits() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trim" data-name="trim">
               <h3>
                  trim 
                  <span class="badge">function</span>
                  
                  <a href="#trim" class="anchor" title="Link to trim">#</a>
               </h3>
               
               <p>trim cuts off any trailing zeros from x's mantissa;
they are meaningless for the value of x.</p>
               
               <pre><code class="language-go">func trim(x *decimal)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trunc" data-name="trunc">
               <h3>
                  trunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trunc" class="anchor" title="Link to trunc">#</a>
               </h3>
               
               <p>trunc returns z = x mod 2ⁿ.</p>
               
               <pre><code class="language-go">func (z nat) trunc(x nat, n uint) nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uadd" data-name="uadd">
               <h3>
                  uadd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uadd" class="anchor" title="Link to uadd">#</a>
               </h3>
               
               <p>z = x + y, ignoring signs of x and y for the addition
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.</p>
               
               <pre><code class="language-go">func (z *Float) uadd(x *Float, y *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ucmp" data-name="ucmp">
               <h3>
                  ucmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ucmp" class="anchor" title="Link to ucmp">#</a>
               </h3>
               
               <p>ucmp returns -1, 0, or +1, depending on whether
|x| < |y|, |x| == |y|, or |x| > |y|.
x and y must have a non-empty mantissa and valid exponent.</p>
               
               <pre><code class="language-go">func (x *Float) ucmp(y *Float) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="umax32" data-name="umax32">
               <h3>
                  umax32 
                  <span class="badge">function</span>
                  
                  <a href="#umax32" class="anchor" title="Link to umax32">#</a>
               </h3>
               
               <pre><code class="language-go">func umax32(x uint32, y uint32) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="umul" data-name="umul">
               <h3>
                  umul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#umul" class="anchor" title="Link to umul">#</a>
               </h3>
               
               <p>z = x * y, ignoring signs of x and y for the multiplication
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.</p>
               
               <pre><code class="language-go">func (z *Float) umul(x *Float, y *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uquo" data-name="uquo">
               <h3>
                  uquo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uquo" class="anchor" title="Link to uquo">#</a>
               </h3>
               
               <p>z = x / y, ignoring signs of x and y for the division
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.</p>
               
               <pre><code class="language-go">func (z *Float) uquo(x *Float, y *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usub" data-name="usub">
               <h3>
                  usub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#usub" class="anchor" title="Link to usub">#</a>
               </h3>
               
               <p>z = x - y for |x| > |y|, ignoring signs of x and y for the subtraction
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.</p>
               
               <pre><code class="language-go">func (z *Float) usub(x *Float, y *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="utoa" data-name="utoa">
               <h3>
                  utoa 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#utoa" class="anchor" title="Link to utoa">#</a>
               </h3>
               
               <p>utoa converts x to an ASCII representation in the given base;
base must be between 2 and MaxBase, inclusive.</p>
               
               <pre><code class="language-go">func (x nat) utoa(base int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validate" data-name="validate">
               <h3>
                  validate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validate" class="anchor" title="Link to validate">#</a>
               </h3>
               
               <p>debugging support</p>
               
               <pre><code class="language-go">func (x *Float) validate()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validate0" data-name="validate0">
               <h3>
                  validate0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validate0" class="anchor" title="Link to validate0">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *Float) validate0() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateBinaryOperands" data-name="validateBinaryOperands">
               <h3>
                  validateBinaryOperands 
                  <span class="badge">function</span>
                  
                  <a href="#validateBinaryOperands" class="anchor" title="Link to validateBinaryOperands">#</a>
               </h3>
               
               <pre><code class="language-go">func validateBinaryOperands(x *Float, y *Float)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeMultiple" data-name="writeMultiple">
               <h3>
                  writeMultiple 
                  <span class="badge">function</span>
                  
                  <a href="#writeMultiple" class="anchor" title="Link to writeMultiple">#</a>
               </h3>
               
               <p>write count copies of text to s.</p>
               
               <pre><code class="language-go">func writeMultiple(s fmt.State, text string, count int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xor" data-name="xor">
               <h3>
                  xor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xor" class="anchor" title="Link to xor">#</a>
               </h3>
               
               <pre><code class="language-go">func (z nat) xor(x nat, y nat) nat</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>