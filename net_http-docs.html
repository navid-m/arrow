<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - http</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="net_http_cgi-docs.html">cgi</a></li>
               
               <li><a href="net_http_cookiejar-docs.html">cookiejar</a></li>
               
               <li><a href="net_http_fcgi-docs.html">fcgi</a></li>
               
               <li><a href="net_http_httptest-docs.html">httptest</a></li>
               
               <li><a href="net_http_httptrace-docs.html">httptrace</a></li>
               
               <li><a href="net_http_httputil-docs.html">httputil</a></li>
               
               <li><a href="net_http_internal-docs.html">internal</a></li>
               
               <li><a href="net_http_pprof-docs.html">pprof</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>http</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"context"
"crypto/tls"
"encoding/base64"
"errors"
"fmt"
"io"
"log"
"net/http/internal/ascii"
"net/url"
"reflect"
"slices"
"strings"
"sync"
"sync/atomic"
"time"
"bufio"
"bytes"
"context"
"crypto/tls"
"encoding/base64"
"errors"
"fmt"
"io"
"maps"
"mime"
"mime/multipart"
"net/http/httptrace"
"net/http/internal/ascii"
"net/textproto"
"net/url"
urlpkg "net/url"
"strconv"
"strings"
"sync"
_ "unsafe"
"golang.org/x/net/http/httpguts"
"golang.org/x/net/idna"
"internal/godebug"
"net/url"
"sort"
"strings"
"sync"
"bufio"
"bytes"
"context"
"crypto/tls"
"errors"
"fmt"
"internal/godebug"
"io"
"log"
"maps"
"math/rand"
"net"
"net/textproto"
"net/url"
urlpkg "net/url"
"path"
"runtime"
"slices"
"strconv"
"strings"
"sync"
"sync/atomic"
"time"
_ "unsafe"
"golang.org/x/net/http/httpguts"
"bufio"
"bytes"
"compress/gzip"
"context"
"crypto/rand"
"crypto/tls"
"encoding/binary"
"errors"
"fmt"
"io"
"io/fs"
"log"
"math"
"math/bits"
mathrand "math/rand"
"net"
"net/http/httptrace"
"net/textproto"
"net/url"
"os"
"reflect"
"runtime"
"sort"
"strconv"
"strings"
"sync"
"sync/atomic"
"time"
"golang.org/x/net/http/httpguts"
"golang.org/x/net/http2/hpack"
"golang.org/x/net/idna"
"io"
"strconv"
"strings"
"time"
"unicode/utf8"
"golang.org/x/net/http/httpguts"
"context"
"errors"
"io"
"net"
"strconv"
"time"
"net/url"
"errors"
"fmt"
"net/url"
"strings"
"unicode"
"bufio"
"bytes"
"crypto/tls"
"errors"
"fmt"
"io"
"net/textproto"
"net/url"
"strconv"
"strings"
"golang.org/x/net/http/httpguts"
"context"
"net"
"errors"
"fmt"
"internal/godebug"
"io"
"io/fs"
"mime"
"mime/multipart"
"net/textproto"
"net/url"
"os"
"path"
"path/filepath"
"sort"
"strconv"
"strings"
"time"
_ "unsafe"
"bytes"
"encoding/binary"
"mime/multipart"
"net/textproto"
"net/url"
_ "unsafe"
"errors"
"fmt"
"log"
"net"
"net/http/internal/ascii"
"net/textproto"
"strconv"
"strings"
"time"
"errors"
"fmt"
"io"
"net/http/internal/ascii"
"strconv"
"strings"
"syscall/js"
"strings"
"bufio"
"compress/gzip"
"container/list"
"context"
"crypto/tls"
"errors"
"fmt"
"internal/godebug"
"io"
"log"
"maps"
"net"
"net/http/httptrace"
"net/http/internal/ascii"
"net/textproto"
"net/url"
"reflect"
"strings"
"sync"
"sync/atomic"
"time"
_ "unsafe"
"golang.org/x/net/http/httpguts"
"golang.org/x/net/http/httpproxy"
"context"
"net"
"bufio"
"bytes"
"errors"
"fmt"
"internal/godebug"
"io"
"maps"
"net/http/httptrace"
"net/http/internal"
"net/http/internal/ascii"
"net/textproto"
"reflect"
"slices"
"strconv"
"strings"
"sync"
"time"
"golang.org/x/net/http/httpguts"
"fmt"
"io"
"io/fs"
"reflect"
"io"
"net/http/httptrace"
"net/http/internal/ascii"
"net/textproto"
"slices"
"strings"
"sync"
"time"
"golang.org/x/net/http/httpguts"
"errors"
"sync"
"time"
"bufio"
"fmt"
"net"
"time"
"math"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="DefaultClient" data-name="DefaultClient">
               <h3>
                  DefaultClient 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DefaultClient" class="anchor" title="Link to DefaultClient">#</a>
               </h3>
               
               <p>DefaultClient is the default [Client] and is used by [Get], [Head], and [Post].</p>
               
               <pre><code>var DefaultClient = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultMaxHeaderBytes" data-name="DefaultMaxHeaderBytes">
               <h3>
                  DefaultMaxHeaderBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultMaxHeaderBytes" class="anchor" title="Link to DefaultMaxHeaderBytes">#</a>
               </h3>
               
               <p>DefaultMaxHeaderBytes is the maximum permitted size of the headers
in an HTTP request.
This can be overridden by setting [Server.MaxHeaderBytes].</p>
               
               <pre><code>const DefaultMaxHeaderBytes = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultMaxIdleConnsPerHost" data-name="DefaultMaxIdleConnsPerHost">
               <h3>
                  DefaultMaxIdleConnsPerHost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultMaxIdleConnsPerHost" class="anchor" title="Link to DefaultMaxIdleConnsPerHost">#</a>
               </h3>
               
               <p>DefaultMaxIdleConnsPerHost is the default value of [Transport]'s
MaxIdleConnsPerHost.</p>
               
               <pre><code>const DefaultMaxIdleConnsPerHost = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultServeMux" data-name="DefaultServeMux">
               <h3>
                  DefaultServeMux 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DefaultServeMux" class="anchor" title="Link to DefaultServeMux">#</a>
               </h3>
               
               <p>DefaultServeMux is the default [ServeMux] used by [Serve].</p>
               
               <pre><code>var DefaultServeMux = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultTransport" data-name="DefaultTransport">
               <h3>
                  DefaultTransport 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DefaultTransport" class="anchor" title="Link to DefaultTransport">#</a>
               </h3>
               
               <p>DefaultTransport is the default implementation of [Transport] and is
used by [DefaultClient]. It establishes network connections as needed
and caches them for reuse by subsequent calls. It uses HTTP proxies
as directed by the environment variables HTTP_PROXY, HTTPS_PROXY
and NO_PROXY (or the lowercase versions thereof).</p>
               
               <pre><code>var DefaultTransport RoundTripper = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrAbortHandler" data-name="ErrAbortHandler">
               <h3>
                  ErrAbortHandler 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrAbortHandler" class="anchor" title="Link to ErrAbortHandler">#</a>
               </h3>
               
               <p>ErrAbortHandler is a sentinel panic value to abort a handler.
While any panic from ServeHTTP aborts the response to the client,
panicking with ErrAbortHandler also suppresses logging of a stack
trace to the server's error log.</p>
               
               <pre><code>var ErrAbortHandler = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrBodyNotAllowed" data-name="ErrBodyNotAllowed">
               <h3>
                  ErrBodyNotAllowed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBodyNotAllowed" class="anchor" title="Link to ErrBodyNotAllowed">#</a>
               </h3>
               
               <p>ErrBodyNotAllowed is returned by ResponseWriter.Write calls
when the HTTP method or response code does not permit a
body.</p>
               
               <pre><code>var ErrBodyNotAllowed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrBodyReadAfterClose" data-name="ErrBodyReadAfterClose">
               <h3>
                  ErrBodyReadAfterClose 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBodyReadAfterClose" class="anchor" title="Link to ErrBodyReadAfterClose">#</a>
               </h3>
               
               <p>ErrBodyReadAfterClose is returned when reading a [Request] or [Response]
Body after the body has been closed. This typically happens when the body is
read after an HTTP [Handler] calls WriteHeader or Write on its
[ResponseWriter].</p>
               
               <pre><code>var ErrBodyReadAfterClose = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrContentLength" data-name="ErrContentLength">
               <h3>
                  ErrContentLength 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrContentLength" class="anchor" title="Link to ErrContentLength">#</a>
               </h3>
               
               <p>ErrContentLength is returned by ResponseWriter.Write calls
when a Handler set a Content-Length response header with a
declared size and then attempted to write more bytes than
declared.</p>
               
               <pre><code>var ErrContentLength = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrHandlerTimeout" data-name="ErrHandlerTimeout">
               <h3>
                  ErrHandlerTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrHandlerTimeout" class="anchor" title="Link to ErrHandlerTimeout">#</a>
               </h3>
               
               <p>ErrHandlerTimeout is returned on [ResponseWriter] Write calls
in handlers which have timed out.</p>
               
               <pre><code>var ErrHandlerTimeout = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrHeaderTooLong" data-name="ErrHeaderTooLong">
               <h3>
                  ErrHeaderTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrHeaderTooLong" class="anchor" title="Link to ErrHeaderTooLong">#</a>
               </h3>
               
               <p>Deprecated: ErrHeaderTooLong is no longer returned by
anything in the net/http package. Callers should not
compare errors against this variable.</p>
               
               <pre><code>var ErrHeaderTooLong = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrHijacked" data-name="ErrHijacked">
               <h3>
                  ErrHijacked 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrHijacked" class="anchor" title="Link to ErrHijacked">#</a>
               </h3>
               
               <p>ErrHijacked is returned by ResponseWriter.Write calls when
the underlying connection has been hijacked using the
Hijacker interface. A zero-byte write on a hijacked
connection will return ErrHijacked without any other side
effects.</p>
               
               <pre><code>var ErrHijacked = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrLineTooLong" data-name="ErrLineTooLong">
               <h3>
                  ErrLineTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrLineTooLong" class="anchor" title="Link to ErrLineTooLong">#</a>
               </h3>
               
               <p>ErrLineTooLong is returned when reading request or response bodies
with malformed chunked encoding.</p>
               
               <pre><code>var ErrLineTooLong = internal.ErrLineTooLong</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMissingBoundary" data-name="ErrMissingBoundary">
               <h3>
                  ErrMissingBoundary 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrMissingBoundary" class="anchor" title="Link to ErrMissingBoundary">#</a>
               </h3>
               
               <p>ErrMissingBoundary is returned by Request.MultipartReader when the
request's Content-Type does not include a "boundary" parameter.</p>
               
               <pre><code>var ErrMissingBoundary = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMissingContentLength" data-name="ErrMissingContentLength">
               <h3>
                  ErrMissingContentLength 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrMissingContentLength" class="anchor" title="Link to ErrMissingContentLength">#</a>
               </h3>
               
               <p>Deprecated: ErrMissingContentLength is no longer returned by
anything in the net/http package. Callers should not
compare errors against this variable.</p>
               
               <pre><code>var ErrMissingContentLength = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMissingFile" data-name="ErrMissingFile">
               <h3>
                  ErrMissingFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrMissingFile" class="anchor" title="Link to ErrMissingFile">#</a>
               </h3>
               
               <p>ErrMissingFile is returned by FormFile when the provided file field name
is either not present in the request or not a file field.</p>
               
               <pre><code>var ErrMissingFile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNoCookie" data-name="ErrNoCookie">
               <h3>
                  ErrNoCookie 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNoCookie" class="anchor" title="Link to ErrNoCookie">#</a>
               </h3>
               
               <p>ErrNoCookie is returned by Request's Cookie method when a cookie is not found.</p>
               
               <pre><code>var ErrNoCookie = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNoLocation" data-name="ErrNoLocation">
               <h3>
                  ErrNoLocation 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNoLocation" class="anchor" title="Link to ErrNoLocation">#</a>
               </h3>
               
               <p>ErrNoLocation is returned by the [Response.Location] method
when no Location header is present.</p>
               
               <pre><code>var ErrNoLocation = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotMultipart" data-name="ErrNotMultipart">
               <h3>
                  ErrNotMultipart 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotMultipart" class="anchor" title="Link to ErrNotMultipart">#</a>
               </h3>
               
               <p>ErrNotMultipart is returned by Request.MultipartReader when the
request's Content-Type is not multipart/form-data.</p>
               
               <pre><code>var ErrNotMultipart = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotSupported" data-name="ErrNotSupported">
               <h3>
                  ErrNotSupported 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotSupported" class="anchor" title="Link to ErrNotSupported">#</a>
               </h3>
               
               <p>ErrNotSupported indicates that a feature is not supported.
It is returned by ResponseController methods to indicate that
the handler does not support the method, and by the Push method
of Pusher implementations to indicate that HTTP/2 Push support
is not available.</p>
               
               <pre><code>var ErrNotSupported = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrSchemeMismatch" data-name="ErrSchemeMismatch">
               <h3>
                  ErrSchemeMismatch 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrSchemeMismatch" class="anchor" title="Link to ErrSchemeMismatch">#</a>
               </h3>
               
               <p>ErrSchemeMismatch is returned when a server returns an HTTP response to an HTTPS client.</p>
               
               <pre><code>var ErrSchemeMismatch = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrServerClosed" data-name="ErrServerClosed">
               <h3>
                  ErrServerClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrServerClosed" class="anchor" title="Link to ErrServerClosed">#</a>
               </h3>
               
               <p>ErrServerClosed is returned by the [Server.Serve], [ServeTLS], [ListenAndServe],
and [ListenAndServeTLS] methods after a call to [Server.Shutdown] or [Server.Close].</p>
               
               <pre><code>var ErrServerClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrShortBody" data-name="ErrShortBody">
               <h3>
                  ErrShortBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrShortBody" class="anchor" title="Link to ErrShortBody">#</a>
               </h3>
               
               <p>Deprecated: ErrShortBody is no longer returned by
anything in the net/http package. Callers should not
compare errors against this variable.</p>
               
               <pre><code>var ErrShortBody = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrSkipAltProtocol" data-name="ErrSkipAltProtocol">
               <h3>
                  ErrSkipAltProtocol 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrSkipAltProtocol" class="anchor" title="Link to ErrSkipAltProtocol">#</a>
               </h3>
               
               <p>ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.</p>
               
               <pre><code>var ErrSkipAltProtocol = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrUnexpectedTrailer" data-name="ErrUnexpectedTrailer">
               <h3>
                  ErrUnexpectedTrailer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrUnexpectedTrailer" class="anchor" title="Link to ErrUnexpectedTrailer">#</a>
               </h3>
               
               <p>Deprecated: ErrUnexpectedTrailer is no longer returned by
anything in the net/http package. Callers should not
compare errors against this variable.</p>
               
               <pre><code>var ErrUnexpectedTrailer = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrUseLastResponse" data-name="ErrUseLastResponse">
               <h3>
                  ErrUseLastResponse 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrUseLastResponse" class="anchor" title="Link to ErrUseLastResponse">#</a>
               </h3>
               
               <p>ErrUseLastResponse can be returned by Client.CheckRedirect hooks to
control how redirects are processed. If returned, the next request
is not sent and the most recent response is returned with its body
unclosed.</p>
               
               <pre><code>var ErrUseLastResponse = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrWriteAfterFlush" data-name="ErrWriteAfterFlush">
               <h3>
                  ErrWriteAfterFlush 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrWriteAfterFlush" class="anchor" title="Link to ErrWriteAfterFlush">#</a>
               </h3>
               
               <p>Deprecated: ErrWriteAfterFlush is no longer returned by
anything in the net/http package. Callers should not
compare errors against this variable.</p>
               
               <pre><code>var ErrWriteAfterFlush = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LocalAddrContextKey" data-name="LocalAddrContextKey">
               <h3>
                  LocalAddrContextKey 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#LocalAddrContextKey" class="anchor" title="Link to LocalAddrContextKey">#</a>
               </h3>
               
               <p>LocalAddrContextKey is a context key. It can be used in
HTTP handlers with Context.Value to access the local
address the connection arrived on.
The associated value will be of type net.Addr.</p>
               
               <pre><code>var LocalAddrContextKey = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodConnect" data-name="MethodConnect">
               <h3>
                  MethodConnect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodConnect" class="anchor" title="Link to MethodConnect">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodConnect = "CONNECT"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodDelete" data-name="MethodDelete">
               <h3>
                  MethodDelete 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodDelete" class="anchor" title="Link to MethodDelete">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodDelete = "DELETE"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodGet" data-name="MethodGet">
               <h3>
                  MethodGet 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodGet" class="anchor" title="Link to MethodGet">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodGet = "GET"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodHead" data-name="MethodHead">
               <h3>
                  MethodHead 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodHead" class="anchor" title="Link to MethodHead">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodHead = "HEAD"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodOptions" data-name="MethodOptions">
               <h3>
                  MethodOptions 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodOptions" class="anchor" title="Link to MethodOptions">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodOptions = "OPTIONS"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodPatch" data-name="MethodPatch">
               <h3>
                  MethodPatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodPatch" class="anchor" title="Link to MethodPatch">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodPatch = "PATCH"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodPost" data-name="MethodPost">
               <h3>
                  MethodPost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodPost" class="anchor" title="Link to MethodPost">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodPost = "POST"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodPut" data-name="MethodPut">
               <h3>
                  MethodPut 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodPut" class="anchor" title="Link to MethodPut">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodPut = "PUT"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodTrace" data-name="MethodTrace">
               <h3>
                  MethodTrace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodTrace" class="anchor" title="Link to MethodTrace">#</a>
               </h3>
               
               <p>Common HTTP methods.
Unless otherwise noted, these are defined in RFC 7231 section 4.3.</p>
               
               <pre><code>const MethodTrace = "TRACE"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoBody" data-name="NoBody">
               <h3>
                  NoBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#NoBody" class="anchor" title="Link to NoBody">#</a>
               </h3>
               
               <p>NoBody is an [io.ReadCloser] with no bytes. Read always returns EOF
and Close always returns nil. It can be used in an outgoing client
request to explicitly signal that a request has zero bytes.
An alternative, however, is to simply set [Request.Body] to nil.</p>
               
               <pre><code>var NoBody = noBody{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SameSiteDefaultMode" data-name="SameSiteDefaultMode">
               <h3>
                  SameSiteDefaultMode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SameSiteDefaultMode" class="anchor" title="Link to SameSiteDefaultMode">#</a>
               </h3>
               
               <pre><code>const SameSiteDefaultMode SameSite = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SameSiteLaxMode" data-name="SameSiteLaxMode">
               <h3>
                  SameSiteLaxMode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SameSiteLaxMode" class="anchor" title="Link to SameSiteLaxMode">#</a>
               </h3>
               
               <pre><code>const SameSiteLaxMode</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SameSiteNoneMode" data-name="SameSiteNoneMode">
               <h3>
                  SameSiteNoneMode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SameSiteNoneMode" class="anchor" title="Link to SameSiteNoneMode">#</a>
               </h3>
               
               <pre><code>const SameSiteNoneMode</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SameSiteStrictMode" data-name="SameSiteStrictMode">
               <h3>
                  SameSiteStrictMode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SameSiteStrictMode" class="anchor" title="Link to SameSiteStrictMode">#</a>
               </h3>
               
               <pre><code>const SameSiteStrictMode</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ServerContextKey" data-name="ServerContextKey">
               <h3>
                  ServerContextKey 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ServerContextKey" class="anchor" title="Link to ServerContextKey">#</a>
               </h3>
               
               <p>ServerContextKey is a context key. It can be used in HTTP
handlers with Context.Value to access the server that
started the handler. The associated value will be of
type *Server.</p>
               
               <pre><code>var ServerContextKey = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StateActive" data-name="StateActive">
               <h3>
                  StateActive 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StateActive" class="anchor" title="Link to StateActive">#</a>
               </h3>
               
               <p>StateActive represents a connection that has read 1 or more
bytes of a request. The Server.ConnState hook for
StateActive fires before the request has entered a handler
and doesn't fire again until the request has been
handled. After the request is handled, the state
transitions to StateClosed, StateHijacked, or StateIdle.
For HTTP/2, StateActive fires on the transition from zero
to one active request, and only transitions away once all
active requests are complete. That means that ConnState
cannot be used to do per-request work; ConnState only notes
the overall state of the connection.</p>
               
               <pre><code>const StateActive</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StateClosed" data-name="StateClosed">
               <h3>
                  StateClosed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StateClosed" class="anchor" title="Link to StateClosed">#</a>
               </h3>
               
               <p>StateClosed represents a closed connection.
This is a terminal state. Hijacked connections do not
transition to StateClosed.</p>
               
               <pre><code>const StateClosed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StateHijacked" data-name="StateHijacked">
               <h3>
                  StateHijacked 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StateHijacked" class="anchor" title="Link to StateHijacked">#</a>
               </h3>
               
               <p>StateHijacked represents a hijacked connection.
This is a terminal state. It does not transition to StateClosed.</p>
               
               <pre><code>const StateHijacked</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StateIdle" data-name="StateIdle">
               <h3>
                  StateIdle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StateIdle" class="anchor" title="Link to StateIdle">#</a>
               </h3>
               
               <p>StateIdle represents a connection that has finished
handling a request and is in the keep-alive state, waiting
for a new request. Connections transition from StateIdle
to either StateActive or StateClosed.</p>
               
               <pre><code>const StateIdle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StateNew" data-name="StateNew">
               <h3>
                  StateNew 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StateNew" class="anchor" title="Link to StateNew">#</a>
               </h3>
               
               <p>StateNew represents a new connection that is expected to
send a request immediately. Connections begin at this
state and then transition to either StateActive or
StateClosed.</p>
               
               <pre><code>const StateNew ConnState = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusAccepted" data-name="StatusAccepted">
               <h3>
                  StatusAccepted 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusAccepted" class="anchor" title="Link to StatusAccepted">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusAccepted = 202</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusAlreadyReported" data-name="StatusAlreadyReported">
               <h3>
                  StatusAlreadyReported 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusAlreadyReported" class="anchor" title="Link to StatusAlreadyReported">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusAlreadyReported = 208</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusBadGateway" data-name="StatusBadGateway">
               <h3>
                  StatusBadGateway 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusBadGateway" class="anchor" title="Link to StatusBadGateway">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusBadGateway = 502</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusBadRequest" data-name="StatusBadRequest">
               <h3>
                  StatusBadRequest 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusBadRequest" class="anchor" title="Link to StatusBadRequest">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusBadRequest = 400</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusConflict" data-name="StatusConflict">
               <h3>
                  StatusConflict 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusConflict" class="anchor" title="Link to StatusConflict">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusConflict = 409</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusContinue" data-name="StatusContinue">
               <h3>
                  StatusContinue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusContinue" class="anchor" title="Link to StatusContinue">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusContinue = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusCreated" data-name="StatusCreated">
               <h3>
                  StatusCreated 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusCreated" class="anchor" title="Link to StatusCreated">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusCreated = 201</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusEarlyHints" data-name="StatusEarlyHints">
               <h3>
                  StatusEarlyHints 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusEarlyHints" class="anchor" title="Link to StatusEarlyHints">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusEarlyHints = 103</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusExpectationFailed" data-name="StatusExpectationFailed">
               <h3>
                  StatusExpectationFailed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusExpectationFailed" class="anchor" title="Link to StatusExpectationFailed">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusExpectationFailed = 417</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusFailedDependency" data-name="StatusFailedDependency">
               <h3>
                  StatusFailedDependency 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusFailedDependency" class="anchor" title="Link to StatusFailedDependency">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusFailedDependency = 424</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusForbidden" data-name="StatusForbidden">
               <h3>
                  StatusForbidden 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusForbidden" class="anchor" title="Link to StatusForbidden">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusForbidden = 403</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusFound" data-name="StatusFound">
               <h3>
                  StatusFound 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusFound" class="anchor" title="Link to StatusFound">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusFound = 302</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusGatewayTimeout" data-name="StatusGatewayTimeout">
               <h3>
                  StatusGatewayTimeout 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusGatewayTimeout" class="anchor" title="Link to StatusGatewayTimeout">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusGatewayTimeout = 504</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusGone" data-name="StatusGone">
               <h3>
                  StatusGone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusGone" class="anchor" title="Link to StatusGone">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusGone = 410</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusHTTPVersionNotSupported" data-name="StatusHTTPVersionNotSupported">
               <h3>
                  StatusHTTPVersionNotSupported 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusHTTPVersionNotSupported" class="anchor" title="Link to StatusHTTPVersionNotSupported">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusHTTPVersionNotSupported = 505</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusIMUsed" data-name="StatusIMUsed">
               <h3>
                  StatusIMUsed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusIMUsed" class="anchor" title="Link to StatusIMUsed">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusIMUsed = 226</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusInsufficientStorage" data-name="StatusInsufficientStorage">
               <h3>
                  StatusInsufficientStorage 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusInsufficientStorage" class="anchor" title="Link to StatusInsufficientStorage">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusInsufficientStorage = 507</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusInternalServerError" data-name="StatusInternalServerError">
               <h3>
                  StatusInternalServerError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusInternalServerError" class="anchor" title="Link to StatusInternalServerError">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusInternalServerError = 500</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusLengthRequired" data-name="StatusLengthRequired">
               <h3>
                  StatusLengthRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusLengthRequired" class="anchor" title="Link to StatusLengthRequired">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusLengthRequired = 411</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusLocked" data-name="StatusLocked">
               <h3>
                  StatusLocked 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusLocked" class="anchor" title="Link to StatusLocked">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusLocked = 423</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusLoopDetected" data-name="StatusLoopDetected">
               <h3>
                  StatusLoopDetected 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusLoopDetected" class="anchor" title="Link to StatusLoopDetected">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusLoopDetected = 508</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusMethodNotAllowed" data-name="StatusMethodNotAllowed">
               <h3>
                  StatusMethodNotAllowed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusMethodNotAllowed" class="anchor" title="Link to StatusMethodNotAllowed">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusMethodNotAllowed = 405</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusMisdirectedRequest" data-name="StatusMisdirectedRequest">
               <h3>
                  StatusMisdirectedRequest 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusMisdirectedRequest" class="anchor" title="Link to StatusMisdirectedRequest">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusMisdirectedRequest = 421</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusMovedPermanently" data-name="StatusMovedPermanently">
               <h3>
                  StatusMovedPermanently 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusMovedPermanently" class="anchor" title="Link to StatusMovedPermanently">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusMovedPermanently = 301</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusMultiStatus" data-name="StatusMultiStatus">
               <h3>
                  StatusMultiStatus 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusMultiStatus" class="anchor" title="Link to StatusMultiStatus">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusMultiStatus = 207</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusMultipleChoices" data-name="StatusMultipleChoices">
               <h3>
                  StatusMultipleChoices 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusMultipleChoices" class="anchor" title="Link to StatusMultipleChoices">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusMultipleChoices = 300</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNetworkAuthenticationRequired" data-name="StatusNetworkAuthenticationRequired">
               <h3>
                  StatusNetworkAuthenticationRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNetworkAuthenticationRequired" class="anchor" title="Link to StatusNetworkAuthenticationRequired">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNetworkAuthenticationRequired = 511</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNoContent" data-name="StatusNoContent">
               <h3>
                  StatusNoContent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNoContent" class="anchor" title="Link to StatusNoContent">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNoContent = 204</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNonAuthoritativeInfo" data-name="StatusNonAuthoritativeInfo">
               <h3>
                  StatusNonAuthoritativeInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNonAuthoritativeInfo" class="anchor" title="Link to StatusNonAuthoritativeInfo">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNonAuthoritativeInfo = 203</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNotAcceptable" data-name="StatusNotAcceptable">
               <h3>
                  StatusNotAcceptable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNotAcceptable" class="anchor" title="Link to StatusNotAcceptable">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNotAcceptable = 406</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNotExtended" data-name="StatusNotExtended">
               <h3>
                  StatusNotExtended 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNotExtended" class="anchor" title="Link to StatusNotExtended">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNotExtended = 510</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNotFound" data-name="StatusNotFound">
               <h3>
                  StatusNotFound 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNotFound" class="anchor" title="Link to StatusNotFound">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNotFound = 404</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNotImplemented" data-name="StatusNotImplemented">
               <h3>
                  StatusNotImplemented 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNotImplemented" class="anchor" title="Link to StatusNotImplemented">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNotImplemented = 501</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusNotModified" data-name="StatusNotModified">
               <h3>
                  StatusNotModified 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusNotModified" class="anchor" title="Link to StatusNotModified">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusNotModified = 304</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusOK" data-name="StatusOK">
               <h3>
                  StatusOK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusOK" class="anchor" title="Link to StatusOK">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusOK = 200</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusPartialContent" data-name="StatusPartialContent">
               <h3>
                  StatusPartialContent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusPartialContent" class="anchor" title="Link to StatusPartialContent">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusPartialContent = 206</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusPaymentRequired" data-name="StatusPaymentRequired">
               <h3>
                  StatusPaymentRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusPaymentRequired" class="anchor" title="Link to StatusPaymentRequired">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusPaymentRequired = 402</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusPermanentRedirect" data-name="StatusPermanentRedirect">
               <h3>
                  StatusPermanentRedirect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusPermanentRedirect" class="anchor" title="Link to StatusPermanentRedirect">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusPermanentRedirect = 308</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusPreconditionFailed" data-name="StatusPreconditionFailed">
               <h3>
                  StatusPreconditionFailed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusPreconditionFailed" class="anchor" title="Link to StatusPreconditionFailed">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusPreconditionFailed = 412</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusPreconditionRequired" data-name="StatusPreconditionRequired">
               <h3>
                  StatusPreconditionRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusPreconditionRequired" class="anchor" title="Link to StatusPreconditionRequired">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusPreconditionRequired = 428</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusProcessing" data-name="StatusProcessing">
               <h3>
                  StatusProcessing 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusProcessing" class="anchor" title="Link to StatusProcessing">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusProcessing = 102</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusProxyAuthRequired" data-name="StatusProxyAuthRequired">
               <h3>
                  StatusProxyAuthRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusProxyAuthRequired" class="anchor" title="Link to StatusProxyAuthRequired">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusProxyAuthRequired = 407</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusRequestEntityTooLarge" data-name="StatusRequestEntityTooLarge">
               <h3>
                  StatusRequestEntityTooLarge 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusRequestEntityTooLarge" class="anchor" title="Link to StatusRequestEntityTooLarge">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusRequestEntityTooLarge = 413</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusRequestHeaderFieldsTooLarge" data-name="StatusRequestHeaderFieldsTooLarge">
               <h3>
                  StatusRequestHeaderFieldsTooLarge 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusRequestHeaderFieldsTooLarge" class="anchor" title="Link to StatusRequestHeaderFieldsTooLarge">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusRequestHeaderFieldsTooLarge = 431</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusRequestTimeout" data-name="StatusRequestTimeout">
               <h3>
                  StatusRequestTimeout 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusRequestTimeout" class="anchor" title="Link to StatusRequestTimeout">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusRequestTimeout = 408</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusRequestURITooLong" data-name="StatusRequestURITooLong">
               <h3>
                  StatusRequestURITooLong 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusRequestURITooLong" class="anchor" title="Link to StatusRequestURITooLong">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusRequestURITooLong = 414</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusRequestedRangeNotSatisfiable" data-name="StatusRequestedRangeNotSatisfiable">
               <h3>
                  StatusRequestedRangeNotSatisfiable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusRequestedRangeNotSatisfiable" class="anchor" title="Link to StatusRequestedRangeNotSatisfiable">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusRequestedRangeNotSatisfiable = 416</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusResetContent" data-name="StatusResetContent">
               <h3>
                  StatusResetContent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusResetContent" class="anchor" title="Link to StatusResetContent">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusResetContent = 205</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusSeeOther" data-name="StatusSeeOther">
               <h3>
                  StatusSeeOther 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusSeeOther" class="anchor" title="Link to StatusSeeOther">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusSeeOther = 303</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusServiceUnavailable" data-name="StatusServiceUnavailable">
               <h3>
                  StatusServiceUnavailable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusServiceUnavailable" class="anchor" title="Link to StatusServiceUnavailable">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusServiceUnavailable = 503</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusSwitchingProtocols" data-name="StatusSwitchingProtocols">
               <h3>
                  StatusSwitchingProtocols 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusSwitchingProtocols" class="anchor" title="Link to StatusSwitchingProtocols">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusSwitchingProtocols = 101</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusTeapot" data-name="StatusTeapot">
               <h3>
                  StatusTeapot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusTeapot" class="anchor" title="Link to StatusTeapot">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusTeapot = 418</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusTemporaryRedirect" data-name="StatusTemporaryRedirect">
               <h3>
                  StatusTemporaryRedirect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusTemporaryRedirect" class="anchor" title="Link to StatusTemporaryRedirect">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusTemporaryRedirect = 307</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusTooEarly" data-name="StatusTooEarly">
               <h3>
                  StatusTooEarly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusTooEarly" class="anchor" title="Link to StatusTooEarly">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusTooEarly = 425</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusTooManyRequests" data-name="StatusTooManyRequests">
               <h3>
                  StatusTooManyRequests 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusTooManyRequests" class="anchor" title="Link to StatusTooManyRequests">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusTooManyRequests = 429</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusUnauthorized" data-name="StatusUnauthorized">
               <h3>
                  StatusUnauthorized 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusUnauthorized" class="anchor" title="Link to StatusUnauthorized">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusUnauthorized = 401</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusUnavailableForLegalReasons" data-name="StatusUnavailableForLegalReasons">
               <h3>
                  StatusUnavailableForLegalReasons 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusUnavailableForLegalReasons" class="anchor" title="Link to StatusUnavailableForLegalReasons">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusUnavailableForLegalReasons = 451</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusUnprocessableEntity" data-name="StatusUnprocessableEntity">
               <h3>
                  StatusUnprocessableEntity 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusUnprocessableEntity" class="anchor" title="Link to StatusUnprocessableEntity">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusUnprocessableEntity = 422</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusUnsupportedMediaType" data-name="StatusUnsupportedMediaType">
               <h3>
                  StatusUnsupportedMediaType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusUnsupportedMediaType" class="anchor" title="Link to StatusUnsupportedMediaType">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusUnsupportedMediaType = 415</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusUpgradeRequired" data-name="StatusUpgradeRequired">
               <h3>
                  StatusUpgradeRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusUpgradeRequired" class="anchor" title="Link to StatusUpgradeRequired">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusUpgradeRequired = 426</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusUseProxy" data-name="StatusUseProxy">
               <h3>
                  StatusUseProxy 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusUseProxy" class="anchor" title="Link to StatusUseProxy">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusUseProxy = 305</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StatusVariantAlsoNegotiates" data-name="StatusVariantAlsoNegotiates">
               <h3>
                  StatusVariantAlsoNegotiates 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StatusVariantAlsoNegotiates" class="anchor" title="Link to StatusVariantAlsoNegotiates">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const StatusVariantAlsoNegotiates = 506</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TimeFormat" data-name="TimeFormat">
               <h3>
                  TimeFormat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TimeFormat" class="anchor" title="Link to TimeFormat">#</a>
               </h3>
               
               <p>TimeFormat is the time format to use when generating times in HTTP
headers. It is like [time.RFC1123] but hard-codes GMT as the time
zone. The time being formatted must be in UTC for Format to
generate the correct format.
For parsing this time format, see [ParseTime].</p>
               
               <pre><code>const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TrailerPrefix" data-name="TrailerPrefix">
               <h3>
                  TrailerPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TrailerPrefix" class="anchor" title="Link to TrailerPrefix">#</a>
               </h3>
               
               <p>TrailerPrefix is a magic prefix for [ResponseWriter.Header] map keys
that, if present, signals that the map entry is actually for
the response trailers, and not the response headers. The prefix
is stripped after the ServeHTTP call finishes and the values are
sent in the trailers.
This mechanism is intended only for trailers that are not known
prior to the headers being written. If the set of trailers is fixed
or known before the header is written, the normal Go trailers mechanism
is preferred:
https://pkg.go.dev/net/http#ResponseWriter
https://pkg.go.dev/net/http#example-ResponseWriter-Trailers</p>
               
               <pre><code>const TrailerPrefix = "Trailer:"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>Optional http.ResponseWriter interfaces implemented.</p>
               
               <pre><code>var _ CloseNotifier = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ io.ReaderFrom = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ io.ReadCloser = NoBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>verify that an io.Copy from NoBody won't require a buffer:</p>
               
               <pre><code>var _ io.WriterTo = NoBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ closeWriter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>HTTP status codes as registered with IANA.
See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
               
               <pre><code>const _ = 306</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ http2clientConnPoolIdleCloser = http2noDialClientConnPool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ http2clientConnPoolIdleCloser = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ Pusher = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ Pusher = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>Optional http.ResponseWriter interfaces implemented.</p>
               
               <pre><code>var _ http2stringWriter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>Optional http.ResponseWriter interfaces implemented.</p>
               
               <pre><code>var _ Flusher = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="aLongTimeAgo" data-name="aLongTimeAgo">
               <h3>
                  aLongTimeAgo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#aLongTimeAgo" class="anchor" title="Link to aLongTimeAgo">#</a>
               </h3>
               
               <p>aLongTimeAgo is a non-zero time, far in the past, used for
immediate cancellation of network operations.</p>
               
               <pre><code>var aLongTimeAgo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufferBeforeChunkingSize" data-name="bufferBeforeChunkingSize">
               <h3>
                  bufferBeforeChunkingSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bufferBeforeChunkingSize" class="anchor" title="Link to bufferBeforeChunkingSize">#</a>
               </h3>
               
               <p>This should be >= 512 bytes for DetectContentType,
but otherwise it's somewhat arbitrary.</p>
               
               <pre><code>const bufferBeforeChunkingSize = 2048</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufioReaderPool" data-name="bufioReaderPool">
               <h3>
                  bufioReaderPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bufioReaderPool" class="anchor" title="Link to bufioReaderPool">#</a>
               </h3>
               
               <pre><code>var bufioReaderPool sync.Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufioWriter2kPool" data-name="bufioWriter2kPool">
               <h3>
                  bufioWriter2kPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bufioWriter2kPool" class="anchor" title="Link to bufioWriter2kPool">#</a>
               </h3>
               
               <pre><code>var bufioWriter2kPool sync.Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufioWriter4kPool" data-name="bufioWriter4kPool">
               <h3>
                  bufioWriter4kPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bufioWriter4kPool" class="anchor" title="Link to bufioWriter4kPool">#</a>
               </h3>
               
               <pre><code>var bufioWriter4kPool sync.Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="colonSpace" data-name="colonSpace">
               <h3>
                  colonSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#colonSpace" class="anchor" title="Link to colonSpace">#</a>
               </h3>
               
               <pre><code>var colonSpace = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="condFalse" data-name="condFalse">
               <h3>
                  condFalse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#condFalse" class="anchor" title="Link to condFalse">#</a>
               </h3>
               
               <pre><code>const condFalse</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="condNone" data-name="condNone">
               <h3>
                  condNone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#condNone" class="anchor" title="Link to condNone">#</a>
               </h3>
               
               <pre><code>const condNone condResult = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="condTrue" data-name="condTrue">
               <h3>
                  condTrue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#condTrue" class="anchor" title="Link to condTrue">#</a>
               </h3>
               
               <pre><code>const condTrue</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cookieNameSanitizer" data-name="cookieNameSanitizer">
               <h3>
                  cookieNameSanitizer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cookieNameSanitizer" class="anchor" title="Link to cookieNameSanitizer">#</a>
               </h3>
               
               <pre><code>var cookieNameSanitizer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="copyBufPool" data-name="copyBufPool">
               <h3>
                  copyBufPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#copyBufPool" class="anchor" title="Link to copyBufPool">#</a>
               </h3>
               
               <pre><code>var copyBufPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="copyBufPoolSize" data-name="copyBufPoolSize">
               <h3>
                  copyBufPoolSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#copyBufPoolSize" class="anchor" title="Link to copyBufPoolSize">#</a>
               </h3>
               
               <pre><code>const copyBufPoolSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="crlf" data-name="crlf">
               <h3>
                  crlf 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#crlf" class="anchor" title="Link to crlf">#</a>
               </h3>
               
               <pre><code>var crlf = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugServerConnections" data-name="debugServerConnections">
               <h3>
                  debugServerConnections 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugServerConnections" class="anchor" title="Link to debugServerConnections">#</a>
               </h3>
               
               <p>debugServerConnections controls whether all server connections are wrapped
with a verbose logging wrapper.</p>
               
               <pre><code>const debugServerConnections = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultMaxMemory" data-name="defaultMaxMemory">
               <h3>
                  defaultMaxMemory 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#defaultMaxMemory" class="anchor" title="Link to defaultMaxMemory">#</a>
               </h3>
               
               <pre><code>const defaultMaxMemory = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultServeMux" data-name="defaultServeMux">
               <h3>
                  defaultServeMux 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultServeMux" class="anchor" title="Link to defaultServeMux">#</a>
               </h3>
               
               <pre><code>var defaultServeMux ServeMux</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultUserAgent" data-name="defaultUserAgent">
               <h3>
                  defaultUserAgent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#defaultUserAgent" class="anchor" title="Link to defaultUserAgent">#</a>
               </h3>
               
               <p>NOTE: This is not intended to reflect the actual Go version being used.
It was changed at the time of Go 1.1 release because the former User-Agent
had ended up blocked by some intrusion detection systems.
See https://codereview.appspot.com/7532043.</p>
               
               <pre><code>const defaultUserAgent = "Go-http-client/1.1"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="disjoint" data-name="disjoint">
               <h3>
                  disjoint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#disjoint" class="anchor" title="Link to disjoint">#</a>
               </h3>
               
               <pre><code>const disjoint relationship = "disjoint"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="doubleCRLF" data-name="doubleCRLF">
               <h3>
                  doubleCRLF 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#doubleCRLF" class="anchor" title="Link to doubleCRLF">#</a>
               </h3>
               
               <pre><code>var doubleCRLF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="envProxyFuncValue" data-name="envProxyFuncValue">
               <h3>
                  envProxyFuncValue 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#envProxyFuncValue" class="anchor" title="Link to envProxyFuncValue">#</a>
               </h3>
               
               <pre><code>var envProxyFuncValue func(*url.URL) (*url.URL, error)</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="envProxyOnce" data-name="envProxyOnce">
               <h3>
                  envProxyOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#envProxyOnce" class="anchor" title="Link to envProxyOnce">#</a>
               </h3>
               
               <pre><code>var envProxyOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="equivalent" data-name="equivalent">
               <h3>
                  equivalent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#equivalent" class="anchor" title="Link to equivalent">#</a>
               </h3>
               
               <pre><code>const equivalent relationship = "equivalent"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errBlankCookie" data-name="errBlankCookie">
               <h3>
                  errBlankCookie 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errBlankCookie" class="anchor" title="Link to errBlankCookie">#</a>
               </h3>
               
               <pre><code>var errBlankCookie = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCallerOwnsConn" data-name="errCallerOwnsConn">
               <h3>
                  errCallerOwnsConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCallerOwnsConn" class="anchor" title="Link to errCallerOwnsConn">#</a>
               </h3>
               
               <p>errCallerOwnsConn is an internal sentinel error used when we hand
off a writable response.Body to the caller. We use this to prevent
closing a net.Conn that is now owned by the caller.</p>
               
               <pre><code>var errCallerOwnsConn = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCannotRewind" data-name="errCannotRewind">
               <h3>
                  errCannotRewind 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCannotRewind" class="anchor" title="Link to errCannotRewind">#</a>
               </h3>
               
               <pre><code>var errCannotRewind = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCloseIdle" data-name="errCloseIdle">
               <h3>
                  errCloseIdle 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCloseIdle" class="anchor" title="Link to errCloseIdle">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errCloseIdle = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCloseIdleConns" data-name="errCloseIdleConns">
               <h3>
                  errCloseIdleConns 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCloseIdleConns" class="anchor" title="Link to errCloseIdleConns">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errCloseIdleConns = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errClosed" data-name="errClosed">
               <h3>
                  errClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errClosed" class="anchor" title="Link to errClosed">#</a>
               </h3>
               
               <pre><code>var errClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errConnBroken" data-name="errConnBroken">
               <h3>
                  errConnBroken 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errConnBroken" class="anchor" title="Link to errConnBroken">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errConnBroken = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errEqualNotFoundInCookie" data-name="errEqualNotFoundInCookie">
               <h3>
                  errEqualNotFoundInCookie 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errEqualNotFoundInCookie" class="anchor" title="Link to errEqualNotFoundInCookie">#</a>
               </h3>
               
               <pre><code>var errEqualNotFoundInCookie = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errIdleConnTimeout" data-name="errIdleConnTimeout">
               <h3>
                  errIdleConnTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errIdleConnTimeout" class="anchor" title="Link to errIdleConnTimeout">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errIdleConnTimeout = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errInvalidCookieName" data-name="errInvalidCookieName">
               <h3>
                  errInvalidCookieName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errInvalidCookieName" class="anchor" title="Link to errInvalidCookieName">#</a>
               </h3>
               
               <pre><code>var errInvalidCookieName = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errInvalidCookieValue" data-name="errInvalidCookieValue">
               <h3>
                  errInvalidCookieValue 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errInvalidCookieValue" class="anchor" title="Link to errInvalidCookieValue">#</a>
               </h3>
               
               <pre><code>var errInvalidCookieValue = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errKeepAlivesDisabled" data-name="errKeepAlivesDisabled">
               <h3>
                  errKeepAlivesDisabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errKeepAlivesDisabled" class="anchor" title="Link to errKeepAlivesDisabled">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errKeepAlivesDisabled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMissingHost" data-name="errMissingHost">
               <h3>
                  errMissingHost 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMissingHost" class="anchor" title="Link to errMissingHost">#</a>
               </h3>
               
               <p>errMissingHost is returned by Write when there is no Host or URL present in
the Request.</p>
               
               <pre><code>var errMissingHost = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMissingReadDir" data-name="errMissingReadDir">
               <h3>
                  errMissingReadDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMissingReadDir" class="anchor" title="Link to errMissingReadDir">#</a>
               </h3>
               
               <pre><code>var errMissingReadDir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMissingSeek" data-name="errMissingSeek">
               <h3>
                  errMissingSeek 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMissingSeek" class="anchor" title="Link to errMissingSeek">#</a>
               </h3>
               
               <pre><code>var errMissingSeek = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoOverlap" data-name="errNoOverlap">
               <h3>
                  errNoOverlap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoOverlap" class="anchor" title="Link to errNoOverlap">#</a>
               </h3>
               
               <p>errNoOverlap is returned by serveContent's parseRange if first-byte-pos of
all of the byte-range-spec values is greater than the content size.</p>
               
               <pre><code>var errNoOverlap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errReadLoopExiting" data-name="errReadLoopExiting">
               <h3>
                  errReadLoopExiting 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errReadLoopExiting" class="anchor" title="Link to errReadLoopExiting">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errReadLoopExiting = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errReadOnClosedResBody" data-name="errReadOnClosedResBody">
               <h3>
                  errReadOnClosedResBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errReadOnClosedResBody" class="anchor" title="Link to errReadOnClosedResBody">#</a>
               </h3>
               
               <pre><code>var errReadOnClosedResBody = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errRequestCanceled" data-name="errRequestCanceled">
               <h3>
                  errRequestCanceled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errRequestCanceled" class="anchor" title="Link to errRequestCanceled">#</a>
               </h3>
               
               <p>errRequestCanceled is set to be identical to the one from h2 to facilitate
testing.</p>
               
               <pre><code>var errRequestCanceled = http2errRequestCanceled</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errRequestCanceledConn" data-name="errRequestCanceledConn">
               <h3>
                  errRequestCanceledConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errRequestCanceledConn" class="anchor" title="Link to errRequestCanceledConn">#</a>
               </h3>
               
               <pre><code>var errRequestCanceledConn = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errRequestDone" data-name="errRequestDone">
               <h3>
                  errRequestDone 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errRequestDone" class="anchor" title="Link to errRequestDone">#</a>
               </h3>
               
               <p>errRequestDone is used to cancel the round trip Context after a request is successfully done.
It should not be seen by the user.</p>
               
               <pre><code>var errRequestDone = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSeeker" data-name="errSeeker">
               <h3>
                  errSeeker 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSeeker" class="anchor" title="Link to errSeeker">#</a>
               </h3>
               
               <p>errSeeker is returned by ServeContent's sizeFunc when the content
doesn't seek properly. The underlying Seeker's error text isn't
included in the sizeFunc reply so it's not sent over HTTP to end
users.</p>
               
               <pre><code>var errSeeker = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errServerClosedIdle" data-name="errServerClosedIdle">
               <h3>
                  errServerClosedIdle 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errServerClosedIdle" class="anchor" title="Link to errServerClosedIdle">#</a>
               </h3>
               
               <p>errServerClosedIdle is not seen by users for idempotent requests, but may be
seen by a user if the server shuts down an idle connection and sends its FIN
in flight with already-written POST body bytes from the client.
See https://github.com/golang/go/issues/19943#issuecomment-355607646</p>
               
               <pre><code>var errServerClosedIdle = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errTimeout" data-name="errTimeout">
               <h3>
                  errTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errTimeout" class="anchor" title="Link to errTimeout">#</a>
               </h3>
               
               <pre><code>var errTimeout error = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errTooLarge" data-name="errTooLarge">
               <h3>
                  errTooLarge 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errTooLarge" class="anchor" title="Link to errTooLarge">#</a>
               </h3>
               
               <pre><code>var errTooLarge = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errTooManyIdle" data-name="errTooManyIdle">
               <h3>
                  errTooManyIdle 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errTooManyIdle" class="anchor" title="Link to errTooManyIdle">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errTooManyIdle = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errTooManyIdleHost" data-name="errTooManyIdleHost">
               <h3>
                  errTooManyIdleHost 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errTooManyIdleHost" class="anchor" title="Link to errTooManyIdleHost">#</a>
               </h3>
               
               <p>error values for debugging and testing, not seen by users.</p>
               
               <pre><code>var errTooManyIdleHost = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errTrailerEOF" data-name="errTrailerEOF">
               <h3>
                  errTrailerEOF 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errTrailerEOF" class="anchor" title="Link to errTrailerEOF">#</a>
               </h3>
               
               <pre><code>var errTrailerEOF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="excludedHeadersNoBody" data-name="excludedHeadersNoBody">
               <h3>
                  excludedHeadersNoBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#excludedHeadersNoBody" class="anchor" title="Link to excludedHeadersNoBody">#</a>
               </h3>
               
               <pre><code>var excludedHeadersNoBody = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="extraHeaderKeys" data-name="extraHeaderKeys">
               <h3>
                  extraHeaderKeys 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#extraHeaderKeys" class="anchor" title="Link to extraHeaderKeys">#</a>
               </h3>
               
               <p>Sorted the same as extraHeader.Write's loop.</p>
               
               <pre><code>var extraHeaderKeys = [][]byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="headerContentLength" data-name="headerContentLength">
               <h3>
                  headerContentLength 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#headerContentLength" class="anchor" title="Link to headerContentLength">#</a>
               </h3>
               
               <pre><code>var headerContentLength = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="headerDate" data-name="headerDate">
               <h3>
                  headerDate 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#headerDate" class="anchor" title="Link to headerDate">#</a>
               </h3>
               
               <pre><code>var headerDate = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="headerNewlineToSpace" data-name="headerNewlineToSpace">
               <h3>
                  headerNewlineToSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#headerNewlineToSpace" class="anchor" title="Link to headerNewlineToSpace">#</a>
               </h3>
               
               <pre><code>var headerNewlineToSpace = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="headerSorterPool" data-name="headerSorterPool">
               <h3>
                  headerSorterPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#headerSorterPool" class="anchor" title="Link to headerSorterPool">#</a>
               </h3>
               
               <pre><code>var headerSorterPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlReplacer" data-name="htmlReplacer">
               <h3>
                  htmlReplacer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlReplacer" class="anchor" title="Link to htmlReplacer">#</a>
               </h3>
               
               <pre><code>var htmlReplacer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ClientPreface" data-name="http2ClientPreface">
               <h3>
                  http2ClientPreface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ClientPreface" class="anchor" title="Link to http2ClientPreface">#</a>
               </h3>
               
               <p>ClientPreface is the string that must be sent by new
connections from clients.</p>
               
               <pre><code>const http2ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2DebugGoroutines" data-name="http2DebugGoroutines">
               <h3>
                  http2DebugGoroutines 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2DebugGoroutines" class="anchor" title="Link to http2DebugGoroutines">#</a>
               </h3>
               
               <pre><code>var http2DebugGoroutines = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeCancel" data-name="http2ErrCodeCancel">
               <h3>
                  http2ErrCodeCancel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeCancel" class="anchor" title="Link to http2ErrCodeCancel">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeCancel http2ErrCode = 0x8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeCompression" data-name="http2ErrCodeCompression">
               <h3>
                  http2ErrCodeCompression 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeCompression" class="anchor" title="Link to http2ErrCodeCompression">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeCompression http2ErrCode = 0x9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeConnect" data-name="http2ErrCodeConnect">
               <h3>
                  http2ErrCodeConnect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeConnect" class="anchor" title="Link to http2ErrCodeConnect">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeConnect http2ErrCode = 0xa</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeEnhanceYourCalm" data-name="http2ErrCodeEnhanceYourCalm">
               <h3>
                  http2ErrCodeEnhanceYourCalm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeEnhanceYourCalm" class="anchor" title="Link to http2ErrCodeEnhanceYourCalm">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeEnhanceYourCalm http2ErrCode = 0xb</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeFlowControl" data-name="http2ErrCodeFlowControl">
               <h3>
                  http2ErrCodeFlowControl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeFlowControl" class="anchor" title="Link to http2ErrCodeFlowControl">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeFlowControl http2ErrCode = 0x3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeFrameSize" data-name="http2ErrCodeFrameSize">
               <h3>
                  http2ErrCodeFrameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeFrameSize" class="anchor" title="Link to http2ErrCodeFrameSize">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeFrameSize http2ErrCode = 0x6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeHTTP11Required" data-name="http2ErrCodeHTTP11Required">
               <h3>
                  http2ErrCodeHTTP11Required 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeHTTP11Required" class="anchor" title="Link to http2ErrCodeHTTP11Required">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeHTTP11Required http2ErrCode = 0xd</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeInadequateSecurity" data-name="http2ErrCodeInadequateSecurity">
               <h3>
                  http2ErrCodeInadequateSecurity 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeInadequateSecurity" class="anchor" title="Link to http2ErrCodeInadequateSecurity">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeInadequateSecurity http2ErrCode = 0xc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeInternal" data-name="http2ErrCodeInternal">
               <h3>
                  http2ErrCodeInternal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeInternal" class="anchor" title="Link to http2ErrCodeInternal">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeInternal http2ErrCode = 0x2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeNo" data-name="http2ErrCodeNo">
               <h3>
                  http2ErrCodeNo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeNo" class="anchor" title="Link to http2ErrCodeNo">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeNo http2ErrCode = 0x0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeProtocol" data-name="http2ErrCodeProtocol">
               <h3>
                  http2ErrCodeProtocol 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeProtocol" class="anchor" title="Link to http2ErrCodeProtocol">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeProtocol http2ErrCode = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeRefusedStream" data-name="http2ErrCodeRefusedStream">
               <h3>
                  http2ErrCodeRefusedStream 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeRefusedStream" class="anchor" title="Link to http2ErrCodeRefusedStream">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeRefusedStream http2ErrCode = 0x7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeSettingsTimeout" data-name="http2ErrCodeSettingsTimeout">
               <h3>
                  http2ErrCodeSettingsTimeout 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeSettingsTimeout" class="anchor" title="Link to http2ErrCodeSettingsTimeout">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeSettingsTimeout http2ErrCode = 0x4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrCodeStreamClosed" data-name="http2ErrCodeStreamClosed">
               <h3>
                  http2ErrCodeStreamClosed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2ErrCodeStreamClosed" class="anchor" title="Link to http2ErrCodeStreamClosed">#</a>
               </h3>
               
               <pre><code>const http2ErrCodeStreamClosed http2ErrCode = 0x5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrFrameTooLarge" data-name="http2ErrFrameTooLarge">
               <h3>
                  http2ErrFrameTooLarge 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2ErrFrameTooLarge" class="anchor" title="Link to http2ErrFrameTooLarge">#</a>
               </h3>
               
               <p>ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
sends a frame that is larger than declared with SetMaxReadFrameSize.</p>
               
               <pre><code>var http2ErrFrameTooLarge = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrNoCachedConn" data-name="http2ErrNoCachedConn">
               <h3>
                  http2ErrNoCachedConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2ErrNoCachedConn" class="anchor" title="Link to http2ErrNoCachedConn">#</a>
               </h3>
               
               <pre><code>var http2ErrNoCachedConn error = http2noCachedConnError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrNoCachedConn" data-name="http2ErrNoCachedConn">
               <h3>
                  http2ErrNoCachedConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2ErrNoCachedConn" class="anchor" title="Link to http2ErrNoCachedConn">#</a>
               </h3>
               
               <pre><code>var http2ErrNoCachedConn = http2noCachedConnError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrPushLimitReached" data-name="http2ErrPushLimitReached">
               <h3>
                  http2ErrPushLimitReached 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2ErrPushLimitReached" class="anchor" title="Link to http2ErrPushLimitReached">#</a>
               </h3>
               
               <p>Push errors.</p>
               
               <pre><code>var http2ErrPushLimitReached = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2ErrRecursivePush" data-name="http2ErrRecursivePush">
               <h3>
                  http2ErrRecursivePush 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2ErrRecursivePush" class="anchor" title="Link to http2ErrRecursivePush">#</a>
               </h3>
               
               <p>Push errors.</p>
               
               <pre><code>var http2ErrRecursivePush = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagContinuationEndHeaders" data-name="http2FlagContinuationEndHeaders">
               <h3>
                  http2FlagContinuationEndHeaders 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagContinuationEndHeaders" class="anchor" title="Link to http2FlagContinuationEndHeaders">#</a>
               </h3>
               
               <p>Continuation Frame</p>
               
               <pre><code>const http2FlagContinuationEndHeaders http2Flags = 0x4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagDataEndStream" data-name="http2FlagDataEndStream">
               <h3>
                  http2FlagDataEndStream 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagDataEndStream" class="anchor" title="Link to http2FlagDataEndStream">#</a>
               </h3>
               
               <p>Data Frame</p>
               
               <pre><code>const http2FlagDataEndStream http2Flags = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagDataPadded" data-name="http2FlagDataPadded">
               <h3>
                  http2FlagDataPadded 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagDataPadded" class="anchor" title="Link to http2FlagDataPadded">#</a>
               </h3>
               
               <p>Frame-specific FrameHeader flag bits.</p>
               
               <pre><code>const http2FlagDataPadded http2Flags = 0x8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagHeadersEndHeaders" data-name="http2FlagHeadersEndHeaders">
               <h3>
                  http2FlagHeadersEndHeaders 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagHeadersEndHeaders" class="anchor" title="Link to http2FlagHeadersEndHeaders">#</a>
               </h3>
               
               <p>Frame-specific FrameHeader flag bits.</p>
               
               <pre><code>const http2FlagHeadersEndHeaders http2Flags = 0x4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagHeadersEndStream" data-name="http2FlagHeadersEndStream">
               <h3>
                  http2FlagHeadersEndStream 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagHeadersEndStream" class="anchor" title="Link to http2FlagHeadersEndStream">#</a>
               </h3>
               
               <p>Headers Frame</p>
               
               <pre><code>const http2FlagHeadersEndStream http2Flags = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagHeadersPadded" data-name="http2FlagHeadersPadded">
               <h3>
                  http2FlagHeadersPadded 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagHeadersPadded" class="anchor" title="Link to http2FlagHeadersPadded">#</a>
               </h3>
               
               <p>Frame-specific FrameHeader flag bits.</p>
               
               <pre><code>const http2FlagHeadersPadded http2Flags = 0x8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagHeadersPriority" data-name="http2FlagHeadersPriority">
               <h3>
                  http2FlagHeadersPriority 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagHeadersPriority" class="anchor" title="Link to http2FlagHeadersPriority">#</a>
               </h3>
               
               <p>Frame-specific FrameHeader flag bits.</p>
               
               <pre><code>const http2FlagHeadersPriority http2Flags = 0x20</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagPingAck" data-name="http2FlagPingAck">
               <h3>
                  http2FlagPingAck 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagPingAck" class="anchor" title="Link to http2FlagPingAck">#</a>
               </h3>
               
               <p>Ping Frame</p>
               
               <pre><code>const http2FlagPingAck http2Flags = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagPushPromiseEndHeaders" data-name="http2FlagPushPromiseEndHeaders">
               <h3>
                  http2FlagPushPromiseEndHeaders 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagPushPromiseEndHeaders" class="anchor" title="Link to http2FlagPushPromiseEndHeaders">#</a>
               </h3>
               
               <p>Frame-specific FrameHeader flag bits.</p>
               
               <pre><code>const http2FlagPushPromiseEndHeaders http2Flags = 0x4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagPushPromisePadded" data-name="http2FlagPushPromisePadded">
               <h3>
                  http2FlagPushPromisePadded 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagPushPromisePadded" class="anchor" title="Link to http2FlagPushPromisePadded">#</a>
               </h3>
               
               <p>Frame-specific FrameHeader flag bits.</p>
               
               <pre><code>const http2FlagPushPromisePadded http2Flags = 0x8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FlagSettingsAck" data-name="http2FlagSettingsAck">
               <h3>
                  http2FlagSettingsAck 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FlagSettingsAck" class="anchor" title="Link to http2FlagSettingsAck">#</a>
               </h3>
               
               <p>Settings Frame</p>
               
               <pre><code>const http2FlagSettingsAck http2Flags = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameContinuation" data-name="http2FrameContinuation">
               <h3>
                  http2FrameContinuation 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameContinuation" class="anchor" title="Link to http2FrameContinuation">#</a>
               </h3>
               
               <pre><code>const http2FrameContinuation http2FrameType = 0x9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameData" data-name="http2FrameData">
               <h3>
                  http2FrameData 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameData" class="anchor" title="Link to http2FrameData">#</a>
               </h3>
               
               <pre><code>const http2FrameData http2FrameType = 0x0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameGoAway" data-name="http2FrameGoAway">
               <h3>
                  http2FrameGoAway 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameGoAway" class="anchor" title="Link to http2FrameGoAway">#</a>
               </h3>
               
               <pre><code>const http2FrameGoAway http2FrameType = 0x7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameHeaders" data-name="http2FrameHeaders">
               <h3>
                  http2FrameHeaders 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameHeaders" class="anchor" title="Link to http2FrameHeaders">#</a>
               </h3>
               
               <pre><code>const http2FrameHeaders http2FrameType = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FramePing" data-name="http2FramePing">
               <h3>
                  http2FramePing 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FramePing" class="anchor" title="Link to http2FramePing">#</a>
               </h3>
               
               <pre><code>const http2FramePing http2FrameType = 0x6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FramePriority" data-name="http2FramePriority">
               <h3>
                  http2FramePriority 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FramePriority" class="anchor" title="Link to http2FramePriority">#</a>
               </h3>
               
               <pre><code>const http2FramePriority http2FrameType = 0x2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FramePushPromise" data-name="http2FramePushPromise">
               <h3>
                  http2FramePushPromise 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FramePushPromise" class="anchor" title="Link to http2FramePushPromise">#</a>
               </h3>
               
               <pre><code>const http2FramePushPromise http2FrameType = 0x5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameRSTStream" data-name="http2FrameRSTStream">
               <h3>
                  http2FrameRSTStream 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameRSTStream" class="anchor" title="Link to http2FrameRSTStream">#</a>
               </h3>
               
               <pre><code>const http2FrameRSTStream http2FrameType = 0x3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameSettings" data-name="http2FrameSettings">
               <h3>
                  http2FrameSettings 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameSettings" class="anchor" title="Link to http2FrameSettings">#</a>
               </h3>
               
               <pre><code>const http2FrameSettings http2FrameType = 0x4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2FrameWindowUpdate" data-name="http2FrameWindowUpdate">
               <h3>
                  http2FrameWindowUpdate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2FrameWindowUpdate" class="anchor" title="Link to http2FrameWindowUpdate">#</a>
               </h3>
               
               <pre><code>const http2FrameWindowUpdate http2FrameType = 0x8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2NextProtoTLS" data-name="http2NextProtoTLS">
               <h3>
                  http2NextProtoTLS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2NextProtoTLS" class="anchor" title="Link to http2NextProtoTLS">#</a>
               </h3>
               
               <p>NextProtoTLS is the NPN/ALPN protocol negotiated during
HTTP/2's TLS setup.</p>
               
               <pre><code>const http2NextProtoTLS = "h2"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2NextProtoTLS" data-name="http2NextProtoTLS">
               <h3>
                  http2NextProtoTLS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2NextProtoTLS" class="anchor" title="Link to http2NextProtoTLS">#</a>
               </h3>
               
               <pre><code>const http2NextProtoTLS = "h2"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingEnableConnectProtocol" data-name="http2SettingEnableConnectProtocol">
               <h3>
                  http2SettingEnableConnectProtocol 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingEnableConnectProtocol" class="anchor" title="Link to http2SettingEnableConnectProtocol">#</a>
               </h3>
               
               <pre><code>const http2SettingEnableConnectProtocol http2SettingID = 0x8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingEnablePush" data-name="http2SettingEnablePush">
               <h3>
                  http2SettingEnablePush 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingEnablePush" class="anchor" title="Link to http2SettingEnablePush">#</a>
               </h3>
               
               <pre><code>const http2SettingEnablePush http2SettingID = 0x2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingHeaderTableSize" data-name="http2SettingHeaderTableSize">
               <h3>
                  http2SettingHeaderTableSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingHeaderTableSize" class="anchor" title="Link to http2SettingHeaderTableSize">#</a>
               </h3>
               
               <pre><code>const http2SettingHeaderTableSize http2SettingID = 0x1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingInitialWindowSize" data-name="http2SettingInitialWindowSize">
               <h3>
                  http2SettingInitialWindowSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingInitialWindowSize" class="anchor" title="Link to http2SettingInitialWindowSize">#</a>
               </h3>
               
               <pre><code>const http2SettingInitialWindowSize http2SettingID = 0x4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingMaxConcurrentStreams" data-name="http2SettingMaxConcurrentStreams">
               <h3>
                  http2SettingMaxConcurrentStreams 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingMaxConcurrentStreams" class="anchor" title="Link to http2SettingMaxConcurrentStreams">#</a>
               </h3>
               
               <pre><code>const http2SettingMaxConcurrentStreams http2SettingID = 0x3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingMaxFrameSize" data-name="http2SettingMaxFrameSize">
               <h3>
                  http2SettingMaxFrameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingMaxFrameSize" class="anchor" title="Link to http2SettingMaxFrameSize">#</a>
               </h3>
               
               <pre><code>const http2SettingMaxFrameSize http2SettingID = 0x5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2SettingMaxHeaderListSize" data-name="http2SettingMaxHeaderListSize">
               <h3>
                  http2SettingMaxHeaderListSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2SettingMaxHeaderListSize" class="anchor" title="Link to http2SettingMaxHeaderListSize">#</a>
               </h3>
               
               <pre><code>const http2SettingMaxHeaderListSize http2SettingID = 0x6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2TrailerPrefix" data-name="http2TrailerPrefix">
               <h3>
                  http2TrailerPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2TrailerPrefix" class="anchor" title="Link to http2TrailerPrefix">#</a>
               </h3>
               
               <p>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
that, if present, signals that the map entry is actually for
the response trailers, and not the response headers. The prefix
is stripped after the ServeHTTP call finishes and the values are
sent in the trailers.
This mechanism is intended only for trailers that are not known
prior to the headers being written. If the set of trailers is fixed
or known before the header is written, the normal Go trailers mechanism
is preferred:
https://golang.org/pkg/net/http/#ResponseWriter
https://golang.org/pkg/net/http/#example_ResponseWriter_trailers</p>
               
               <pre><code>const http2TrailerPrefix = "Trailer:"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2VerboseLogs" data-name="http2VerboseLogs">
               <h3>
                  http2VerboseLogs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2VerboseLogs" class="anchor" title="Link to http2VerboseLogs">#</a>
               </h3>
               
               <pre><code>var http2VerboseLogs bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2bufPools" data-name="http2bufPools">
               <h3>
                  http2bufPools 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2bufPools" class="anchor" title="Link to http2bufPools">#</a>
               </h3>
               
               <p>Seven bufPools manage different frame sizes. This helps to avoid scenarios where long-running
streaming requests using small frame sizes occupy large buffers initially allocated for prior
requests needing big buffers. The size ranges are as follows:
{0 KB, 16 KB], {16 KB, 32 KB], {32 KB, 64 KB], {64 KB, 128 KB], {128 KB, 256 KB],
{256 KB, 512 KB], {512 KB, infinity}
In practice, the maximum scratch buffer size should not exceed 512 KB due to
frameScratchBufferLen(maxFrameSize), thus the "infinity pool" should never be used.
It exists mainly as a safety measure, for potential future increases in max buffer size.</p>
               
               <pre><code>var http2bufPools [7]sync.Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2bufWriterPool" data-name="http2bufWriterPool">
               <h3>
                  http2bufWriterPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2bufWriterPool" class="anchor" title="Link to http2bufWriterPool">#</a>
               </h3>
               
               <pre><code>var http2bufWriterPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2bufWriterPoolBufferSize" data-name="http2bufWriterPoolBufferSize">
               <h3>
                  http2bufWriterPoolBufferSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2bufWriterPoolBufferSize" class="anchor" title="Link to http2bufWriterPoolBufferSize">#</a>
               </h3>
               
               <p>bufWriterPoolBufferSize is the size of bufio.Writer's
buffers created using bufWriterPool.
TODO: pick a less arbitrary value? this is a bit under
(3 x typical 1500 byte MTU) at least. Other than that,
not much thought went into it.</p>
               
               <pre><code>const http2bufWriterPoolBufferSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0011</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA uint16 = 0x0013</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA uint16 = 0x0032</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 uint16 = 0x0040</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 uint16 = 0x00A2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA uint16 = 0x0038</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 uint16 = 0x006A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 uint16 = 0x00A3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC042</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC056</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC043</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC057</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0044</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BD</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC080</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0087</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256" data-name="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC081</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA uint16 = 0x0012</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA" data-name="http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA uint16 = 0x0099</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0x008F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA uint16 = 0x0090</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0x00B2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM uint16 = 0xC0A6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 uint16 = 0x00AA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA uint16 = 0x0091</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0x00B3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM uint16 = 0xC0A7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 uint16 = 0x00AB</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC066</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC06C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC067</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC06D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC090</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC097</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC091</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAD</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_NULL_SHA" data-name="http2cipher_TLS_DHE_PSK_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_NULL_SHA uint16 = 0x002D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256" data-name="http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 uint16 = 0x00B4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384" data-name="http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 uint16 = 0x00B5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA" data-name="http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA uint16 = 0x008E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0014</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x0016</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0x0033</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <p>Reserved uint16 =  0x0047-4F
Reserved uint16 =  0x0050-58
Reserved uint16 =  0x0059-5C
Unassigned uint16 =  0x005D-5F
Reserved uint16 =  0x0060-66</p>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x0067</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM uint16 = 0xC09E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8 uint16 = 0xC0A2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x009E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0039</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x006B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM uint16 = 0xC09F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8 uint16 = 0xC0A3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x009F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC044</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC052</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC045</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC053</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0045</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BE</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC07C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0088</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC07D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA uint16 = 0x0015</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA" data-name="http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA">
               <h3>
                  http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA uint16 = 0x009A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x000B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA uint16 = 0x000D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA uint16 = 0x0030</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 uint16 = 0x003E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 uint16 = 0x00A4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA uint16 = 0x0036</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 uint16 = 0x0068</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 uint16 = 0x00A5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC03E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC058</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC03F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC059</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0042</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BB</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC082</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0085</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256" data-name="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC083</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA uint16 = 0x000C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA" data-name="http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA uint16 = 0x0097</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x000E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x0010</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA uint16 = 0x0031</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x003F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x00A0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0037</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x0069</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x00A1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC040</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC054</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC041</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC055</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0043</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC07E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0086</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256" data-name="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC07F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA uint16 = 0x000F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA" data-name="http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA uint16 = 0x0098</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA" data-name="http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0019</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5" data-name="http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5">
               <h3>
                  http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5" class="anchor" title="Link to http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 uint16 = 0x0017</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA uint16 = 0x001B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA uint16 = 0x0034</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 uint16 = 0x006C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 uint16 = 0x00A6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA uint16 = 0x003A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 uint16 = 0x006D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 uint16 = 0x00A7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC046</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC05A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC047</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC05B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0046</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC084</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0089</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256" data-name="http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC085</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA uint16 = 0x001A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_RC4_128_MD5" data-name="http2cipher_TLS_DH_anon_WITH_RC4_128_MD5">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_RC4_128_MD5" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_RC4_128_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 uint16 = 0x0018</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA" data-name="http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA">
               <h3>
                  http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA uint16 = 0x009B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC008</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA uint16 = 0xC009</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC023</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM uint16 = 0xC0AC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 uint16 = 0xC0AE</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC02B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA uint16 = 0xC00A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC024</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM uint16 = 0xC0AD</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 uint16 = 0xC0AF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC02C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC048</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC05C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC049</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC05D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC072</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC086</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC073</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC087</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCA9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA uint16 = 0xC006</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA" data-name="http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA uint16 = 0xC007</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0xC034</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA uint16 = 0xC035</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0xC037</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA uint16 = 0xC036</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0xC038</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC070</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC071</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC09A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC09B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA" data-name="http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA uint16 = 0xC039</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256" data-name="http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 uint16 = 0xC03A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384" data-name="http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 uint16 = 0xC03B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA" data-name="http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA uint16 = 0xC033</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC012</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0xC013</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC027</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC02F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA uint16 = 0xC014</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC028</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC030</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC04C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC060</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC04D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC061</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC076</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC08A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC077</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC08B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <p>Unassigned uint16 =  0xC0B0-FF
Unassigned uint16 =  0xC1-CB,*
Unassigned uint16 =  0xCC00-A7</p>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCA8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA" data-name="http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA uint16 = 0xC010</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA" data-name="http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA uint16 = 0xC011</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC003</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA uint16 = 0xC004</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC025</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC02D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA uint16 = 0xC005</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC026</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC02E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC04A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC05E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC04B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC05F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC074</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC088</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC075</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC089</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA">#</a>
               </h3>
               
               <p>Unassigned                                   uint16 = 0x5601 - 0xC000</p>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA uint16 = 0xC001</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA" data-name="http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA uint16 = 0xC002</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC00D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA uint16 = 0xC00E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC029</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC031</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA uint16 = 0xC00F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC02A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC032</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC04E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC062</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC04F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC063</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC078</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC08C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC079</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC08D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA" data-name="http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA uint16 = 0xC00B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA" data-name="http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA uint16 = 0xC00C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA uint16 = 0xC017</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA uint16 = 0xC018</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA uint16 = 0xC019</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_anon_WITH_NULL_SHA" data-name="http2cipher_TLS_ECDH_anon_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_ECDH_anon_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_anon_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_anon_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_anon_WITH_NULL_SHA uint16 = 0xC015</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA" data-name="http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA uint16 = 0xC016</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV" data-name="http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV">
               <h3>
                  http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV" class="anchor" title="Link to http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV">#</a>
               </h3>
               
               <p>Unassigned uint16 =  0x00C6-FE</p>
               
               <pre><code>const http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV uint16 = 0x00FF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_FALLBACK_SCSV" data-name="http2cipher_TLS_FALLBACK_SCSV">
               <h3>
                  http2cipher_TLS_FALLBACK_SCSV 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_FALLBACK_SCSV" class="anchor" title="Link to http2cipher_TLS_FALLBACK_SCSV">#</a>
               </h3>
               
               <p>Unassigned uint16 =  0x01-55,*</p>
               
               <pre><code>const http2cipher_TLS_FALLBACK_SCSV uint16 = 0x5600</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5" data-name="http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5">
               <h3>
                  http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 uint16 = 0x0029</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA" data-name="http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA">
               <h3>
                  http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA uint16 = 0x0026</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5" data-name="http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5">
               <h3>
                  http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 uint16 = 0x002A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA" data-name="http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA">
               <h3>
                  http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA uint16 = 0x0027</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5" data-name="http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5">
               <h3>
                  http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 uint16 = 0x002B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA" data-name="http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA">
               <h3>
                  http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA uint16 = 0x0028</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5" data-name="http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5">
               <h3>
                  http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 uint16 = 0x0023</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA uint16 = 0x001F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_DES_CBC_MD5" data-name="http2cipher_TLS_KRB5_WITH_DES_CBC_MD5">
               <h3>
                  http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_DES_CBC_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_DES_CBC_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 uint16 = 0x0022</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_KRB5_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_KRB5_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <p>Reserved uint16 =  0x001C-1D</p>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_DES_CBC_SHA uint16 = 0x001E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5" data-name="http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5">
               <h3>
                  http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 uint16 = 0x0025</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA" data-name="http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA">
               <h3>
                  http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA uint16 = 0x0021</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_RC4_128_MD5" data-name="http2cipher_TLS_KRB5_WITH_RC4_128_MD5">
               <h3>
                  http2cipher_TLS_KRB5_WITH_RC4_128_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_RC4_128_MD5" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_RC4_128_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_RC4_128_MD5 uint16 = 0x0024</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_KRB5_WITH_RC4_128_SHA" data-name="http2cipher_TLS_KRB5_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_KRB5_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_KRB5_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_KRB5_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_KRB5_WITH_RC4_128_SHA uint16 = 0x0020</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_NULL_WITH_NULL_NULL" data-name="http2cipher_TLS_NULL_WITH_NULL_NULL">
               <h3>
                  http2cipher_TLS_NULL_WITH_NULL_NULL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_NULL_WITH_NULL_NULL" class="anchor" title="Link to http2cipher_TLS_NULL_WITH_NULL_NULL">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_NULL_WITH_NULL_NULL uint16 = 0x0000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8" data-name="http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8">
               <h3>
                  http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8" class="anchor" title="Link to http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8 uint16 = 0xC0AA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8" data-name="http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8">
               <h3>
                  http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8" class="anchor" title="Link to http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8 uint16 = 0xC0AB</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0x008B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA uint16 = 0x008C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0x00AE</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_128_CCM" data-name="http2cipher_TLS_PSK_WITH_AES_128_CCM">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_128_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_128_CCM" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_128_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_128_CCM uint16 = 0xC0A4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_128_CCM_8" data-name="http2cipher_TLS_PSK_WITH_AES_128_CCM_8">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_128_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_128_CCM_8" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_128_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_128_CCM_8 uint16 = 0xC0A8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 uint16 = 0x00A8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA uint16 = 0x008D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0x00AF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_256_CCM" data-name="http2cipher_TLS_PSK_WITH_AES_256_CCM">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_256_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_256_CCM" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_256_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_256_CCM uint16 = 0xC0A5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_256_CCM_8" data-name="http2cipher_TLS_PSK_WITH_AES_256_CCM_8">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_256_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_256_CCM_8" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_256_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_256_CCM_8 uint16 = 0xC0A9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 uint16 = 0x00A9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC064</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC06A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC065</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC06B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC094</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC08E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC095</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC08F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAB</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_NULL_SHA" data-name="http2cipher_TLS_PSK_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_PSK_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_NULL_SHA uint16 = 0x002C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_NULL_SHA256" data-name="http2cipher_TLS_PSK_WITH_NULL_SHA256">
               <h3>
                  http2cipher_TLS_PSK_WITH_NULL_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_NULL_SHA256" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_NULL_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_NULL_SHA256 uint16 = 0x00B0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_NULL_SHA384" data-name="http2cipher_TLS_PSK_WITH_NULL_SHA384">
               <h3>
                  http2cipher_TLS_PSK_WITH_NULL_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_NULL_SHA384" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_NULL_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_NULL_SHA384 uint16 = 0x00B1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_PSK_WITH_RC4_128_SHA" data-name="http2cipher_TLS_PSK_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_PSK_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_PSK_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_PSK_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_PSK_WITH_RC4_128_SHA uint16 = 0x008A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA" data-name="http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0008</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5" data-name="http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5">
               <h3>
                  http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5" class="anchor" title="Link to http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 uint16 = 0x0006</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5" data-name="http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5">
               <h3>
                  http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5" class="anchor" title="Link to http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 uint16 = 0x0003</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0x0093</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA uint16 = 0x0094</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0x00B6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 uint16 = 0x00AC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA uint16 = 0x0095</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0x00B7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 uint16 = 0x00AD</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC068</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC06E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC069</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC06F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC098</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC092</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC099</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC093</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAE</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_NULL_SHA" data-name="http2cipher_TLS_RSA_PSK_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_NULL_SHA uint16 = 0x002E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256" data-name="http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 uint16 = 0x00B8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384" data-name="http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 uint16 = 0x00B9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA" data-name="http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA uint16 = 0x0092</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x000A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA uint16 = 0x002F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256" data-name="http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x003C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_128_CCM" data-name="http2cipher_TLS_RSA_WITH_AES_128_CCM">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_128_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_128_CCM" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_128_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_128_CCM uint16 = 0xC09C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_128_CCM_8" data-name="http2cipher_TLS_RSA_WITH_AES_128_CCM_8">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_128_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_128_CCM_8" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_128_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_128_CCM_8 uint16 = 0xC0A0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256" data-name="http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x009C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0035</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256" data-name="http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x003D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_256_CCM" data-name="http2cipher_TLS_RSA_WITH_AES_256_CCM">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_256_CCM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_256_CCM" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_256_CCM">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_256_CCM uint16 = 0xC09D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_256_CCM_8" data-name="http2cipher_TLS_RSA_WITH_AES_256_CCM_8">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_256_CCM_8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_256_CCM_8" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_256_CCM_8">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_256_CCM_8 uint16 = 0xC0A1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384" data-name="http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x009D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256" data-name="http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC03C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256" data-name="http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC050</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384" data-name="http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384">
               <h3>
                  http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC03D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384" data-name="http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC051</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0041</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256" data-name="http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256" data-name="http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC07A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA">#</a>
               </h3>
               
               <p>Unassigned uint16 =  0x006E-83</p>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0084</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256" data-name="http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384" data-name="http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384">
               <h3>
                  http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC07B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_DES_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_DES_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_DES_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_DES_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_DES_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_DES_CBC_SHA uint16 = 0x0009</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA uint16 = 0x0007</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_NULL_MD5" data-name="http2cipher_TLS_RSA_WITH_NULL_MD5">
               <h3>
                  http2cipher_TLS_RSA_WITH_NULL_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_NULL_MD5" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_NULL_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_NULL_MD5 uint16 = 0x0001</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_NULL_SHA" data-name="http2cipher_TLS_RSA_WITH_NULL_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_NULL_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_NULL_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_NULL_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_NULL_SHA uint16 = 0x0002</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_NULL_SHA256" data-name="http2cipher_TLS_RSA_WITH_NULL_SHA256">
               <h3>
                  http2cipher_TLS_RSA_WITH_NULL_SHA256 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_NULL_SHA256" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_NULL_SHA256">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_NULL_SHA256 uint16 = 0x003B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_RC4_128_MD5" data-name="http2cipher_TLS_RSA_WITH_RC4_128_MD5">
               <h3>
                  http2cipher_TLS_RSA_WITH_RC4_128_MD5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_RC4_128_MD5" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_RC4_128_MD5">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_RC4_128_MD5 uint16 = 0x0004</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_RC4_128_SHA" data-name="http2cipher_TLS_RSA_WITH_RC4_128_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_RC4_128_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_RC4_128_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_RC4_128_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_RC4_128_SHA uint16 = 0x0005</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_RSA_WITH_SEED_CBC_SHA" data-name="http2cipher_TLS_RSA_WITH_SEED_CBC_SHA">
               <h3>
                  http2cipher_TLS_RSA_WITH_SEED_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_RSA_WITH_SEED_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_RSA_WITH_SEED_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_RSA_WITH_SEED_CBC_SHA uint16 = 0x0096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA uint16 = 0xC01C</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA uint16 = 0xC01F</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA uint16 = 0xC022</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC01B</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA uint16 = 0xC01E</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA uint16 = 0xC021</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC01A</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA uint16 = 0xC01D</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA" data-name="http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA">
               <h3>
                  http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA" class="anchor" title="Link to http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA">#</a>
               </h3>
               
               <pre><code>const http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA uint16 = 0xC020</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2client" data-name="http2client">
               <h3>
                  http2client 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2client" class="anchor" title="Link to http2client">#</a>
               </h3>
               
               <pre><code>var http2client = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2clientPreface" data-name="http2clientPreface">
               <h3>
                  http2clientPreface 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2clientPreface" class="anchor" title="Link to http2clientPreface">#</a>
               </h3>
               
               <pre><code>var http2clientPreface = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2commonBuildOnce" data-name="http2commonBuildOnce">
               <h3>
                  http2commonBuildOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2commonBuildOnce" class="anchor" title="Link to http2commonBuildOnce">#</a>
               </h3>
               
               <pre><code>var http2commonBuildOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2commonCanonHeader" data-name="http2commonCanonHeader">
               <h3>
                  http2commonCanonHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2commonCanonHeader" class="anchor" title="Link to http2commonCanonHeader">#</a>
               </h3>
               
               <pre><code>var http2commonCanonHeader map[string]string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2commonLowerHeader" data-name="http2commonLowerHeader">
               <h3>
                  http2commonLowerHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2commonLowerHeader" class="anchor" title="Link to http2commonLowerHeader">#</a>
               </h3>
               
               <pre><code>var http2commonLowerHeader map[string]string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2connHeaders" data-name="http2connHeaders">
               <h3>
                  http2connHeaders 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2connHeaders" class="anchor" title="Link to http2connHeaders">#</a>
               </h3>
               
               <p>From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2</p>
               
               <pre><code>var http2connHeaders = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2dataChunkPools" data-name="http2dataChunkPools">
               <h3>
                  http2dataChunkPools 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2dataChunkPools" class="anchor" title="Link to http2dataChunkPools">#</a>
               </h3>
               
               <p>Buffer chunks are allocated from a pool to reduce pressure on GC.
The maximum wasted space per dataBuffer is 2x the largest size class,
which happens when the dataBuffer has multiple chunks and there is
one unread byte in both the first and last chunks. We use a few size
classes to minimize overheads for servers that typically receive very
small request bodies.
TODO: Benchmark to determine if the pools are necessary. The GC may have
improved enough that we can instead allocate chunks like this:
make([]byte, max(16<<10, expectedBytesRemaining))</p>
               
               <pre><code>var http2dataChunkPools = [...]sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2defaultMaxConcurrentStreams" data-name="http2defaultMaxConcurrentStreams">
               <h3>
                  http2defaultMaxConcurrentStreams 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2defaultMaxConcurrentStreams" class="anchor" title="Link to http2defaultMaxConcurrentStreams">#</a>
               </h3>
               
               <p>defaultMaxConcurrentStreams is a connections default maxConcurrentStreams
if the server doesn't include one in its initial SETTINGS frame.</p>
               
               <pre><code>const http2defaultMaxConcurrentStreams = 1000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2defaultMaxReadFrameSize" data-name="http2defaultMaxReadFrameSize">
               <h3>
                  http2defaultMaxReadFrameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2defaultMaxReadFrameSize" class="anchor" title="Link to http2defaultMaxReadFrameSize">#</a>
               </h3>
               
               <pre><code>const http2defaultMaxReadFrameSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2defaultMaxStreams" data-name="http2defaultMaxStreams">
               <h3>
                  http2defaultMaxStreams 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2defaultMaxStreams" class="anchor" title="Link to http2defaultMaxStreams">#</a>
               </h3>
               
               <pre><code>const http2defaultMaxStreams = 250</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2defaultUserAgent" data-name="http2defaultUserAgent">
               <h3>
                  http2defaultUserAgent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2defaultUserAgent" class="anchor" title="Link to http2defaultUserAgent">#</a>
               </h3>
               
               <pre><code>const http2defaultUserAgent = "Go-http-client/2.0"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2dialOnMiss" data-name="http2dialOnMiss">
               <h3>
                  http2dialOnMiss 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2dialOnMiss" class="anchor" title="Link to http2dialOnMiss">#</a>
               </h3>
               
               <pre><code>const http2dialOnMiss = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2disableExtendedConnectProtocol" data-name="http2disableExtendedConnectProtocol">
               <h3>
                  http2disableExtendedConnectProtocol 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2disableExtendedConnectProtocol" class="anchor" title="Link to http2disableExtendedConnectProtocol">#</a>
               </h3>
               
               <p>Enabling extended CONNECT by causes browsers to attempt to use
WebSockets-over-HTTP/2. This results in problems when the server's websocket
package doesn't support extended CONNECT.
Disable extended CONNECT by default for now.
Issue #71128.</p>
               
               <pre><code>var http2disableExtendedConnectProtocol = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errChanPool" data-name="http2errChanPool">
               <h3>
                  http2errChanPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errChanPool" class="anchor" title="Link to http2errChanPool">#</a>
               </h3>
               
               <pre><code>var http2errChanPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClientConnClosed" data-name="http2errClientConnClosed">
               <h3>
                  http2errClientConnClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClientConnClosed" class="anchor" title="Link to http2errClientConnClosed">#</a>
               </h3>
               
               <pre><code>var http2errClientConnClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClientConnGotGoAway" data-name="http2errClientConnGotGoAway">
               <h3>
                  http2errClientConnGotGoAway 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClientConnGotGoAway" class="anchor" title="Link to http2errClientConnGotGoAway">#</a>
               </h3>
               
               <pre><code>var http2errClientConnGotGoAway = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClientConnNotEstablished" data-name="http2errClientConnNotEstablished">
               <h3>
                  http2errClientConnNotEstablished 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClientConnNotEstablished" class="anchor" title="Link to http2errClientConnNotEstablished">#</a>
               </h3>
               
               <pre><code>var http2errClientConnNotEstablished = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClientConnUnusable" data-name="http2errClientConnUnusable">
               <h3>
                  http2errClientConnUnusable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClientConnUnusable" class="anchor" title="Link to http2errClientConnUnusable">#</a>
               </h3>
               
               <pre><code>var http2errClientConnUnusable = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClientDisconnected" data-name="http2errClientDisconnected">
               <h3>
                  http2errClientDisconnected 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClientDisconnected" class="anchor" title="Link to http2errClientDisconnected">#</a>
               </h3>
               
               <pre><code>var http2errClientDisconnected = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClosedBody" data-name="http2errClosedBody">
               <h3>
                  http2errClosedBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClosedBody" class="anchor" title="Link to http2errClosedBody">#</a>
               </h3>
               
               <pre><code>var http2errClosedBody = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClosedPipeWrite" data-name="http2errClosedPipeWrite">
               <h3>
                  http2errClosedPipeWrite 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClosedPipeWrite" class="anchor" title="Link to http2errClosedPipeWrite">#</a>
               </h3>
               
               <pre><code>var http2errClosedPipeWrite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errClosedResponseBody" data-name="http2errClosedResponseBody">
               <h3>
                  http2errClosedResponseBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errClosedResponseBody" class="anchor" title="Link to http2errClosedResponseBody">#</a>
               </h3>
               
               <pre><code>var http2errClosedResponseBody = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errCodeName" data-name="http2errCodeName">
               <h3>
                  http2errCodeName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errCodeName" class="anchor" title="Link to http2errCodeName">#</a>
               </h3>
               
               <pre><code>var http2errCodeName = map[http2ErrCode]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errDepStreamID" data-name="http2errDepStreamID">
               <h3>
                  http2errDepStreamID 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errDepStreamID" class="anchor" title="Link to http2errDepStreamID">#</a>
               </h3>
               
               <pre><code>var http2errDepStreamID = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errExtendedConnectNotSupported" data-name="http2errExtendedConnectNotSupported">
               <h3>
                  http2errExtendedConnectNotSupported 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errExtendedConnectNotSupported" class="anchor" title="Link to http2errExtendedConnectNotSupported">#</a>
               </h3>
               
               <pre><code>var http2errExtendedConnectNotSupported = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errFromPeer" data-name="http2errFromPeer">
               <h3>
                  http2errFromPeer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errFromPeer" class="anchor" title="Link to http2errFromPeer">#</a>
               </h3>
               
               <p>errFromPeer is a sentinel error value for StreamError.Cause to
indicate that the StreamError was sent from the peer over the wire
and wasn't locally generated in the Transport.</p>
               
               <pre><code>var http2errFromPeer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errHandlerComplete" data-name="http2errHandlerComplete">
               <h3>
                  http2errHandlerComplete 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errHandlerComplete" class="anchor" title="Link to http2errHandlerComplete">#</a>
               </h3>
               
               <pre><code>var http2errHandlerComplete = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errHandlerPanicked" data-name="http2errHandlerPanicked">
               <h3>
                  http2errHandlerPanicked 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errHandlerPanicked" class="anchor" title="Link to http2errHandlerPanicked">#</a>
               </h3>
               
               <p>errHandlerPanicked is the error given to any callers blocked in a read from
Request.Body when the main goroutine panics. Since most handlers read in the
main ServeHTTP goroutine, this will show up rarely.</p>
               
               <pre><code>var http2errHandlerPanicked = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errMixPseudoHeaderTypes" data-name="http2errMixPseudoHeaderTypes">
               <h3>
                  http2errMixPseudoHeaderTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errMixPseudoHeaderTypes" class="anchor" title="Link to http2errMixPseudoHeaderTypes">#</a>
               </h3>
               
               <pre><code>var http2errMixPseudoHeaderTypes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errNilRequestURL" data-name="http2errNilRequestURL">
               <h3>
                  http2errNilRequestURL 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errNilRequestURL" class="anchor" title="Link to http2errNilRequestURL">#</a>
               </h3>
               
               <pre><code>var http2errNilRequestURL = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errPadBytes" data-name="http2errPadBytes">
               <h3>
                  http2errPadBytes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errPadBytes" class="anchor" title="Link to http2errPadBytes">#</a>
               </h3>
               
               <pre><code>var http2errPadBytes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errPadLength" data-name="http2errPadLength">
               <h3>
                  http2errPadLength 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errPadLength" class="anchor" title="Link to http2errPadLength">#</a>
               </h3>
               
               <pre><code>var http2errPadLength = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errPrefaceTimeout" data-name="http2errPrefaceTimeout">
               <h3>
                  http2errPrefaceTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errPrefaceTimeout" class="anchor" title="Link to http2errPrefaceTimeout">#</a>
               </h3>
               
               <pre><code>var http2errPrefaceTimeout = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errPseudoAfterRegular" data-name="http2errPseudoAfterRegular">
               <h3>
                  http2errPseudoAfterRegular 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errPseudoAfterRegular" class="anchor" title="Link to http2errPseudoAfterRegular">#</a>
               </h3>
               
               <pre><code>var http2errPseudoAfterRegular = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errReadEmpty" data-name="http2errReadEmpty">
               <h3>
                  http2errReadEmpty 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errReadEmpty" class="anchor" title="Link to http2errReadEmpty">#</a>
               </h3>
               
               <pre><code>var http2errReadEmpty = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errReqBodyTooLong" data-name="http2errReqBodyTooLong">
               <h3>
                  http2errReqBodyTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errReqBodyTooLong" class="anchor" title="Link to http2errReqBodyTooLong">#</a>
               </h3>
               
               <p>internal error values; they don't escape to callers</p>
               
               <pre><code>var http2errReqBodyTooLong = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errRequestCanceled" data-name="http2errRequestCanceled">
               <h3>
                  http2errRequestCanceled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errRequestCanceled" class="anchor" title="Link to http2errRequestCanceled">#</a>
               </h3>
               
               <pre><code>var http2errRequestCanceled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errRequestCanceled" data-name="http2errRequestCanceled">
               <h3>
                  http2errRequestCanceled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errRequestCanceled" class="anchor" title="Link to http2errRequestCanceled">#</a>
               </h3>
               
               <p>errRequestCanceled is a copy of net/http's errRequestCanceled because it's not
exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests.</p>
               
               <pre><code>var http2errRequestCanceled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errRequestHeaderListSize" data-name="http2errRequestHeaderListSize">
               <h3>
                  http2errRequestHeaderListSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errRequestHeaderListSize" class="anchor" title="Link to http2errRequestHeaderListSize">#</a>
               </h3>
               
               <pre><code>var http2errRequestHeaderListSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errResponseHeaderListSize" data-name="http2errResponseHeaderListSize">
               <h3>
                  http2errResponseHeaderListSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errResponseHeaderListSize" class="anchor" title="Link to http2errResponseHeaderListSize">#</a>
               </h3>
               
               <pre><code>var http2errResponseHeaderListSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errStopReqBodyWrite" data-name="http2errStopReqBodyWrite">
               <h3>
                  http2errStopReqBodyWrite 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errStopReqBodyWrite" class="anchor" title="Link to http2errStopReqBodyWrite">#</a>
               </h3>
               
               <p>abort request body write; don't send cancel</p>
               
               <pre><code>var http2errStopReqBodyWrite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errStopReqBodyWriteAndCancel" data-name="http2errStopReqBodyWriteAndCancel">
               <h3>
                  http2errStopReqBodyWriteAndCancel 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errStopReqBodyWriteAndCancel" class="anchor" title="Link to http2errStopReqBodyWriteAndCancel">#</a>
               </h3>
               
               <p>abort request body write, but send stream reset of cancel.</p>
               
               <pre><code>var http2errStopReqBodyWriteAndCancel = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errStreamClosed" data-name="http2errStreamClosed">
               <h3>
                  http2errStreamClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errStreamClosed" class="anchor" title="Link to http2errStreamClosed">#</a>
               </h3>
               
               <pre><code>var http2errStreamClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errStreamID" data-name="http2errStreamID">
               <h3>
                  http2errStreamID 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errStreamID" class="anchor" title="Link to http2errStreamID">#</a>
               </h3>
               
               <pre><code>var http2errStreamID = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errTimeout" data-name="http2errTimeout">
               <h3>
                  http2errTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errTimeout" class="anchor" title="Link to http2errTimeout">#</a>
               </h3>
               
               <pre><code>var http2errTimeout error = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2errUninitializedPipeWrite" data-name="http2errUninitializedPipeWrite">
               <h3>
                  http2errUninitializedPipeWrite 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2errUninitializedPipeWrite" class="anchor" title="Link to http2errUninitializedPipeWrite">#</a>
               </h3>
               
               <pre><code>var http2errUninitializedPipeWrite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2fhBytes" data-name="http2fhBytes">
               <h3>
                  http2fhBytes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2fhBytes" class="anchor" title="Link to http2fhBytes">#</a>
               </h3>
               
               <p>frame header bytes.
Used only by ReadFrameHeader.</p>
               
               <pre><code>var http2fhBytes = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2firstSettingsTimeout" data-name="http2firstSettingsTimeout">
               <h3>
                  http2firstSettingsTimeout 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2firstSettingsTimeout" class="anchor" title="Link to http2firstSettingsTimeout">#</a>
               </h3>
               
               <pre><code>const http2firstSettingsTimeout = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2flagName" data-name="http2flagName">
               <h3>
                  http2flagName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2flagName" class="anchor" title="Link to http2flagName">#</a>
               </h3>
               
               <pre><code>var http2flagName = map[http2FrameType]map[http2Flags]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2frameHeaderLen" data-name="http2frameHeaderLen">
               <h3>
                  http2frameHeaderLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2frameHeaderLen" class="anchor" title="Link to http2frameHeaderLen">#</a>
               </h3>
               
               <pre><code>const http2frameHeaderLen = 9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2frameName" data-name="http2frameName">
               <h3>
                  http2frameName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2frameName" class="anchor" title="Link to http2frameName">#</a>
               </h3>
               
               <pre><code>var http2frameName = map[http2FrameType]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2frameParsers" data-name="http2frameParsers">
               <h3>
                  http2frameParsers 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2frameParsers" class="anchor" title="Link to http2frameParsers">#</a>
               </h3>
               
               <pre><code>var http2frameParsers = map[http2FrameType]http2frameParser{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2goAwayTimeout" data-name="http2goAwayTimeout">
               <h3>
                  http2goAwayTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2goAwayTimeout" class="anchor" title="Link to http2goAwayTimeout">#</a>
               </h3>
               
               <pre><code>var http2goAwayTimeout = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2goAwayTimeout" data-name="http2goAwayTimeout">
               <h3>
                  http2goAwayTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2goAwayTimeout" class="anchor" title="Link to http2goAwayTimeout">#</a>
               </h3>
               
               <p>After sending GOAWAY with an error code (non-graceful shutdown), the
connection will close after goAwayTimeout.
If we close the connection immediately after sending GOAWAY, there may
be unsent data in our kernel receive buffer, which will cause the kernel
to send a TCP RST on close() instead of a FIN. This RST will abort the
connection immediately, whether or not the client had received the GOAWAY.
Ideally we should delay for at least 1 RTT + epsilon so the client has
a chance to read the GOAWAY and stop sending messages. Measuring RTT
is hard, so we approximate with 1 second. See golang.org/issue/18701.
This is a var so it can be shorter in tests, where all requests uses the
loopback interface making the expected RTT very small.
TODO: configurable?</p>
               
               <pre><code>var http2goAwayTimeout = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2goroutineSpace" data-name="http2goroutineSpace">
               <h3>
                  http2goroutineSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2goroutineSpace" class="anchor" title="Link to http2goroutineSpace">#</a>
               </h3>
               
               <pre><code>var http2goroutineSpace = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2got1xxFuncForTests" data-name="http2got1xxFuncForTests">
               <h3>
                  http2got1xxFuncForTests 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2got1xxFuncForTests" class="anchor" title="Link to http2got1xxFuncForTests">#</a>
               </h3>
               
               <pre><code>var http2got1xxFuncForTests func(int, textproto.MIMEHeader) error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2gracefulShutdownMsg" data-name="http2gracefulShutdownMsg">
               <h3>
                  http2gracefulShutdownMsg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2gracefulShutdownMsg" class="anchor" title="Link to http2gracefulShutdownMsg">#</a>
               </h3>
               
               <p>Message values sent to serveMsgCh.</p>
               
               <pre><code>var http2gracefulShutdownMsg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2handlerChunkWriteSize" data-name="http2handlerChunkWriteSize">
               <h3>
                  http2handlerChunkWriteSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2handlerChunkWriteSize" class="anchor" title="Link to http2handlerChunkWriteSize">#</a>
               </h3>
               
               <pre><code>const http2handlerChunkWriteSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2handlerDoneMsg" data-name="http2handlerDoneMsg">
               <h3>
                  http2handlerDoneMsg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2handlerDoneMsg" class="anchor" title="Link to http2handlerDoneMsg">#</a>
               </h3>
               
               <p>Message values sent to serveMsgCh.</p>
               
               <pre><code>var http2handlerDoneMsg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2headerOrDataFrame" data-name="http2headerOrDataFrame">
               <h3>
                  http2headerOrDataFrame 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2headerOrDataFrame" class="anchor" title="Link to http2headerOrDataFrame">#</a>
               </h3>
               
               <p>Constants passed to streamByID for documentation purposes.</p>
               
               <pre><code>const http2headerOrDataFrame = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2idleTimerMsg" data-name="http2idleTimerMsg">
               <h3>
                  http2idleTimerMsg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2idleTimerMsg" class="anchor" title="Link to http2idleTimerMsg">#</a>
               </h3>
               
               <p>Message values sent to serveMsgCh.</p>
               
               <pre><code>var http2idleTimerMsg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2inTests" data-name="http2inTests">
               <h3>
                  http2inTests 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2inTests" class="anchor" title="Link to http2inTests">#</a>
               </h3>
               
               <pre><code>var http2inTests bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2inflowMinRefresh" data-name="http2inflowMinRefresh">
               <h3>
                  http2inflowMinRefresh 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2inflowMinRefresh" class="anchor" title="Link to http2inflowMinRefresh">#</a>
               </h3>
               
               <p>inflowMinRefresh is the minimum number of bytes we'll send for a
flow control window update.</p>
               
               <pre><code>const http2inflowMinRefresh = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2initialHeaderTableSize" data-name="http2initialHeaderTableSize">
               <h3>
                  http2initialHeaderTableSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2initialHeaderTableSize" class="anchor" title="Link to http2initialHeaderTableSize">#</a>
               </h3>
               
               <p>https://httpwg.org/specs/rfc7540.html#SettingValues</p>
               
               <pre><code>const http2initialHeaderTableSize = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2initialMaxConcurrentStreams" data-name="http2initialMaxConcurrentStreams">
               <h3>
                  http2initialMaxConcurrentStreams 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2initialMaxConcurrentStreams" class="anchor" title="Link to http2initialMaxConcurrentStreams">#</a>
               </h3>
               
               <p>initialMaxConcurrentStreams is a connections maxConcurrentStreams until
it's received servers initial SETTINGS frame, which corresponds with the
spec's minimum recommended value.</p>
               
               <pre><code>const http2initialMaxConcurrentStreams = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2initialMaxFrameSize" data-name="http2initialMaxFrameSize">
               <h3>
                  http2initialMaxFrameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2initialMaxFrameSize" class="anchor" title="Link to http2initialMaxFrameSize">#</a>
               </h3>
               
               <p>SETTINGS_MAX_FRAME_SIZE default
https://httpwg.org/specs/rfc7540.html#rfc.section.6.5.2</p>
               
               <pre><code>const http2initialMaxFrameSize = 16384</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2initialWindowSize" data-name="http2initialWindowSize">
               <h3>
                  http2initialWindowSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2initialWindowSize" class="anchor" title="Link to http2initialWindowSize">#</a>
               </h3>
               
               <pre><code>const http2initialWindowSize = 65535</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2littleBuf" data-name="http2littleBuf">
               <h3>
                  http2littleBuf 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2littleBuf" class="anchor" title="Link to http2littleBuf">#</a>
               </h3>
               
               <pre><code>var http2littleBuf = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2logFrameReads" data-name="http2logFrameReads">
               <h3>
                  http2logFrameReads 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2logFrameReads" class="anchor" title="Link to http2logFrameReads">#</a>
               </h3>
               
               <pre><code>var http2logFrameReads bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2logFrameWrites" data-name="http2logFrameWrites">
               <h3>
                  http2logFrameWrites 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2logFrameWrites" class="anchor" title="Link to http2logFrameWrites">#</a>
               </h3>
               
               <pre><code>var http2logFrameWrites bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2maxCachedCanonicalHeadersKeysSize" data-name="http2maxCachedCanonicalHeadersKeysSize">
               <h3>
                  http2maxCachedCanonicalHeadersKeysSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2maxCachedCanonicalHeadersKeysSize" class="anchor" title="Link to http2maxCachedCanonicalHeadersKeysSize">#</a>
               </h3>
               
               <p>maxCachedCanonicalHeadersKeysSize is an arbitrarily-chosen limit on the size
of the entries in the canonHeader cache.
This should be larger than the size of unique, uncommon header keys likely to
be sent by the peer, while not so high as to permit unreasonable memory usage
if the peer sends an unbounded number of unique header keys.</p>
               
               <pre><code>const http2maxCachedCanonicalHeadersKeysSize = 2048</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2maxFrameSize" data-name="http2maxFrameSize">
               <h3>
                  http2maxFrameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2maxFrameSize" class="anchor" title="Link to http2maxFrameSize">#</a>
               </h3>
               
               <pre><code>const http2maxFrameSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2maxQueuedControlFrames" data-name="http2maxQueuedControlFrames">
               <h3>
                  http2maxQueuedControlFrames 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2maxQueuedControlFrames" class="anchor" title="Link to http2maxQueuedControlFrames">#</a>
               </h3>
               
               <p>maxQueuedControlFrames is the maximum number of control frames like
SETTINGS, PING and RST_STREAM that will be queued for writing before
the connection is closed to prevent memory exhaustion attacks.</p>
               
               <pre><code>const http2maxQueuedControlFrames = 10000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2minMaxFrameSize" data-name="http2minMaxFrameSize">
               <h3>
                  http2minMaxFrameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2minMaxFrameSize" class="anchor" title="Link to http2minMaxFrameSize">#</a>
               </h3>
               
               <pre><code>const http2minMaxFrameSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2nextProtoUnencryptedHTTP2" data-name="http2nextProtoUnencryptedHTTP2">
               <h3>
                  http2nextProtoUnencryptedHTTP2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2nextProtoUnencryptedHTTP2" class="anchor" title="Link to http2nextProtoUnencryptedHTTP2">#</a>
               </h3>
               
               <pre><code>const http2nextProtoUnencryptedHTTP2 = "unencrypted_http2"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2noBody" data-name="http2noBody">
               <h3>
                  http2noBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2noBody" class="anchor" title="Link to http2noBody">#</a>
               </h3>
               
               <pre><code>var http2noBody io.ReadCloser = http2noBodyReader{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2noDialOnMiss" data-name="http2noDialOnMiss">
               <h3>
                  http2noDialOnMiss 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2noDialOnMiss" class="anchor" title="Link to http2noDialOnMiss">#</a>
               </h3>
               
               <pre><code>const http2noDialOnMiss = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2notHeaderOrDataFrame" data-name="http2notHeaderOrDataFrame">
               <h3>
                  http2notHeaderOrDataFrame 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2notHeaderOrDataFrame" class="anchor" title="Link to http2notHeaderOrDataFrame">#</a>
               </h3>
               
               <p>Constants passed to streamByID for documentation purposes.</p>
               
               <pre><code>const http2notHeaderOrDataFrame = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2padZeros" data-name="http2padZeros">
               <h3>
                  http2padZeros 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2padZeros" class="anchor" title="Link to http2padZeros">#</a>
               </h3>
               
               <pre><code>var http2padZeros = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2prefaceTimeout" data-name="http2prefaceTimeout">
               <h3>
                  http2prefaceTimeout 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2prefaceTimeout" class="anchor" title="Link to http2prefaceTimeout">#</a>
               </h3>
               
               <pre><code>const http2prefaceTimeout = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2priorityDefaultWeight" data-name="http2priorityDefaultWeight">
               <h3>
                  http2priorityDefaultWeight 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2priorityDefaultWeight" class="anchor" title="Link to http2priorityDefaultWeight">#</a>
               </h3>
               
               <p>RFC 7540, Section 5.3.5: the default weight is 16.</p>
               
               <pre><code>const http2priorityDefaultWeight = 15</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2priorityNodeClosed" data-name="http2priorityNodeClosed">
               <h3>
                  http2priorityNodeClosed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2priorityNodeClosed" class="anchor" title="Link to http2priorityNodeClosed">#</a>
               </h3>
               
               <pre><code>const http2priorityNodeClosed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2priorityNodeIdle" data-name="http2priorityNodeIdle">
               <h3>
                  http2priorityNodeIdle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2priorityNodeIdle" class="anchor" title="Link to http2priorityNodeIdle">#</a>
               </h3>
               
               <pre><code>const http2priorityNodeIdle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2priorityNodeOpen" data-name="http2priorityNodeOpen">
               <h3>
                  http2priorityNodeOpen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2priorityNodeOpen" class="anchor" title="Link to http2priorityNodeOpen">#</a>
               </h3>
               
               <pre><code>const http2priorityNodeOpen http2priorityNodeState = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2readIdleTimerMsg" data-name="http2readIdleTimerMsg">
               <h3>
                  http2readIdleTimerMsg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2readIdleTimerMsg" class="anchor" title="Link to http2readIdleTimerMsg">#</a>
               </h3>
               
               <p>Message values sent to serveMsgCh.</p>
               
               <pre><code>var http2readIdleTimerMsg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2responseWriterStatePool" data-name="http2responseWriterStatePool">
               <h3>
                  http2responseWriterStatePool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2responseWriterStatePool" class="anchor" title="Link to http2responseWriterStatePool">#</a>
               </h3>
               
               <pre><code>var http2responseWriterStatePool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2server" data-name="http2server">
               <h3>
                  http2server 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2server" class="anchor" title="Link to http2server">#</a>
               </h3>
               
               <pre><code>var http2server = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2settingName" data-name="http2settingName">
               <h3>
                  http2settingName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2settingName" class="anchor" title="Link to http2settingName">#</a>
               </h3>
               
               <pre><code>var http2settingName = map[http2SettingID]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2settingsTimerMsg" data-name="http2settingsTimerMsg">
               <h3>
                  http2settingsTimerMsg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2settingsTimerMsg" class="anchor" title="Link to http2settingsTimerMsg">#</a>
               </h3>
               
               <p>Message values sent to serveMsgCh.</p>
               
               <pre><code>var http2settingsTimerMsg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2shutdownEnterWaitStateHook" data-name="http2shutdownEnterWaitStateHook">
               <h3>
                  http2shutdownEnterWaitStateHook 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2shutdownEnterWaitStateHook" class="anchor" title="Link to http2shutdownEnterWaitStateHook">#</a>
               </h3>
               
               <pre><code>var http2shutdownEnterWaitStateHook = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2shutdownTimerMsg" data-name="http2shutdownTimerMsg">
               <h3>
                  http2shutdownTimerMsg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2shutdownTimerMsg" class="anchor" title="Link to http2shutdownTimerMsg">#</a>
               </h3>
               
               <p>Message values sent to serveMsgCh.</p>
               
               <pre><code>var http2shutdownTimerMsg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2sorterPool" data-name="http2sorterPool">
               <h3>
                  http2sorterPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2sorterPool" class="anchor" title="Link to http2sorterPool">#</a>
               </h3>
               
               <pre><code>var http2sorterPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2stateClosed" data-name="http2stateClosed">
               <h3>
                  http2stateClosed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2stateClosed" class="anchor" title="Link to http2stateClosed">#</a>
               </h3>
               
               <p>HTTP/2 stream states.
See http://tools.ietf.org/html/rfc7540#section-5.1.
For simplicity, the server code merges "reserved (local)" into
"half-closed (remote)". This is one less state transition to track.
The only downside is that we send PUSH_PROMISEs slightly less
liberally than allowable. More discussion here:
https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
"reserved (remote)" is omitted since the client code does not
support server push.</p>
               
               <pre><code>const http2stateClosed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2stateHalfClosedLocal" data-name="http2stateHalfClosedLocal">
               <h3>
                  http2stateHalfClosedLocal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2stateHalfClosedLocal" class="anchor" title="Link to http2stateHalfClosedLocal">#</a>
               </h3>
               
               <p>HTTP/2 stream states.
See http://tools.ietf.org/html/rfc7540#section-5.1.
For simplicity, the server code merges "reserved (local)" into
"half-closed (remote)". This is one less state transition to track.
The only downside is that we send PUSH_PROMISEs slightly less
liberally than allowable. More discussion here:
https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
"reserved (remote)" is omitted since the client code does not
support server push.</p>
               
               <pre><code>const http2stateHalfClosedLocal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2stateHalfClosedRemote" data-name="http2stateHalfClosedRemote">
               <h3>
                  http2stateHalfClosedRemote 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2stateHalfClosedRemote" class="anchor" title="Link to http2stateHalfClosedRemote">#</a>
               </h3>
               
               <p>HTTP/2 stream states.
See http://tools.ietf.org/html/rfc7540#section-5.1.
For simplicity, the server code merges "reserved (local)" into
"half-closed (remote)". This is one less state transition to track.
The only downside is that we send PUSH_PROMISEs slightly less
liberally than allowable. More discussion here:
https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
"reserved (remote)" is omitted since the client code does not
support server push.</p>
               
               <pre><code>const http2stateHalfClosedRemote</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2stateIdle" data-name="http2stateIdle">
               <h3>
                  http2stateIdle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2stateIdle" class="anchor" title="Link to http2stateIdle">#</a>
               </h3>
               
               <p>HTTP/2 stream states.
See http://tools.ietf.org/html/rfc7540#section-5.1.
For simplicity, the server code merges "reserved (local)" into
"half-closed (remote)". This is one less state transition to track.
The only downside is that we send PUSH_PROMISEs slightly less
liberally than allowable. More discussion here:
https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
"reserved (remote)" is omitted since the client code does not
support server push.</p>
               
               <pre><code>const http2stateIdle http2streamState = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2stateName" data-name="http2stateName">
               <h3>
                  http2stateName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2stateName" class="anchor" title="Link to http2stateName">#</a>
               </h3>
               
               <pre><code>var http2stateName = [...]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2stateOpen" data-name="http2stateOpen">
               <h3>
                  http2stateOpen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2stateOpen" class="anchor" title="Link to http2stateOpen">#</a>
               </h3>
               
               <p>HTTP/2 stream states.
See http://tools.ietf.org/html/rfc7540#section-5.1.
For simplicity, the server code merges "reserved (local)" into
"half-closed (remote)". This is one less state transition to track.
The only downside is that we send PUSH_PROMISEs slightly less
liberally than allowable. More discussion here:
https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
"reserved (remote)" is omitted since the client code does not
support server push.</p>
               
               <pre><code>const http2stateOpen</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2testHookGetServerConn" data-name="http2testHookGetServerConn">
               <h3>
                  http2testHookGetServerConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2testHookGetServerConn" class="anchor" title="Link to http2testHookGetServerConn">#</a>
               </h3>
               
               <p>Test hooks.</p>
               
               <pre><code>var http2testHookGetServerConn func(*http2serverConn)</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2testHookOnConn" data-name="http2testHookOnConn">
               <h3>
                  http2testHookOnConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2testHookOnConn" class="anchor" title="Link to http2testHookOnConn">#</a>
               </h3>
               
               <p>Test hooks.</p>
               
               <pre><code>var http2testHookOnConn func()</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2testHookOnPanic" data-name="http2testHookOnPanic">
               <h3>
                  http2testHookOnPanic 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2testHookOnPanic" class="anchor" title="Link to http2testHookOnPanic">#</a>
               </h3>
               
               <p>Test hooks.</p>
               
               <pre><code>var http2testHookOnPanic func(sc *http2serverConn, panicVal interface{}) rePanic bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2testHookOnPanicMu" data-name="http2testHookOnPanicMu">
               <h3>
                  http2testHookOnPanicMu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2testHookOnPanicMu" class="anchor" title="Link to http2testHookOnPanicMu">#</a>
               </h3>
               
               <p>Test hooks.</p>
               
               <pre><code>var http2testHookOnPanicMu *sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2transportDefaultConnFlow" data-name="http2transportDefaultConnFlow">
               <h3>
                  http2transportDefaultConnFlow 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2transportDefaultConnFlow" class="anchor" title="Link to http2transportDefaultConnFlow">#</a>
               </h3>
               
               <p>transportDefaultConnFlow is how many connection-level flow control
tokens we give the server at start-up, past the default 64k.</p>
               
               <pre><code>const http2transportDefaultConnFlow = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2transportDefaultStreamFlow" data-name="http2transportDefaultStreamFlow">
               <h3>
                  http2transportDefaultStreamFlow 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#http2transportDefaultStreamFlow" class="anchor" title="Link to http2transportDefaultStreamFlow">#</a>
               </h3>
               
               <p>transportDefaultStreamFlow is how many stream-level flow
control tokens we announce to the peer, and how many bytes
we buffer per stream.</p>
               
               <pre><code>const http2transportDefaultStreamFlow = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="http2writeDataPool" data-name="http2writeDataPool">
               <h3>
                  http2writeDataPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#http2writeDataPool" class="anchor" title="Link to http2writeDataPool">#</a>
               </h3>
               
               <pre><code>var http2writeDataPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="httplaxcontentlength" data-name="httplaxcontentlength">
               <h3>
                  httplaxcontentlength 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#httplaxcontentlength" class="anchor" title="Link to httplaxcontentlength">#</a>
               </h3>
               
               <pre><code>var httplaxcontentlength = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="httpmuxgo121" data-name="httpmuxgo121">
               <h3>
                  httpmuxgo121 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#httpmuxgo121" class="anchor" title="Link to httpmuxgo121">#</a>
               </h3>
               
               <pre><code>var httpmuxgo121 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="httpservecontentkeepheaders" data-name="httpservecontentkeepheaders">
               <h3>
                  httpservecontentkeepheaders 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#httpservecontentkeepheaders" class="anchor" title="Link to httpservecontentkeepheaders">#</a>
               </h3>
               
               <p>GODEBUG=httpservecontentkeepheaders=1 restores the pre-1.23 behavior of not deleting
Cache-Control, Content-Encoding, Etag, or Last-Modified headers on ServeContent errors.</p>
               
               <pre><code>var httpservecontentkeepheaders = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsFetchCreds" data-name="jsFetchCreds">
               <h3>
                  jsFetchCreds 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#jsFetchCreds" class="anchor" title="Link to jsFetchCreds">#</a>
               </h3>
               
               <p>jsFetchCreds is a Request.Header map key that, if present,
signals that the map entry is actually an option to the Fetch API credentials setting.
Valid values are: "omit", "same-origin", "include"
The default is "same-origin".
Reference: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters</p>
               
               <pre><code>const jsFetchCreds = "js.fetch:credentials"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsFetchDisabled" data-name="jsFetchDisabled">
               <h3>
                  jsFetchDisabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsFetchDisabled" class="anchor" title="Link to jsFetchDisabled">#</a>
               </h3>
               
               <p>jsFetchDisabled controls whether the use of Fetch API is disabled.
It's set to true when we detect we're running in Node.js, so that
RoundTrip ends up talking over the same fake network the HTTP servers
currently use in various tests and examples. See go.dev/issue/57613.
TODO(go.dev/issue/60810): See if it's viable to test the Fetch API
code path.</p>
               
               <pre><code>var jsFetchDisabled = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsFetchMissing" data-name="jsFetchMissing">
               <h3>
                  jsFetchMissing 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsFetchMissing" class="anchor" title="Link to jsFetchMissing">#</a>
               </h3>
               
               <p>jsFetchMissing will be true if the Fetch API is not present in
the browser globals.</p>
               
               <pre><code>var jsFetchMissing = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsFetchMode" data-name="jsFetchMode">
               <h3>
                  jsFetchMode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#jsFetchMode" class="anchor" title="Link to jsFetchMode">#</a>
               </h3>
               
               <p>jsFetchMode is a Request.Header map key that, if present,
signals that the map entry is actually an option to the Fetch API mode setting.
Valid values are: "cors", "no-cors", "same-origin", "navigate"
The default is "same-origin".
Reference: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters</p>
               
               <pre><code>const jsFetchMode = "js.fetch:mode"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsFetchRedirect" data-name="jsFetchRedirect">
               <h3>
                  jsFetchRedirect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#jsFetchRedirect" class="anchor" title="Link to jsFetchRedirect">#</a>
               </h3>
               
               <p>jsFetchRedirect is a Request.Header map key that, if present,
signals that the map entry is actually an option to the Fetch API redirect setting.
Valid values are: "follow", "error", "manual"
The default is "follow".
Reference: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters</p>
               
               <pre><code>const jsFetchRedirect = "js.fetch:redirect"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxInt64" data-name="maxInt64">
               <h3>
                  maxInt64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxInt64" class="anchor" title="Link to maxInt64">#</a>
               </h3>
               
               <p>maxInt64 is the effective "infinite" value for the Server and
Transport's byte-limiting readers.</p>
               
               <pre><code>const maxInt64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxPostHandlerReadBytes" data-name="maxPostHandlerReadBytes">
               <h3>
                  maxPostHandlerReadBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxPostHandlerReadBytes" class="anchor" title="Link to maxPostHandlerReadBytes">#</a>
               </h3>
               
               <p>maxPostHandlerReadBytes is the max number of Request.Body bytes not
consumed by a handler that the server will read from the client
in order to keep a connection alive. If there are more bytes
than this, the server, to be paranoid, instead sends a
"Connection close" response.
This number is approximately what a typical machine's TCP buffer
size is anyway.  (if we have the bytes on the machine, we might as
well read them)</p>
               
               <pre><code>const maxPostHandlerReadBytes = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxSlice" data-name="maxSlice">
               <h3>
                  maxSlice 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#maxSlice" class="anchor" title="Link to maxSlice">#</a>
               </h3>
               
               <p>maxSlice is the maximum number of pairs for which a slice is used.
It is a variable for benchmarking.</p>
               
               <pre><code>var maxSlice int = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxWriteWaitBeforeConnReuse" data-name="maxWriteWaitBeforeConnReuse">
               <h3>
                  maxWriteWaitBeforeConnReuse 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#maxWriteWaitBeforeConnReuse" class="anchor" title="Link to maxWriteWaitBeforeConnReuse">#</a>
               </h3>
               
               <p>maxWriteWaitBeforeConnReuse is how long the a Transport RoundTrip
will wait to see the Request's Body.Write result after getting a
response from the server. See comments in (*persistConn).wroteRequest.
In tests, we set this to a large value to avoid flakiness from inconsistent
recycling of connections.</p>
               
               <pre><code>var maxWriteWaitBeforeConnReuse = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="moreGeneral" data-name="moreGeneral">
               <h3>
                  moreGeneral 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#moreGeneral" class="anchor" title="Link to moreGeneral">#</a>
               </h3>
               
               <pre><code>const moreGeneral relationship = "moreGeneral"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="moreSpecific" data-name="moreSpecific">
               <h3>
                  moreSpecific 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#moreSpecific" class="anchor" title="Link to moreSpecific">#</a>
               </h3>
               
               <pre><code>const moreSpecific relationship = "moreSpecific"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mp4" data-name="mp4">
               <h3>
                  mp4 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mp4" class="anchor" title="Link to mp4">#</a>
               </h3>
               
               <pre><code>var mp4 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mp4ftype" data-name="mp4ftype">
               <h3>
                  mp4ftype 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mp4ftype" class="anchor" title="Link to mp4ftype">#</a>
               </h3>
               
               <pre><code>var mp4ftype = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="multipartByReader" data-name="multipartByReader">
               <h3>
                  multipartByReader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#multipartByReader" class="anchor" title="Link to multipartByReader">#</a>
               </h3>
               
               <p>multipartByReader is a sentinel value.
Its presence in Request.MultipartForm indicates that parsing of the request
body has been handed off to a MultipartReader instead of ParseMultipartForm.</p>
               
               <pre><code>var multipartByReader = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nextProtoUnencryptedHTTP2" data-name="nextProtoUnencryptedHTTP2">
               <h3>
                  nextProtoUnencryptedHTTP2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nextProtoUnencryptedHTTP2" class="anchor" title="Link to nextProtoUnencryptedHTTP2">#</a>
               </h3>
               
               <p>TLSNextProto key to use for unencrypted HTTP/2 connections.
Not actually a TLS-negotiated protocol.</p>
               
               <pre><code>const nextProtoUnencryptedHTTP2 = "unencrypted_http2"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noHTTP2" data-name="noHTTP2">
               <h3>
                  noHTTP2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noHTTP2" class="anchor" title="Link to noHTTP2">#</a>
               </h3>
               
               <pre><code>const noHTTP2 = "no bundled HTTP/2"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nopCloserType" data-name="nopCloserType">
               <h3>
                  nopCloserType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nopCloserType" class="anchor" title="Link to nopCloserType">#</a>
               </h3>
               
               <pre><code>var nopCloserType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nopCloserWriterToType" data-name="nopCloserWriterToType">
               <h3>
                  nopCloserWriterToType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nopCloserWriterToType" class="anchor" title="Link to nopCloserWriterToType">#</a>
               </h3>
               
               <pre><code>var nopCloserWriterToType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="omitBundledHTTP2" data-name="omitBundledHTTP2">
               <h3>
                  omitBundledHTTP2 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#omitBundledHTTP2" class="anchor" title="Link to omitBundledHTTP2">#</a>
               </h3>
               
               <p>omitBundledHTTP2 is set by omithttp2.go when the nethttpomithttp2
build tag is set. That means h2_bundle.go isn't compiled in and we
shouldn't try to use it.</p>
               
               <pre><code>var omitBundledHTTP2 bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="overlaps" data-name="overlaps">
               <h3>
                  overlaps 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#overlaps" class="anchor" title="Link to overlaps">#</a>
               </h3>
               
               <pre><code>const overlaps relationship = "overlaps"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="portMap" data-name="portMap">
               <h3>
                  portMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#portMap" class="anchor" title="Link to portMap">#</a>
               </h3>
               
               <pre><code>var portMap = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="protoHTTP1" data-name="protoHTTP1">
               <h3>
                  protoHTTP1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#protoHTTP1" class="anchor" title="Link to protoHTTP1">#</a>
               </h3>
               
               <pre><code>const protoHTTP1 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="protoHTTP2" data-name="protoHTTP2">
               <h3>
                  protoHTTP2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#protoHTTP2" class="anchor" title="Link to protoHTTP2">#</a>
               </h3>
               
               <pre><code>const protoHTTP2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="protoUnencryptedHTTP2" data-name="protoUnencryptedHTTP2">
               <h3>
                  protoUnencryptedHTTP2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#protoUnencryptedHTTP2" class="anchor" title="Link to protoUnencryptedHTTP2">#</a>
               </h3>
               
               <pre><code>const protoUnencryptedHTTP2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="reqWriteExcludeHeader" data-name="reqWriteExcludeHeader">
               <h3>
                  reqWriteExcludeHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#reqWriteExcludeHeader" class="anchor" title="Link to reqWriteExcludeHeader">#</a>
               </h3>
               
               <p>Headers that Request.Write handles itself and should be skipped.</p>
               
               <pre><code>var reqWriteExcludeHeader = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="respExcludeHeader" data-name="respExcludeHeader">
               <h3>
                  respExcludeHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#respExcludeHeader" class="anchor" title="Link to respExcludeHeader">#</a>
               </h3>
               
               <pre><code>var respExcludeHeader = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rstAvoidanceDelay" data-name="rstAvoidanceDelay">
               <h3>
                  rstAvoidanceDelay 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#rstAvoidanceDelay" class="anchor" title="Link to rstAvoidanceDelay">#</a>
               </h3>
               
               <p>rstAvoidanceDelay is the amount of time we sleep after closing the
write side of a TCP connection before closing the entire socket.
By sleeping, we increase the chances that the client sees our FIN
and processes its final data before they process the subsequent RST
from closing a connection with known unread data.
This RST seems to occur mostly on BSD systems. (And Windows?)
This timeout is somewhat arbitrary (~latency around the planet),
and may be modified by tests.
TODO(bcmills): This should arguably be a server configuration parameter,
not a hard-coded value.</p>
               
               <pre><code>var rstAvoidanceDelay = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runHooks" data-name="runHooks">
               <h3>
                  runHooks 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#runHooks" class="anchor" title="Link to runHooks">#</a>
               </h3>
               
               <pre><code>const runHooks = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="shutdownPollIntervalMax" data-name="shutdownPollIntervalMax">
               <h3>
                  shutdownPollIntervalMax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#shutdownPollIntervalMax" class="anchor" title="Link to shutdownPollIntervalMax">#</a>
               </h3>
               
               <p>shutdownPollIntervalMax is the max polling interval when checking
quiescence during Server.Shutdown. Polling starts with a small
interval and backs off to the max.
Ideally we could find a solution that doesn't involve polling,
but which also doesn't have a high runtime cost (and doesn't
involve any contentious mutexes), but that is left as an
exercise for the reader.</p>
               
               <pre><code>const shutdownPollIntervalMax = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="singleCRLF" data-name="singleCRLF">
               <h3>
                  singleCRLF 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#singleCRLF" class="anchor" title="Link to singleCRLF">#</a>
               </h3>
               
               <pre><code>var singleCRLF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skipHooks" data-name="skipHooks">
               <h3>
                  skipHooks 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#skipHooks" class="anchor" title="Link to skipHooks">#</a>
               </h3>
               
               <pre><code>const skipHooks = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sniffLen" data-name="sniffLen">
               <h3>
                  sniffLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sniffLen" class="anchor" title="Link to sniffLen">#</a>
               </h3>
               
               <p>The algorithm uses at most sniffLen bytes to make its decision.</p>
               
               <pre><code>const sniffLen = 512</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sniffSignatures" data-name="sniffSignatures">
               <h3>
                  sniffSignatures 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#sniffSignatures" class="anchor" title="Link to sniffSignatures">#</a>
               </h3>
               
               <p>Data matching the table in section 6.</p>
               
               <pre><code>var sniffSignatures = []sniffSig{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksAddrTypeFQDN" data-name="socksAddrTypeFQDN">
               <h3>
                  socksAddrTypeFQDN 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksAddrTypeFQDN" class="anchor" title="Link to socksAddrTypeFQDN">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksAddrTypeFQDN = 0x03</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksAddrTypeIPv4" data-name="socksAddrTypeIPv4">
               <h3>
                  socksAddrTypeIPv4 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksAddrTypeIPv4" class="anchor" title="Link to socksAddrTypeIPv4">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksAddrTypeIPv4 = 0x01</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksAddrTypeIPv6" data-name="socksAddrTypeIPv6">
               <h3>
                  socksAddrTypeIPv6 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksAddrTypeIPv6" class="anchor" title="Link to socksAddrTypeIPv6">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksAddrTypeIPv6 = 0x04</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksAuthMethodNoAcceptableMethods" data-name="socksAuthMethodNoAcceptableMethods">
               <h3>
                  socksAuthMethodNoAcceptableMethods 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksAuthMethodNoAcceptableMethods" class="anchor" title="Link to socksAuthMethodNoAcceptableMethods">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksAuthMethodNoAcceptableMethods socksAuthMethod = 0xff</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksAuthMethodNotRequired" data-name="socksAuthMethodNotRequired">
               <h3>
                  socksAuthMethodNotRequired 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksAuthMethodNotRequired" class="anchor" title="Link to socksAuthMethodNotRequired">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksAuthMethodNotRequired socksAuthMethod = 0x00</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksAuthMethodUsernamePassword" data-name="socksAuthMethodUsernamePassword">
               <h3>
                  socksAuthMethodUsernamePassword 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksAuthMethodUsernamePassword" class="anchor" title="Link to socksAuthMethodUsernamePassword">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksAuthMethodUsernamePassword socksAuthMethod = 0x02</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksCmdConnect" data-name="socksCmdConnect">
               <h3>
                  socksCmdConnect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksCmdConnect" class="anchor" title="Link to socksCmdConnect">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksCmdConnect socksCommand = 0x01</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksStatusSucceeded" data-name="socksStatusSucceeded">
               <h3>
                  socksStatusSucceeded 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksStatusSucceeded" class="anchor" title="Link to socksStatusSucceeded">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksStatusSucceeded socksReply = 0x00</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksVersion5" data-name="socksVersion5">
               <h3>
                  socksVersion5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksVersion5" class="anchor" title="Link to socksVersion5">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const socksVersion5 = 0x05</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksaLongTimeAgo" data-name="socksaLongTimeAgo">
               <h3>
                  socksaLongTimeAgo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#socksaLongTimeAgo" class="anchor" title="Link to socksaLongTimeAgo">#</a>
               </h3>
               
               <pre><code>var socksaLongTimeAgo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksauthStatusSucceeded" data-name="socksauthStatusSucceeded">
               <h3>
                  socksauthStatusSucceeded 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksauthStatusSucceeded" class="anchor" title="Link to socksauthStatusSucceeded">#</a>
               </h3>
               
               <pre><code>const socksauthStatusSucceeded = 0x00</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksauthUsernamePasswordVersion" data-name="socksauthUsernamePasswordVersion">
               <h3>
                  socksauthUsernamePasswordVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#socksauthUsernamePasswordVersion" class="anchor" title="Link to socksauthUsernamePasswordVersion">#</a>
               </h3>
               
               <pre><code>const socksauthUsernamePasswordVersion = 0x01</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sockscmdBind" data-name="sockscmdBind">
               <h3>
                  sockscmdBind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sockscmdBind" class="anchor" title="Link to sockscmdBind">#</a>
               </h3>
               
               <p>Wire protocol constants.</p>
               
               <pre><code>const sockscmdBind socksCommand = 0x02</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="socksnoDeadline" data-name="socksnoDeadline">
               <h3>
                  socksnoDeadline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#socksnoDeadline" class="anchor" title="Link to socksnoDeadline">#</a>
               </h3>
               
               <pre><code>var socksnoDeadline = time.Time{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stateName" data-name="stateName">
               <h3>
                  stateName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stateName" class="anchor" title="Link to stateName">#</a>
               </h3>
               
               <pre><code>var stateName = map[ConnState]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="suppressedHeaders304" data-name="suppressedHeaders304">
               <h3>
                  suppressedHeaders304 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#suppressedHeaders304" class="anchor" title="Link to suppressedHeaders304">#</a>
               </h3>
               
               <pre><code>var suppressedHeaders304 = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="suppressedHeadersNoBody" data-name="suppressedHeadersNoBody">
               <h3>
                  suppressedHeadersNoBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#suppressedHeadersNoBody" class="anchor" title="Link to suppressedHeadersNoBody">#</a>
               </h3>
               
               <pre><code>var suppressedHeadersNoBody = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookClientDoResult" data-name="testHookClientDoResult">
               <h3>
                  testHookClientDoResult 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookClientDoResult" class="anchor" title="Link to testHookClientDoResult">#</a>
               </h3>
               
               <pre><code>var testHookClientDoResult func(retres *Response, reterr error)</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookEnterRoundTrip" data-name="testHookEnterRoundTrip">
               <h3>
                  testHookEnterRoundTrip 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookEnterRoundTrip" class="anchor" title="Link to testHookEnterRoundTrip">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookEnterRoundTrip = nop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookMu" data-name="testHookMu">
               <h3>
                  testHookMu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookMu" class="anchor" title="Link to testHookMu">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookMu sync.Locker = fakeLocker{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookPostPendingDial" data-name="testHookPostPendingDial">
               <h3>
                  testHookPostPendingDial 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookPostPendingDial" class="anchor" title="Link to testHookPostPendingDial">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookPostPendingDial = nop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookPrePendingDial" data-name="testHookPrePendingDial">
               <h3>
                  testHookPrePendingDial 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookPrePendingDial" class="anchor" title="Link to testHookPrePendingDial">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookPrePendingDial = nop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookProxyConnectTimeout" data-name="testHookProxyConnectTimeout">
               <h3>
                  testHookProxyConnectTimeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookProxyConnectTimeout" class="anchor" title="Link to testHookProxyConnectTimeout">#</a>
               </h3>
               
               <pre><code>var testHookProxyConnectTimeout = context.WithTimeout</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookReadLoopBeforeNextRead" data-name="testHookReadLoopBeforeNextRead">
               <h3>
                  testHookReadLoopBeforeNextRead 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookReadLoopBeforeNextRead" class="anchor" title="Link to testHookReadLoopBeforeNextRead">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookReadLoopBeforeNextRead = nop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookRoundTripRetried" data-name="testHookRoundTripRetried">
               <h3>
                  testHookRoundTripRetried 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookRoundTripRetried" class="anchor" title="Link to testHookRoundTripRetried">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookRoundTripRetried = nop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookServerServe" data-name="testHookServerServe">
               <h3>
                  testHookServerServe 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookServerServe" class="anchor" title="Link to testHookServerServe">#</a>
               </h3>
               
               <pre><code>var testHookServerServe func(*Server, net.Listener)</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testHookWaitResLoop" data-name="testHookWaitResLoop">
               <h3>
                  testHookWaitResLoop 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookWaitResLoop" class="anchor" title="Link to testHookWaitResLoop">#</a>
               </h3>
               
               <p>testHooks. Always non-nil.</p>
               
               <pre><code>var testHookWaitResLoop = nop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="textprotoReaderPool" data-name="textprotoReaderPool">
               <h3>
                  textprotoReaderPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#textprotoReaderPool" class="anchor" title="Link to textprotoReaderPool">#</a>
               </h3>
               
               <pre><code>var textprotoReaderPool sync.Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="timeFormats" data-name="timeFormats">
               <h3>
                  timeFormats 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#timeFormats" class="anchor" title="Link to timeFormats">#</a>
               </h3>
               
               <pre><code>var timeFormats = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uint8Array" data-name="uint8Array">
               <h3>
                  uint8Array 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#uint8Array" class="anchor" title="Link to uint8Array">#</a>
               </h3>
               
               <pre><code>var uint8Array = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uniqNameMu" data-name="uniqNameMu">
               <h3>
                  uniqNameMu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#uniqNameMu" class="anchor" title="Link to uniqNameMu">#</a>
               </h3>
               
               <pre><code>var uniqNameMu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uniqNameNext" data-name="uniqNameNext">
               <h3>
                  uniqNameNext 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#uniqNameNext" class="anchor" title="Link to uniqNameNext">#</a>
               </h3>
               
               <pre><code>var uniqNameNext = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unixEpochTime" data-name="unixEpochTime">
               <h3>
                  unixEpochTime 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unixEpochTime" class="anchor" title="Link to unixEpochTime">#</a>
               </h3>
               
               <pre><code>var unixEpochTime = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="use121" data-name="use121">
               <h3>
                  use121 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#use121" class="anchor" title="Link to use121">#</a>
               </h3>
               
               <pre><code>var use121 bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zeroDialer" data-name="zeroDialer">
               <h3>
                  zeroDialer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zeroDialer" class="anchor" title="Link to zeroDialer">#</a>
               </h3>
               
               <pre><code>var zeroDialer net.Dialer</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ConnState" data-name="ConnState">
               <h3>
                  ConnState
                  <span class="badge type-badge">type</span>
                  <a href="#ConnState" class="anchor" title="Link to ConnState">#</a>
               </h3>
               
               <p>A ConnState represents the state of a client connection to a server.
It's used by the optional [Server.ConnState] hook.</p>
               
               <pre><code>type ConnState int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Dir" data-name="Dir">
               <h3>
                  Dir
                  <span class="badge type-badge">type</span>
                  <a href="#Dir" class="anchor" title="Link to Dir">#</a>
               </h3>
               
               <p>A Dir implements [FileSystem] using the native file system restricted to a
specific directory tree.
While the [FileSystem.Open] method takes '/'-separated paths, a Dir's string
value is a directory path on the native file system, not a URL, so it is separated
by [filepath.Separator], which isn't necessarily '/'.
Note that Dir could expose sensitive files and directories. Dir will follow
symlinks pointing out of the directory tree, which can be especially dangerous
if serving from a directory in which users are able to create arbitrary symlinks.
Dir will also allow access to files and directories starting with a period,
which could expose sensitive directories like .git or sensitive files like
.htpasswd. To exclude files with a leading period, remove the files/directories
from the server or create a custom FileSystem implementation.
An empty Dir is treated as ".".</p>
               
               <pre><code>type Dir string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="HandlerFunc" data-name="HandlerFunc">
               <h3>
                  HandlerFunc
                  <span class="badge type-badge">type</span>
                  <a href="#HandlerFunc" class="anchor" title="Link to HandlerFunc">#</a>
               </h3>
               
               <p>The HandlerFunc type is an adapter to allow the use of
ordinary functions as HTTP handlers. If f is a function
with the appropriate signature, HandlerFunc(f) is a
[Handler] that calls f.</p>
               
               <pre><code>type HandlerFunc func(ResponseWriter, *Request)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header
                  <span class="badge type-badge">type</span>
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <p>A Header represents the key-value pairs in an HTTP header.
The keys should be in canonical form, as returned by
[CanonicalHeaderKey].</p>
               
               <pre><code>type Header map[string][]string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="SameSite" data-name="SameSite">
               <h3>
                  SameSite
                  <span class="badge type-badge">type</span>
                  <a href="#SameSite" class="anchor" title="Link to SameSite">#</a>
               </h3>
               
               <p>SameSite allows a server to define a cookie attribute making it impossible for
the browser to send this cookie along with cross-site requests. The main
goal is to mitigate the risk of cross-origin information leakage, and provide
some protection against cross-site request forgery attacks.
See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.</p>
               
               <pre><code>type SameSite int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="condResult" data-name="condResult">
               <h3>
                  condResult
                  <span class="badge type-badge">type</span>
                  <a href="#condResult" class="anchor" title="Link to condResult">#</a>
               </h3>
               
               <p>condResult is the result of an HTTP request precondition check.
See https://tools.ietf.org/html/rfc7232 section 3.</p>
               
               <pre><code>type condResult int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="countingWriter" data-name="countingWriter">
               <h3>
                  countingWriter
                  <span class="badge type-badge">type</span>
                  <a href="#countingWriter" class="anchor" title="Link to countingWriter">#</a>
               </h3>
               
               <p>countingWriter counts how many bytes have been written to it.</p>
               
               <pre><code>type countingWriter int64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="dirEntryDirs" data-name="dirEntryDirs">
               <h3>
                  dirEntryDirs
                  <span class="badge type-badge">type</span>
                  <a href="#dirEntryDirs" class="anchor" title="Link to dirEntryDirs">#</a>
               </h3>
               
               <pre><code>type dirEntryDirs []fs.DirEntry</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="fileInfoDirs" data-name="fileInfoDirs">
               <h3>
                  fileInfoDirs
                  <span class="badge type-badge">type</span>
                  <a href="#fileInfoDirs" class="anchor" title="Link to fileInfoDirs">#</a>
               </h3>
               
               <pre><code>type fileInfoDirs []fs.FileInfo</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="htmlSig" data-name="htmlSig">
               <h3>
                  htmlSig
                  <span class="badge type-badge">type</span>
                  <a href="#htmlSig" class="anchor" title="Link to htmlSig">#</a>
               </h3>
               
               <pre><code>type htmlSig []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2ConnectionError" data-name="http2ConnectionError">
               <h3>
                  http2ConnectionError
                  <span class="badge type-badge">type</span>
                  <a href="#http2ConnectionError" class="anchor" title="Link to http2ConnectionError">#</a>
               </h3>
               
               <p>ConnectionError is an error that results in the termination of the
entire connection.</p>
               
               <pre><code>type http2ConnectionError http2ErrCode</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2ErrCode" data-name="http2ErrCode">
               <h3>
                  http2ErrCode
                  <span class="badge type-badge">type</span>
                  <a href="#http2ErrCode" class="anchor" title="Link to http2ErrCode">#</a>
               </h3>
               
               <p>An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.</p>
               
               <pre><code>type http2ErrCode uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2Flags" data-name="http2Flags">
               <h3>
                  http2Flags
                  <span class="badge type-badge">type</span>
                  <a href="#http2Flags" class="anchor" title="Link to http2Flags">#</a>
               </h3>
               
               <p>Flags is a bitmask of HTTP/2 flags.
The meaning of flags varies depending on the frame type.</p>
               
               <pre><code>type http2Flags uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2FrameType" data-name="http2FrameType">
               <h3>
                  http2FrameType
                  <span class="badge type-badge">type</span>
                  <a href="#http2FrameType" class="anchor" title="Link to http2FrameType">#</a>
               </h3>
               
               <p>A FrameType is a registered frame type as defined in
https://httpwg.org/specs/rfc7540.html#rfc.section.11.2</p>
               
               <pre><code>type http2FrameType uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2SettingID" data-name="http2SettingID">
               <h3>
                  http2SettingID
                  <span class="badge type-badge">type</span>
                  <a href="#http2SettingID" class="anchor" title="Link to http2SettingID">#</a>
               </h3>
               
               <p>A SettingID is an HTTP/2 setting as defined in
https://httpwg.org/specs/rfc7540.html#iana-settings</p>
               
               <pre><code>type http2SettingID uint16</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2WriteScheduler" data-name="http2WriteScheduler">
               <h3>
                  http2WriteScheduler
                  <span class="badge type-badge">type</span>
                  <a href="#http2WriteScheduler" class="anchor" title="Link to http2WriteScheduler">#</a>
               </h3>
               
               <pre><code>type http2WriteScheduler any</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2bufferedWriterTimeoutWriter" data-name="http2bufferedWriterTimeoutWriter">
               <h3>
                  http2bufferedWriterTimeoutWriter
                  <span class="badge type-badge">type</span>
                  <a href="#http2bufferedWriterTimeoutWriter" class="anchor" title="Link to http2bufferedWriterTimeoutWriter">#</a>
               </h3>
               
               <pre><code>type http2bufferedWriterTimeoutWriter http2bufferedWriter</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2closeWaiter" data-name="http2closeWaiter">
               <h3>
                  http2closeWaiter
                  <span class="badge type-badge">type</span>
                  <a href="#http2closeWaiter" class="anchor" title="Link to http2closeWaiter">#</a>
               </h3>
               
               <p>A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).</p>
               
               <pre><code>type http2closeWaiter chan struct{...}</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2duplicatePseudoHeaderError" data-name="http2duplicatePseudoHeaderError">
               <h3>
                  http2duplicatePseudoHeaderError
                  <span class="badge type-badge">type</span>
                  <a href="#http2duplicatePseudoHeaderError" class="anchor" title="Link to http2duplicatePseudoHeaderError">#</a>
               </h3>
               
               <pre><code>type http2duplicatePseudoHeaderError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2frameParser" data-name="http2frameParser">
               <h3>
                  http2frameParser
                  <span class="badge type-badge">type</span>
                  <a href="#http2frameParser" class="anchor" title="Link to http2frameParser">#</a>
               </h3>
               
               <p>a frameParser parses a frame given its FrameHeader and payload
bytes. The length of payload will always equal fh.Length (which
might be 0).</p>
               
               <pre><code>type http2frameParser func(fc *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2goroutineLock" data-name="http2goroutineLock">
               <h3>
                  http2goroutineLock
                  <span class="badge type-badge">type</span>
                  <a href="#http2goroutineLock" class="anchor" title="Link to http2goroutineLock">#</a>
               </h3>
               
               <pre><code>type http2goroutineLock uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2headerFieldNameError" data-name="http2headerFieldNameError">
               <h3>
                  http2headerFieldNameError
                  <span class="badge type-badge">type</span>
                  <a href="#http2headerFieldNameError" class="anchor" title="Link to http2headerFieldNameError">#</a>
               </h3>
               
               <pre><code>type http2headerFieldNameError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2headerFieldValueError" data-name="http2headerFieldValueError">
               <h3>
                  http2headerFieldValueError
                  <span class="badge type-badge">type</span>
                  <a href="#http2headerFieldValueError" class="anchor" title="Link to http2headerFieldValueError">#</a>
               </h3>
               
               <pre><code>type http2headerFieldValueError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2incomparable" data-name="http2incomparable">
               <h3>
                  http2incomparable
                  <span class="badge type-badge">type</span>
                  <a href="#http2incomparable" class="anchor" title="Link to http2incomparable">#</a>
               </h3>
               
               <p>incomparable is a zero-width, non-comparable type. Adding it to a struct
makes that struct also non-comparable, and generally doesn't add
any size (as long as it's first).</p>
               
               <pre><code>type http2incomparable [0]func()</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2priorityNodeState" data-name="http2priorityNodeState">
               <h3>
                  http2priorityNodeState
                  <span class="badge type-badge">type</span>
                  <a href="#http2priorityNodeState" class="anchor" title="Link to http2priorityNodeState">#</a>
               </h3>
               
               <pre><code>type http2priorityNodeState int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2pseudoHeaderError" data-name="http2pseudoHeaderError">
               <h3>
                  http2pseudoHeaderError
                  <span class="badge type-badge">type</span>
                  <a href="#http2pseudoHeaderError" class="anchor" title="Link to http2pseudoHeaderError">#</a>
               </h3>
               
               <pre><code>type http2pseudoHeaderError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2serverMessage" data-name="http2serverMessage">
               <h3>
                  http2serverMessage
                  <span class="badge type-badge">type</span>
                  <a href="#http2serverMessage" class="anchor" title="Link to http2serverMessage">#</a>
               </h3>
               
               <pre><code>type http2serverMessage int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2sortPriorityNodeSiblings" data-name="http2sortPriorityNodeSiblings">
               <h3>
                  http2sortPriorityNodeSiblings
                  <span class="badge type-badge">type</span>
                  <a href="#http2sortPriorityNodeSiblings" class="anchor" title="Link to http2sortPriorityNodeSiblings">#</a>
               </h3>
               
               <pre><code>type http2sortPriorityNodeSiblings []*http2priorityNode</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2streamState" data-name="http2streamState">
               <h3>
                  http2streamState
                  <span class="badge type-badge">type</span>
                  <a href="#http2streamState" class="anchor" title="Link to http2streamState">#</a>
               </h3>
               
               <pre><code>type http2streamState int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2unencryptedTransport" data-name="http2unencryptedTransport">
               <h3>
                  http2unencryptedTransport
                  <span class="badge type-badge">type</span>
                  <a href="#http2unencryptedTransport" class="anchor" title="Link to http2unencryptedTransport">#</a>
               </h3>
               
               <p>unencryptedTransport is a Transport with a RoundTrip method that
always permits http:// URLs.</p>
               
               <pre><code>type http2unencryptedTransport http2Transport</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2writeQueuePool" data-name="http2writeQueuePool">
               <h3>
                  http2writeQueuePool
                  <span class="badge type-badge">type</span>
                  <a href="#http2writeQueuePool" class="anchor" title="Link to http2writeQueuePool">#</a>
               </h3>
               
               <pre><code>type http2writeQueuePool []*http2writeQueue</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="http2writeSettings" data-name="http2writeSettings">
               <h3>
                  http2writeSettings
                  <span class="badge type-badge">type</span>
                  <a href="#http2writeSettings" class="anchor" title="Link to http2writeSettings">#</a>
               </h3>
               
               <pre><code>type http2writeSettings []http2Setting</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="incomparable" data-name="incomparable">
               <h3>
                  incomparable
                  <span class="badge type-badge">type</span>
                  <a href="#incomparable" class="anchor" title="Link to incomparable">#</a>
               </h3>
               
               <p>incomparable is a zero-width, non-comparable type. Adding it to a struct
makes that struct also non-comparable, and generally doesn't add
any size (as long as it's first).</p>
               
               <pre><code>type incomparable [0]func()</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="relationship" data-name="relationship">
               <h3>
                  relationship
                  <span class="badge type-badge">type</span>
                  <a href="#relationship" class="anchor" title="Link to relationship">#</a>
               </h3>
               
               <p>relationship is a relationship between two patterns, p1 and p2.</p>
               
               <pre><code>type relationship string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="socksAuthMethod" data-name="socksAuthMethod">
               <h3>
                  socksAuthMethod
                  <span class="badge type-badge">type</span>
                  <a href="#socksAuthMethod" class="anchor" title="Link to socksAuthMethod">#</a>
               </h3>
               
               <p>An AuthMethod represents a SOCKS authentication method.</p>
               
               <pre><code>type socksAuthMethod int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="socksCommand" data-name="socksCommand">
               <h3>
                  socksCommand
                  <span class="badge type-badge">type</span>
                  <a href="#socksCommand" class="anchor" title="Link to socksCommand">#</a>
               </h3>
               
               <p>A Command represents a SOCKS command.</p>
               
               <pre><code>type socksCommand int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="socksReply" data-name="socksReply">
               <h3>
                  socksReply
                  <span class="badge type-badge">type</span>
                  <a href="#socksReply" class="anchor" title="Link to socksReply">#</a>
               </h3>
               
               <p>A Reply represents a SOCKS command reply code.</p>
               
               <pre><code>type socksReply int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="CloseNotifier" data-name="CloseNotifier">
               <h3>
                  CloseNotifier
                  <span class="badge interface-badge">interface</span>
                  <a href="#CloseNotifier" class="anchor" title="Link to CloseNotifier">#</a>
               </h3>
               
               <p>The CloseNotifier interface is implemented by ResponseWriters which
allow detecting when the underlying connection has gone away.
This mechanism can be used to cancel long operations on the server
if the client has disconnected before the response is ready.
Deprecated: the CloseNotifier interface predates Go's context package.
New code should use [Request.Context] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type CloseNotifier interface {
CloseNotify() <-chan bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="CookieJar" data-name="CookieJar">
               <h3>
                  CookieJar
                  <span class="badge interface-badge">interface</span>
                  <a href="#CookieJar" class="anchor" title="Link to CookieJar">#</a>
               </h3>
               
               <p>A CookieJar manages storage and use of cookies in HTTP requests.
Implementations of CookieJar must be safe for concurrent use by multiple
goroutines.
The net/http/cookiejar package provides a CookieJar implementation.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type CookieJar interface {
SetCookies(u *url.URL, cookies []*Cookie)
Cookies(u *url.URL) []*Cookie
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge interface-badge">interface</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>A File is returned by a [FileSystem]'s Open method and can be
served by the [FileServer] implementation.
The methods should behave the same as those on an [*os.File].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type File interface {
io.Closer
io.Reader
io.Seeker
Readdir(count int) ([]fs.FileInfo, error)
Stat() (fs.FileInfo, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="FileSystem" data-name="FileSystem">
               <h3>
                  FileSystem
                  <span class="badge interface-badge">interface</span>
                  <a href="#FileSystem" class="anchor" title="Link to FileSystem">#</a>
               </h3>
               
               <p>A FileSystem implements access to a collection of named files.
The elements in a file path are separated by slash ('/', U+002F)
characters, regardless of host operating system convention.
See the [FileServer] function to convert a FileSystem to a [Handler].
This interface predates the [fs.FS] interface, which can be used instead:
the [FS] adapter function converts an fs.FS to a FileSystem.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type FileSystem interface {
Open(name string) (File, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Flusher" data-name="Flusher">
               <h3>
                  Flusher
                  <span class="badge interface-badge">interface</span>
                  <a href="#Flusher" class="anchor" title="Link to Flusher">#</a>
               </h3>
               
               <p>The Flusher interface is implemented by ResponseWriters that allow
an HTTP handler to flush buffered data to the client.
The default HTTP/1.x and HTTP/2 [ResponseWriter] implementations
support [Flusher], but ResponseWriter wrappers may not. Handlers
should always test for this ability at runtime.
Note that even for ResponseWriters that support Flush,
if the client is connected through an HTTP proxy,
the buffered data may not reach the client until the response
completes.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Flusher interface {
Flush()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Handler" data-name="Handler">
               <h3>
                  Handler
                  <span class="badge interface-badge">interface</span>
                  <a href="#Handler" class="anchor" title="Link to Handler">#</a>
               </h3>
               
               <p>A Handler responds to an HTTP request.
[Handler.ServeHTTP] should write reply headers and data to the [ResponseWriter]
and then return. Returning signals that the request is finished; it
is not valid to use the [ResponseWriter] or read from the
[Request.Body] after or concurrently with the completion of the
ServeHTTP call.
Depending on the HTTP client software, HTTP protocol version, and
any intermediaries between the client and the Go server, it may not
be possible to read from the [Request.Body] after writing to the
[ResponseWriter]. Cautious handlers should read the [Request.Body]
first, and then reply.
Except for reading the body, handlers should not modify the
provided Request.
If ServeHTTP panics, the server (the caller of ServeHTTP) assumes
that the effect of the panic was isolated to the active request.
It recovers the panic, logs a stack trace to the server error log,
and either closes the network connection or sends an HTTP/2
RST_STREAM, depending on the HTTP protocol. To abort a handler so
the client sees an interrupted response but the server doesn't log
an error, panic with the value [ErrAbortHandler].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Handler interface {
ServeHTTP(ResponseWriter, *Request)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Hijacker" data-name="Hijacker">
               <h3>
                  Hijacker
                  <span class="badge interface-badge">interface</span>
                  <a href="#Hijacker" class="anchor" title="Link to Hijacker">#</a>
               </h3>
               
               <p>The Hijacker interface is implemented by ResponseWriters that allow
an HTTP handler to take over the connection.
The default [ResponseWriter] for HTTP/1.x connections supports
Hijacker, but HTTP/2 connections intentionally do not.
ResponseWriter wrappers may also not support Hijacker. Handlers
should always test for this ability at runtime.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Hijacker interface {
Hijack() (net.Conn, *bufio.ReadWriter, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Pusher" data-name="Pusher">
               <h3>
                  Pusher
                  <span class="badge interface-badge">interface</span>
                  <a href="#Pusher" class="anchor" title="Link to Pusher">#</a>
               </h3>
               
               <p>Pusher is the interface implemented by ResponseWriters that support
HTTP/2 server push. For more background, see
https://tools.ietf.org/html/rfc7540#section-8.2.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Pusher interface {
Push(target string, opts *PushOptions) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ResponseWriter" data-name="ResponseWriter">
               <h3>
                  ResponseWriter
                  <span class="badge interface-badge">interface</span>
                  <a href="#ResponseWriter" class="anchor" title="Link to ResponseWriter">#</a>
               </h3>
               
               <p>A ResponseWriter interface is used by an HTTP handler to
construct an HTTP response.
A ResponseWriter may not be used after [Handler.ServeHTTP] has returned.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ResponseWriter interface {
Header() Header
Write([]byte) (int, error)
WriteHeader(statusCode int)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RoundTripper" data-name="RoundTripper">
               <h3>
                  RoundTripper
                  <span class="badge interface-badge">interface</span>
                  <a href="#RoundTripper" class="anchor" title="Link to RoundTripper">#</a>
               </h3>
               
               <p>RoundTripper is an interface representing the ability to execute a
single HTTP transaction, obtaining the [Response] for a given [Request].
A RoundTripper must be safe for concurrent use by multiple
goroutines.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RoundTripper interface {
RoundTrip(*Request) (*Response, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="anyDirs" data-name="anyDirs">
               <h3>
                  anyDirs
                  <span class="badge interface-badge">interface</span>
                  <a href="#anyDirs" class="anchor" title="Link to anyDirs">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type anyDirs interface {
len() int
name(i int) string
isDir(i int) bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="closeWriter" data-name="closeWriter">
               <h3>
                  closeWriter
                  <span class="badge interface-badge">interface</span>
                  <a href="#closeWriter" class="anchor" title="Link to closeWriter">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type closeWriter interface {
CloseWrite() error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="erringRoundTripper" data-name="erringRoundTripper">
               <h3>
                  erringRoundTripper
                  <span class="badge interface-badge">interface</span>
                  <a href="#erringRoundTripper" class="anchor" title="Link to erringRoundTripper">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type erringRoundTripper interface {
RoundTripErr() error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="h2Transport" data-name="h2Transport">
               <h3>
                  h2Transport
                  <span class="badge interface-badge">interface</span>
                  <a href="#h2Transport" class="anchor" title="Link to h2Transport">#</a>
               </h3>
               
               <p>h2Transport is the interface we expect to be able to call from
net/http against an *http2.Transport that's either bundled into
h2_bundle.go or supplied by the user via x/net/http2.
We name it with the "h2" prefix to stay out of the "http2" prefix
namespace used by x/tools/cmd/bundle for h2_bundle.go.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type h2Transport interface {
CloseIdleConnections()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2ClientConnPool" data-name="http2ClientConnPool">
               <h3>
                  http2ClientConnPool
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2ClientConnPool" class="anchor" title="Link to http2ClientConnPool">#</a>
               </h3>
               
               <p>ClientConnPool manages a pool of HTTP/2 client connections.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2ClientConnPool interface {
GetClientConn(req *Request, addr string) (*http2ClientConn, error)
MarkDead(*http2ClientConn)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2Frame" data-name="http2Frame">
               <h3>
                  http2Frame
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2Frame" class="anchor" title="Link to http2Frame">#</a>
               </h3>
               
               <p>A Frame is the base interface implemented by all frame types.
Callers will generally type-assert the specific frame type:
*HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
Frames are only valid until the next call to Framer.ReadFrame.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2Frame interface {
Header() http2FrameHeader
invalidate()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2WriteScheduler" data-name="http2WriteScheduler">
               <h3>
                  http2WriteScheduler
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2WriteScheduler" class="anchor" title="Link to http2WriteScheduler">#</a>
               </h3>
               
               <p>WriteScheduler is the interface implemented by HTTP/2 write schedulers.
Methods are never called concurrently.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2WriteScheduler interface {
OpenStream(streamID uint32, options http2OpenStreamOptions)
CloseStream(streamID uint32)
AdjustStream(streamID uint32, priority http2PriorityParam)
Push(wr http2FrameWriteRequest)
Pop() (wr http2FrameWriteRequest, ok bool)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2clientConnPoolIdleCloser" data-name="http2clientConnPoolIdleCloser">
               <h3>
                  http2clientConnPoolIdleCloser
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2clientConnPoolIdleCloser" class="anchor" title="Link to http2clientConnPoolIdleCloser">#</a>
               </h3>
               
               <p>clientConnPoolIdleCloser is the interface implemented by ClientConnPool
implementations which can close their idle connections.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2clientConnPoolIdleCloser interface {
http2ClientConnPool
closeIdleConnections()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2connectionStater" data-name="http2connectionStater">
               <h3>
                  http2connectionStater
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2connectionStater" class="anchor" title="Link to http2connectionStater">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2connectionStater interface {
ConnectionState() tls.ConnectionState
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2headersEnder" data-name="http2headersEnder">
               <h3>
                  http2headersEnder
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2headersEnder" class="anchor" title="Link to http2headersEnder">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2headersEnder interface {
HeadersEnded() bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2headersOrContinuation" data-name="http2headersOrContinuation">
               <h3>
                  http2headersOrContinuation
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2headersOrContinuation" class="anchor" title="Link to http2headersOrContinuation">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2headersOrContinuation interface {
http2headersEnder
HeaderBlockFragment() []byte
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2pipeBuffer" data-name="http2pipeBuffer">
               <h3>
                  http2pipeBuffer
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2pipeBuffer" class="anchor" title="Link to http2pipeBuffer">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2pipeBuffer interface {
Len() int
io.Writer
io.Reader
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2streamEnder" data-name="http2streamEnder">
               <h3>
                  http2streamEnder
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2streamEnder" class="anchor" title="Link to http2streamEnder">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2streamEnder interface {
StreamEnded() bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2stringWriter" data-name="http2stringWriter">
               <h3>
                  http2stringWriter
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2stringWriter" class="anchor" title="Link to http2stringWriter">#</a>
               </h3>
               
               <p>from pkg io</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2stringWriter interface {
WriteString(s string) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2synctestGroupInterface" data-name="http2synctestGroupInterface">
               <h3>
                  http2synctestGroupInterface
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2synctestGroupInterface" class="anchor" title="Link to http2synctestGroupInterface">#</a>
               </h3>
               
               <p>synctestGroupInterface is the methods of synctestGroup used by Server and Transport.
It's defined as an interface here to let us keep synctestGroup entirely test-only
and not a part of non-test builds.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2synctestGroupInterface interface {
Join()
Now() time.Time
NewTimer(d time.Duration) http2timer
AfterFunc(d time.Duration, f func()) http2timer
ContextWithTimeout(ctx context.Context, d time.Duration) (context.Context, context.CancelFunc)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2timer" data-name="http2timer">
               <h3>
                  http2timer
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2timer" class="anchor" title="Link to http2timer">#</a>
               </h3>
               
               <p>A timer is a time.Timer, as an interface which can be replaced in tests.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2timer interface {
C() <-chan time.Time
Reset(d time.Duration) bool
Stop() bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2writeContext" data-name="http2writeContext">
               <h3>
                  http2writeContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2writeContext" class="anchor" title="Link to http2writeContext">#</a>
               </h3>
               
               <p>writeContext is the interface needed by the various frame writer
types below. All the writeFrame methods below are scheduled via the
frame writing scheduler (see writeScheduler in writesched.go).
This interface is implemented by *serverConn.
TODO: decide whether to a) use this in the client code (which didn't
end up using this yet, because it has a simpler design, not
currently implementing priorities), or b) delete this and
make the server code a bit more concrete.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2writeContext interface {
Framer() *http2Framer
Flush() error
CloseConn() error
HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="http2writeFramer" data-name="http2writeFramer">
               <h3>
                  http2writeFramer
                  <span class="badge interface-badge">interface</span>
                  <a href="#http2writeFramer" class="anchor" title="Link to http2writeFramer">#</a>
               </h3>
               
               <p>writeFramer is implemented by any type that is used to write frames.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type http2writeFramer interface {
writeFrame(http2writeContext) error
staysWithinBuffer(size int) bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="rwUnwrapper" data-name="rwUnwrapper">
               <h3>
                  rwUnwrapper
                  <span class="badge interface-badge">interface</span>
                  <a href="#rwUnwrapper" class="anchor" title="Link to rwUnwrapper">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type rwUnwrapper interface {
Unwrap() ResponseWriter
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="sniffSig" data-name="sniffSig">
               <h3>
                  sniffSig
                  <span class="badge interface-badge">interface</span>
                  <a href="#sniffSig" class="anchor" title="Link to sniffSig">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type sniffSig interface {
match(data []byte, firstNonWS int) string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Client" data-name="Client">
               <h3>
                  Client
                  <span class="badge">struct</span>
                  <a href="#Client" class="anchor" title="Link to Client">#</a>
               </h3>
               
               <p>A Client is an HTTP client. Its zero value ([DefaultClient]) is a
usable client that uses [DefaultTransport].
The [Client.Transport] typically has internal state (cached TCP
connections), so Clients should be reused instead of created as
needed. Clients are safe for concurrent use by multiple goroutines.
A Client is higher-level than a [RoundTripper] (such as [Transport])
and additionally handles HTTP details such as cookies and
redirects.
When following redirects, the Client will forward all headers set on the
initial [Request] except:
- when forwarding sensitive headers like "Authorization",
"WWW-Authenticate", and "Cookie" to untrusted targets.
These headers will be ignored when following a redirect to a domain
that is not a subdomain match or exact match of the initial domain.
For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
will forward the sensitive headers, but a redirect to "bar.com" will not.
- when forwarding the "Cookie" header with a non-nil cookie Jar.
Since each redirect may mutate the state of the cookie jar,
a redirect may possibly alter a cookie set in the initial request.
When forwarding the "Cookie" header, any mutated cookies will be omitted,
with the expectation that the Jar will insert those mutated cookies
with the updated values (assuming the origin matches).
If Jar is nil, the initial cookies are forwarded without change.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Client struct {
Transport RoundTripper
CheckRedirect func(req *Request, via []*Request) error
Jar CookieJar
Timeout time.Duration
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Cookie" data-name="Cookie">
               <h3>
                  Cookie
                  <span class="badge">struct</span>
                  <a href="#Cookie" class="anchor" title="Link to Cookie">#</a>
               </h3>
               
               <p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an
HTTP response or the Cookie header of an HTTP request.
See https://tools.ietf.org/html/rfc6265 for details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Cookie struct {
Name string
Value string
Quoted bool
Path string
Domain string
Expires time.Time
RawExpires string
MaxAge int
Secure bool
HttpOnly bool
SameSite SameSite
Partitioned bool
Raw string
Unparsed []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="HTTP2Config" data-name="HTTP2Config">
               <h3>
                  HTTP2Config
                  <span class="badge">struct</span>
                  <a href="#HTTP2Config" class="anchor" title="Link to HTTP2Config">#</a>
               </h3>
               
               <p>HTTP2Config defines HTTP/2 configuration parameters common to
both [Transport] and [Server].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type HTTP2Config struct {
MaxConcurrentStreams int
MaxDecoderHeaderTableSize int
MaxEncoderHeaderTableSize int
MaxReadFrameSize int
MaxReceiveBufferPerConnection int
MaxReceiveBufferPerStream int
SendPingTimeout time.Duration
PingTimeout time.Duration
WriteByteTimeout time.Duration
PermitProhibitedCipherSuites bool
CountError func(errType string)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MaxBytesError" data-name="MaxBytesError">
               <h3>
                  MaxBytesError
                  <span class="badge">struct</span>
                  <a href="#MaxBytesError" class="anchor" title="Link to MaxBytesError">#</a>
               </h3>
               
               <p>MaxBytesError is returned by [MaxBytesReader] when its read limit is exceeded.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MaxBytesError struct {
Limit int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ProtocolError" data-name="ProtocolError">
               <h3>
                  ProtocolError
                  <span class="badge">struct</span>
                  <a href="#ProtocolError" class="anchor" title="Link to ProtocolError">#</a>
               </h3>
               
               <p>ProtocolError represents an HTTP protocol error.
Deprecated: Not all errors in the http package related to protocol errors
are of type ProtocolError.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ProtocolError struct {
ErrorString string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Protocols" data-name="Protocols">
               <h3>
                  Protocols
                  <span class="badge">struct</span>
                  <a href="#Protocols" class="anchor" title="Link to Protocols">#</a>
               </h3>
               
               <p>Protocols is a set of HTTP protocols.
The zero value is an empty set of protocols.
The supported protocols are:
- HTTP1 is the HTTP/1.0 and HTTP/1.1 protocols.
HTTP1 is supported on both unsecured TCP and secured TLS connections.
- HTTP2 is the HTTP/2 protcol over a TLS connection.
- UnencryptedHTTP2 is the HTTP/2 protocol over an unsecured TCP connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Protocols struct {
bits uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PushOptions" data-name="PushOptions">
               <h3>
                  PushOptions
                  <span class="badge">struct</span>
                  <a href="#PushOptions" class="anchor" title="Link to PushOptions">#</a>
               </h3>
               
               <p>PushOptions describes options for [Pusher.Push].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PushOptions struct {
Method string
Header Header
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Request" data-name="Request">
               <h3>
                  Request
                  <span class="badge">struct</span>
                  <a href="#Request" class="anchor" title="Link to Request">#</a>
               </h3>
               
               <p>A Request represents an HTTP request received by a server
or to be sent by a client.
The field semantics differ slightly between client and server
usage. In addition to the notes on the fields below, see the
documentation for [Request.Write] and [RoundTripper].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Request struct {
Method string
URL *url.URL
Proto string
ProtoMajor int
ProtoMinor int
Header Header
Body io.ReadCloser
GetBody func() (io.ReadCloser, error)
ContentLength int64
TransferEncoding []string
Close bool
Host string
Form url.Values
PostForm url.Values
MultipartForm *multipart.Form
Trailer Header
RemoteAddr string
RequestURI string
TLS *tls.ConnectionState
Cancel <-chan struct{...}
Response *Response
Pattern string
ctx context.Context
pat *pattern
matches []string
otherValues map[string]string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Response" data-name="Response">
               <h3>
                  Response
                  <span class="badge">struct</span>
                  <a href="#Response" class="anchor" title="Link to Response">#</a>
               </h3>
               
               <p>Response represents the response from an HTTP request.
The [Client] and [Transport] return Responses from servers once
the response headers have been received. The response body
is streamed on demand as the Body field is read.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Response struct {
Status string
StatusCode int
Proto string
ProtoMajor int
ProtoMinor int
Header Header
Body io.ReadCloser
ContentLength int64
TransferEncoding []string
Close bool
Uncompressed bool
Trailer Header
Request *Request
TLS *tls.ConnectionState
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ResponseController" data-name="ResponseController">
               <h3>
                  ResponseController
                  <span class="badge">struct</span>
                  <a href="#ResponseController" class="anchor" title="Link to ResponseController">#</a>
               </h3>
               
               <p>A ResponseController is used by an HTTP handler to control the response.
A ResponseController may not be used after the [Handler.ServeHTTP] method has returned.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ResponseController struct {
rw ResponseWriter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ServeMux" data-name="ServeMux">
               <h3>
                  ServeMux
                  <span class="badge">struct</span>
                  <a href="#ServeMux" class="anchor" title="Link to ServeMux">#</a>
               </h3>
               
               <p>ServeMux is an HTTP request multiplexer.
It matches the URL of each incoming request against a list of registered
patterns and calls the handler for the pattern that
most closely matches the URL.
# Patterns
Patterns can match the method, host and path of a request.
Some examples:
- "/index.html" matches the path "/index.html" for any host and method.
- "GET /static/" matches a GET request whose path begins with "/static/".
- "example.com/" matches any request to the host "example.com".
- "example.com/{$}" matches requests with host "example.com" and path "/".
- "/b/{bucket}/o/{objectname...}" matches paths whose first segment is "b"
and whose third segment is "o". The name "bucket" denotes the second
segment and "objectname" denotes the remainder of the path.
In general, a pattern looks like
[METHOD ][HOST]/[PATH]
All three parts are optional; "/" is a valid pattern.
If METHOD is present, it must be followed by at least one space or tab.
Literal (that is, non-wildcard) parts of a pattern match
the corresponding parts of a request case-sensitively.
A pattern with no method matches every method. A pattern
with the method GET matches both GET and HEAD requests.
Otherwise, the method must match exactly.
A pattern with no host matches every host.
A pattern with a host matches URLs on that host only.
A path can include wildcard segments of the form {NAME} or {NAME...}.
For example, "/b/{bucket}/o/{objectname...}".
The wildcard name must be a valid Go identifier.
Wildcards must be full path segments: they must be preceded by a slash and followed by
either a slash or the end of the string.
For example, "/b_{bucket}" is not a valid pattern.
Normally a wildcard matches only a single path segment,
ending at the next literal slash (not %2F) in the request URL.
But if the "..." is present, then the wildcard matches the remainder of the URL path, including slashes.
(Therefore it is invalid for a "..." wildcard to appear anywhere but at the end of a pattern.)
The match for a wildcard can be obtained by calling [Request.PathValue] with the wildcard's name.
A trailing slash in a path acts as an anonymous "..." wildcard.
The special wildcard {$} matches only the end of the URL.
For example, the pattern "/{$}" matches only the path "/",
whereas the pattern "/" matches every path.
For matching, both pattern paths and incoming request paths are unescaped segment by segment.
So, for example, the path "/a%2Fb/100%25" is treated as having two segments, "a/b" and "100%".
The pattern "/a%2fb/" matches it, but the pattern "/a/b/" does not.
# Precedence
If two or more patterns match a request, then the most specific pattern takes precedence.
A pattern P1 is more specific than P2 if P1 matches a strict subset of P2’s requests;
that is, if P2 matches all the requests of P1 and more.
If neither is more specific, then the patterns conflict.
There is one exception to this rule, for backwards compatibility:
if two patterns would otherwise conflict and one has a host while the other does not,
then the pattern with the host takes precedence.
If a pattern passed to [ServeMux.Handle] or [ServeMux.HandleFunc] conflicts with
another pattern that is already registered, those functions panic.
As an example of the general rule, "/images/thumbnails/" is more specific than "/images/",
so both can be registered.
The former matches paths beginning with "/images/thumbnails/"
and the latter will match any other path in the "/images/" subtree.
As another example, consider the patterns "GET /" and "/index.html":
both match a GET request for "/index.html", but the former pattern
matches all other GET and HEAD requests, while the latter matches any
request for "/index.html" that uses a different method.
The patterns conflict.
# Trailing-slash redirection
Consider a [ServeMux] with a handler for a subtree, registered using a trailing slash or "..." wildcard.
If the ServeMux receives a request for the subtree root without a trailing slash,
it redirects the request by adding the trailing slash.
This behavior can be overridden with a separate registration for the path without
the trailing slash or "..." wildcard. For example, registering "/images/" causes ServeMux
to redirect a request for "/images" to "/images/", unless "/images" has
been registered separately.
# Request sanitizing
ServeMux also takes care of sanitizing the URL request path and the Host
header, stripping the port number and redirecting any request containing . or
.. segments or repeated slashes to an equivalent, cleaner URL.
Escaped path elements such as "%2e" for "." and "%2f" for "/" are preserved
and aren't considered separators for request routing.
# Compatibility
The pattern syntax and matching behavior of ServeMux changed significantly
in Go 1.22. To restore the old behavior, set the GODEBUG environment variable
to "httpmuxgo121=1". This setting is read once, at program startup; changes
during execution will be ignored.
The backwards-incompatible changes include:
- Wildcards are just ordinary literal path segments in 1.21.
For example, the pattern "/{x}" will match only that path in 1.21,
but will match any one-segment path in 1.22.
- In 1.21, no pattern was rejected, unless it was empty or conflicted with an existing pattern.
In 1.22, syntactically invalid patterns will cause [ServeMux.Handle] and [ServeMux.HandleFunc] to panic.
For example, in 1.21, the patterns "/{"  and "/a{x}" match themselves,
but in 1.22 they are invalid and will cause a panic when registered.
- In 1.22, each segment of a pattern is unescaped; this was not done in 1.21.
For example, in 1.22 the pattern "/%61" matches the path "/a" ("%61" being the URL escape sequence for "a"),
but in 1.21 it would match only the path "/%2561" (where "%25" is the escape for the percent sign).
- When matching patterns to paths, in 1.22 each segment of the path is unescaped; in 1.21, the entire path is unescaped.
This change mostly affects how paths with %2F escapes adjacent to slashes are treated.
See https://go.dev/issue/21955 for details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ServeMux struct {
mu sync.RWMutex
tree routingNode
index routingIndex
mux121 serveMux121
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Server" data-name="Server">
               <h3>
                  Server
                  <span class="badge">struct</span>
                  <a href="#Server" class="anchor" title="Link to Server">#</a>
               </h3>
               
               <p>A Server defines parameters for running an HTTP server.
The zero value for Server is a valid configuration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Server struct {
Addr string
Handler Handler
DisableGeneralOptionsHandler bool
TLSConfig *tls.Config
ReadTimeout time.Duration
ReadHeaderTimeout time.Duration
WriteTimeout time.Duration
IdleTimeout time.Duration
MaxHeaderBytes int
TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
ConnState func(net.Conn, ConnState)
ErrorLog *log.Logger
BaseContext func(net.Listener) context.Context
ConnContext func(ctx context.Context, c net.Conn) context.Context
HTTP2 *HTTP2Config
Protocols *Protocols
inShutdown atomic.Bool
disableKeepAlives atomic.Bool
nextProtoOnce sync.Once
nextProtoErr error
mu sync.Mutex
listeners map[*net.Listener]struct{...}
activeConn map[*conn]struct{...}
onShutdown []func()
listenerGroup sync.WaitGroup
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Transport" data-name="Transport">
               <h3>
                  Transport
                  <span class="badge">struct</span>
                  <a href="#Transport" class="anchor" title="Link to Transport">#</a>
               </h3>
               
               <p>Transport is an implementation of [RoundTripper] that supports HTTP,
HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).
By default, Transport caches connections for future re-use.
This may leave many open connections when accessing many hosts.
This behavior can be managed using [Transport.CloseIdleConnections] method
and the [Transport.MaxIdleConnsPerHost] and [Transport.DisableKeepAlives] fields.
Transports should be reused instead of created as needed.
Transports are safe for concurrent use by multiple goroutines.
A Transport is a low-level primitive for making HTTP and HTTPS requests.
For high-level functionality, such as cookies and redirects, see [Client].
Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2
for HTTPS URLs, depending on whether the server supports HTTP/2,
and how the Transport is configured. The [DefaultTransport] supports HTTP/2.
To explicitly enable HTTP/2 on a transport, set [Transport.Protocols].
Responses with status codes in the 1xx range are either handled
automatically (100 expect-continue) or ignored. The one
exception is HTTP status code 101 (Switching Protocols), which is
considered a terminal status and returned by [Transport.RoundTrip]. To see the
ignored 1xx responses, use the httptrace trace package's
ClientTrace.Got1xxResponse.
Transport only retries a request upon encountering a network error
if the connection has been already been used successfully and if the
request is idempotent and either has no body or has its [Request.GetBody]
defined. HTTP requests are considered idempotent if they have HTTP methods
GET, HEAD, OPTIONS, or TRACE; or if their [Header] map contains an
"Idempotency-Key" or "X-Idempotency-Key" entry. If the idempotency key
value is a zero-length slice, the request is treated as idempotent but the
header is not sent on the wire.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Transport struct {
idleMu sync.Mutex
closeIdle bool
idleConn map[connectMethodKey][]*persistConn
idleConnWait map[connectMethodKey]wantConnQueue
idleLRU connLRU
reqMu sync.Mutex
reqCanceler map[*Request]context.CancelCauseFunc
altMu sync.Mutex
altProto atomic.Value
connsPerHostMu sync.Mutex
connsPerHost map[connectMethodKey]int
connsPerHostWait map[connectMethodKey]wantConnQueue
dialsInProgress wantConnQueue
Proxy func(*Request) (*url.URL, error)
OnProxyConnectResponse func(ctx context.Context, proxyURL *url.URL, connectReq *Request, connectRes *Response) error
DialContext func(ctx context.Context, network string, addr string) (net.Conn, error)
Dial func(network string, addr string) (net.Conn, error)
DialTLSContext func(ctx context.Context, network string, addr string) (net.Conn, error)
DialTLS func(network string, addr string) (net.Conn, error)
TLSClientConfig *tls.Config
TLSHandshakeTimeout time.Duration
DisableKeepAlives bool
DisableCompression bool
MaxIdleConns int
MaxIdleConnsPerHost int
MaxConnsPerHost int
IdleConnTimeout time.Duration
ResponseHeaderTimeout time.Duration
ExpectContinueTimeout time.Duration
TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper
ProxyConnectHeader Header
GetProxyConnectHeader func(ctx context.Context, proxyURL *url.URL, target string) (Header, error)
MaxResponseHeaderBytes int64
WriteBufferSize int
ReadBufferSize int
nextProtoOnce sync.Once
h2transport h2Transport
tlsNextProtoWasNil bool
ForceAttemptHTTP2 bool
HTTP2 *HTTP2Config
Protocols *Protocols
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="arrayReader" data-name="arrayReader">
               <h3>
                  arrayReader
                  <span class="badge">struct</span>
                  <a href="#arrayReader" class="anchor" title="Link to arrayReader">#</a>
               </h3>
               
               <p>arrayReader implements an io.ReadCloser wrapper for ArrayBuffer.
https://developer.mozilla.org/en-US/docs/Web/API/Body/arrayBuffer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type arrayReader struct {
arrayPromise js.Value
pending []byte
read bool
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="body" data-name="body">
               <h3>
                  body
                  <span class="badge">struct</span>
                  <a href="#body" class="anchor" title="Link to body">#</a>
               </h3>
               
               <p>body turns a Reader into a ReadCloser.
Close ensures that the body has been fully read
and then reads the trailer if necessary.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type body struct {
src io.Reader
hdr any
r *bufio.Reader
closing bool
doEarlyClose bool
mu sync.Mutex
sawEOF bool
closed bool
earlyClose bool
onHitEOF func()
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bodyEOFSignal" data-name="bodyEOFSignal">
               <h3>
                  bodyEOFSignal
                  <span class="badge">struct</span>
                  <a href="#bodyEOFSignal" class="anchor" title="Link to bodyEOFSignal">#</a>
               </h3>
               
               <p>bodyEOFSignal is used by the HTTP/1 transport when reading response
bodies to make sure we see the end of a response body before
proceeding and reading on the connection again.
It wraps a ReadCloser but runs fn (if non-nil) at most
once, right before its final (error-producing) Read or Close call
returns. fn should return the new error to return from Read or Close.
If earlyCloseFn is non-nil and Close is called before io.EOF is
seen, earlyCloseFn is called instead of fn, and its return value is
the return value from Close.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bodyEOFSignal struct {
body io.ReadCloser
mu sync.Mutex
closed bool
rerr error
fn func(error) error
earlyCloseFn func() error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bodyLocked" data-name="bodyLocked">
               <h3>
                  bodyLocked
                  <span class="badge">struct</span>
                  <a href="#bodyLocked" class="anchor" title="Link to bodyLocked">#</a>
               </h3>
               
               <p>bodyLocked is an io.Reader reading from a *body when its mutex is
already held.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bodyLocked struct {
b *body
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bufioFlushWriter" data-name="bufioFlushWriter">
               <h3>
                  bufioFlushWriter
                  <span class="badge">struct</span>
                  <a href="#bufioFlushWriter" class="anchor" title="Link to bufioFlushWriter">#</a>
               </h3>
               
               <p>bufioFlushWriter is an io.Writer wrapper that flushes all writes
on its wrapped writer if it's a *bufio.Writer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bufioFlushWriter struct {
w io.Writer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="byteReader" data-name="byteReader">
               <h3>
                  byteReader
                  <span class="badge">struct</span>
                  <a href="#byteReader" class="anchor" title="Link to byteReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type byteReader struct {
b byte
done bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cancelTimerBody" data-name="cancelTimerBody">
               <h3>
                  cancelTimerBody
                  <span class="badge">struct</span>
                  <a href="#cancelTimerBody" class="anchor" title="Link to cancelTimerBody">#</a>
               </h3>
               
               <p>cancelTimerBody is an io.ReadCloser that wraps rc with two features:
1. On Read error or close, the stop func is called.
2. On Read failure, if reqDidTimeout is true, the error is wrapped and
marked as net.Error that hit its timeout.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cancelTimerBody struct {
stop func()
rc io.ReadCloser
reqDidTimeout func() bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="checkConnErrorWriter" data-name="checkConnErrorWriter">
               <h3>
                  checkConnErrorWriter
                  <span class="badge">struct</span>
                  <a href="#checkConnErrorWriter" class="anchor" title="Link to checkConnErrorWriter">#</a>
               </h3>
               
               <p>checkConnErrorWriter writes to c.rwc and records any write errors to c.werr.
It only contains one field (and a pointer field at that), so it
fits in an interface value without an extra allocation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type checkConnErrorWriter struct {
c *conn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="chunkWriter" data-name="chunkWriter">
               <h3>
                  chunkWriter
                  <span class="badge">struct</span>
                  <a href="#chunkWriter" class="anchor" title="Link to chunkWriter">#</a>
               </h3>
               
               <p>chunkWriter writes to a response's conn buffer, and is the writer
wrapped by the response.w buffered writer.
chunkWriter also is responsible for finalizing the Header, including
conditionally setting the Content-Type and setting a Content-Length
in cases where the handler's final output is smaller than the buffer
size. It also conditionally adds chunk headers, when in chunking mode.
See the comment above (*response).Write for the entire write flow.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type chunkWriter struct {
res *response
header Header
wroteHeader bool
chunking bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="conn" data-name="conn">
               <h3>
                  conn
                  <span class="badge">struct</span>
                  <a href="#conn" class="anchor" title="Link to conn">#</a>
               </h3>
               
               <p>A conn represents the server side of an HTTP connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type conn struct {
server *Server
cancelCtx context.CancelFunc
rwc net.Conn
remoteAddr string
tlsState *tls.ConnectionState
werr error
r *connReader
bufr *bufio.Reader
bufw *bufio.Writer
lastMethod string
curReq *ast.IndexExpr
curState atomic.Uint64
mu sync.Mutex
hijackedv bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="connLRU" data-name="connLRU">
               <h3>
                  connLRU
                  <span class="badge">struct</span>
                  <a href="#connLRU" class="anchor" title="Link to connLRU">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connLRU struct {
ll *list.List
m map[*persistConn]*list.Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="connOrError" data-name="connOrError">
               <h3>
                  connOrError
                  <span class="badge">struct</span>
                  <a href="#connOrError" class="anchor" title="Link to connOrError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connOrError struct {
pc *persistConn
err error
idleAt time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="connReader" data-name="connReader">
               <h3>
                  connReader
                  <span class="badge">struct</span>
                  <a href="#connReader" class="anchor" title="Link to connReader">#</a>
               </h3>
               
               <p>connReader is the io.Reader wrapper used by *conn. It combines a
selectively-activated io.LimitedReader (to bound request header
read sizes) with support for selectively keeping an io.Reader.Read
call blocked in a background goroutine to wait for activity and
trigger a CloseNotifier channel.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connReader struct {
conn *conn
mu sync.Mutex
hasByte bool
byteBuf [1]byte
cond *sync.Cond
inRead bool
aborted bool
remain int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="connectMethod" data-name="connectMethod">
               <h3>
                  connectMethod
                  <span class="badge">struct</span>
                  <a href="#connectMethod" class="anchor" title="Link to connectMethod">#</a>
               </h3>
               
               <p>connectMethod is the map key (in its String form) for keeping persistent
TCP connections alive for subsequent HTTP requests.
A connect method may be of the following types:
connectMethod.key().String()      Description
------------------------------    -------------------------
|http|foo.com                     http directly to server, no proxy
|https|foo.com                    https directly to server, no proxy
|https,h1|foo.com                 https directly to server w/o HTTP/2, no proxy
http://proxy.com|https|foo.com    http to proxy, then CONNECT to foo.com
http://proxy.com|http             http to proxy, http to anywhere after that
socks5://proxy.com|http|foo.com   socks5 to proxy, then http to foo.com
socks5://proxy.com|https|foo.com  socks5 to proxy, then https to foo.com
https://proxy.com|https|foo.com   https to proxy, then CONNECT to foo.com
https://proxy.com|http            https to proxy, http to anywhere after that</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connectMethod struct {
_ incomparable
proxyURL *url.URL
targetScheme string
targetAddr string
onlyH1 bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="connectMethodKey" data-name="connectMethodKey">
               <h3>
                  connectMethodKey
                  <span class="badge">struct</span>
                  <a href="#connectMethodKey" class="anchor" title="Link to connectMethodKey">#</a>
               </h3>
               
               <p>connectMethodKey is the map key version of connectMethod, with a
stringified proxy URL (or the empty string) instead of a pointer to
a URL.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connectMethodKey struct {
proxy string
scheme string
addr string
onlyH1 bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="contextKey" data-name="contextKey">
               <h3>
                  contextKey
                  <span class="badge">struct</span>
                  <a href="#contextKey" class="anchor" title="Link to contextKey">#</a>
               </h3>
               
               <p>contextKey is a value for use with context.WithValue. It's used as
a pointer so it fits in an interface{} without allocation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type contextKey struct {
name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="entry" data-name="entry">
               <h3>
                  entry
                  <span class="badge">struct</span>
                  <a href="#entry" class="anchor" title="Link to entry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type entry struct {
key K
value V
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="errorReader" data-name="errorReader">
               <h3>
                  errorReader
                  <span class="badge">struct</span>
                  <a href="#errorReader" class="anchor" title="Link to errorReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type errorReader struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="exactSig" data-name="exactSig">
               <h3>
                  exactSig
                  <span class="badge">struct</span>
                  <a href="#exactSig" class="anchor" title="Link to exactSig">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type exactSig struct {
sig []byte
ct string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="expectContinueReader" data-name="expectContinueReader">
               <h3>
                  expectContinueReader
                  <span class="badge">struct</span>
                  <a href="#expectContinueReader" class="anchor" title="Link to expectContinueReader">#</a>
               </h3>
               
               <p>wrapper around io.ReadCloser which on first read, sends an
HTTP/1.1 100 Continue header</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type expectContinueReader struct {
resp *response
readCloser io.ReadCloser
closed atomic.Bool
sawEOF atomic.Bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="extraHeader" data-name="extraHeader">
               <h3>
                  extraHeader
                  <span class="badge">struct</span>
                  <a href="#extraHeader" class="anchor" title="Link to extraHeader">#</a>
               </h3>
               
               <p>extraHeader is the set of headers sometimes added by chunkWriter.writeHeader.
This type is used to avoid extra allocations from cloning and/or populating
the response Header map and all its 1-element slices.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type extraHeader struct {
contentType string
connection string
transferEncoding string
date []byte
contentLength []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fakeLocker" data-name="fakeLocker">
               <h3>
                  fakeLocker
                  <span class="badge">struct</span>
                  <a href="#fakeLocker" class="anchor" title="Link to fakeLocker">#</a>
               </h3>
               
               <p>fakeLocker is a sync.Locker which does nothing. It's used to guard
test-only fields when not under test, to avoid runtime atomic
overhead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fakeLocker struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileHandler" data-name="fileHandler">
               <h3>
                  fileHandler
                  <span class="badge">struct</span>
                  <a href="#fileHandler" class="anchor" title="Link to fileHandler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileHandler struct {
root FileSystem
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileTransport" data-name="fileTransport">
               <h3>
                  fileTransport
                  <span class="badge">struct</span>
                  <a href="#fileTransport" class="anchor" title="Link to fileTransport">#</a>
               </h3>
               
               <p>fileTransport implements RoundTripper for the 'file' protocol.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileTransport struct {
fh fileHandler
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="finishAsyncByteRead" data-name="finishAsyncByteRead">
               <h3>
                  finishAsyncByteRead
                  <span class="badge">struct</span>
                  <a href="#finishAsyncByteRead" class="anchor" title="Link to finishAsyncByteRead">#</a>
               </h3>
               
               <p>finishAsyncByteRead finishes reading the 1-byte sniff
from the ContentLength==0, Body!=nil case.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type finishAsyncByteRead struct {
tw *transferWriter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="globalOptionsHandler" data-name="globalOptionsHandler">
               <h3>
                  globalOptionsHandler
                  <span class="badge">struct</span>
                  <a href="#globalOptionsHandler" class="anchor" title="Link to globalOptionsHandler">#</a>
               </h3>
               
               <p>globalOptionsHandler responds to "OPTIONS *" requests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type globalOptionsHandler struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gzipReader" data-name="gzipReader">
               <h3>
                  gzipReader
                  <span class="badge">struct</span>
                  <a href="#gzipReader" class="anchor" title="Link to gzipReader">#</a>
               </h3>
               
               <p>gzipReader wraps a response body so it can lazily
call gzip.NewReader on the first call to Read</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gzipReader struct {
_ incomparable
body *bodyEOFSignal
zr *gzip.Reader
zerr error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="headerSorter" data-name="headerSorter">
               <h3>
                  headerSorter
                  <span class="badge">struct</span>
                  <a href="#headerSorter" class="anchor" title="Link to headerSorter">#</a>
               </h3>
               
               <p>headerSorter contains a slice of keyValues sorted by keyValues.key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type headerSorter struct {
kvs []keyValues
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2ClientConn" data-name="http2ClientConn">
               <h3>
                  http2ClientConn
                  <span class="badge">struct</span>
                  <a href="#http2ClientConn" class="anchor" title="Link to http2ClientConn">#</a>
               </h3>
               
               <p>ClientConn is the state of a single HTTP/2 client connection to an
HTTP/2 server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2ClientConn struct {
t *http2Transport
tconn net.Conn
tlsState *tls.ConnectionState
atomicReused uint32
singleUse bool
getConnCalled bool
readerDone chan struct{...}
readerErr error
idleTimeout time.Duration
idleTimer http2timer
mu sync.Mutex
cond *sync.Cond
flow http2outflow
inflow http2inflow
doNotReuse bool
closing bool
closed bool
seenSettings bool
seenSettingsChan chan struct{...}
wantSettingsAck bool
goAway *http2GoAwayFrame
goAwayDebug string
streams map[uint32]*http2clientStream
streamsReserved int
nextStreamID uint32
pendingRequests int
pings map[[8]byte]chan struct{...}
br *bufio.Reader
lastActive time.Time
lastIdle time.Time
maxFrameSize uint32
maxConcurrentStreams uint32
peerMaxHeaderListSize uint64
peerMaxHeaderTableSize uint32
initialWindowSize uint32
initialStreamRecvWindowSize int32
readIdleTimeout time.Duration
pingTimeout time.Duration
extendedConnectAllowed bool
rstStreamPingsBlocked bool
pendingResets int
reqHeaderMu chan struct{...}
wmu sync.Mutex
bw *bufio.Writer
fr *http2Framer
werr error
hbuf bytes.Buffer
henc *hpack.Encoder
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2ClientConnState" data-name="http2ClientConnState">
               <h3>
                  http2ClientConnState
                  <span class="badge">struct</span>
                  <a href="#http2ClientConnState" class="anchor" title="Link to http2ClientConnState">#</a>
               </h3>
               
               <p>ClientConnState describes the state of a ClientConn.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2ClientConnState struct {
Closed bool
Closing bool
StreamsActive int
StreamsReserved int
StreamsPending int
MaxConcurrentStreams uint32
LastIdle time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2ContinuationFrame" data-name="http2ContinuationFrame">
               <h3>
                  http2ContinuationFrame
                  <span class="badge">struct</span>
                  <a href="#http2ContinuationFrame" class="anchor" title="Link to http2ContinuationFrame">#</a>
               </h3>
               
               <p>A ContinuationFrame is used to continue a sequence of header block fragments.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.10</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2ContinuationFrame struct {
http2FrameHeader
headerFragBuf []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2DataFrame" data-name="http2DataFrame">
               <h3>
                  http2DataFrame
                  <span class="badge">struct</span>
                  <a href="#http2DataFrame" class="anchor" title="Link to http2DataFrame">#</a>
               </h3>
               
               <p>A DataFrame conveys arbitrary, variable-length sequences of octets
associated with a stream.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.1</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2DataFrame struct {
http2FrameHeader
data []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2FrameHeader" data-name="http2FrameHeader">
               <h3>
                  http2FrameHeader
                  <span class="badge">struct</span>
                  <a href="#http2FrameHeader" class="anchor" title="Link to http2FrameHeader">#</a>
               </h3>
               
               <p>A FrameHeader is the 9 byte header of all HTTP/2 frames.
See https://httpwg.org/specs/rfc7540.html#FrameHeader</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2FrameHeader struct {
valid bool
Type http2FrameType
Flags http2Flags
Length uint32
StreamID uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2FrameWriteRequest" data-name="http2FrameWriteRequest">
               <h3>
                  http2FrameWriteRequest
                  <span class="badge">struct</span>
                  <a href="#http2FrameWriteRequest" class="anchor" title="Link to http2FrameWriteRequest">#</a>
               </h3>
               
               <p>FrameWriteRequest is a request to write a frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2FrameWriteRequest struct {
write http2writeFramer
stream *http2stream
done chan error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2Framer" data-name="http2Framer">
               <h3>
                  http2Framer
                  <span class="badge">struct</span>
                  <a href="#http2Framer" class="anchor" title="Link to http2Framer">#</a>
               </h3>
               
               <p>A Framer reads and writes Frames.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2Framer struct {
r io.Reader
lastFrame http2Frame
errDetail error
countError func(errToken string)
lastHeaderStream uint32
maxReadSize uint32
headerBuf [http2frameHeaderLen]byte
getReadBuf func(size uint32) []byte
readBuf []byte
maxWriteSize uint32
w io.Writer
wbuf []byte
AllowIllegalWrites bool
AllowIllegalReads bool
ReadMetaHeaders *hpack.Decoder
MaxHeaderListSize uint32
logReads bool
logWrites bool
debugFramer *http2Framer
debugFramerBuf *bytes.Buffer
debugReadLoggerf func(string, ...interface{})
debugWriteLoggerf func(string, ...interface{})
frameCache *http2frameCache
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2GoAwayError" data-name="http2GoAwayError">
               <h3>
                  http2GoAwayError
                  <span class="badge">struct</span>
                  <a href="#http2GoAwayError" class="anchor" title="Link to http2GoAwayError">#</a>
               </h3>
               
               <p>GoAwayError is returned by the Transport when the server closes the
TCP connection after sending a GOAWAY frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2GoAwayError struct {
LastStreamID uint32
ErrCode http2ErrCode
DebugData string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2GoAwayFrame" data-name="http2GoAwayFrame">
               <h3>
                  http2GoAwayFrame
                  <span class="badge">struct</span>
                  <a href="#http2GoAwayFrame" class="anchor" title="Link to http2GoAwayFrame">#</a>
               </h3>
               
               <p>A GoAwayFrame informs the remote peer to stop creating streams on this connection.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.8</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2GoAwayFrame struct {
http2FrameHeader
LastStreamID uint32
ErrCode http2ErrCode
debugData []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2HeadersFrame" data-name="http2HeadersFrame">
               <h3>
                  http2HeadersFrame
                  <span class="badge">struct</span>
                  <a href="#http2HeadersFrame" class="anchor" title="Link to http2HeadersFrame">#</a>
               </h3>
               
               <p>A HeadersFrame is used to open a stream and additionally carries a
header block fragment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2HeadersFrame struct {
http2FrameHeader
Priority http2PriorityParam
headerFragBuf []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2HeadersFrameParam" data-name="http2HeadersFrameParam">
               <h3>
                  http2HeadersFrameParam
                  <span class="badge">struct</span>
                  <a href="#http2HeadersFrameParam" class="anchor" title="Link to http2HeadersFrameParam">#</a>
               </h3>
               
               <p>HeadersFrameParam are the parameters for writing a HEADERS frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2HeadersFrameParam struct {
StreamID uint32
BlockFragment []byte
EndStream bool
EndHeaders bool
PadLength uint8
Priority http2PriorityParam
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2MetaHeadersFrame" data-name="http2MetaHeadersFrame">
               <h3>
                  http2MetaHeadersFrame
                  <span class="badge">struct</span>
                  <a href="#http2MetaHeadersFrame" class="anchor" title="Link to http2MetaHeadersFrame">#</a>
               </h3>
               
               <p>A MetaHeadersFrame is the representation of one HEADERS frame and
zero or more contiguous CONTINUATION frames and the decoding of
their HPACK-encoded contents.
This type of frame does not appear on the wire and is only returned
by the Framer when Framer.ReadMetaHeaders is set.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2MetaHeadersFrame struct {
*http2HeadersFrame
Fields []hpack.HeaderField
Truncated bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2OpenStreamOptions" data-name="http2OpenStreamOptions">
               <h3>
                  http2OpenStreamOptions
                  <span class="badge">struct</span>
                  <a href="#http2OpenStreamOptions" class="anchor" title="Link to http2OpenStreamOptions">#</a>
               </h3>
               
               <p>OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2OpenStreamOptions struct {
PusherID uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2PingFrame" data-name="http2PingFrame">
               <h3>
                  http2PingFrame
                  <span class="badge">struct</span>
                  <a href="#http2PingFrame" class="anchor" title="Link to http2PingFrame">#</a>
               </h3>
               
               <p>A PingFrame is a mechanism for measuring a minimal round trip time
from the sender, as well as determining whether an idle connection
is still functional.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.7</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2PingFrame struct {
http2FrameHeader
Data [8]byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2PriorityFrame" data-name="http2PriorityFrame">
               <h3>
                  http2PriorityFrame
                  <span class="badge">struct</span>
                  <a href="#http2PriorityFrame" class="anchor" title="Link to http2PriorityFrame">#</a>
               </h3>
               
               <p>A PriorityFrame specifies the sender-advised priority of a stream.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.3</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2PriorityFrame struct {
http2FrameHeader
http2PriorityParam
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2PriorityParam" data-name="http2PriorityParam">
               <h3>
                  http2PriorityParam
                  <span class="badge">struct</span>
                  <a href="#http2PriorityParam" class="anchor" title="Link to http2PriorityParam">#</a>
               </h3>
               
               <p>PriorityParam are the stream prioritzation parameters.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2PriorityParam struct {
StreamDep uint32
Exclusive bool
Weight uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2PriorityWriteSchedulerConfig" data-name="http2PriorityWriteSchedulerConfig">
               <h3>
                  http2PriorityWriteSchedulerConfig
                  <span class="badge">struct</span>
                  <a href="#http2PriorityWriteSchedulerConfig" class="anchor" title="Link to http2PriorityWriteSchedulerConfig">#</a>
               </h3>
               
               <p>PriorityWriteSchedulerConfig configures a priorityWriteScheduler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2PriorityWriteSchedulerConfig struct {
MaxClosedNodesInTree int
MaxIdleNodesInTree int
ThrottleOutOfOrderWrites bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2PushPromiseFrame" data-name="http2PushPromiseFrame">
               <h3>
                  http2PushPromiseFrame
                  <span class="badge">struct</span>
                  <a href="#http2PushPromiseFrame" class="anchor" title="Link to http2PushPromiseFrame">#</a>
               </h3>
               
               <p>A PushPromiseFrame is used to initiate a server stream.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.6</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2PushPromiseFrame struct {
http2FrameHeader
PromiseID uint32
headerFragBuf []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2PushPromiseParam" data-name="http2PushPromiseParam">
               <h3>
                  http2PushPromiseParam
                  <span class="badge">struct</span>
                  <a href="#http2PushPromiseParam" class="anchor" title="Link to http2PushPromiseParam">#</a>
               </h3>
               
               <p>PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2PushPromiseParam struct {
StreamID uint32
PromiseID uint32
BlockFragment []byte
EndHeaders bool
PadLength uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2RSTStreamFrame" data-name="http2RSTStreamFrame">
               <h3>
                  http2RSTStreamFrame
                  <span class="badge">struct</span>
                  <a href="#http2RSTStreamFrame" class="anchor" title="Link to http2RSTStreamFrame">#</a>
               </h3>
               
               <p>A RSTStreamFrame allows for abnormal termination of a stream.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.4</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2RSTStreamFrame struct {
http2FrameHeader
ErrCode http2ErrCode
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2RoundTripOpt" data-name="http2RoundTripOpt">
               <h3>
                  http2RoundTripOpt
                  <span class="badge">struct</span>
                  <a href="#http2RoundTripOpt" class="anchor" title="Link to http2RoundTripOpt">#</a>
               </h3>
               
               <p>RoundTripOpt are options for the Transport.RoundTripOpt method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2RoundTripOpt struct {
OnlyCachedConn bool
allowHTTP bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2ServeConnOpts" data-name="http2ServeConnOpts">
               <h3>
                  http2ServeConnOpts
                  <span class="badge">struct</span>
                  <a href="#http2ServeConnOpts" class="anchor" title="Link to http2ServeConnOpts">#</a>
               </h3>
               
               <p>ServeConnOpts are options for the Server.ServeConn method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2ServeConnOpts struct {
Context context.Context
BaseConfig *Server
Handler Handler
UpgradeRequest *Request
Settings []byte
SawClientPreface bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2Server" data-name="http2Server">
               <h3>
                  http2Server
                  <span class="badge">struct</span>
                  <a href="#http2Server" class="anchor" title="Link to http2Server">#</a>
               </h3>
               
               <p>Server is an HTTP/2 server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2Server struct {
MaxHandlers int
MaxConcurrentStreams uint32
MaxDecoderHeaderTableSize uint32
MaxEncoderHeaderTableSize uint32
MaxReadFrameSize uint32
PermitProhibitedCipherSuites bool
IdleTimeout time.Duration
ReadIdleTimeout time.Duration
PingTimeout time.Duration
WriteByteTimeout time.Duration
MaxUploadBufferPerConnection int32
MaxUploadBufferPerStream int32
NewWriteScheduler func() http2WriteScheduler
CountError func(errType string)
state *http2serverInternalState
group http2synctestGroupInterface
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2Server" data-name="http2Server">
               <h3>
                  http2Server
                  <span class="badge">struct</span>
                  <a href="#http2Server" class="anchor" title="Link to http2Server">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2Server struct {
NewWriteScheduler func() http2WriteScheduler
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2Setting" data-name="http2Setting">
               <h3>
                  http2Setting
                  <span class="badge">struct</span>
                  <a href="#http2Setting" class="anchor" title="Link to http2Setting">#</a>
               </h3>
               
               <p>Setting is a setting parameter: which setting it is, and its value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2Setting struct {
ID http2SettingID
Val uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2SettingsFrame" data-name="http2SettingsFrame">
               <h3>
                  http2SettingsFrame
                  <span class="badge">struct</span>
                  <a href="#http2SettingsFrame" class="anchor" title="Link to http2SettingsFrame">#</a>
               </h3>
               
               <p>A SettingsFrame conveys configuration parameters that affect how
endpoints communicate, such as preferences and constraints on peer
behavior.
See https://httpwg.org/specs/rfc7540.html#SETTINGS</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2SettingsFrame struct {
http2FrameHeader
p []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2StreamError" data-name="http2StreamError">
               <h3>
                  http2StreamError
                  <span class="badge">struct</span>
                  <a href="#http2StreamError" class="anchor" title="Link to http2StreamError">#</a>
               </h3>
               
               <p>StreamError is an error that only affects one stream within an
HTTP/2 connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2StreamError struct {
StreamID uint32
Code http2ErrCode
Cause error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2Transport" data-name="http2Transport">
               <h3>
                  http2Transport
                  <span class="badge">struct</span>
                  <a href="#http2Transport" class="anchor" title="Link to http2Transport">#</a>
               </h3>
               
               <p>Transport is an HTTP/2 Transport.
A Transport internally caches connections to servers. It is safe
for concurrent use by multiple goroutines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2Transport struct {
DialTLSContext func(ctx context.Context, network string, addr string, cfg *tls.Config) (net.Conn, error)
DialTLS func(network string, addr string, cfg *tls.Config) (net.Conn, error)
TLSClientConfig *tls.Config
ConnPool http2ClientConnPool
DisableCompression bool
AllowHTTP bool
MaxHeaderListSize uint32
MaxReadFrameSize uint32
MaxDecoderHeaderTableSize uint32
MaxEncoderHeaderTableSize uint32
StrictMaxConcurrentStreams bool
IdleConnTimeout time.Duration
ReadIdleTimeout time.Duration
PingTimeout time.Duration
WriteByteTimeout time.Duration
CountError func(errType string)
t1 *Transport
connPoolOnce sync.Once
connPoolOrDef http2ClientConnPool
*http2transportTestHooks
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2Transport" data-name="http2Transport">
               <h3>
                  http2Transport
                  <span class="badge">struct</span>
                  <a href="#http2Transport" class="anchor" title="Link to http2Transport">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2Transport struct {
MaxHeaderListSize uint32
ConnPool any
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2UnknownFrame" data-name="http2UnknownFrame">
               <h3>
                  http2UnknownFrame
                  <span class="badge">struct</span>
                  <a href="#http2UnknownFrame" class="anchor" title="Link to http2UnknownFrame">#</a>
               </h3>
               
               <p>An UnknownFrame is the frame type returned when the frame type is unknown
or no specific frame type parser exists.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2UnknownFrame struct {
http2FrameHeader
p []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2WindowUpdateFrame" data-name="http2WindowUpdateFrame">
               <h3>
                  http2WindowUpdateFrame
                  <span class="badge">struct</span>
                  <a href="#http2WindowUpdateFrame" class="anchor" title="Link to http2WindowUpdateFrame">#</a>
               </h3>
               
               <p>A WindowUpdateFrame is used to implement flow control.
See https://httpwg.org/specs/rfc7540.html#rfc.section.6.9</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2WindowUpdateFrame struct {
http2FrameHeader
Increment uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2addConnCall" data-name="http2addConnCall">
               <h3>
                  http2addConnCall
                  <span class="badge">struct</span>
                  <a href="#http2addConnCall" class="anchor" title="Link to http2addConnCall">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2addConnCall struct {
_ http2incomparable
p *http2clientConnPool
done chan struct{...}
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2bodyReadMsg" data-name="http2bodyReadMsg">
               <h3>
                  http2bodyReadMsg
                  <span class="badge">struct</span>
                  <a href="#http2bodyReadMsg" class="anchor" title="Link to http2bodyReadMsg">#</a>
               </h3>
               
               <p>A bodyReadMsg tells the server loop that the http.Handler read n
bytes of the DATA from the client on the given stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2bodyReadMsg struct {
st *http2stream
n int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2bufferedWriter" data-name="http2bufferedWriter">
               <h3>
                  http2bufferedWriter
                  <span class="badge">struct</span>
                  <a href="#http2bufferedWriter" class="anchor" title="Link to http2bufferedWriter">#</a>
               </h3>
               
               <p>bufferedWriter is a buffered writer that writes to w.
Its buffered writer is lazily allocated as needed, to minimize
idle memory usage with many connections.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2bufferedWriter struct {
_ http2incomparable
group http2synctestGroupInterface
conn net.Conn
bw *bufio.Writer
byteTimeout time.Duration
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2chunkWriter" data-name="http2chunkWriter">
               <h3>
                  http2chunkWriter
                  <span class="badge">struct</span>
                  <a href="#http2chunkWriter" class="anchor" title="Link to http2chunkWriter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2chunkWriter struct {
rws *http2responseWriterState
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientConn" data-name="http2clientConn">
               <h3>
                  http2clientConn
                  <span class="badge">struct</span>
                  <a href="#http2clientConn" class="anchor" title="Link to http2clientConn">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientConn struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientConnIdleState" data-name="http2clientConnIdleState">
               <h3>
                  http2clientConnIdleState
                  <span class="badge">struct</span>
                  <a href="#http2clientConnIdleState" class="anchor" title="Link to http2clientConnIdleState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientConnIdleState struct {
canTakeNewRequest bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientConnIdleState" data-name="http2clientConnIdleState">
               <h3>
                  http2clientConnIdleState
                  <span class="badge">struct</span>
                  <a href="#http2clientConnIdleState" class="anchor" title="Link to http2clientConnIdleState">#</a>
               </h3>
               
               <p>clientConnIdleState describes the suitability of a client
connection to initiate a new RoundTrip request.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientConnIdleState struct {
canTakeNewRequest bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientConnPool" data-name="http2clientConnPool">
               <h3>
                  http2clientConnPool
                  <span class="badge">struct</span>
                  <a href="#http2clientConnPool" class="anchor" title="Link to http2clientConnPool">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientConnPool struct {
mu *sync.Mutex
conns map[string][]*http2clientConn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientConnPool" data-name="http2clientConnPool">
               <h3>
                  http2clientConnPool
                  <span class="badge">struct</span>
                  <a href="#http2clientConnPool" class="anchor" title="Link to http2clientConnPool">#</a>
               </h3>
               
               <p>TODO: use singleflight for dialing and addConnCalls?</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientConnPool struct {
t *http2Transport
mu sync.Mutex
conns map[string][]*http2ClientConn
dialing map[string]*http2dialCall
keys map[*http2ClientConn][]string
addConnCalls map[string]*http2addConnCall
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientConnReadLoop" data-name="http2clientConnReadLoop">
               <h3>
                  http2clientConnReadLoop
                  <span class="badge">struct</span>
                  <a href="#http2clientConnReadLoop" class="anchor" title="Link to http2clientConnReadLoop">#</a>
               </h3>
               
               <p>clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientConnReadLoop struct {
_ http2incomparable
cc *http2ClientConn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2clientStream" data-name="http2clientStream">
               <h3>
                  http2clientStream
                  <span class="badge">struct</span>
                  <a href="#http2clientStream" class="anchor" title="Link to http2clientStream">#</a>
               </h3>
               
               <p>clientStream is the state for a single HTTP/2 stream. One of these
is created for each Transport.RoundTrip call.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2clientStream struct {
cc *http2ClientConn
ctx context.Context
reqCancel <-chan struct{...}
trace *httptrace.ClientTrace
ID uint32
bufPipe http2pipe
requestedGzip bool
isHead bool
abortOnce sync.Once
abort chan struct{...}
abortErr error
peerClosed chan struct{...}
donec chan struct{...}
on100 chan struct{...}
respHeaderRecv chan struct{...}
res *Response
flow http2outflow
inflow http2inflow
bytesRemain int64
readErr error
reqBody io.ReadCloser
reqBodyContentLength int64
reqBodyClosed chan struct{...}
sentEndStream bool
sentHeaders bool
firstByte bool
pastHeaders bool
pastTrailers bool
readClosed bool
readAborted bool
totalHeaderSize int64
trailer Header
resTrailer *Header
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2connError" data-name="http2connError">
               <h3>
                  http2connError
                  <span class="badge">struct</span>
                  <a href="#http2connError" class="anchor" title="Link to http2connError">#</a>
               </h3>
               
               <p>connError represents an HTTP/2 ConnectionError error code, along
with a string (for debugging) explaining why.
Errors of this type are only returned by the frame parser functions
and converted into ConnectionError(Code), after stashing away
the Reason into the Framer's errDetail field, accessible via
the (*Framer).ErrorDetail method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2connError struct {
Code http2ErrCode
Reason string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2dataBuffer" data-name="http2dataBuffer">
               <h3>
                  http2dataBuffer
                  <span class="badge">struct</span>
                  <a href="#http2dataBuffer" class="anchor" title="Link to http2dataBuffer">#</a>
               </h3>
               
               <p>dataBuffer is an io.ReadWriter backed by a list of data chunks.
Each dataBuffer is used to read DATA frames on a single stream.
The buffer is divided into chunks so the server can limit the
total memory used by a single connection without limiting the
request body size on any single stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2dataBuffer struct {
chunks [][]byte
r int
w int
size int
expected int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2dialCall" data-name="http2dialCall">
               <h3>
                  http2dialCall
                  <span class="badge">struct</span>
                  <a href="#http2dialCall" class="anchor" title="Link to http2dialCall">#</a>
               </h3>
               
               <p>dialCall is an in-flight Transport dial call to a host.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2dialCall struct {
_ http2incomparable
p *http2clientConnPool
ctx context.Context
done chan struct{...}
res *http2ClientConn
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2erringRoundTripper" data-name="http2erringRoundTripper">
               <h3>
                  http2erringRoundTripper
                  <span class="badge">struct</span>
                  <a href="#http2erringRoundTripper" class="anchor" title="Link to http2erringRoundTripper">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2erringRoundTripper struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2errorReader" data-name="http2errorReader">
               <h3>
                  http2errorReader
                  <span class="badge">struct</span>
                  <a href="#http2errorReader" class="anchor" title="Link to http2errorReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2errorReader struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2flushFrameWriter" data-name="http2flushFrameWriter">
               <h3>
                  http2flushFrameWriter
                  <span class="badge">struct</span>
                  <a href="#http2flushFrameWriter" class="anchor" title="Link to http2flushFrameWriter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2flushFrameWriter struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2frameCache" data-name="http2frameCache">
               <h3>
                  http2frameCache
                  <span class="badge">struct</span>
                  <a href="#http2frameCache" class="anchor" title="Link to http2frameCache">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2frameCache struct {
dataFrame http2DataFrame
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2frameWriteResult" data-name="http2frameWriteResult">
               <h3>
                  http2frameWriteResult
                  <span class="badge">struct</span>
                  <a href="#http2frameWriteResult" class="anchor" title="Link to http2frameWriteResult">#</a>
               </h3>
               
               <p>frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2frameWriteResult struct {
_ http2incomparable
wr http2FrameWriteRequest
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2goAwayFlowError" data-name="http2goAwayFlowError">
               <h3>
                  http2goAwayFlowError
                  <span class="badge">struct</span>
                  <a href="#http2goAwayFlowError" class="anchor" title="Link to http2goAwayFlowError">#</a>
               </h3>
               
               <p>6.9.1 The Flow Control Window
"If a sender receives a WINDOW_UPDATE that causes a flow control
window to exceed this maximum it MUST terminate either the stream
or the connection, as appropriate. For streams, [...]; for the
connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2goAwayFlowError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2gzipReader" data-name="http2gzipReader">
               <h3>
                  http2gzipReader
                  <span class="badge">struct</span>
                  <a href="#http2gzipReader" class="anchor" title="Link to http2gzipReader">#</a>
               </h3>
               
               <p>gzipReader wraps a response body so it can lazily
call gzip.NewReader on the first call to Read</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2gzipReader struct {
_ http2incomparable
body io.ReadCloser
zr *gzip.Reader
zerr error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2handlerPanicRST" data-name="http2handlerPanicRST">
               <h3>
                  http2handlerPanicRST
                  <span class="badge">struct</span>
                  <a href="#http2handlerPanicRST" class="anchor" title="Link to http2handlerPanicRST">#</a>
               </h3>
               
               <p>handlerPanicRST is the message sent from handler goroutines when
the handler panics.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2handlerPanicRST struct {
StreamID uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2http2Config" data-name="http2http2Config">
               <h3>
                  http2http2Config
                  <span class="badge">struct</span>
                  <a href="#http2http2Config" class="anchor" title="Link to http2http2Config">#</a>
               </h3>
               
               <p>http2Config is a package-internal version of net/http.HTTP2Config.
http.HTTP2Config was added in Go 1.24.
When running with a version of net/http that includes HTTP2Config,
we merge the configuration with the fields in Transport or Server
to produce an http2Config.
Zero valued fields in http2Config are interpreted as in the
net/http.HTTPConfig documentation.
Precedence order for reconciling configurations is:
- Use the net/http.{Server,Transport}.HTTP2Config value, when non-zero.
- Otherwise use the http2.{Server.Transport} value.
- If the resulting value is zero or out of range, use a default.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2http2Config struct {
MaxConcurrentStreams uint32
MaxDecoderHeaderTableSize uint32
MaxEncoderHeaderTableSize uint32
MaxReadFrameSize uint32
MaxUploadBufferPerConnection int32
MaxUploadBufferPerStream int32
SendPingTimeout time.Duration
PingTimeout time.Duration
WriteByteTimeout time.Duration
PermitProhibitedCipherSuites bool
CountError func(errType string)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2httpError" data-name="http2httpError">
               <h3>
                  http2httpError
                  <span class="badge">struct</span>
                  <a href="#http2httpError" class="anchor" title="Link to http2httpError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2httpError struct {
_ http2incomparable
msg string
timeout bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2inflow" data-name="http2inflow">
               <h3>
                  http2inflow
                  <span class="badge">struct</span>
                  <a href="#http2inflow" class="anchor" title="Link to http2inflow">#</a>
               </h3>
               
               <p>inflow accounts for an inbound flow control window.
It tracks both the latest window sent to the peer (used for enforcement)
and the accumulated unsent window.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2inflow struct {
avail int32
unsent int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2missingBody" data-name="http2missingBody">
               <h3>
                  http2missingBody
                  <span class="badge">struct</span>
                  <a href="#http2missingBody" class="anchor" title="Link to http2missingBody">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2missingBody struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noBodyReader" data-name="http2noBodyReader">
               <h3>
                  http2noBodyReader
                  <span class="badge">struct</span>
                  <a href="#http2noBodyReader" class="anchor" title="Link to http2noBodyReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noBodyReader struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noCachedConnError" data-name="http2noCachedConnError">
               <h3>
                  http2noCachedConnError
                  <span class="badge">struct</span>
                  <a href="#http2noCachedConnError" class="anchor" title="Link to http2noCachedConnError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noCachedConnError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noCachedConnError" data-name="http2noCachedConnError">
               <h3>
                  http2noCachedConnError
                  <span class="badge">struct</span>
                  <a href="#http2noCachedConnError" class="anchor" title="Link to http2noCachedConnError">#</a>
               </h3>
               
               <p>noCachedConnError is the concrete type of ErrNoCachedConn, which
needs to be detected by net/http regardless of whether it's its
bundled version (in h2_bundle.go with a rewritten type name) or
from a user's x/net/http2. As such, as it has a unique method name
(IsHTTP2NoCachedConnError) that net/http sniffs for via func
isNoCachedConnError.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noCachedConnError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noDialClientConnPool" data-name="http2noDialClientConnPool">
               <h3>
                  http2noDialClientConnPool
                  <span class="badge">struct</span>
                  <a href="#http2noDialClientConnPool" class="anchor" title="Link to http2noDialClientConnPool">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noDialClientConnPool struct {
http2clientConnPool http2clientConnPool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noDialClientConnPool" data-name="http2noDialClientConnPool">
               <h3>
                  http2noDialClientConnPool
                  <span class="badge">struct</span>
                  <a href="#http2noDialClientConnPool" class="anchor" title="Link to http2noDialClientConnPool">#</a>
               </h3>
               
               <p>noDialClientConnPool is an implementation of http2.ClientConnPool
which never dials. We let the HTTP/1.1 client dial and use its TLS
connection instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noDialClientConnPool struct {
*http2clientConnPool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noDialH2RoundTripper" data-name="http2noDialH2RoundTripper">
               <h3>
                  http2noDialH2RoundTripper
                  <span class="badge">struct</span>
                  <a href="#http2noDialH2RoundTripper" class="anchor" title="Link to http2noDialH2RoundTripper">#</a>
               </h3>
               
               <p>noDialH2RoundTripper is a RoundTripper which only tries to complete the request
if there's already has a cached connection to the host.
(The field is exported so it can be accessed via reflect from net/http; tested
by TestNoDialH2RoundTripperType)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noDialH2RoundTripper struct {
*http2Transport
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2noDialH2RoundTripper" data-name="http2noDialH2RoundTripper">
               <h3>
                  http2noDialH2RoundTripper
                  <span class="badge">struct</span>
                  <a href="#http2noDialH2RoundTripper" class="anchor" title="Link to http2noDialH2RoundTripper">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2noDialH2RoundTripper struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2outflow" data-name="http2outflow">
               <h3>
                  http2outflow
                  <span class="badge">struct</span>
                  <a href="#http2outflow" class="anchor" title="Link to http2outflow">#</a>
               </h3>
               
               <p>outflow is the outbound flow control window's size.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2outflow struct {
_ http2incomparable
n int32
conn *http2outflow
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2pipe" data-name="http2pipe">
               <h3>
                  http2pipe
                  <span class="badge">struct</span>
                  <a href="#http2pipe" class="anchor" title="Link to http2pipe">#</a>
               </h3>
               
               <p>pipe is a goroutine-safe io.Reader/io.Writer pair. It's like
io.Pipe except there are no PipeReader/PipeWriter halves, and the
underlying buffer is an interface. (io.Pipe is always unbuffered)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2pipe struct {
mu sync.Mutex
c sync.Cond
b http2pipeBuffer
unread int
err error
breakErr error
donec chan struct{...}
readFn func()
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2priorityNode" data-name="http2priorityNode">
               <h3>
                  http2priorityNode
                  <span class="badge">struct</span>
                  <a href="#http2priorityNode" class="anchor" title="Link to http2priorityNode">#</a>
               </h3>
               
               <p>priorityNode is a node in an HTTP/2 priority tree.
Each node is associated with a single stream ID.
See RFC 7540, Section 5.3.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2priorityNode struct {
q http2writeQueue
id uint32
weight uint8
state http2priorityNodeState
bytes int64
subtreeBytes int64
parent *http2priorityNode
kids *http2priorityNode
prev *http2priorityNode
next *http2priorityNode
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2priorityWriteScheduler" data-name="http2priorityWriteScheduler">
               <h3>
                  http2priorityWriteScheduler
                  <span class="badge">struct</span>
                  <a href="#http2priorityWriteScheduler" class="anchor" title="Link to http2priorityWriteScheduler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2priorityWriteScheduler struct {
root http2priorityNode
nodes map[uint32]*http2priorityNode
maxID uint32
closedNodes []*http2priorityNode
idleNodes []*http2priorityNode
maxClosedNodesInTree int
maxIdleNodesInTree int
writeThrottleLimit int32
enableWriteThrottle bool
tmp []*http2priorityNode
queuePool http2writeQueuePool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2randomWriteScheduler" data-name="http2randomWriteScheduler">
               <h3>
                  http2randomWriteScheduler
                  <span class="badge">struct</span>
                  <a href="#http2randomWriteScheduler" class="anchor" title="Link to http2randomWriteScheduler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2randomWriteScheduler struct {
zero http2writeQueue
sq map[uint32]*http2writeQueue
queuePool http2writeQueuePool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2readFrameResult" data-name="http2readFrameResult">
               <h3>
                  http2readFrameResult
                  <span class="badge">struct</span>
                  <a href="#http2readFrameResult" class="anchor" title="Link to http2readFrameResult">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2readFrameResult struct {
f http2Frame
err error
readMore func()
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2requestBody" data-name="http2requestBody">
               <h3>
                  http2requestBody
                  <span class="badge">struct</span>
                  <a href="#http2requestBody" class="anchor" title="Link to http2requestBody">#</a>
               </h3>
               
               <p>requestBody is the Handler's Request.Body type.
Read and Close may be called concurrently.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2requestBody struct {
_ http2incomparable
stream *http2stream
conn *http2serverConn
closeOnce sync.Once
sawEOF bool
pipe *http2pipe
needsContinue bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2requestParam" data-name="http2requestParam">
               <h3>
                  http2requestParam
                  <span class="badge">struct</span>
                  <a href="#http2requestParam" class="anchor" title="Link to http2requestParam">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2requestParam struct {
method string
scheme string
authority string
path string
protocol string
header Header
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2resAndError" data-name="http2resAndError">
               <h3>
                  http2resAndError
                  <span class="badge">struct</span>
                  <a href="#http2resAndError" class="anchor" title="Link to http2resAndError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2resAndError struct {
_ http2incomparable
res *Response
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2responseWriter" data-name="http2responseWriter">
               <h3>
                  http2responseWriter
                  <span class="badge">struct</span>
                  <a href="#http2responseWriter" class="anchor" title="Link to http2responseWriter">#</a>
               </h3>
               
               <p>responseWriter is the http.ResponseWriter implementation. It's
intentionally small (1 pointer wide) to minimize garbage. The
responseWriterState pointer inside is zeroed at the end of a
request (in handlerDone) and calls on the responseWriter thereafter
simply crash (caller's mistake), but the much larger responseWriterState
and buffers are reused between multiple requests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2responseWriter struct {
rws *http2responseWriterState
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2responseWriterState" data-name="http2responseWriterState">
               <h3>
                  http2responseWriterState
                  <span class="badge">struct</span>
                  <a href="#http2responseWriterState" class="anchor" title="Link to http2responseWriterState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2responseWriterState struct {
stream *http2stream
req *Request
conn *http2serverConn
bw *bufio.Writer
handlerHeader Header
snapHeader Header
trailers []string
status int
wroteHeader bool
sentHeader bool
handlerDone bool
sentContentLen int64
wroteBytes int64
closeNotifierMu sync.Mutex
closeNotifierCh chan bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2roundRobinWriteScheduler" data-name="http2roundRobinWriteScheduler">
               <h3>
                  http2roundRobinWriteScheduler
                  <span class="badge">struct</span>
                  <a href="#http2roundRobinWriteScheduler" class="anchor" title="Link to http2roundRobinWriteScheduler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2roundRobinWriteScheduler struct {
control http2writeQueue
streams map[uint32]*http2writeQueue
head *http2writeQueue
queuePool http2writeQueuePool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2serverConn" data-name="http2serverConn">
               <h3>
                  http2serverConn
                  <span class="badge">struct</span>
                  <a href="#http2serverConn" class="anchor" title="Link to http2serverConn">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2serverConn struct {
srv *http2Server
hs *Server
conn net.Conn
bw *http2bufferedWriter
handler Handler
baseCtx context.Context
framer *http2Framer
doneServing chan struct{...}
readFrameCh chan http2readFrameResult
wantWriteFrameCh chan http2FrameWriteRequest
wroteFrameCh chan http2frameWriteResult
bodyReadCh chan http2bodyReadMsg
serveMsgCh chan interface{}
flow http2outflow
inflow http2inflow
tlsState *tls.ConnectionState
remoteAddrStr string
writeSched http2WriteScheduler
countErrorFunc func(errType string)
serveG http2goroutineLock
pushEnabled bool
sawClientPreface bool
sawFirstSettings bool
needToSendSettingsAck bool
unackedSettings int
queuedControlFrames int
clientMaxStreams uint32
advMaxStreams uint32
curClientStreams uint32
curPushedStreams uint32
curHandlers uint32
maxClientStreamID uint32
maxPushPromiseID uint32
streams map[uint32]*http2stream
unstartedHandlers []http2unstartedHandler
initialStreamSendWindowSize int32
initialStreamRecvWindowSize int32
maxFrameSize int32
peerMaxHeaderListSize uint32
canonHeader map[string]string
canonHeaderKeysSize int
writingFrame bool
writingFrameAsync bool
needsFrameFlush bool
inGoAway bool
inFrameScheduleLoop bool
needToSendGoAway bool
pingSent bool
sentPingData [8]byte
goAwayCode http2ErrCode
shutdownTimer http2timer
idleTimer http2timer
readIdleTimeout time.Duration
pingTimeout time.Duration
readIdleTimer http2timer
headerWriteBuf bytes.Buffer
hpackEncoder *hpack.Encoder
shutdownOnce sync.Once
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2serverInternalState" data-name="http2serverInternalState">
               <h3>
                  http2serverInternalState
                  <span class="badge">struct</span>
                  <a href="#http2serverInternalState" class="anchor" title="Link to http2serverInternalState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2serverInternalState struct {
mu sync.Mutex
activeConns map[*http2serverConn]struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2sorter" data-name="http2sorter">
               <h3>
                  http2sorter
                  <span class="badge">struct</span>
                  <a href="#http2sorter" class="anchor" title="Link to http2sorter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2sorter struct {
v []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2startPushRequest" data-name="http2startPushRequest">
               <h3>
                  http2startPushRequest
                  <span class="badge">struct</span>
                  <a href="#http2startPushRequest" class="anchor" title="Link to http2startPushRequest">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2startPushRequest struct {
parent *http2stream
method string
url *url.URL
header Header
done chan error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2stickyErrWriter" data-name="http2stickyErrWriter">
               <h3>
                  http2stickyErrWriter
                  <span class="badge">struct</span>
                  <a href="#http2stickyErrWriter" class="anchor" title="Link to http2stickyErrWriter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2stickyErrWriter struct {
group http2synctestGroupInterface
conn net.Conn
timeout time.Duration
err *error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2stream" data-name="http2stream">
               <h3>
                  http2stream
                  <span class="badge">struct</span>
                  <a href="#http2stream" class="anchor" title="Link to http2stream">#</a>
               </h3>
               
               <p>stream represents a stream. This is the minimal metadata needed by
the serve goroutine. Most of the actual stream state is owned by
the http.Handler's goroutine in the responseWriter. Because the
responseWriter's responseWriterState is recycled at the end of a
handler, this struct intentionally has no pointer to the
*responseWriter{,State} itself, as the Handler ending nils out the
responseWriter's state field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2stream struct {
sc *http2serverConn
id uint32
body *http2pipe
cw http2closeWaiter
ctx context.Context
cancelCtx func()
bodyBytes int64
declBodyBytes int64
flow http2outflow
inflow http2inflow
state http2streamState
resetQueued bool
gotTrailerHeader bool
wroteHeaders bool
readDeadline http2timer
writeDeadline http2timer
closeErr error
trailer Header
reqTrailer Header
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2timeTimer" data-name="http2timeTimer">
               <h3>
                  http2timeTimer
                  <span class="badge">struct</span>
                  <a href="#http2timeTimer" class="anchor" title="Link to http2timeTimer">#</a>
               </h3>
               
               <p>timeTimer adapts a time.Timer to the timer interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2timeTimer struct {
*time.Timer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2transportResponseBody" data-name="http2transportResponseBody">
               <h3>
                  http2transportResponseBody
                  <span class="badge">struct</span>
                  <a href="#http2transportResponseBody" class="anchor" title="Link to http2transportResponseBody">#</a>
               </h3>
               
               <p>transportResponseBody is the concrete type of Transport.RoundTrip's
Response.Body. It is an io.ReadCloser.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2transportResponseBody struct {
cs *http2clientStream
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2transportTestHooks" data-name="http2transportTestHooks">
               <h3>
                  http2transportTestHooks
                  <span class="badge">struct</span>
                  <a href="#http2transportTestHooks" class="anchor" title="Link to http2transportTestHooks">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2transportTestHooks struct {
newclientconn func(*http2ClientConn)
group http2synctestGroupInterface
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2unstartedHandler" data-name="http2unstartedHandler">
               <h3>
                  http2unstartedHandler
                  <span class="badge">struct</span>
                  <a href="#http2unstartedHandler" class="anchor" title="Link to http2unstartedHandler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2unstartedHandler struct {
streamID uint32
rw *http2responseWriter
req *Request
handler func(ResponseWriter, *Request)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2write100ContinueHeadersFrame" data-name="http2write100ContinueHeadersFrame">
               <h3>
                  http2write100ContinueHeadersFrame
                  <span class="badge">struct</span>
                  <a href="#http2write100ContinueHeadersFrame" class="anchor" title="Link to http2write100ContinueHeadersFrame">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2write100ContinueHeadersFrame struct {
streamID uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writeData" data-name="http2writeData">
               <h3>
                  http2writeData
                  <span class="badge">struct</span>
                  <a href="#http2writeData" class="anchor" title="Link to http2writeData">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writeData struct {
streamID uint32
p []byte
endStream bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writeGoAway" data-name="http2writeGoAway">
               <h3>
                  http2writeGoAway
                  <span class="badge">struct</span>
                  <a href="#http2writeGoAway" class="anchor" title="Link to http2writeGoAway">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writeGoAway struct {
maxStreamID uint32
code http2ErrCode
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writePing" data-name="http2writePing">
               <h3>
                  http2writePing
                  <span class="badge">struct</span>
                  <a href="#http2writePing" class="anchor" title="Link to http2writePing">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writePing struct {
data [8]byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writePingAck" data-name="http2writePingAck">
               <h3>
                  http2writePingAck
                  <span class="badge">struct</span>
                  <a href="#http2writePingAck" class="anchor" title="Link to http2writePingAck">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writePingAck struct {
pf *http2PingFrame
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writePushPromise" data-name="http2writePushPromise">
               <h3>
                  http2writePushPromise
                  <span class="badge">struct</span>
                  <a href="#http2writePushPromise" class="anchor" title="Link to http2writePushPromise">#</a>
               </h3>
               
               <p>writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writePushPromise struct {
streamID uint32
method string
url *url.URL
h Header
allocatePromisedID func() (uint32, error)
promisedID uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writeQueue" data-name="http2writeQueue">
               <h3>
                  http2writeQueue
                  <span class="badge">struct</span>
                  <a href="#http2writeQueue" class="anchor" title="Link to http2writeQueue">#</a>
               </h3>
               
               <p>writeQueue is used by implementations of WriteScheduler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writeQueue struct {
s []http2FrameWriteRequest
prev *http2writeQueue
next *http2writeQueue
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writeResHeaders" data-name="http2writeResHeaders">
               <h3>
                  http2writeResHeaders
                  <span class="badge">struct</span>
                  <a href="#http2writeResHeaders" class="anchor" title="Link to http2writeResHeaders">#</a>
               </h3>
               
               <p>writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames
for HTTP response headers or trailers from a server handler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writeResHeaders struct {
streamID uint32
httpResCode int
h Header
trailers []string
endStream bool
date string
contentType string
contentLength string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writeSettingsAck" data-name="http2writeSettingsAck">
               <h3>
                  http2writeSettingsAck
                  <span class="badge">struct</span>
                  <a href="#http2writeSettingsAck" class="anchor" title="Link to http2writeSettingsAck">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writeSettingsAck struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="http2writeWindowUpdate" data-name="http2writeWindowUpdate">
               <h3>
                  http2writeWindowUpdate
                  <span class="badge">struct</span>
                  <a href="#http2writeWindowUpdate" class="anchor" title="Link to http2writeWindowUpdate">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type http2writeWindowUpdate struct {
streamID uint32
n uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="httpRange" data-name="httpRange">
               <h3>
                  httpRange
                  <span class="badge">struct</span>
                  <a href="#httpRange" class="anchor" title="Link to httpRange">#</a>
               </h3>
               
               <p>httpRange specifies the byte range to be sent to the client.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type httpRange struct {
start int64
length int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="initALPNRequest" data-name="initALPNRequest">
               <h3>
                  initALPNRequest
                  <span class="badge">struct</span>
                  <a href="#initALPNRequest" class="anchor" title="Link to initALPNRequest">#</a>
               </h3>
               
               <p>initALPNRequest is an HTTP handler that initializes certain
uninitialized fields in its *Request. Such partially-initialized
Requests come from ALPN protocol handlers.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type initALPNRequest struct {
ctx context.Context
c *tls.Conn
h serverHandler
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ioFS" data-name="ioFS">
               <h3>
                  ioFS
                  <span class="badge">struct</span>
                  <a href="#ioFS" class="anchor" title="Link to ioFS">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ioFS struct {
fsys fs.FS
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ioFile" data-name="ioFile">
               <h3>
                  ioFile
                  <span class="badge">struct</span>
                  <a href="#ioFile" class="anchor" title="Link to ioFile">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ioFile struct {
file fs.File
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="keyValues" data-name="keyValues">
               <h3>
                  keyValues
                  <span class="badge">struct</span>
                  <a href="#keyValues" class="anchor" title="Link to keyValues">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type keyValues struct {
key string
values []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="loggingConn" data-name="loggingConn">
               <h3>
                  loggingConn
                  <span class="badge">struct</span>
                  <a href="#loggingConn" class="anchor" title="Link to loggingConn">#</a>
               </h3>
               
               <p>loggingConn is used for debugging.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type loggingConn struct {
name string
net.Conn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mapping" data-name="mapping">
               <h3>
                  mapping
                  <span class="badge">struct</span>
                  <a href="#mapping" class="anchor" title="Link to mapping">#</a>
               </h3>
               
               <p>A mapping is a collection of key-value pairs where the keys are unique.
A zero mapping is empty and ready to use.
A mapping tries to pick a representation that makes [mapping.find] most efficient.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mapping struct {
s []*ast.IndexListExpr
m map[K]V
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="maskedSig" data-name="maskedSig">
               <h3>
                  maskedSig
                  <span class="badge">struct</span>
                  <a href="#maskedSig" class="anchor" title="Link to maskedSig">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type maskedSig struct {
mask []byte
pat []byte
skipWS bool
ct string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="maxBytesReader" data-name="maxBytesReader">
               <h3>
                  maxBytesReader
                  <span class="badge">struct</span>
                  <a href="#maxBytesReader" class="anchor" title="Link to maxBytesReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type maxBytesReader struct {
w ResponseWriter
r io.ReadCloser
i int64
n int64
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mp4Sig" data-name="mp4Sig">
               <h3>
                  mp4Sig
                  <span class="badge">struct</span>
                  <a href="#mp4Sig" class="anchor" title="Link to mp4Sig">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mp4Sig struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="muxEntry" data-name="muxEntry">
               <h3>
                  muxEntry
                  <span class="badge">struct</span>
                  <a href="#muxEntry" class="anchor" title="Link to muxEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type muxEntry struct {
h Handler
pattern string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noBody" data-name="noBody">
               <h3>
                  noBody
                  <span class="badge">struct</span>
                  <a href="#noBody" class="anchor" title="Link to noBody">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noBody struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nothingWrittenError" data-name="nothingWrittenError">
               <h3>
                  nothingWrittenError
                  <span class="badge">struct</span>
                  <a href="#nothingWrittenError" class="anchor" title="Link to nothingWrittenError">#</a>
               </h3>
               
               <p>nothingWrittenError wraps a write errors which ended up writing zero bytes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nothingWrittenError struct {
error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="onceCloseListener" data-name="onceCloseListener">
               <h3>
                  onceCloseListener
                  <span class="badge">struct</span>
                  <a href="#onceCloseListener" class="anchor" title="Link to onceCloseListener">#</a>
               </h3>
               
               <p>onceCloseListener wraps a net.Listener, protecting it from
multiple Close calls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type onceCloseListener struct {
net.Listener
once sync.Once
closeErr error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pattern" data-name="pattern">
               <h3>
                  pattern
                  <span class="badge">struct</span>
                  <a href="#pattern" class="anchor" title="Link to pattern">#</a>
               </h3>
               
               <p>A pattern is something that can be matched against an HTTP request.
It has an optional method, an optional host, and a path.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pattern struct {
str string
method string
host string
segments []segment
loc string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="persistConn" data-name="persistConn">
               <h3>
                  persistConn
                  <span class="badge">struct</span>
                  <a href="#persistConn" class="anchor" title="Link to persistConn">#</a>
               </h3>
               
               <p>persistConn wraps a connection, usually a persistent one
(but may be used for non-keep-alive requests as well)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type persistConn struct {
alt RoundTripper
t *Transport
cacheKey connectMethodKey
conn net.Conn
tlsState *tls.ConnectionState
br *bufio.Reader
bw *bufio.Writer
nwrite int64
reqch chan requestAndChan
writech chan writeRequest
closech chan struct{...}
isProxy bool
sawEOF bool
readLimit int64
writeErrCh chan error
writeLoopDone chan struct{...}
idleAt time.Time
idleTimer *time.Timer
mu sync.Mutex
numExpectedResponses int
closed error
canceledErr error
broken bool
reused bool
mutateHeaderFunc func(Header)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="persistConnWriter" data-name="persistConnWriter">
               <h3>
                  persistConnWriter
                  <span class="badge">struct</span>
                  <a href="#persistConnWriter" class="anchor" title="Link to persistConnWriter">#</a>
               </h3>
               
               <p>persistConnWriter is the io.Writer written to by pc.bw.
It accumulates the number of bytes written to the underlying conn,
so the retry logic can determine whether any bytes made it across
the wire.
This is exactly 1 pointer field wide so it can go into an interface
without allocation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type persistConnWriter struct {
pc *persistConn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="populateResponse" data-name="populateResponse">
               <h3>
                  populateResponse
                  <span class="badge">struct</span>
                  <a href="#populateResponse" class="anchor" title="Link to populateResponse">#</a>
               </h3>
               
               <p>populateResponse is a ResponseWriter that populates the *Response
in res, and writes its body to a pipe connected to the response
body. Once writes begin or finish() is called, the response is sent
on ch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type populateResponse struct {
res *Response
ch chan *Response
wroteHeader bool
hasContent bool
sentResponse bool
pw *io.PipeWriter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readResult" data-name="readResult">
               <h3>
                  readResult
                  <span class="badge">struct</span>
                  <a href="#readResult" class="anchor" title="Link to readResult">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readResult struct {
_ incomparable
n int
err error
b byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readTrackingBody" data-name="readTrackingBody">
               <h3>
                  readTrackingBody
                  <span class="badge">struct</span>
                  <a href="#readTrackingBody" class="anchor" title="Link to readTrackingBody">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readTrackingBody struct {
io.ReadCloser
didRead bool
didClose bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readWriteCloserBody" data-name="readWriteCloserBody">
               <h3>
                  readWriteCloserBody
                  <span class="badge">struct</span>
                  <a href="#readWriteCloserBody" class="anchor" title="Link to readWriteCloserBody">#</a>
               </h3>
               
               <p>readWriteCloserBody is the Response.Body type used when we want to
give users write access to the Body through the underlying
connection (TCP, unless using custom dialers). This is then
the concrete type for a Response.Body on the 101 Switching
Protocols response, as used by WebSockets, h2c, etc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readWriteCloserBody struct {
_ incomparable
br *bufio.Reader
io.ReadWriteCloser
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="redirectHandler" data-name="redirectHandler">
               <h3>
                  redirectHandler
                  <span class="badge">struct</span>
                  <a href="#redirectHandler" class="anchor" title="Link to redirectHandler">#</a>
               </h3>
               
               <p>Redirect to a fixed URL</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type redirectHandler struct {
url string
code int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="requestAndChan" data-name="requestAndChan">
               <h3>
                  requestAndChan
                  <span class="badge">struct</span>
                  <a href="#requestAndChan" class="anchor" title="Link to requestAndChan">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type requestAndChan struct {
_ incomparable
treq *transportRequest
ch chan responseAndError
addedGzip bool
continueCh chan<- struct{...}
callerGone <-chan struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="requestBodyReadError" data-name="requestBodyReadError">
               <h3>
                  requestBodyReadError
                  <span class="badge">struct</span>
                  <a href="#requestBodyReadError" class="anchor" title="Link to requestBodyReadError">#</a>
               </h3>
               
               <p>requestBodyReadError wraps an error from (*Request).write to indicate
that the error came from a Read call on the Request.Body.
This error type should not escape the net/http package to users.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type requestBodyReadError struct {
error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="response" data-name="response">
               <h3>
                  response
                  <span class="badge">struct</span>
                  <a href="#response" class="anchor" title="Link to response">#</a>
               </h3>
               
               <p>A response represents the server side of an HTTP response.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type response struct {
conn *conn
req *Request
reqBody io.ReadCloser
cancelCtx context.CancelFunc
wroteHeader bool
wants10KeepAlive bool
wantsClose bool
writeContinueMu sync.Mutex
canWriteContinue atomic.Bool
w *bufio.Writer
cw chunkWriter
handlerHeader Header
calledHeader bool
written int64
contentLength int64
status int
closeAfterReply bool
fullDuplex bool
requestBodyLimitHit bool
trailers []string
handlerDone atomic.Bool
dateBuf [*ast.CallExpr]byte
clenBuf [10]byte
statusBuf [3]byte
closeNotifyCh chan bool
didCloseNotify atomic.Bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="responseAndError" data-name="responseAndError">
               <h3>
                  responseAndError
                  <span class="badge">struct</span>
                  <a href="#responseAndError" class="anchor" title="Link to responseAndError">#</a>
               </h3>
               
               <p>responseAndError is how the goroutine reading from an HTTP/1 server
communicates with the goroutine doing the RoundTrip.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type responseAndError struct {
_ incomparable
res *Response
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="routingIndex" data-name="routingIndex">
               <h3>
                  routingIndex
                  <span class="badge">struct</span>
                  <a href="#routingIndex" class="anchor" title="Link to routingIndex">#</a>
               </h3>
               
               <p>A routingIndex optimizes conflict detection by indexing patterns.
The basic idea is to rule out patterns that cannot conflict with a given
pattern because they have a different literal in a corresponding segment.
See the comments in [routingIndex.possiblyConflictingPatterns] for more details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type routingIndex struct {
segments map[routingIndexKey][]*pattern
multis []*pattern
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="routingIndexKey" data-name="routingIndexKey">
               <h3>
                  routingIndexKey
                  <span class="badge">struct</span>
                  <a href="#routingIndexKey" class="anchor" title="Link to routingIndexKey">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type routingIndexKey struct {
pos int
s string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="routingNode" data-name="routingNode">
               <h3>
                  routingNode
                  <span class="badge">struct</span>
                  <a href="#routingNode" class="anchor" title="Link to routingNode">#</a>
               </h3>
               
               <p>A routingNode is a node in the decision tree.
The same struct is used for leaf and interior nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type routingNode struct {
pattern *pattern
handler Handler
children *ast.IndexListExpr
multiChild *routingNode
emptyChild *routingNode
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="segment" data-name="segment">
               <h3>
                  segment
                  <span class="badge">struct</span>
                  <a href="#segment" class="anchor" title="Link to segment">#</a>
               </h3>
               
               <p>A segment is a pattern piece that matches one or more path segments, or
a trailing slash.
If wild is false, it matches a literal segment, or, if s == "/", a trailing slash.
Examples:
"a" => segment{s: "a"}
"/{$}" => segment{s: "/"}
If wild is true and multi is false, it matches a single path segment.
Example:
"{x}" => segment{s: "x", wild: true}
If both wild and multi are true, it matches all remaining path segments.
Example:
"{rest...}" => segment{s: "rest", wild: true, multi: true}</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type segment struct {
s string
wild bool
multi bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="serveMux121" data-name="serveMux121">
               <h3>
                  serveMux121
                  <span class="badge">struct</span>
                  <a href="#serveMux121" class="anchor" title="Link to serveMux121">#</a>
               </h3>
               
               <p>serveMux121 holds the state of a ServeMux needed for Go 1.21 behavior.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type serveMux121 struct {
mu sync.RWMutex
m map[string]muxEntry
es []muxEntry
hosts bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="serverHandler" data-name="serverHandler">
               <h3>
                  serverHandler
                  <span class="badge">struct</span>
                  <a href="#serverHandler" class="anchor" title="Link to serverHandler">#</a>
               </h3>
               
               <p>serverHandler delegates to either the server's Handler or
DefaultServeMux and also handles "OPTIONS *" requests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type serverHandler struct {
srv *Server
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="socksAddr" data-name="socksAddr">
               <h3>
                  socksAddr
                  <span class="badge">struct</span>
                  <a href="#socksAddr" class="anchor" title="Link to socksAddr">#</a>
               </h3>
               
               <p>An Addr represents a SOCKS-specific address.
Either Name or IP is used exclusively.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type socksAddr struct {
Name string
IP net.IP
Port int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="socksConn" data-name="socksConn">
               <h3>
                  socksConn
                  <span class="badge">struct</span>
                  <a href="#socksConn" class="anchor" title="Link to socksConn">#</a>
               </h3>
               
               <p>A Conn represents a forward proxy connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type socksConn struct {
net.Conn
boundAddr net.Addr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="socksDialer" data-name="socksDialer">
               <h3>
                  socksDialer
                  <span class="badge">struct</span>
                  <a href="#socksDialer" class="anchor" title="Link to socksDialer">#</a>
               </h3>
               
               <p>A Dialer holds SOCKS-specific options.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type socksDialer struct {
cmd socksCommand
proxyNetwork string
proxyAddress string
ProxyDial func(context.Context, string, string) (net.Conn, error)
AuthMethods []socksAuthMethod
Authenticate func(context.Context, io.ReadWriter, socksAuthMethod) error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="socksUsernamePassword" data-name="socksUsernamePassword">
               <h3>
                  socksUsernamePassword
                  <span class="badge">struct</span>
                  <a href="#socksUsernamePassword" class="anchor" title="Link to socksUsernamePassword">#</a>
               </h3>
               
               <p>UsernamePassword are the credentials for the username/password
authentication method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type socksUsernamePassword struct {
Username string
Password string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="statusError" data-name="statusError">
               <h3>
                  statusError
                  <span class="badge">struct</span>
                  <a href="#statusError" class="anchor" title="Link to statusError">#</a>
               </h3>
               
               <p>statusError is an error used to respond to a request with an HTTP status.
The text should be plain text without user info or other embedded errors.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type statusError struct {
code int
text string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="streamReader" data-name="streamReader">
               <h3>
                  streamReader
                  <span class="badge">struct</span>
                  <a href="#streamReader" class="anchor" title="Link to streamReader">#</a>
               </h3>
               
               <p>streamReader implements an io.ReadCloser wrapper for ReadableStream.
See https://fetch.spec.whatwg.org/#readablestream for more information.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type streamReader struct {
pending []byte
stream js.Value
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stringWriter" data-name="stringWriter">
               <h3>
                  stringWriter
                  <span class="badge">struct</span>
                  <a href="#stringWriter" class="anchor" title="Link to stringWriter">#</a>
               </h3>
               
               <p>stringWriter implements WriteString on a Writer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stringWriter struct {
w io.Writer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tLogKey" data-name="tLogKey">
               <h3>
                  tLogKey
                  <span class="badge">struct</span>
                  <a href="#tLogKey" class="anchor" title="Link to tLogKey">#</a>
               </h3>
               
               <p>tLogKey is a context WithValue key for test debugging contexts containing
a t.Logf func. See export_test.go's Request.WithT method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tLogKey struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="textSig" data-name="textSig">
               <h3>
                  textSig
                  <span class="badge">struct</span>
                  <a href="#textSig" class="anchor" title="Link to textSig">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type textSig struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="timeoutError" data-name="timeoutError">
               <h3>
                  timeoutError
                  <span class="badge">struct</span>
                  <a href="#timeoutError" class="anchor" title="Link to timeoutError">#</a>
               </h3>
               
               <p>httpTimeoutError represents a timeout.
It implements net.Error and wraps context.DeadlineExceeded.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type timeoutError struct {
err string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="timeoutHandler" data-name="timeoutHandler">
               <h3>
                  timeoutHandler
                  <span class="badge">struct</span>
                  <a href="#timeoutHandler" class="anchor" title="Link to timeoutHandler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type timeoutHandler struct {
handler Handler
body string
dt time.Duration
testContext context.Context
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="timeoutWriter" data-name="timeoutWriter">
               <h3>
                  timeoutWriter
                  <span class="badge">struct</span>
                  <a href="#timeoutWriter" class="anchor" title="Link to timeoutWriter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type timeoutWriter struct {
w ResponseWriter
h Header
wbuf bytes.Buffer
req *Request
mu sync.Mutex
err error
wroteHeader bool
code int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tlsHandshakeTimeoutError" data-name="tlsHandshakeTimeoutError">
               <h3>
                  tlsHandshakeTimeoutError
                  <span class="badge">struct</span>
                  <a href="#tlsHandshakeTimeoutError" class="anchor" title="Link to tlsHandshakeTimeoutError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tlsHandshakeTimeoutError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="transferReader" data-name="transferReader">
               <h3>
                  transferReader
                  <span class="badge">struct</span>
                  <a href="#transferReader" class="anchor" title="Link to transferReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type transferReader struct {
Header Header
StatusCode int
RequestMethod string
ProtoMajor int
ProtoMinor int
Body io.ReadCloser
ContentLength int64
Chunked bool
Close bool
Trailer Header
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="transferWriter" data-name="transferWriter">
               <h3>
                  transferWriter
                  <span class="badge">struct</span>
                  <a href="#transferWriter" class="anchor" title="Link to transferWriter">#</a>
               </h3>
               
               <p>transferWriter inspects the fields of a user-supplied Request or Response,
sanitizes them without changing the user object and provides methods for
writing the respective header, body and trailer in wire format.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type transferWriter struct {
Method string
Body io.Reader
BodyCloser io.Closer
ResponseToHEAD bool
ContentLength int64
Close bool
TransferEncoding []string
Header Header
Trailer Header
IsResponse bool
bodyReadError error
FlushHeaders bool
ByteReadCh chan readResult
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="transportReadFromServerError" data-name="transportReadFromServerError">
               <h3>
                  transportReadFromServerError
                  <span class="badge">struct</span>
                  <a href="#transportReadFromServerError" class="anchor" title="Link to transportReadFromServerError">#</a>
               </h3>
               
               <p>transportReadFromServerError is used by Transport.readLoop when the
1 byte peek read fails and we're actually anticipating a response.
Usually this is just due to the inherent keep-alive shut down race,
where the server closed the connection at the same time the client
wrote. The underlying err field is usually io.EOF or some
ECONNRESET sort of thing which varies by platform. But it might be
the user's custom net.Conn.Read error too, so we carry it along for
them to return from Transport.RoundTrip.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type transportReadFromServerError struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="transportRequest" data-name="transportRequest">
               <h3>
                  transportRequest
                  <span class="badge">struct</span>
                  <a href="#transportRequest" class="anchor" title="Link to transportRequest">#</a>
               </h3>
               
               <p>transportRequest is a wrapper around a *Request that adds
optional extra headers to write and stores any error to return
from roundTrip.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type transportRequest struct {
*Request
extra Header
trace *httptrace.ClientTrace
ctx context.Context
cancel context.CancelCauseFunc
mu sync.Mutex
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="unencryptedHTTP2Request" data-name="unencryptedHTTP2Request">
               <h3>
                  unencryptedHTTP2Request
                  <span class="badge">struct</span>
                  <a href="#unencryptedHTTP2Request" class="anchor" title="Link to unencryptedHTTP2Request">#</a>
               </h3>
               
               <p>unencryptedHTTP2Request is an HTTP handler that initializes
certain uninitialized fields in its *Request.
It's the unencrypted version of initALPNRequest.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unencryptedHTTP2Request struct {
ctx context.Context
c net.Conn
h serverHandler
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="unencryptedNetConnInTLSConn" data-name="unencryptedNetConnInTLSConn">
               <h3>
                  unencryptedNetConnInTLSConn
                  <span class="badge">struct</span>
                  <a href="#unencryptedNetConnInTLSConn" class="anchor" title="Link to unencryptedNetConnInTLSConn">#</a>
               </h3>
               
               <p>unencryptedNetConnInTLSConn is used to pass an unencrypted net.Conn to
functions that only accept a *tls.Conn.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unencryptedNetConnInTLSConn struct {
net.Conn
conn net.Conn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="unsupportedTEError" data-name="unsupportedTEError">
               <h3>
                  unsupportedTEError
                  <span class="badge">struct</span>
                  <a href="#unsupportedTEError" class="anchor" title="Link to unsupportedTEError">#</a>
               </h3>
               
               <p>unsupportedTEError reports unsupported transfer-encodings.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unsupportedTEError struct {
err string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="wantConn" data-name="wantConn">
               <h3>
                  wantConn
                  <span class="badge">struct</span>
                  <a href="#wantConn" class="anchor" title="Link to wantConn">#</a>
               </h3>
               
               <p>A wantConn records state about a wanted connection
(that is, an active call to getConn).
The conn may be gotten by dialing or by finding an idle connection,
or a cancellation may make the conn no longer wanted.
These three options are racing against each other and use
wantConn to coordinate and agree about the winning outcome.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type wantConn struct {
cm connectMethod
key connectMethodKey
beforeDial func()
afterDial func()
mu sync.Mutex
ctx context.Context
cancelCtx context.CancelFunc
done bool
result chan connOrError
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="wantConnQueue" data-name="wantConnQueue">
               <h3>
                  wantConnQueue
                  <span class="badge">struct</span>
                  <a href="#wantConnQueue" class="anchor" title="Link to wantConnQueue">#</a>
               </h3>
               
               <p>A wantConnQueue is a queue of wantConns.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type wantConnQueue struct {
head []*wantConn
headPos int
tail []*wantConn
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writeRequest" data-name="writeRequest">
               <h3>
                  writeRequest
                  <span class="badge">struct</span>
                  <a href="#writeRequest" class="anchor" title="Link to writeRequest">#</a>
               </h3>
               
               <p>A writeRequest is sent by the caller's goroutine to the
writeLoop's goroutine to write a request while the read loop
concurrently waits on both the write response and the server's
reply.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writeRequest struct {
req *transportRequest
ch chan<- error
continueCh <-chan struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writerOnly" data-name="writerOnly">
               <h3>
                  writerOnly
                  <span class="badge">struct</span>
                  <a href="#writerOnly" class="anchor" title="Link to writerOnly">#</a>
               </h3>
               
               <p>writerOnly hides an io.Writer value's optional ReadFrom method
from io.Copy.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writerOnly struct {
io.Writer
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add adds the key, value pair to the header.
It appends to any existing values associated with key.
The key is case insensitive; it is canonicalized by
[CanonicalHeaderKey].</p>
               
               <pre><code>func (h Header) Add(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddCookie" data-name="AddCookie">
               <h3>
                  AddCookie 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddCookie" class="anchor" title="Link to AddCookie">#</a>
               </h3>
               
               <p>AddCookie adds a cookie to the request. Per RFC 6265 section 5.4,
AddCookie does not attach more than one [Cookie] header field. That
means all cookies, if any, are written into the same line,
separated by semicolon.
AddCookie only sanitizes c's name and value, and does not sanitize
a Cookie header already present in the request.</p>
               
               <pre><code>func (r *Request) AddCookie(c *Cookie)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AdjustStream" data-name="AdjustStream">
               <h3>
                  AdjustStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AdjustStream" class="anchor" title="Link to AdjustStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AdjustStream" data-name="AdjustStream">
               <h3>
                  AdjustStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AdjustStream" class="anchor" title="Link to AdjustStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2roundRobinWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AdjustStream" data-name="AdjustStream">
               <h3>
                  AdjustStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AdjustStream" class="anchor" title="Link to AdjustStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2randomWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllowQuerySemicolons" data-name="AllowQuerySemicolons">
               <h3>
                  AllowQuerySemicolons 
                  <span class="badge">function</span>
                  
                  <a href="#AllowQuerySemicolons" class="anchor" title="Link to AllowQuerySemicolons">#</a>
               </h3>
               
               <p>AllowQuerySemicolons returns a handler that serves requests by converting any
unescaped semicolons in the URL query to ampersands, and invoking the handler h.
This restores the pre-Go 1.17 behavior of splitting query parameters on both
semicolons and ampersands. (See golang.org/issue/25192). Note that this
behavior doesn't match that of many proxies, and the mismatch can lead to
security issues.
AllowQuerySemicolons should be invoked before [Request.ParseForm] is called.</p>
               
               <pre><code>func AllowQuerySemicolons(h Handler) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="As" data-name="As">
               <h3>
                  As 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#As" class="anchor" title="Link to As">#</a>
               </h3>
               
               <pre><code>func (e http2StreamError) As(target any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Authenticate" data-name="Authenticate">
               <h3>
                  Authenticate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Authenticate" class="anchor" title="Link to Authenticate">#</a>
               </h3>
               
               <p>Authenticate authenticates a pair of username and password with the
proxy server.</p>
               
               <pre><code>func (up *socksUsernamePassword) Authenticate(ctx context.Context, rw io.ReadWriter, auth socksAuthMethod) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Available" data-name="Available">
               <h3>
                  Available 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Available" class="anchor" title="Link to Available">#</a>
               </h3>
               
               <pre><code>func (w *http2bufferedWriter) Available() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BaseContext" data-name="BaseContext">
               <h3>
                  BaseContext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BaseContext" class="anchor" title="Link to BaseContext">#</a>
               </h3>
               
               <p>BaseContext is an exported but unadvertised [http.Handler] method
recognized by x/net/http2 to pass down a context; the TLSNextProto
API predates context support so we shoehorn through the only
interface we have available.</p>
               
               <pre><code>func (h initALPNRequest) BaseContext() context.Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BaseContext" data-name="BaseContext">
               <h3>
                  BaseContext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BaseContext" class="anchor" title="Link to BaseContext">#</a>
               </h3>
               
               <pre><code>func (h unencryptedHTTP2Request) BaseContext() context.Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BasicAuth" data-name="BasicAuth">
               <h3>
                  BasicAuth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BasicAuth" class="anchor" title="Link to BasicAuth">#</a>
               </h3>
               
               <p>BasicAuth returns the username and password provided in the request's
Authorization header, if the request uses HTTP Basic Authentication.
See RFC 2617, Section 2.</p>
               
               <pre><code>func (r *Request) BasicAuth() (username string, password string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BoundAddr" data-name="BoundAddr">
               <h3>
                  BoundAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BoundAddr" class="anchor" title="Link to BoundAddr">#</a>
               </h3>
               
               <p>BoundAddr returns the address assigned by the proxy server for
connecting to the command target address from the proxy server.</p>
               
               <pre><code>func (c *socksConn) BoundAddr() net.Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BreakWithError" data-name="BreakWithError">
               <h3>
                  BreakWithError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BreakWithError" class="anchor" title="Link to BreakWithError">#</a>
               </h3>
               
               <p>BreakWithError causes the next Read (waking up a current blocked
Read if needed) to return the provided err immediately, without
waiting for unread data.</p>
               
               <pre><code>func (p *http2pipe) BreakWithError(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="C" data-name="C">
               <h3>
                  C 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#C" class="anchor" title="Link to C">#</a>
               </h3>
               
               <pre><code>func (t http2timeTimer) C() (<-chan time.Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanTakeNewRequest" data-name="CanTakeNewRequest">
               <h3>
                  CanTakeNewRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanTakeNewRequest" class="anchor" title="Link to CanTakeNewRequest">#</a>
               </h3>
               
               <p>CanTakeNewRequest reports whether the connection can take a new request,
meaning it has not been closed or received or sent a GOAWAY.
If the caller is going to immediately make a new request on this
connection, use ReserveNewRequest instead.</p>
               
               <pre><code>func (cc *http2ClientConn) CanTakeNewRequest() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CancelRequest" data-name="CancelRequest">
               <h3>
                  CancelRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CancelRequest" class="anchor" title="Link to CancelRequest">#</a>
               </h3>
               
               <p>CancelRequest cancels an in-flight request by closing its connection.
CancelRequest should only be called after [Transport.RoundTrip] has returned.
Deprecated: Use [Request.WithContext] to create a request with a
cancelable context instead. CancelRequest cannot cancel HTTP/2
requests. This may become a no-op in a future release of Go.</p>
               
               <pre><code>func (t *Transport) CancelRequest(req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanonicalHeaderKey" data-name="CanonicalHeaderKey">
               <h3>
                  CanonicalHeaderKey 
                  <span class="badge">function</span>
                  
                  <a href="#CanonicalHeaderKey" class="anchor" title="Link to CanonicalHeaderKey">#</a>
               </h3>
               
               <p>CanonicalHeaderKey returns the canonical format of the
header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
If s contains a space or invalid header field bytes, it is
returned without modifications.</p>
               
               <pre><code>func CanonicalHeaderKey(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clone" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clone" class="anchor" title="Link to Clone">#</a>
               </h3>
               
               <p>Clone returns a copy of h or nil if h is nil.</p>
               
               <pre><code>func (h Header) Clone() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clone" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clone" class="anchor" title="Link to Clone">#</a>
               </h3>
               
               <p>Clone returns a deep copy of r with its context changed to ctx.
The provided ctx must be non-nil.
Clone only makes a shallow copy of the Body field.
For an outgoing client request, the context controls the entire
lifetime of a request and its response: obtaining a connection,
sending the request, and reading the response headers and body.</p>
               
               <pre><code>func (r *Request) Clone(ctx context.Context) *Request</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clone" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clone" class="anchor" title="Link to Clone">#</a>
               </h3>
               
               <p>Clone returns a deep copy of t's exported fields.</p>
               
               <pre><code>func (t *Transport) Clone() *Transport</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (l *maxBytesReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (oc *onceCloseListener) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (b http2transportResponseBody) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (r *arrayReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (ecr *expectContinueReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (http2noBodyReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (b *cancelTimerBody) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (gz *gzipReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (es *bodyEOFSignal) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (b *http2requestBody) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close immediately closes all active net.Listeners and any
connections in state [StateNew], [StateActive], or [StateIdle]. For a
graceful shutdown, use [Server.Shutdown].
Close does not attempt to close (and does not even know about)
any hijacked connections, such as WebSockets.
Close returns any error returned from closing the [Server]'s
underlying Listener(s).</p>
               
               <pre><code>func (s *Server) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (f ioFile) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the client connection immediately.
In-flight requests are interrupted. For a graceful shutdown, use Shutdown instead.</p>
               
               <pre><code>func (cc *http2ClientConn) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (r *streamReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (b *body) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (r *readTrackingBody) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (noBody) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close marks the closeWaiter as closed and unblocks any waiters.</p>
               
               <pre><code>func (cw http2closeWaiter) Close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (gz *http2gzipReader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (http2missingBody) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (c *loggingConn) Close() (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseConn" data-name="CloseConn">
               <h3>
                  CloseConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseConn" class="anchor" title="Link to CloseConn">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) CloseConn() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseIdleConnections" data-name="CloseIdleConnections">
               <h3>
                  CloseIdleConnections 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseIdleConnections" class="anchor" title="Link to CloseIdleConnections">#</a>
               </h3>
               
               <p>CloseIdleConnections closes any connections which were previously
connected from previous requests but are now sitting idle in
a "keep-alive" state. It does not interrupt any connections currently
in use.</p>
               
               <pre><code>func (t *Transport) CloseIdleConnections()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseIdleConnections" data-name="CloseIdleConnections">
               <h3>
                  CloseIdleConnections 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseIdleConnections" class="anchor" title="Link to CloseIdleConnections">#</a>
               </h3>
               
               <p>CloseIdleConnections closes any connections which were previously
connected from previous requests but are now sitting idle.
It does not interrupt any connections currently in use.</p>
               
               <pre><code>func (t *http2Transport) CloseIdleConnections()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseIdleConnections" data-name="CloseIdleConnections">
               <h3>
                  CloseIdleConnections 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseIdleConnections" class="anchor" title="Link to CloseIdleConnections">#</a>
               </h3>
               
               <p>CloseIdleConnections closes any connections on its [Transport] which
were previously connected from previous requests but are now
sitting idle in a "keep-alive" state. It does not interrupt any
connections currently in use.
If [Client.Transport] does not have a [Client.CloseIdleConnections] method
then this method does nothing.</p>
               
               <pre><code>func (c *Client) CloseIdleConnections()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseIdleConnections" data-name="CloseIdleConnections">
               <h3>
                  CloseIdleConnections 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseIdleConnections" class="anchor" title="Link to CloseIdleConnections">#</a>
               </h3>
               
               <pre><code>func (*http2Transport) CloseIdleConnections()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseNotify" data-name="CloseNotify">
               <h3>
                  CloseNotify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseNotify" class="anchor" title="Link to CloseNotify">#</a>
               </h3>
               
               <pre><code>func (w *response) CloseNotify() (<-chan bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseNotify" data-name="CloseNotify">
               <h3>
                  CloseNotify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseNotify" class="anchor" title="Link to CloseNotify">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) CloseNotify() (<-chan bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseStream" data-name="CloseStream">
               <h3>
                  CloseStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseStream" class="anchor" title="Link to CloseStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2randomWriteScheduler) CloseStream(streamID uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseStream" data-name="CloseStream">
               <h3>
                  CloseStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseStream" class="anchor" title="Link to CloseStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) CloseStream(streamID uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseStream" data-name="CloseStream">
               <h3>
                  CloseStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseStream" class="anchor" title="Link to CloseStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2roundRobinWriteScheduler) CloseStream(streamID uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CloseWithError" data-name="CloseWithError">
               <h3>
                  CloseWithError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CloseWithError" class="anchor" title="Link to CloseWithError">#</a>
               </h3>
               
               <p>CloseWithError causes the next Read (waking up a current blocked
Read if needed) to return the provided err after all data has been
read.
The error must be non-nil.</p>
               
               <pre><code>func (p *http2pipe) CloseWithError(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Consume" data-name="Consume">
               <h3>
                  Consume 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Consume" class="anchor" title="Link to Consume">#</a>
               </h3>
               
               <p>Consume consumes min(n, available) bytes from this frame, where available
is the number of flow control bytes available on the stream. Consume returns
0, 1, or 2 frames, where the integer return value gives the number of frames
returned.
If flow control prevents consuming any bytes, this returns (_, _, 0). If
the entire frame was consumed, this returns (wr, _, 1). Otherwise, this
returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and
'rest' contains the remaining bytes. The consumed bytes are deducted from the
underlying stream's flow control budget.</p>
               
               <pre><code>func (wr http2FrameWriteRequest) Consume(n int32) (http2FrameWriteRequest, http2FrameWriteRequest, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Context" data-name="Context">
               <h3>
                  Context 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Context" class="anchor" title="Link to Context">#</a>
               </h3>
               
               <p>Context returns the request's context. To change the context, use
[Request.Clone] or [Request.WithContext].
The returned context is always non-nil; it defaults to the
background context.
For outgoing client requests, the context controls cancellation.
For incoming server requests, the context is canceled when the
client's connection closes, the request is canceled (with HTTP/2),
or when the ServeHTTP method returns.</p>
               
               <pre><code>func (r *Request) Context() context.Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cookie" data-name="Cookie">
               <h3>
                  Cookie 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cookie" class="anchor" title="Link to Cookie">#</a>
               </h3>
               
               <p>Cookie returns the named cookie provided in the request or
[ErrNoCookie] if not found.
If multiple cookies match the given name, only one cookie will
be returned.</p>
               
               <pre><code>func (r *Request) Cookie(name string) (*Cookie, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cookies" data-name="Cookies">
               <h3>
                  Cookies 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cookies" class="anchor" title="Link to Cookies">#</a>
               </h3>
               
               <p>Cookies parses and returns the HTTP cookies sent with the request.</p>
               
               <pre><code>func (r *Request) Cookies() []*Cookie</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cookies" data-name="Cookies">
               <h3>
                  Cookies 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cookies" class="anchor" title="Link to Cookies">#</a>
               </h3>
               
               <p>Cookies parses and returns the cookies set in the Set-Cookie headers.</p>
               
               <pre><code>func (r *Response) Cookies() []*Cookie</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CookiesNamed" data-name="CookiesNamed">
               <h3>
                  CookiesNamed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CookiesNamed" class="anchor" title="Link to CookiesNamed">#</a>
               </h3>
               
               <p>CookiesNamed parses and returns the named HTTP cookies sent with the request
or an empty slice if none matched.</p>
               
               <pre><code>func (r *Request) CookiesNamed(name string) []*Cookie</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Data" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Data" class="anchor" title="Link to Data">#</a>
               </h3>
               
               <p>Data returns the frame's data octets, not including any padding
size byte or padding suffix bytes.
The caller must not retain the returned memory past the next
call to ReadFrame.</p>
               
               <pre><code>func (f *http2DataFrame) Data() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DataSize" data-name="DataSize">
               <h3>
                  DataSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DataSize" class="anchor" title="Link to DataSize">#</a>
               </h3>
               
               <p>DataSize returns the number of flow control bytes that must be consumed
to write this entire frame. This is 0 for non-DATA frames.</p>
               
               <pre><code>func (wr http2FrameWriteRequest) DataSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DebugData" data-name="DebugData">
               <h3>
                  DebugData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DebugData" class="anchor" title="Link to DebugData">#</a>
               </h3>
               
               <p>DebugData returns any debug data in the GOAWAY frame. Its contents
are not defined.
The caller must not retain the returned memory past the next
call to ReadFrame.</p>
               
               <pre><code>func (f *http2GoAwayFrame) DebugData() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Del" data-name="Del">
               <h3>
                  Del 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Del" class="anchor" title="Link to Del">#</a>
               </h3>
               
               <p>Del deletes the values associated with key.
The key is case insensitive; it is canonicalized by
[CanonicalHeaderKey].</p>
               
               <pre><code>func (h Header) Del(key string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DetectContentType" data-name="DetectContentType">
               <h3>
                  DetectContentType 
                  <span class="badge">function</span>
                  
                  <a href="#DetectContentType" class="anchor" title="Link to DetectContentType">#</a>
               </h3>
               
               <p>DetectContentType implements the algorithm described
at https://mimesniff.spec.whatwg.org/ to determine the
Content-Type of the given data. It considers at most the
first 512 bytes of data. DetectContentType always returns
a valid MIME type: if it cannot determine a more specific one, it
returns "application/octet-stream".</p>
               
               <pre><code>func DetectContentType(data []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dial" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Dial" class="anchor" title="Link to Dial">#</a>
               </h3>
               
               <p>Dial connects to the provided address on the provided network.
Unlike DialContext, it returns a raw transport connection instead
of a forward proxy connection.
Deprecated: Use DialContext or DialWithConn instead.</p>
               
               <pre><code>func (d *socksDialer) Dial(network string, address string) (net.Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DialContext" data-name="DialContext">
               <h3>
                  DialContext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DialContext" class="anchor" title="Link to DialContext">#</a>
               </h3>
               
               <p>DialContext connects to the provided address on the provided
network.
The returned error value may be a net.OpError. When the Op field of
net.OpError contains "socks", the Source field contains a proxy
server address and the Addr field contains a command target
address.
See func Dial of the net package of standard library for a
description of the network and address parameters.</p>
               
               <pre><code>func (d *socksDialer) DialContext(ctx context.Context, network string, address string) (net.Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DialWithConn" data-name="DialWithConn">
               <h3>
                  DialWithConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DialWithConn" class="anchor" title="Link to DialWithConn">#</a>
               </h3>
               
               <p>DialWithConn initiates a connection from SOCKS server to the target
network and address using the connection c that is already
connected to the SOCKS server.
It returns the connection's local address assigned by the SOCKS
server.</p>
               
               <pre><code>func (d *socksDialer) DialWithConn(ctx context.Context, c net.Conn, network string, address string) (net.Addr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Do" data-name="Do">
               <h3>
                  Do 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Do" class="anchor" title="Link to Do">#</a>
               </h3>
               
               <p>Do sends an HTTP request and returns an HTTP response, following
policy (such as redirects, cookies, auth) as configured on the
client.
An error is returned if caused by client policy (such as
CheckRedirect), or failure to speak HTTP (such as a network
connectivity problem). A non-2xx status code doesn't cause an
error.
If the returned error is nil, the [Response] will contain a non-nil
Body which the user is expected to close. If the Body is not both
read to EOF and closed, the [Client]'s underlying [RoundTripper]
(typically [Transport]) may not be able to re-use a persistent TCP
connection to the server for a subsequent "keep-alive" request.
The request Body, if non-nil, will be closed by the underlying
Transport, even on errors. The Body may be closed asynchronously after
Do returns.
On error, any Response can be ignored. A non-nil Response with a
non-nil error only occurs when CheckRedirect fails, and even then
the returned [Response.Body] is already closed.
Generally [Get], [Post], or [PostForm] will be used instead of Do.
If the server replies with a redirect, the Client first uses the
CheckRedirect function to determine whether the redirect should be
followed. If permitted, a 301, 302, or 303 redirect causes
subsequent requests to use HTTP method GET
(or HEAD if the original request was HEAD), with no body.
A 307 or 308 redirect preserves the original HTTP method and body,
provided that the [Request.GetBody] function is defined.
The [NewRequest] function automatically sets GetBody for common
standard library body types.
Any returned error will be of type [*url.Error]. The url.Error
value's Timeout method will report true if the request timed out.</p>
               
               <pre><code>func (c *Client) Do(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Done" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Done" class="anchor" title="Link to Done">#</a>
               </h3>
               
               <p>Done returns a channel which is closed if and when this pipe is closed
with CloseWithError.</p>
               
               <pre><code>func (p *http2pipe) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnableFullDuplex" data-name="EnableFullDuplex">
               <h3>
                  EnableFullDuplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EnableFullDuplex" class="anchor" title="Link to EnableFullDuplex">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) EnableFullDuplex() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnableFullDuplex" data-name="EnableFullDuplex">
               <h3>
                  EnableFullDuplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EnableFullDuplex" class="anchor" title="Link to EnableFullDuplex">#</a>
               </h3>
               
               <p>EnableFullDuplex indicates that the request handler will interleave reads from [Request.Body]
with writes to the [ResponseWriter].
For HTTP/1 requests, the Go HTTP server by default consumes any unread portion of
the request body before beginning to write the response, preventing handlers from
concurrently reading from the request and writing the response.
Calling EnableFullDuplex disables this behavior and permits handlers to continue to read
from the request while concurrently writing the response.
For HTTP/2 requests, the Go HTTP server always permits concurrent reads and responses.</p>
               
               <pre><code>func (c *ResponseController) EnableFullDuplex() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnableFullDuplex" data-name="EnableFullDuplex">
               <h3>
                  EnableFullDuplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EnableFullDuplex" class="anchor" title="Link to EnableFullDuplex">#</a>
               </h3>
               
               <pre><code>func (c *response) EnableFullDuplex() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <p>Err returns the error (if any) first set by BreakWithError or CloseWithError.</p>
               
               <pre><code>func (p *http2pipe) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *MaxBytesError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2ConnectionError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *http2httpError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2headerFieldValueError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (tlsHandshakeTimeoutError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2StreamError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2connError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (http2noCachedConnError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2GoAwayError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e statusError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *timeoutError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (http2goAwayFlowError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge">function</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error replies to the request with the specified error message and HTTP code.
It does not otherwise end the request; the caller should ensure no further
writes are done to w.
The error message should be plain text.
Error deletes the Content-Length header,
sets Content-Type to “text/plain; charset=utf-8”,
and sets X-Content-Type-Options to “nosniff”.
This configures the header properly for the error message,
in case the caller had set it up expecting a successful output.</p>
               
               <pre><code>func Error(w ResponseWriter, error string, code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (uste *unsupportedTEError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2pseudoHeaderError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e transportReadFromServerError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2duplicatePseudoHeaderError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (pe *ProtocolError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e http2headerFieldNameError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (http2noCachedConnError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ErrorDetail" data-name="ErrorDetail">
               <h3>
                  ErrorDetail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ErrorDetail" class="anchor" title="Link to ErrorDetail">#</a>
               </h3>
               
               <p>ErrorDetail returns a more detailed error of the last error
returned by Framer.ReadFrame. For instance, if ReadFrame
returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
will say exactly what was invalid. ErrorDetail is not guaranteed
to return a non-nil value and like the rest of the http2 package,
its return value is not protected by an API compatibility promise.
ErrorDetail is reset after the next call to ReadFrame.</p>
               
               <pre><code>func (fr *http2Framer) ErrorDetail() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FS" data-name="FS">
               <h3>
                  FS 
                  <span class="badge">function</span>
                  
                  <a href="#FS" class="anchor" title="Link to FS">#</a>
               </h3>
               
               <p>FS converts fsys to a [FileSystem] implementation,
for use with [FileServer] and [NewFileTransport].
The files provided by fsys must implement [io.Seeker].</p>
               
               <pre><code>func FS(fsys fs.FS) FileSystem</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileServer" data-name="FileServer">
               <h3>
                  FileServer 
                  <span class="badge">function</span>
                  
                  <a href="#FileServer" class="anchor" title="Link to FileServer">#</a>
               </h3>
               
               <p>FileServer returns a handler that serves HTTP requests
with the contents of the file system rooted at root.
As a special case, the returned file server redirects any request
ending in "/index.html" to the same path, without the final
"index.html".
To use the operating system's file system implementation,
use [http.Dir]:
http.Handle("/", http.FileServer(http.Dir("/tmp")))
To use an [fs.FS] implementation, use [http.FileServerFS] instead.</p>
               
               <pre><code>func FileServer(root FileSystem) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileServerFS" data-name="FileServerFS">
               <h3>
                  FileServerFS 
                  <span class="badge">function</span>
                  
                  <a href="#FileServerFS" class="anchor" title="Link to FileServerFS">#</a>
               </h3>
               
               <p>FileServerFS returns a handler that serves HTTP requests
with the contents of the file system fsys.
The files provided by fsys must implement [io.Seeker].
As a special case, the returned file server redirects any request
ending in "/index.html" to the same path, without the final
"index.html".
http.Handle("/", http.FileServerFS(fsys))</p>
               
               <pre><code>func FileServerFS(root fs.FS) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <pre><code>func (w *response) Flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush flushes buffered data to the client.</p>
               
               <pre><code>func (c *ResponseController) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <pre><code>func (w *http2bufferedWriter) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) Flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FlushError" data-name="FlushError">
               <h3>
                  FlushError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FlushError" class="anchor" title="Link to FlushError">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) FlushError() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FlushError" data-name="FlushError">
               <h3>
                  FlushError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FlushError" class="anchor" title="Link to FlushError">#</a>
               </h3>
               
               <pre><code>func (w *response) FlushError() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ForeachSetting" data-name="ForeachSetting">
               <h3>
                  ForeachSetting 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ForeachSetting" class="anchor" title="Link to ForeachSetting">#</a>
               </h3>
               
               <p>ForeachSetting runs fn for each setting.
It stops and returns the first error.</p>
               
               <pre><code>func (f *http2SettingsFrame) ForeachSetting(fn func(http2Setting) error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormFile" data-name="FormFile">
               <h3>
                  FormFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FormFile" class="anchor" title="Link to FormFile">#</a>
               </h3>
               
               <p>FormFile returns the first file for the provided form key.
FormFile calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary.</p>
               
               <pre><code>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormValue" data-name="FormValue">
               <h3>
                  FormValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FormValue" class="anchor" title="Link to FormValue">#</a>
               </h3>
               
               <p>FormValue returns the first value for the named component of the query.
The precedence order:
1. application/x-www-form-urlencoded form body (POST, PUT, PATCH only)
2. query parameters (always)
3. multipart/form-data form body (always)
FormValue calls [Request.ParseMultipartForm] and [Request.ParseForm]
if necessary and ignores any errors returned by these functions.
If key is not present, FormValue returns the empty string.
To access multiple values of the same key, call ParseForm and
then inspect [Request.Form] directly.</p>
               
               <pre><code>func (r *Request) FormValue(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Framer" data-name="Framer">
               <h3>
                  Framer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Framer" class="anchor" title="Link to Framer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) Framer() *http2Framer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get gets the first value associated with the given key. If
there are no values associated with the key, Get returns "".
It is case insensitive; [textproto.CanonicalMIMEHeaderKey] is
used to canonicalize the provided key. Get assumes that all
keys are stored in canonical form. To use non-canonical keys,
access the map directly.</p>
               
               <pre><code>func (h Header) Get(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge">function</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get issues a GET to the specified URL. If the response is one of
the following redirect codes, Get follows the redirect, up to a
maximum of 10 redirects:
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
308 (Permanent Redirect)
An error is returned if there were too many redirects or if there
was an HTTP protocol error. A non-2xx response doesn't cause an
error. Any returned error will be of type [*url.Error]. The url.Error
value's Timeout method will report true if the request timed out.
When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.
Get is a wrapper around DefaultClient.Get.
To make a request with custom headers, use [NewRequest] and
DefaultClient.Do.
To make a request with a specified context.Context, use [NewRequestWithContext]
and DefaultClient.Do.</p>
               
               <pre><code>func Get(url string) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get issues a GET to the specified URL. If the response is one of the
following redirect codes, Get follows the redirect after calling the
[Client.CheckRedirect] function:
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
308 (Permanent Redirect)
An error is returned if the [Client.CheckRedirect] function fails
or if there was an HTTP protocol error. A non-2xx response doesn't
cause an error. Any returned error will be of type [*url.Error]. The
url.Error value's Timeout method will report true if the request
timed out.
When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.
To make a request with custom headers, use [NewRequest] and [Client.Do].
To make a request with a specified context.Context, use [NewRequestWithContext]
and Client.Do.</p>
               
               <pre><code>func (c *Client) Get(url string) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetClientConn" data-name="GetClientConn">
               <h3>
                  GetClientConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetClientConn" class="anchor" title="Link to GetClientConn">#</a>
               </h3>
               
               <pre><code>func (p http2noDialClientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetClientConn" data-name="GetClientConn">
               <h3>
                  GetClientConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetClientConn" class="anchor" title="Link to GetClientConn">#</a>
               </h3>
               
               <pre><code>func (p *http2clientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTTP1" data-name="HTTP1">
               <h3>
                  HTTP1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HTTP1" class="anchor" title="Link to HTTP1">#</a>
               </h3>
               
               <p>HTTP1 reports whether p includes HTTP/1.</p>
               
               <pre><code>func (p Protocols) HTTP1() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTTP2" data-name="HTTP2">
               <h3>
                  HTTP2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HTTP2" class="anchor" title="Link to HTTP2">#</a>
               </h3>
               
               <p>HTTP2 reports whether p includes HTTP/2.</p>
               
               <pre><code>func (p Protocols) HTTP2() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Handle" data-name="Handle">
               <h3>
                  Handle 
                  <span class="badge">function</span>
                  
                  <a href="#Handle" class="anchor" title="Link to Handle">#</a>
               </h3>
               
               <p>Handle registers the handler for the given pattern in [DefaultServeMux].
The documentation for [ServeMux] explains how patterns are matched.</p>
               
               <pre><code>func Handle(pattern string, handler Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Handle" data-name="Handle">
               <h3>
                  Handle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Handle" class="anchor" title="Link to Handle">#</a>
               </h3>
               
               <p>Handle registers the handler for the given pattern.
If the given pattern conflicts, with one that is already registered, Handle
panics.</p>
               
               <pre><code>func (mux *ServeMux) Handle(pattern string, handler Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HandleFunc" data-name="HandleFunc">
               <h3>
                  HandleFunc 
                  <span class="badge">function</span>
                  
                  <a href="#HandleFunc" class="anchor" title="Link to HandleFunc">#</a>
               </h3>
               
               <p>HandleFunc registers the handler function for the given pattern in [DefaultServeMux].
The documentation for [ServeMux] explains how patterns are matched.</p>
               
               <pre><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HandleFunc" data-name="HandleFunc">
               <h3>
                  HandleFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HandleFunc" class="anchor" title="Link to HandleFunc">#</a>
               </h3>
               
               <p>HandleFunc registers the handler function for the given pattern.
If the given pattern conflicts, with one that is already registered, HandleFunc
panics.</p>
               
               <pre><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Handler" data-name="Handler">
               <h3>
                  Handler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Handler" class="anchor" title="Link to Handler">#</a>
               </h3>
               
               <p>Handler returns the handler to use for the given request,
consulting r.Method, r.Host, and r.URL.Path. It always returns
a non-nil handler. If the path is not in its canonical form, the
handler will be an internally-generated handler that redirects
to the canonical path. If the host contains a port, it is ignored
when matching handlers.
The path and host are used unchanged for CONNECT requests.
Handler also returns the registered pattern that matches the
request or, in the case of internally-generated redirects,
the path that will match after following the redirect.
If there is no registered handler that applies to the request,
Handler returns a “page not found” handler and an empty pattern.</p>
               
               <pre><code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Has" data-name="Has">
               <h3>
                  Has 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Has" class="anchor" title="Link to Has">#</a>
               </h3>
               
               <p>Has reports whether f contains all (0 or more) flags in v.</p>
               
               <pre><code>func (f http2Flags) Has(v http2Flags) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasDuplicates" data-name="HasDuplicates">
               <h3>
                  HasDuplicates 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HasDuplicates" class="anchor" title="Link to HasDuplicates">#</a>
               </h3>
               
               <p>HasDuplicates reports whether f contains any duplicate setting IDs.</p>
               
               <pre><code>func (f *http2SettingsFrame) HasDuplicates() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPriority" data-name="HasPriority">
               <h3>
                  HasPriority 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HasPriority" class="anchor" title="Link to HasPriority">#</a>
               </h3>
               
               <pre><code>func (f *http2HeadersFrame) HasPriority() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Head" data-name="Head">
               <h3>
                  Head 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Head" class="anchor" title="Link to Head">#</a>
               </h3>
               
               <p>Head issues a HEAD to the specified URL. If the response is one of the
following redirect codes, Head follows the redirect after calling the
[Client.CheckRedirect] function:
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
308 (Permanent Redirect)
To make a request with a specified [context.Context], use [NewRequestWithContext]
and [Client.Do].</p>
               
               <pre><code>func (c *Client) Head(url string) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Head" data-name="Head">
               <h3>
                  Head 
                  <span class="badge">function</span>
                  
                  <a href="#Head" class="anchor" title="Link to Head">#</a>
               </h3>
               
               <p>Head issues a HEAD to the specified URL. If the response is one of
the following redirect codes, Head follows the redirect, up to a
maximum of 10 redirects:
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
308 (Permanent Redirect)
Head is a wrapper around DefaultClient.Head.
To make a request with a specified [context.Context], use [NewRequestWithContext]
and DefaultClient.Do.</p>
               
               <pre><code>func Head(url string) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <pre><code>func (w *response) Header() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <p>Header returns h. It exists so FrameHeaders can be embedded in other
specific frame types and implement the Frame interface.</p>
               
               <pre><code>func (h http2FrameHeader) Header() http2FrameHeader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <pre><code>func (tw *timeoutWriter) Header() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <pre><code>func (pr *populateResponse) Header() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) Header() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeaderBlockFragment" data-name="HeaderBlockFragment">
               <h3>
                  HeaderBlockFragment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeaderBlockFragment" class="anchor" title="Link to HeaderBlockFragment">#</a>
               </h3>
               
               <pre><code>func (f *http2PushPromiseFrame) HeaderBlockFragment() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeaderBlockFragment" data-name="HeaderBlockFragment">
               <h3>
                  HeaderBlockFragment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeaderBlockFragment" class="anchor" title="Link to HeaderBlockFragment">#</a>
               </h3>
               
               <pre><code>func (f *http2HeadersFrame) HeaderBlockFragment() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeaderBlockFragment" data-name="HeaderBlockFragment">
               <h3>
                  HeaderBlockFragment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeaderBlockFragment" class="anchor" title="Link to HeaderBlockFragment">#</a>
               </h3>
               
               <pre><code>func (f *http2ContinuationFrame) HeaderBlockFragment() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeaderEncoder" data-name="HeaderEncoder">
               <h3>
                  HeaderEncoder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeaderEncoder" class="anchor" title="Link to HeaderEncoder">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeadersEnded" data-name="HeadersEnded">
               <h3>
                  HeadersEnded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeadersEnded" class="anchor" title="Link to HeadersEnded">#</a>
               </h3>
               
               <pre><code>func (f *http2PushPromiseFrame) HeadersEnded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeadersEnded" data-name="HeadersEnded">
               <h3>
                  HeadersEnded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeadersEnded" class="anchor" title="Link to HeadersEnded">#</a>
               </h3>
               
               <pre><code>func (f *http2HeadersFrame) HeadersEnded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeadersEnded" data-name="HeadersEnded">
               <h3>
                  HeadersEnded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HeadersEnded" class="anchor" title="Link to HeadersEnded">#</a>
               </h3>
               
               <pre><code>func (f *http2ContinuationFrame) HeadersEnded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hijack" data-name="Hijack">
               <h3>
                  Hijack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hijack" class="anchor" title="Link to Hijack">#</a>
               </h3>
               
               <p>Hijack lets the caller take over the connection.
See the Hijacker interface for details.</p>
               
               <pre><code>func (c *ResponseController) Hijack() (net.Conn, *bufio.ReadWriter, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hijack" data-name="Hijack">
               <h3>
                  Hijack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hijack" class="anchor" title="Link to Hijack">#</a>
               </h3>
               
               <p>Hijack implements the [Hijacker.Hijack] method. Our response is both a [ResponseWriter]
and a [Hijacker].</p>
               
               <pre><code>func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>Init makes a closeWaiter usable.
It exists because so a closeWaiter value can be placed inside a
larger struct and have the Mutex and Cond's memory in the same
allocation.</p>
               
               <pre><code>func (cw *http2closeWaiter) Init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <p>Is lets http.ErrNotSupported match errors.ErrUnsupported.</p>
               
               <pre><code>func (pe *ProtocolError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <pre><code>func (e *timeoutError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsAck" data-name="IsAck">
               <h3>
                  IsAck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsAck" class="anchor" title="Link to IsAck">#</a>
               </h3>
               
               <pre><code>func (f *http2PingFrame) IsAck() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsAck" data-name="IsAck">
               <h3>
                  IsAck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsAck" class="anchor" title="Link to IsAck">#</a>
               </h3>
               
               <pre><code>func (f *http2SettingsFrame) IsAck() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsHTTP2NoCachedConnError" data-name="IsHTTP2NoCachedConnError">
               <h3>
                  IsHTTP2NoCachedConnError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsHTTP2NoCachedConnError" class="anchor" title="Link to IsHTTP2NoCachedConnError">#</a>
               </h3>
               
               <pre><code>func (http2noCachedConnError) IsHTTP2NoCachedConnError()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsHTTP2NoCachedConnError" data-name="IsHTTP2NoCachedConnError">
               <h3>
                  IsHTTP2NoCachedConnError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsHTTP2NoCachedConnError" class="anchor" title="Link to IsHTTP2NoCachedConnError">#</a>
               </h3>
               
               <pre><code>func (http2noCachedConnError) IsHTTP2NoCachedConnError()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsZero" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsZero" class="anchor" title="Link to IsZero">#</a>
               </h3>
               
               <pre><code>func (p http2PriorityParam) IsZero() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Keys" data-name="Keys">
               <h3>
                  Keys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Keys" class="anchor" title="Link to Keys">#</a>
               </h3>
               
               <p>Keys returns the sorted keys of h.
The returned slice is only valid until s used again or returned to
its pool.</p>
               
               <pre><code>func (s *http2sorter) Keys(h Header) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code>func (s *http2sorter) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of bytes of the unread portion of the buffer.</p>
               
               <pre><code>func (b *http2dataBuffer) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code>func (z http2sortPriorityNodeSiblings) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code>func (p *http2pipe) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code>func (s *http2sorter) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code>func (z http2sortPriorityNodeSiblings) Less(i int, k int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ListenAndServe" data-name="ListenAndServe">
               <h3>
                  ListenAndServe 
                  <span class="badge">function</span>
                  
                  <a href="#ListenAndServe" class="anchor" title="Link to ListenAndServe">#</a>
               </h3>
               
               <p>ListenAndServe listens on the TCP network address addr and then calls
[Serve] with handler to handle requests on incoming connections.
Accepted connections are configured to enable TCP keep-alives.
The handler is typically nil, in which case [DefaultServeMux] is used.
ListenAndServe always returns a non-nil error.</p>
               
               <pre><code>func ListenAndServe(addr string, handler Handler) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ListenAndServe" data-name="ListenAndServe">
               <h3>
                  ListenAndServe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ListenAndServe" class="anchor" title="Link to ListenAndServe">#</a>
               </h3>
               
               <p>ListenAndServe listens on the TCP network address s.Addr and then
calls [Serve] to handle requests on incoming connections.
Accepted connections are configured to enable TCP keep-alives.
If s.Addr is blank, ":http" is used.
ListenAndServe always returns a non-nil error. After [Server.Shutdown] or [Server.Close],
the returned error is [ErrServerClosed].</p>
               
               <pre><code>func (s *Server) ListenAndServe() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ListenAndServeTLS" data-name="ListenAndServeTLS">
               <h3>
                  ListenAndServeTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ListenAndServeTLS" class="anchor" title="Link to ListenAndServeTLS">#</a>
               </h3>
               
               <p>ListenAndServeTLS listens on the TCP network address s.Addr and
then calls [ServeTLS] to handle requests on incoming TLS connections.
Accepted connections are configured to enable TCP keep-alives.
Filenames containing a certificate and matching private key for the
server must be provided if neither the [Server]'s TLSConfig.Certificates
nor TLSConfig.GetCertificate are populated. If the certificate is
signed by a certificate authority, the certFile should be the
concatenation of the server's certificate, any intermediates, and
the CA's certificate.
If s.Addr is blank, ":https" is used.
ListenAndServeTLS always returns a non-nil error. After [Server.Shutdown] or
[Server.Close], the returned error is [ErrServerClosed].</p>
               
               <pre><code>func (s *Server) ListenAndServeTLS(certFile string, keyFile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ListenAndServeTLS" data-name="ListenAndServeTLS">
               <h3>
                  ListenAndServeTLS 
                  <span class="badge">function</span>
                  
                  <a href="#ListenAndServeTLS" class="anchor" title="Link to ListenAndServeTLS">#</a>
               </h3>
               
               <p>ListenAndServeTLS acts identically to [ListenAndServe], except that it
expects HTTPS connections. Additionally, files containing a certificate and
matching private key for the server must be provided. If the certificate
is signed by a certificate authority, the certFile should be the concatenation
of the server's certificate, any intermediates, and the CA's certificate.</p>
               
               <pre><code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Location" data-name="Location">
               <h3>
                  Location 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Location" class="anchor" title="Link to Location">#</a>
               </h3>
               
               <p>Location returns the URL of the response's "Location" header,
if present. Relative redirects are resolved relative to
[Response.Request]. [ErrNoLocation] is returned if no
Location header is present.</p>
               
               <pre><code>func (r *Response) Location() (*url.URL, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <pre><code>func (fakeLocker) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkDead" data-name="MarkDead">
               <h3>
                  MarkDead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarkDead" class="anchor" title="Link to MarkDead">#</a>
               </h3>
               
               <pre><code>func (p *http2clientConnPool) MarkDead(cc *http2ClientConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MaxBytesHandler" data-name="MaxBytesHandler">
               <h3>
                  MaxBytesHandler 
                  <span class="badge">function</span>
                  
                  <a href="#MaxBytesHandler" class="anchor" title="Link to MaxBytesHandler">#</a>
               </h3>
               
               <p>MaxBytesHandler returns a [Handler] that runs h with its [ResponseWriter] and [Request.Body] wrapped by a MaxBytesReader.</p>
               
               <pre><code>func MaxBytesHandler(h Handler, n int64) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MaxBytesReader" data-name="MaxBytesReader">
               <h3>
                  MaxBytesReader 
                  <span class="badge">function</span>
                  
                  <a href="#MaxBytesReader" class="anchor" title="Link to MaxBytesReader">#</a>
               </h3>
               
               <p>MaxBytesReader is similar to [io.LimitReader] but is intended for
limiting the size of incoming request bodies. In contrast to
io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
non-nil error of type [*MaxBytesError] for a Read beyond the limit,
and closes the underlying reader when its Close method is called.
MaxBytesReader prevents clients from accidentally or maliciously
sending a large request and wasting server resources. If possible,
it tells the [ResponseWriter] to close the connection after the limit
has been reached.</p>
               
               <pre><code>func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MultipartReader" data-name="MultipartReader">
               <h3>
                  MultipartReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MultipartReader" class="anchor" title="Link to MultipartReader">#</a>
               </h3>
               
               <p>MultipartReader returns a MIME multipart reader if this is a
multipart/form-data or a multipart/mixed POST request, else returns nil and an error.
Use this function instead of [Request.ParseMultipartForm] to
process the request body as a stream.</p>
               
               <pre><code>func (r *Request) MultipartReader() (*multipart.Reader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Network" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Network" class="anchor" title="Link to Network">#</a>
               </h3>
               
               <pre><code>func (a *socksAddr) Network() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewClientConn" data-name="NewClientConn">
               <h3>
                  NewClientConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewClientConn" class="anchor" title="Link to NewClientConn">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFileTransport" data-name="NewFileTransport">
               <h3>
                  NewFileTransport 
                  <span class="badge">function</span>
                  
                  <a href="#NewFileTransport" class="anchor" title="Link to NewFileTransport">#</a>
               </h3>
               
               <p>NewFileTransport returns a new [RoundTripper], serving the provided
[FileSystem]. The returned RoundTripper ignores the URL host in its
incoming requests, as well as most other properties of the
request.
The typical use case for NewFileTransport is to register the "file"
protocol with a [Transport], as in:
t := &http.Transport{}
t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
c := &http.Client{Transport: t}
res, err := c.Get("file:///etc/passwd")
...</p>
               
               <pre><code>func NewFileTransport(fs FileSystem) RoundTripper</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFileTransportFS" data-name="NewFileTransportFS">
               <h3>
                  NewFileTransportFS 
                  <span class="badge">function</span>
                  
                  <a href="#NewFileTransportFS" class="anchor" title="Link to NewFileTransportFS">#</a>
               </h3>
               
               <p>NewFileTransportFS returns a new [RoundTripper], serving the provided
file system fsys. The returned RoundTripper ignores the URL host in its
incoming requests, as well as most other properties of the
request. The files provided by fsys must implement [io.Seeker].
The typical use case for NewFileTransportFS is to register the "file"
protocol with a [Transport], as in:
fsys := os.DirFS("/")
t := &http.Transport{}
t.RegisterProtocol("file", http.NewFileTransportFS(fsys))
c := &http.Client{Transport: t}
res, err := c.Get("file:///etc/passwd")
...</p>
               
               <pre><code>func NewFileTransportFS(fsys fs.FS) RoundTripper</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewRequest" data-name="NewRequest">
               <h3>
                  NewRequest 
                  <span class="badge">function</span>
                  
                  <a href="#NewRequest" class="anchor" title="Link to NewRequest">#</a>
               </h3>
               
               <p>NewRequest wraps [NewRequestWithContext] using [context.Background].</p>
               
               <pre><code>func NewRequest(method string, url string, body io.Reader) (*Request, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewRequestWithContext" data-name="NewRequestWithContext">
               <h3>
                  NewRequestWithContext 
                  <span class="badge">function</span>
                  
                  <a href="#NewRequestWithContext" class="anchor" title="Link to NewRequestWithContext">#</a>
               </h3>
               
               <p>NewRequestWithContext returns a new [Request] given a method, URL, and
optional body.
If the provided body is also an [io.Closer], the returned
[Request.Body] is set to body and will be closed (possibly
asynchronously) by the Client methods Do, Post, and PostForm,
and [Transport.RoundTrip].
NewRequestWithContext returns a Request suitable for use with
[Client.Do] or [Transport.RoundTrip]. To create a request for use with
testing a Server Handler, either use the [net/http/httptest.NewRequest] function,
use [ReadRequest], or manually update the Request fields.
For an outgoing client request, the context
controls the entire lifetime of a request and its response:
obtaining a connection, sending the request, and reading the
response headers and body. See the Request type's documentation for
the difference between inbound and outbound request fields.
If body is of type [*bytes.Buffer], [*bytes.Reader], or
[*strings.Reader], the returned request's ContentLength is set to its
exact value (instead of -1), GetBody is populated (so 307 and 308
redirects can replay the body), and Body is set to [NoBody] if the
ContentLength is 0.</p>
               
               <pre><code>func NewRequestWithContext(ctx context.Context, method string, url string, body io.Reader) (*Request, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewResponseController" data-name="NewResponseController">
               <h3>
                  NewResponseController 
                  <span class="badge">function</span>
                  
                  <a href="#NewResponseController" class="anchor" title="Link to NewResponseController">#</a>
               </h3>
               
               <p>NewResponseController creates a [ResponseController] for a request.
The ResponseWriter should be the original value passed to the [Handler.ServeHTTP] method,
or have an Unwrap method returning the original ResponseWriter.
If the ResponseWriter implements any of the following methods, the ResponseController
will call them as appropriate:
Flush()
FlushError() error // alternative Flush returning an error
Hijack() (net.Conn, *bufio.ReadWriter, error)
SetReadDeadline(deadline time.Time) error
SetWriteDeadline(deadline time.Time) error
EnableFullDuplex() error
If the ResponseWriter does not support a method, ResponseController returns
an error matching [ErrNotSupported].</p>
               
               <pre><code>func NewResponseController(rw ResponseWriter) *ResponseController</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewServeMux" data-name="NewServeMux">
               <h3>
                  NewServeMux 
                  <span class="badge">function</span>
                  
                  <a href="#NewServeMux" class="anchor" title="Link to NewServeMux">#</a>
               </h3>
               
               <p>NewServeMux allocates and returns a new [ServeMux].</p>
               
               <pre><code>func NewServeMux() *ServeMux</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NotFound" data-name="NotFound">
               <h3>
                  NotFound 
                  <span class="badge">function</span>
                  
                  <a href="#NotFound" class="anchor" title="Link to NotFound">#</a>
               </h3>
               
               <p>NotFound replies to the request with an HTTP 404 not found error.</p>
               
               <pre><code>func NotFound(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NotFoundHandler" data-name="NotFoundHandler">
               <h3>
                  NotFoundHandler 
                  <span class="badge">function</span>
                  
                  <a href="#NotFoundHandler" class="anchor" title="Link to NotFoundHandler">#</a>
               </h3>
               
               <p>NotFoundHandler returns a simple request handler
that replies to each request with a “404 page not found” reply.</p>
               
               <pre><code>func NotFoundHandler() Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumSettings" data-name="NumSettings">
               <h3>
                  NumSettings 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumSettings" class="anchor" title="Link to NumSettings">#</a>
               </h3>
               
               <pre><code>func (f *http2SettingsFrame) NumSettings() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code>func (f ioFS) Open(name string) (File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open implements [FileSystem] using [os.Open], opening files for reading rooted
and relative to the directory d.</p>
               
               <pre><code>func (d Dir) Open(name string) (File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenStream" data-name="OpenStream">
               <h3>
                  OpenStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OpenStream" class="anchor" title="Link to OpenStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenStream" data-name="OpenStream">
               <h3>
                  OpenStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OpenStream" class="anchor" title="Link to OpenStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2roundRobinWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenStream" data-name="OpenStream">
               <h3>
                  OpenStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OpenStream" class="anchor" title="Link to OpenStream">#</a>
               </h3>
               
               <pre><code>func (ws *http2randomWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseCookie" data-name="ParseCookie">
               <h3>
                  ParseCookie 
                  <span class="badge">function</span>
                  
                  <a href="#ParseCookie" class="anchor" title="Link to ParseCookie">#</a>
               </h3>
               
               <p>ParseCookie parses a Cookie header value and returns all the cookies
which were set in it. Since the same cookie name can appear multiple times
the returned Values can contain more than one value for a given key.</p>
               
               <pre><code>func ParseCookie(line string) ([]*Cookie, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseForm" data-name="ParseForm">
               <h3>
                  ParseForm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ParseForm" class="anchor" title="Link to ParseForm">#</a>
               </h3>
               
               <p>ParseForm populates r.Form and r.PostForm.
For all requests, ParseForm parses the raw query from the URL and updates
r.Form.
For POST, PUT, and PATCH requests, it also reads the request body, parses it
as a form and puts the results into both r.PostForm and r.Form. Request body
parameters take precedence over URL query string values in r.Form.
If the request Body's size has not already been limited by [MaxBytesReader],
the size is capped at 10MB.
For other HTTP methods, or when the Content-Type is not
application/x-www-form-urlencoded, the request Body is not read, and
r.PostForm is initialized to a non-nil, empty value.
[Request.ParseMultipartForm] calls ParseForm automatically.
ParseForm is idempotent.</p>
               
               <pre><code>func (r *Request) ParseForm() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseHTTPVersion" data-name="ParseHTTPVersion">
               <h3>
                  ParseHTTPVersion 
                  <span class="badge">function</span>
                  
                  <a href="#ParseHTTPVersion" class="anchor" title="Link to ParseHTTPVersion">#</a>
               </h3>
               
               <p>ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6.
"HTTP/1.0" returns (1, 0, true). Note that strings without
a minor version, such as "HTTP/2", are not valid.</p>
               
               <pre><code>func ParseHTTPVersion(vers string) (major int, minor int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseMultipartForm" data-name="ParseMultipartForm">
               <h3>
                  ParseMultipartForm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ParseMultipartForm" class="anchor" title="Link to ParseMultipartForm">#</a>
               </h3>
               
               <p>ParseMultipartForm parses a request body as multipart/form-data.
The whole request body is parsed and up to a total of maxMemory bytes of
its file parts are stored in memory, with the remainder stored on
disk in temporary files.
ParseMultipartForm calls [Request.ParseForm] if necessary.
If ParseForm returns an error, ParseMultipartForm returns it but also
continues parsing the request body.
After one call to ParseMultipartForm, subsequent calls have no effect.</p>
               
               <pre><code>func (r *Request) ParseMultipartForm(maxMemory int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseSetCookie" data-name="ParseSetCookie">
               <h3>
                  ParseSetCookie 
                  <span class="badge">function</span>
                  
                  <a href="#ParseSetCookie" class="anchor" title="Link to ParseSetCookie">#</a>
               </h3>
               
               <p>ParseSetCookie parses a Set-Cookie header value and returns a cookie.
It returns an error on syntax error.</p>
               
               <pre><code>func ParseSetCookie(line string) (*Cookie, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseTime" data-name="ParseTime">
               <h3>
                  ParseTime 
                  <span class="badge">function</span>
                  
                  <a href="#ParseTime" class="anchor" title="Link to ParseTime">#</a>
               </h3>
               
               <p>ParseTime parses a time header (such as the Date: header),
trying each of the three formats allowed by HTTP/1.1:
[TimeFormat], [time.RFC850], and [time.ANSIC].</p>
               
               <pre><code>func ParseTime(text string) (t time.Time, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PathValue" data-name="PathValue">
               <h3>
                  PathValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PathValue" class="anchor" title="Link to PathValue">#</a>
               </h3>
               
               <p>PathValue returns the value for the named path wildcard in the [ServeMux] pattern
that matched the request.
It returns the empty string if the request was not matched against a pattern
or there is no such wildcard in the pattern.</p>
               
               <pre><code>func (r *Request) PathValue(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Payload" data-name="Payload">
               <h3>
                  Payload 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Payload" class="anchor" title="Link to Payload">#</a>
               </h3>
               
               <p>Payload returns the frame's payload (after the header).  It is not
valid to call this method after a subsequent call to
Framer.ReadFrame, nor is it valid to retain the returned slice.
The memory is owned by the Framer and is invalidated when the next
frame is read.</p>
               
               <pre><code>func (f *http2UnknownFrame) Payload() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Ping" data-name="Ping">
               <h3>
                  Ping 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Ping" class="anchor" title="Link to Ping">#</a>
               </h3>
               
               <p>Ping sends a PING frame to the server and waits for the ack.</p>
               
               <pre><code>func (cc *http2ClientConn) Ping(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code>func (ws *http2randomWriteScheduler) Pop() (http2FrameWriteRequest, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code>func (ws *http2roundRobinWriteScheduler) Pop() (http2FrameWriteRequest, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) Pop() (wr http2FrameWriteRequest, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Post" data-name="Post">
               <h3>
                  Post 
                  <span class="badge">function</span>
                  
                  <a href="#Post" class="anchor" title="Link to Post">#</a>
               </h3>
               
               <p>Post issues a POST to the specified URL.
Caller should close resp.Body when done reading from it.
If the provided body is an [io.Closer], it is closed after the
request.
Post is a wrapper around DefaultClient.Post.
To set custom headers, use [NewRequest] and DefaultClient.Do.
See the [Client.Do] method documentation for details on how redirects
are handled.
To make a request with a specified context.Context, use [NewRequestWithContext]
and DefaultClient.Do.</p>
               
               <pre><code>func Post(url string, contentType string, body io.Reader) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Post" data-name="Post">
               <h3>
                  Post 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Post" class="anchor" title="Link to Post">#</a>
               </h3>
               
               <p>Post issues a POST to the specified URL.
Caller should close resp.Body when done reading from it.
If the provided body is an [io.Closer], it is closed after the
request.
To set custom headers, use [NewRequest] and [Client.Do].
To make a request with a specified context.Context, use [NewRequestWithContext]
and [Client.Do].
See the Client.Do method documentation for details on how redirects
are handled.</p>
               
               <pre><code>func (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PostForm" data-name="PostForm">
               <h3>
                  PostForm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PostForm" class="anchor" title="Link to PostForm">#</a>
               </h3>
               
               <p>PostForm issues a POST to the specified URL,
with data's keys and values URL-encoded as the request body.
The Content-Type header is set to application/x-www-form-urlencoded.
To set other headers, use [NewRequest] and [Client.Do].
When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.
See the Client.Do method documentation for details on how redirects
are handled.
To make a request with a specified context.Context, use [NewRequestWithContext]
and Client.Do.</p>
               
               <pre><code>func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PostForm" data-name="PostForm">
               <h3>
                  PostForm 
                  <span class="badge">function</span>
                  
                  <a href="#PostForm" class="anchor" title="Link to PostForm">#</a>
               </h3>
               
               <p>PostForm issues a POST to the specified URL, with data's keys and
values URL-encoded as the request body.
The Content-Type header is set to application/x-www-form-urlencoded.
To set other headers, use [NewRequest] and DefaultClient.Do.
When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.
PostForm is a wrapper around DefaultClient.PostForm.
See the [Client.Do] method documentation for details on how redirects
are handled.
To make a request with a specified [context.Context], use [NewRequestWithContext]
and DefaultClient.Do.</p>
               
               <pre><code>func PostForm(url string, data url.Values) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PostFormValue" data-name="PostFormValue">
               <h3>
                  PostFormValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PostFormValue" class="anchor" title="Link to PostFormValue">#</a>
               </h3>
               
               <p>PostFormValue returns the first value for the named component of the POST,
PUT, or PATCH request body. URL query parameters are ignored.
PostFormValue calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary and ignores
any errors returned by these functions.
If key is not present, PostFormValue returns the empty string.</p>
               
               <pre><code>func (r *Request) PostFormValue(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProtoAtLeast" data-name="ProtoAtLeast">
               <h3>
                  ProtoAtLeast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProtoAtLeast" class="anchor" title="Link to ProtoAtLeast">#</a>
               </h3>
               
               <p>ProtoAtLeast reports whether the HTTP protocol used
in the request is at least major.minor.</p>
               
               <pre><code>func (r *Request) ProtoAtLeast(major int, minor int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProtoAtLeast" data-name="ProtoAtLeast">
               <h3>
                  ProtoAtLeast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProtoAtLeast" class="anchor" title="Link to ProtoAtLeast">#</a>
               </h3>
               
               <p>ProtoAtLeast reports whether the HTTP protocol used
in the response is at least major.minor.</p>
               
               <pre><code>func (r *Response) ProtoAtLeast(major int, minor int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProxyFromEnvironment" data-name="ProxyFromEnvironment">
               <h3>
                  ProxyFromEnvironment 
                  <span class="badge">function</span>
                  
                  <a href="#ProxyFromEnvironment" class="anchor" title="Link to ProxyFromEnvironment">#</a>
               </h3>
               
               <p>ProxyFromEnvironment returns the URL of the proxy to use for a
given request, as indicated by the environment variables
HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions
thereof). Requests use the proxy from the environment variable
matching their scheme, unless excluded by NO_PROXY.
The environment values may be either a complete URL or a
"host[:port]", in which case the "http" scheme is assumed.
An error is returned if the value is a different form.
A nil URL and nil error are returned if no proxy is defined in the
environment, or a proxy should not be used for the given request,
as defined by NO_PROXY.
As a special case, if req.URL.Host is "localhost" (with or without
a port number), then a nil URL and nil error will be returned.</p>
               
               <pre><code>func ProxyFromEnvironment(req *Request) (*url.URL, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProxyURL" data-name="ProxyURL">
               <h3>
                  ProxyURL 
                  <span class="badge">function</span>
                  
                  <a href="#ProxyURL" class="anchor" title="Link to ProxyURL">#</a>
               </h3>
               
               <p>ProxyURL returns a proxy function (for use in a [Transport])
that always returns the same URL.</p>
               
               <pre><code>func ProxyURL(fixedURL *url.URL) (func(*Request) (*url.URL, error))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PseudoFields" data-name="PseudoFields">
               <h3>
                  PseudoFields 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PseudoFields" class="anchor" title="Link to PseudoFields">#</a>
               </h3>
               
               <p>PseudoFields returns the pseudo header fields of mh.
The caller does not own the returned slice.</p>
               
               <pre><code>func (mh *http2MetaHeadersFrame) PseudoFields() []hpack.HeaderField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PseudoValue" data-name="PseudoValue">
               <h3>
                  PseudoValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PseudoValue" class="anchor" title="Link to PseudoValue">#</a>
               </h3>
               
               <p>PseudoValue returns the given pseudo header field's value.
The provided pseudo field should not contain the leading colon.</p>
               
               <pre><code>func (mh *http2MetaHeadersFrame) PseudoValue(pseudo string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <p>Push implements the [Pusher] interface.</p>
               
               <pre><code>func (tw *timeoutWriter) Push(target string, opts *PushOptions) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) Push(wr http2FrameWriteRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code>func (ws *http2randomWriteScheduler) Push(wr http2FrameWriteRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code>func (ws *http2roundRobinWriteScheduler) Push(wr http2FrameWriteRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) Push(target string, opts *PushOptions) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read copies bytes from the buffer into p.
It is an error to read when no data is available.</p>
               
               <pre><code>func (b *http2dataBuffer) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r *readTrackingBody) Read(data []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r *streamReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (ecr *expectContinueReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (b *readWriteCloserBody) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (b *http2requestBody) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (es *bodyEOFSignal) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (http2noBodyReader) Read([]byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r *arrayReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (br *byteReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (b *body) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (http2missingBody) Read([]byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (b *cancelTimerBody) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (b http2transportResponseBody) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (f ioFile) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read waits until data is available and copies bytes
from the buffer into p.</p>
               
               <pre><code>func (p *http2pipe) Read(d []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (gz *http2gzipReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r errorReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (bl bodyLocked) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (noBody) Read([]byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (gz *gzipReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (fr finishAsyncByteRead) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (l *maxBytesReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (c *loggingConn) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r http2errorReader) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <pre><code>func (f ioFile) ReadDir(count int) ([]fs.DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrame" data-name="ReadFrame">
               <h3>
                  ReadFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrame" class="anchor" title="Link to ReadFrame">#</a>
               </h3>
               
               <p>ReadFrame reads a single frame. The returned Frame is only valid
until the next call to ReadFrame.
If the frame is larger than previously set with SetMaxReadFrameSize, the
returned error is ErrFrameTooLarge. Other errors may be of type
ConnectionError, StreamError, or anything else from the underlying
reader.
If ReadFrame returns an error and a non-nil Frame, the Frame's StreamID
indicates the stream responsible for the error.</p>
               
               <pre><code>func (fr *http2Framer) ReadFrame() (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <p>ReadFrom is here to optimize copying from an [*os.File] regular file
to a [*net.TCPConn] with sendfile, or from a supported src type such
as a *net.TCPConn on Linux with splice.</p>
               
               <pre><code>func (w *response) ReadFrom(src io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <p>ReadFrom exposes persistConnWriter's underlying Conn to io.Copy and if
the Conn implements io.ReaderFrom, it can take advantage of optimizations
such as sendfile.</p>
               
               <pre><code>func (w persistConnWriter) ReadFrom(r io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRequest" data-name="ReadRequest">
               <h3>
                  ReadRequest 
                  <span class="badge">function</span>
                  
                  <a href="#ReadRequest" class="anchor" title="Link to ReadRequest">#</a>
               </h3>
               
               <p>ReadRequest reads and parses an incoming request from b.
ReadRequest is a low-level function and should only be used for
specialized applications; most code should use the [Server] to read
requests and handle them via the [Handler] interface. ReadRequest
only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</p>
               
               <pre><code>func ReadRequest(b *bufio.Reader) (*Request, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadResponse" data-name="ReadResponse">
               <h3>
                  ReadResponse 
                  <span class="badge">function</span>
                  
                  <a href="#ReadResponse" class="anchor" title="Link to ReadResponse">#</a>
               </h3>
               
               <p>ReadResponse reads and returns an HTTP response from r.
The req parameter optionally specifies the [Request] that corresponds
to this [Response]. If nil, a GET request is assumed.
Clients must call resp.Body.Close when finished reading resp.Body.
After that call, clients can inspect resp.Trailer to find key/value
pairs included in the response trailer.</p>
               
               <pre><code>func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Readdir" data-name="Readdir">
               <h3>
                  Readdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Readdir" class="anchor" title="Link to Readdir">#</a>
               </h3>
               
               <pre><code>func (f ioFile) Readdir(count int) ([]fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Redirect" data-name="Redirect">
               <h3>
                  Redirect 
                  <span class="badge">function</span>
                  
                  <a href="#Redirect" class="anchor" title="Link to Redirect">#</a>
               </h3>
               
               <p>Redirect replies to the request with a redirect to url,
which may be a path relative to the request path.
The provided code should be in the 3xx range and is usually
[StatusMovedPermanently], [StatusFound] or [StatusSeeOther].
If the Content-Type header has not been set, [Redirect] sets it
to "text/html; charset=utf-8" and writes a small HTML body.
Setting the Content-Type header to any value, including nil,
disables that behavior.</p>
               
               <pre><code>func Redirect(w ResponseWriter, r *Request, url string, code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RedirectHandler" data-name="RedirectHandler">
               <h3>
                  RedirectHandler 
                  <span class="badge">function</span>
                  
                  <a href="#RedirectHandler" class="anchor" title="Link to RedirectHandler">#</a>
               </h3>
               
               <p>RedirectHandler returns a request handler that redirects
each request it receives to the given url using the given
status code.
The provided code should be in the 3xx range and is usually
[StatusMovedPermanently], [StatusFound] or [StatusSeeOther].</p>
               
               <pre><code>func RedirectHandler(url string, code int) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Referer" data-name="Referer">
               <h3>
                  Referer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Referer" class="anchor" title="Link to Referer">#</a>
               </h3>
               
               <p>Referer returns the referring URL, if sent in the request.
Referer is misspelled as in the request itself, a mistake from the
earliest days of HTTP.  This value can also be fetched from the
[Header] map as Header["Referer"]; the benefit of making it available
as a method is that the compiler can diagnose programs that use the
alternate (correct English) spelling req.Referrer() but cannot
diagnose programs that use Header["Referrer"].</p>
               
               <pre><code>func (r *Request) Referer() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterOnShutdown" data-name="RegisterOnShutdown">
               <h3>
                  RegisterOnShutdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RegisterOnShutdown" class="anchor" title="Link to RegisterOnShutdown">#</a>
               </h3>
               
               <p>RegisterOnShutdown registers a function to call on [Server.Shutdown].
This can be used to gracefully shutdown connections that have
undergone ALPN protocol upgrade or that have been hijacked.
This function should start protocol-specific graceful shutdown,
but should not wait for shutdown to complete.</p>
               
               <pre><code>func (s *Server) RegisterOnShutdown(f func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterProtocol" data-name="RegisterProtocol">
               <h3>
                  RegisterProtocol 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RegisterProtocol" class="anchor" title="Link to RegisterProtocol">#</a>
               </h3>
               
               <p>RegisterProtocol registers a new protocol with scheme.
The [Transport] will pass requests using the given scheme to rt.
It is rt's responsibility to simulate HTTP request semantics.
RegisterProtocol can be used by other packages to provide
implementations of protocol schemes like "ftp" or "file".
If rt.RoundTrip returns [ErrSkipAltProtocol], the Transport will
handle the [Transport.RoundTrip] itself for that one request, as if the
protocol were not registered.</p>
               
               <pre><code>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegularFields" data-name="RegularFields">
               <h3>
                  RegularFields 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RegularFields" class="anchor" title="Link to RegularFields">#</a>
               </h3>
               
               <p>RegularFields returns the regular (non-pseudo) header fields of mh.
The caller does not own the returned slice.</p>
               
               <pre><code>func (mh *http2MetaHeadersFrame) RegularFields() []hpack.HeaderField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReserveNewRequest" data-name="ReserveNewRequest">
               <h3>
                  ReserveNewRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReserveNewRequest" class="anchor" title="Link to ReserveNewRequest">#</a>
               </h3>
               
               <p>ReserveNewRequest is like CanTakeNewRequest but also reserves a
concurrent stream in cc. The reservation is decremented on the
next call to RoundTrip.</p>
               
               <pre><code>func (cc *http2ClientConn) ReserveNewRequest() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <p>RoundTrip implements the [RoundTripper] interface.
For higher-level HTTP client support (such as handling of cookies
and redirects), see [Get], [Post], and the [Client] type.
Like the RoundTripper interface, the error types returned
by RoundTrip are unspecified.</p>
               
               <pre><code>func (t *Transport) RoundTrip(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) RoundTrip(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (http2noDialH2RoundTripper) RoundTrip(*Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (*http2Transport) RoundTrip(*Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <p>RoundTrip implements the [RoundTripper] interface using the WHATWG Fetch API.</p>
               
               <pre><code>func (t *Transport) RoundTrip(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (rt http2noDialH2RoundTripper) RoundTrip(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (rt http2erringRoundTripper) RoundTrip(*Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (t *http2unencryptedTransport) RoundTrip(req *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTrip" data-name="RoundTrip">
               <h3>
                  RoundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTrip" class="anchor" title="Link to RoundTrip">#</a>
               </h3>
               
               <pre><code>func (t fileTransport) RoundTrip(req *Request) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTripErr" data-name="RoundTripErr">
               <h3>
                  RoundTripErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTripErr" class="anchor" title="Link to RoundTripErr">#</a>
               </h3>
               
               <pre><code>func (rt http2erringRoundTripper) RoundTripErr() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RoundTripOpt" data-name="RoundTripOpt">
               <h3>
                  RoundTripOpt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RoundTripOpt" class="anchor" title="Link to RoundTripOpt">#</a>
               </h3>
               
               <p>RoundTripOpt is like RoundTrip, but takes options.</p>
               
               <pre><code>func (t *http2Transport) RoundTripOpt(req *Request, opt http2RoundTripOpt) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seek" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seek" class="anchor" title="Link to Seek">#</a>
               </h3>
               
               <pre><code>func (f ioFile) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Serve" data-name="Serve">
               <h3>
                  Serve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Serve" class="anchor" title="Link to Serve">#</a>
               </h3>
               
               <p>Serve accepts incoming connections on the Listener l, creating a
new service goroutine for each. The service goroutines read requests and
then call s.Handler to reply to them.
HTTP/2 support is only enabled if the Listener returns [*tls.Conn]
connections and they were configured with "h2" in the TLS
Config.NextProtos.
Serve always returns a non-nil error and closes l.
After [Server.Shutdown] or [Server.Close], the returned error is [ErrServerClosed].</p>
               
               <pre><code>func (s *Server) Serve(l net.Listener) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Serve" data-name="Serve">
               <h3>
                  Serve 
                  <span class="badge">function</span>
                  
                  <a href="#Serve" class="anchor" title="Link to Serve">#</a>
               </h3>
               
               <p>Serve accepts incoming HTTP connections on the listener l,
creating a new service goroutine for each. The service goroutines
read requests and then call handler to reply to them.
The handler is typically nil, in which case [DefaultServeMux] is used.
HTTP/2 support is only enabled if the Listener returns [*tls.Conn]
connections and they were configured with "h2" in the TLS
Config.NextProtos.
Serve always returns a non-nil error.</p>
               
               <pre><code>func Serve(l net.Listener, handler Handler) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeConn" data-name="ServeConn">
               <h3>
                  ServeConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeConn" class="anchor" title="Link to ServeConn">#</a>
               </h3>
               
               <p>ServeConn serves HTTP/2 requests on the provided connection and
blocks until the connection is no longer readable.
ServeConn starts speaking HTTP/2 assuming that c has not had any
reads or writes. It writes its initial settings frame and expects
to be able to read the preface and settings frame from the
client. If c has a ConnectionState method like a *tls.Conn, the
ConnectionState is used to verify the TLS ciphersuite and to set
the Request.TLS field in Handlers.
ServeConn does not support h2c by itself. Any h2c support must be
implemented in terms of providing a suitably-behaving net.Conn.
The opts parameter is optional. If nil, default values are used.</p>
               
               <pre><code>func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeContent" data-name="ServeContent">
               <h3>
                  ServeContent 
                  <span class="badge">function</span>
                  
                  <a href="#ServeContent" class="anchor" title="Link to ServeContent">#</a>
               </h3>
               
               <p>ServeContent replies to the request using the content in the
provided ReadSeeker. The main benefit of ServeContent over [io.Copy]
is that it handles Range requests properly, sets the MIME type, and
handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,
and If-Range requests.
If the response's Content-Type header is not set, ServeContent
first tries to deduce the type from name's file extension and,
if that fails, falls back to reading the first block of the content
and passing it to [DetectContentType].
The name is otherwise unused; in particular it can be empty and is
never sent in the response.
If modtime is not the zero time or Unix epoch, ServeContent
includes it in a Last-Modified header in the response. If the
request includes an If-Modified-Since header, ServeContent uses
modtime to decide whether the content needs to be sent at all.
The content's Seek method must work: ServeContent uses
a seek to the end of the content to determine its size.
Note that [*os.File] implements the [io.ReadSeeker] interface.
If the caller has set w's ETag header formatted per RFC 7232, section 2.3,
ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.
If an error occurs when serving the request (for example, when
handling an invalid range request), ServeContent responds with an
error message. By default, ServeContent strips the Cache-Control,
Content-Encoding, ETag, and Last-Modified headers from error responses.
The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent
to preserve these headers.</p>
               
               <pre><code>func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeFile" data-name="ServeFile">
               <h3>
                  ServeFile 
                  <span class="badge">function</span>
                  
                  <a href="#ServeFile" class="anchor" title="Link to ServeFile">#</a>
               </h3>
               
               <p>ServeFile replies to the request with the contents of the named
file or directory.
If the provided file or directory name is a relative path, it is
interpreted relative to the current directory and may ascend to
parent directories. If the provided name is constructed from user
input, it should be sanitized before calling [ServeFile].
As a precaution, ServeFile will reject requests where r.URL.Path
contains a ".." path element; this protects against callers who
might unsafely use [filepath.Join] on r.URL.Path without sanitizing
it and then use that filepath.Join result as the name argument.
As another special case, ServeFile redirects any request where r.URL.Path
ends in "/index.html" to the same path, without the final
"index.html". To avoid such redirects either modify the path or
use [ServeContent].
Outside of those two special cases, ServeFile does not use
r.URL.Path for selecting the file or directory to serve; only the
file or directory provided in the name argument is used.</p>
               
               <pre><code>func ServeFile(w ResponseWriter, r *Request, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeFileFS" data-name="ServeFileFS">
               <h3>
                  ServeFileFS 
                  <span class="badge">function</span>
                  
                  <a href="#ServeFileFS" class="anchor" title="Link to ServeFileFS">#</a>
               </h3>
               
               <p>ServeFileFS replies to the request with the contents
of the named file or directory from the file system fsys.
The files provided by fsys must implement [io.Seeker].
If the provided name is constructed from user input, it should be
sanitized before calling [ServeFileFS].
As a precaution, ServeFileFS will reject requests where r.URL.Path
contains a ".." path element; this protects against callers who
might unsafely use [filepath.Join] on r.URL.Path without sanitizing
it and then use that filepath.Join result as the name argument.
As another special case, ServeFileFS redirects any request where r.URL.Path
ends in "/index.html" to the same path, without the final
"index.html". To avoid such redirects either modify the path or
use [ServeContent].
Outside of those two special cases, ServeFileFS does not use
r.URL.Path for selecting the file or directory to serve; only the
file or directory provided in the name argument is used.</p>
               
               <pre><code>func ServeFileFS(w ResponseWriter, r *Request, fsys fs.FS, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code>func (h initALPNRequest) ServeHTTP(rw ResponseWriter, req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <p>ServeHTTP dispatches the request to the handler whose
pattern most closely matches the request URL.</p>
               
               <pre><code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <p>ServeHTTP calls f(w, r).</p>
               
               <pre><code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code>func (rh *redirectHandler) ServeHTTP(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code>func (f *fileHandler) ServeHTTP(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code>func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code>func (h unencryptedHTTP2Request) ServeHTTP(rw ResponseWriter, req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <p>ServeHTTP should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/erda-project/erda-infra
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname badServeHTTP net/http.serverHandler.ServeHTTP</p>
               
               <pre><code>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code>func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeTLS" data-name="ServeTLS">
               <h3>
                  ServeTLS 
                  <span class="badge">function</span>
                  
                  <a href="#ServeTLS" class="anchor" title="Link to ServeTLS">#</a>
               </h3>
               
               <p>ServeTLS accepts incoming HTTPS connections on the listener l,
creating a new service goroutine for each. The service goroutines
read requests and then call handler to reply to them.
The handler is typically nil, in which case [DefaultServeMux] is used.
Additionally, files containing a certificate and matching private key
for the server must be provided. If the certificate is signed by a
certificate authority, the certFile should be the concatenation
of the server's certificate, any intermediates, and the CA's certificate.
ServeTLS always returns a non-nil error.</p>
               
               <pre><code>func ServeTLS(l net.Listener, handler Handler, certFile string, keyFile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeTLS" data-name="ServeTLS">
               <h3>
                  ServeTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeTLS" class="anchor" title="Link to ServeTLS">#</a>
               </h3>
               
               <p>ServeTLS accepts incoming connections on the Listener l, creating a
new service goroutine for each. The service goroutines perform TLS
setup and then read requests, calling s.Handler to reply to them.
Files containing a certificate and matching private key for the
server must be provided if neither the [Server]'s
TLSConfig.Certificates, TLSConfig.GetCertificate nor
config.GetConfigForClient are populated.
If the certificate is signed by a certificate authority, the
certFile should be the concatenation of the server's certificate,
any intermediates, and the CA's certificate.
ServeTLS always returns a non-nil error. After [Server.Shutdown] or [Server.Close], the
returned error is [ErrServerClosed].</p>
               
               <pre><code>func (s *Server) ServeTLS(l net.Listener, certFile string, keyFile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets the header entries associated with key to the
single element value. It replaces any existing values
associated with key. The key is case insensitive; it is
canonicalized by [textproto.CanonicalMIMEHeaderKey].
To use non-canonical keys, assign to the map directly.</p>
               
               <pre><code>func (h Header) Set(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBasicAuth" data-name="SetBasicAuth">
               <h3>
                  SetBasicAuth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBasicAuth" class="anchor" title="Link to SetBasicAuth">#</a>
               </h3>
               
               <p>SetBasicAuth sets the request's Authorization header to use HTTP
Basic Authentication with the provided username and password.
With HTTP Basic Authentication the provided username and password
are not encrypted. It should generally only be used in an HTTPS
request.
The username may not contain a colon. Some protocols may impose
additional requirements on pre-escaping the username and
password. For instance, when used with OAuth2, both arguments must
be URL encoded first with [url.QueryEscape].</p>
               
               <pre><code>func (r *Request) SetBasicAuth(username string, password string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetCookie" data-name="SetCookie">
               <h3>
                  SetCookie 
                  <span class="badge">function</span>
                  
                  <a href="#SetCookie" class="anchor" title="Link to SetCookie">#</a>
               </h3>
               
               <p>SetCookie adds a Set-Cookie header to the provided [ResponseWriter]'s headers.
The provided cookie must have a valid Name. Invalid cookies may be
silently dropped.</p>
               
               <pre><code>func SetCookie(w ResponseWriter, cookie *Cookie)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetDoNotReuse" data-name="SetDoNotReuse">
               <h3>
                  SetDoNotReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetDoNotReuse" class="anchor" title="Link to SetDoNotReuse">#</a>
               </h3>
               
               <p>SetDoNotReuse marks cc as not reusable for future HTTP requests.</p>
               
               <pre><code>func (cc *http2ClientConn) SetDoNotReuse()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetHTTP1" data-name="SetHTTP1">
               <h3>
                  SetHTTP1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetHTTP1" class="anchor" title="Link to SetHTTP1">#</a>
               </h3>
               
               <p>SetHTTP1 adds or removes HTTP/1 from p.</p>
               
               <pre><code>func (p *Protocols) SetHTTP1(ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetHTTP2" data-name="SetHTTP2">
               <h3>
                  SetHTTP2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetHTTP2" class="anchor" title="Link to SetHTTP2">#</a>
               </h3>
               
               <p>SetHTTP2 adds or removes HTTP/2 from p.</p>
               
               <pre><code>func (p *Protocols) SetHTTP2(ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetKeepAlivesEnabled" data-name="SetKeepAlivesEnabled">
               <h3>
                  SetKeepAlivesEnabled 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetKeepAlivesEnabled" class="anchor" title="Link to SetKeepAlivesEnabled">#</a>
               </h3>
               
               <p>SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.
By default, keep-alives are always enabled. Only very
resource-constrained environments or servers in the process of
shutting down should disable them.</p>
               
               <pre><code>func (s *Server) SetKeepAlivesEnabled(v bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMaxReadFrameSize" data-name="SetMaxReadFrameSize">
               <h3>
                  SetMaxReadFrameSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMaxReadFrameSize" class="anchor" title="Link to SetMaxReadFrameSize">#</a>
               </h3>
               
               <p>SetMaxReadFrameSize sets the maximum size of a frame
that will be read by a subsequent call to ReadFrame.
It is the caller's responsibility to advertise this
limit with a SETTINGS frame.</p>
               
               <pre><code>func (fr *http2Framer) SetMaxReadFrameSize(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPathValue" data-name="SetPathValue">
               <h3>
                  SetPathValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPathValue" class="anchor" title="Link to SetPathValue">#</a>
               </h3>
               
               <p>SetPathValue sets name to value, so that subsequent calls to r.PathValue(name)
return value.</p>
               
               <pre><code>func (r *Request) SetPathValue(name string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetReadDeadline" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetReadDeadline" class="anchor" title="Link to SetReadDeadline">#</a>
               </h3>
               
               <p>SetReadDeadline sets the deadline for reading the entire request, including the body.
Reads from the request body after the deadline has been exceeded will return an error.
A zero value means no deadline.
Setting the read deadline after it has been exceeded will not extend it.</p>
               
               <pre><code>func (c *ResponseController) SetReadDeadline(deadline time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetReadDeadline" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetReadDeadline" class="anchor" title="Link to SetReadDeadline">#</a>
               </h3>
               
               <pre><code>func (c *response) SetReadDeadline(deadline time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetReadDeadline" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetReadDeadline" class="anchor" title="Link to SetReadDeadline">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) SetReadDeadline(deadline time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetReuseFrames" data-name="SetReuseFrames">
               <h3>
                  SetReuseFrames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetReuseFrames" class="anchor" title="Link to SetReuseFrames">#</a>
               </h3>
               
               <p>SetReuseFrames allows the Framer to reuse Frames.
If called on a Framer, Frames returned by calls to ReadFrame are only
valid until the next call to ReadFrame.</p>
               
               <pre><code>func (fr *http2Framer) SetReuseFrames()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUnencryptedHTTP2" data-name="SetUnencryptedHTTP2">
               <h3>
                  SetUnencryptedHTTP2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUnencryptedHTTP2" class="anchor" title="Link to SetUnencryptedHTTP2">#</a>
               </h3>
               
               <p>SetUnencryptedHTTP2 adds or removes unencrypted HTTP/2 from p.</p>
               
               <pre><code>func (p *Protocols) SetUnencryptedHTTP2(ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetWriteDeadline" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetWriteDeadline" class="anchor" title="Link to SetWriteDeadline">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) SetWriteDeadline(deadline time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetWriteDeadline" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetWriteDeadline" class="anchor" title="Link to SetWriteDeadline">#</a>
               </h3>
               
               <pre><code>func (c *response) SetWriteDeadline(deadline time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetWriteDeadline" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetWriteDeadline" class="anchor" title="Link to SetWriteDeadline">#</a>
               </h3>
               
               <p>SetWriteDeadline sets the deadline for writing the response.
Writes to the response body after the deadline has been exceeded will not block,
but may succeed if the data has been buffered.
A zero value means no deadline.
Setting the write deadline after it has been exceeded will not extend it.</p>
               
               <pre><code>func (c *ResponseController) SetWriteDeadline(deadline time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Setting" data-name="Setting">
               <h3>
                  Setting 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Setting" class="anchor" title="Link to Setting">#</a>
               </h3>
               
               <p>Setting returns the setting from the frame at the given 0-based index.
The index must be >= 0 and less than f.NumSettings().</p>
               
               <pre><code>func (f *http2SettingsFrame) Setting(i int) http2Setting</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Shutdown" data-name="Shutdown">
               <h3>
                  Shutdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Shutdown" class="anchor" title="Link to Shutdown">#</a>
               </h3>
               
               <p>Shutdown gracefully closes the client connection, waiting for running streams to complete.</p>
               
               <pre><code>func (cc *http2ClientConn) Shutdown(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Shutdown" data-name="Shutdown">
               <h3>
                  Shutdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Shutdown" class="anchor" title="Link to Shutdown">#</a>
               </h3>
               
               <p>Shutdown gracefully shuts down the server without interrupting any
active connections. Shutdown works by first closing all open
listeners, then closing all idle connections, and then waiting
indefinitely for connections to return to idle and then shut down.
If the provided context expires before the shutdown is complete,
Shutdown returns the context's error, otherwise it returns any
error returned from closing the [Server]'s underlying Listener(s).
When Shutdown is called, [Serve], [ListenAndServe], and
[ListenAndServeTLS] immediately return [ErrServerClosed]. Make sure the
program doesn't exit and waits instead for Shutdown to return.
Shutdown does not attempt to close nor wait for hijacked
connections such as WebSockets. The caller of Shutdown should
separately notify such long-lived connections of shutdown and wait
for them to close, if desired. See [Server.RegisterOnShutdown] for a way to
register shutdown notification functions.
Once Shutdown has been called on a server, it may not be reused;
future calls to methods such as Serve will return ErrServerClosed.</p>
               
               <pre><code>func (s *Server) Shutdown(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortStrings" data-name="SortStrings">
               <h3>
                  SortStrings 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SortStrings" class="anchor" title="Link to SortStrings">#</a>
               </h3>
               
               <pre><code>func (s *http2sorter) SortStrings(ss []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code>func (f ioFile) Stat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="State" data-name="State">
               <h3>
                  State 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#State" class="anchor" title="Link to State">#</a>
               </h3>
               
               <p>State returns a snapshot of cc's state.</p>
               
               <pre><code>func (cc *http2ClientConn) State() http2ClientConnState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StatusText" data-name="StatusText">
               <h3>
                  StatusText 
                  <span class="badge">function</span>
                  
                  <a href="#StatusText" class="anchor" title="Link to StatusText">#</a>
               </h3>
               
               <p>StatusText returns a text for the HTTP status code. It returns the empty
string if the code is unknown.</p>
               
               <pre><code>func StatusText(code int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StreamEnded" data-name="StreamEnded">
               <h3>
                  StreamEnded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StreamEnded" class="anchor" title="Link to StreamEnded">#</a>
               </h3>
               
               <pre><code>func (f *http2HeadersFrame) StreamEnded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StreamEnded" data-name="StreamEnded">
               <h3>
                  StreamEnded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StreamEnded" class="anchor" title="Link to StreamEnded">#</a>
               </h3>
               
               <pre><code>func (f *http2DataFrame) StreamEnded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StreamID" data-name="StreamID">
               <h3>
                  StreamID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StreamID" class="anchor" title="Link to StreamID">#</a>
               </h3>
               
               <p>StreamID returns the id of the stream this frame will be written to.
0 is used for non-stream frames such as PING and SETTINGS.</p>
               
               <pre><code>func (wr http2FrameWriteRequest) StreamID() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p *pattern) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (e http2ErrCode) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the serialization of the cookie for use in a [Cookie]
header (if only Name and Value are set) or a Set-Cookie response
header (if other fields are set).
If c is nil or c.Name is invalid, the empty string is returned.</p>
               
               <pre><code>func (c *Cookie) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (k connectMethodKey) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String is for debugging only.</p>
               
               <pre><code>func (wr http2FrameWriteRequest) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (st http2streamState) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (h http2FrameHeader) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (a *socksAddr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (w *http2writeData) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p Protocols) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (s http2Setting) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (k *contextKey) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (t http2FrameType) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (c ConnState) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (code socksReply) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (s http2SettingID) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (cmd socksCommand) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StripPrefix" data-name="StripPrefix">
               <h3>
                  StripPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#StripPrefix" class="anchor" title="Link to StripPrefix">#</a>
               </h3>
               
               <p>StripPrefix returns a handler that serves HTTP requests by removing the
given prefix from the request URL's Path (and RawPath if set) and invoking
the handler h. StripPrefix handles a request for a path that doesn't begin
with prefix by replying with an HTTP 404 not found error. The prefix must
match exactly: if the prefix in the request contains escaped characters
the reply is also an HTTP 404 not found error.</p>
               
               <pre><code>func StripPrefix(prefix string, h Handler) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code>func (z http2sortPriorityNodeSiblings) Swap(i int, k int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code>func (s *http2sorter) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Temporary" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Temporary" class="anchor" title="Link to Temporary">#</a>
               </h3>
               
               <pre><code>func (tlsHandshakeTimeoutError) Temporary() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Temporary" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Temporary" class="anchor" title="Link to Temporary">#</a>
               </h3>
               
               <pre><code>func (e *timeoutError) Temporary() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Temporary" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Temporary" class="anchor" title="Link to Temporary">#</a>
               </h3>
               
               <pre><code>func (e *http2httpError) Temporary() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Timeout" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Timeout" class="anchor" title="Link to Timeout">#</a>
               </h3>
               
               <pre><code>func (e *timeoutError) Timeout() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Timeout" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Timeout" class="anchor" title="Link to Timeout">#</a>
               </h3>
               
               <pre><code>func (tlsHandshakeTimeoutError) Timeout() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Timeout" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Timeout" class="anchor" title="Link to Timeout">#</a>
               </h3>
               
               <pre><code>func (e *http2httpError) Timeout() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TimeoutHandler" data-name="TimeoutHandler">
               <h3>
                  TimeoutHandler 
                  <span class="badge">function</span>
                  
                  <a href="#TimeoutHandler" class="anchor" title="Link to TimeoutHandler">#</a>
               </h3>
               
               <p>TimeoutHandler returns a [Handler] that runs h with the given time limit.
The new Handler calls h.ServeHTTP to handle each request, but if a
call runs for longer than its time limit, the handler responds with
a 503 Service Unavailable error and the given message in its body.
(If msg is empty, a suitable default message will be sent.)
After such a timeout, writes by h to its [ResponseWriter] will return
[ErrHandlerTimeout].
TimeoutHandler supports the [Pusher] interface but does not support
the [Hijacker] or [Flusher] interfaces.</p>
               
               <pre><code>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnencryptedHTTP2" data-name="UnencryptedHTTP2">
               <h3>
                  UnencryptedHTTP2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnencryptedHTTP2" class="anchor" title="Link to UnencryptedHTTP2">#</a>
               </h3>
               
               <p>UnencryptedHTTP2 reports whether p includes unencrypted HTTP/2.</p>
               
               <pre><code>func (p Protocols) UnencryptedHTTP2() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnencryptedNetConn" data-name="UnencryptedNetConn">
               <h3>
                  UnencryptedNetConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnencryptedNetConn" class="anchor" title="Link to UnencryptedNetConn">#</a>
               </h3>
               
               <pre><code>func (c unencryptedNetConnInTLSConn) UnencryptedNetConn() net.Conn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <pre><code>func (fakeLocker) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (nwe nothingWrittenError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e transportReadFromServerError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserAgent" data-name="UserAgent">
               <h3>
                  UserAgent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UserAgent" class="anchor" title="Link to UserAgent">#</a>
               </h3>
               
               <p>UserAgent returns the client's User-Agent, if sent in the request.</p>
               
               <pre><code>func (r *Request) UserAgent() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Valid" data-name="Valid">
               <h3>
                  Valid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Valid" class="anchor" title="Link to Valid">#</a>
               </h3>
               
               <p>Valid reports whether the cookie is valid.</p>
               
               <pre><code>func (c *Cookie) Valid() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Valid" data-name="Valid">
               <h3>
                  Valid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Valid" class="anchor" title="Link to Valid">#</a>
               </h3>
               
               <p>Valid reports whether the setting is valid.</p>
               
               <pre><code>func (s http2Setting) Valid() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code>func (f *http2SettingsFrame) Value(id http2SettingID) (v uint32, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Values" data-name="Values">
               <h3>
                  Values 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Values" class="anchor" title="Link to Values">#</a>
               </h3>
               
               <p>Values returns all values associated with the given key.
It is case insensitive; [textproto.CanonicalMIMEHeaderKey] is
used to canonicalize the provided key. To use non-canonical
keys, access the map directly.
The returned slice is not a copy.</p>
               
               <pre><code>func (h Header) Values(key string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Wait" data-name="Wait">
               <h3>
                  Wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Wait" class="anchor" title="Link to Wait">#</a>
               </h3>
               
               <p>Wait waits for the closeWaiter to become closed.</p>
               
               <pre><code>func (cw http2closeWaiter) Wait()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithContext" data-name="WithContext">
               <h3>
                  WithContext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithContext" class="anchor" title="Link to WithContext">#</a>
               </h3>
               
               <p>WithContext returns a shallow copy of r with its context changed
to ctx. The provided ctx must be non-nil.
For outgoing client request, the context controls the entire
lifetime of a request and its response: obtaining a connection,
sending the request, and reading the response headers and body.
To create a new request with a context, use [NewRequestWithContext].
To make a deep copy of a request with a new context, use [Request.Clone].</p>
               
               <pre><code>func (r *Request) WithContext(ctx context.Context) *Request</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (cw *chunkWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes the headers described in h to w.
This method has a value receiver, despite the somewhat large size
of h, because it prevents an allocation. The escape analysis isn't
smart enough to realize this function doesn't mutate h.</p>
               
               <pre><code>func (h extraHeader) Write(w *bufio.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (sew http2stickyErrWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>The Life Of A Write is like this:
Handler starts. No header has been sent. The handler can either
write a header, or just start writing. Writing before sending a header
sends an implicitly empty 200 OK header.
If the handler didn't declare a Content-Length up front, we either
go into chunking mode or, if the handler finishes running before
the chunking buffer size, we compute a Content-Length and send that
in the header instead.
Likewise, if the handler didn't set a Content-Type, we sniff that
from the initial chunk of output.
The Writers are wired together like:
1. *response (the ResponseWriter) ->
2. (*response).w, a [*bufio.Writer] of bufferBeforeChunkingSize bytes ->
3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)
and which writes the chunk headers, if needed ->
4. conn.bufw, a *bufio.Writer of default (4kB) bytes, writing to ->
5. checkConnErrorWriter{c}, which notes any non-nil error on Write
and populates c.werr with it if so, but otherwise writes to ->
6. the rwc, the [net.Conn].
TODO(bradfitz): short-circuit some of the buffering when the
initial header contains both a Content-Type and Content-Length.
Also short-circuit in (1) when the header's been sent and not in
chunking mode, writing directly to (4) instead, if (2) has no
buffered data. More generally, we could short-circuit from (1) to
(3) even in chunking mode if the write size from (1) is over some
threshold and nothing is in (2).  The answer might be mostly making
bufferBeforeChunkingSize smaller and having bufio's fast-paths deal
with this instead.</p>
               
               <pre><code>func (w *response) Write(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (w checkConnErrorWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>The Life Of A Write is like this:
* Handler calls w.Write or w.WriteString ->
* -> rws.bw (*bufio.Writer) ->
* (Handler might call Flush)
* -> chunkWriter{rws}
* -> responseWriterState.writeChunk(p []byte)
* -> responseWriterState.writeChunk (most of the magic; see comment there)</p>
               
               <pre><code>func (w *http2responseWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (w *countingWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (c *loggingConn) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (cw http2chunkWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (w *http2bufferedWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write appends p to the buffer.</p>
               
               <pre><code>func (b *http2dataBuffer) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (tw *timeoutWriter) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (w persistConnWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes r to w in the HTTP/1.x server response format,
including the status line, headers, body, and optional trailer.
This method consults the following fields of the response r:
StatusCode
ProtoMajor
ProtoMinor
Request.Method
TransferEncoding
Trailer
Body
ContentLength
Header, values for non-canonical keys will have unpredictable behavior
The Response Body is closed after it is sent.</p>
               
               <pre><code>func (r *Response) Write(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes a header in wire format.</p>
               
               <pre><code>func (h Header) Write(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes an HTTP/1.1 request, which is the header and body, in wire format.
This method consults the following fields of the request:
Host
URL
Method (defaults to "GET")
Header
ContentLength
TransferEncoding
Body
If Body is present, Content-Length is <= 0 and [Request.TransferEncoding]
hasn't been set to "identity", Write adds "Transfer-Encoding:
chunked" to the header. Body is closed after it is sent.</p>
               
               <pre><code>func (r *Request) Write(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (fw bufioFlushWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (w *http2bufferedWriterTimeoutWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write copies bytes from p into the buffer and wakes a reader.
It is an error to write more data than the buffer can hold.</p>
               
               <pre><code>func (p *http2pipe) Write(d []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (pr *populateResponse) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteContinuation" data-name="WriteContinuation">
               <h3>
                  WriteContinuation 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteContinuation" class="anchor" title="Link to WriteContinuation">#</a>
               </h3>
               
               <p>WriteContinuation writes a CONTINUATION frame.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteData" data-name="WriteData">
               <h3>
                  WriteData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteData" class="anchor" title="Link to WriteData">#</a>
               </h3>
               
               <p>WriteData writes a DATA frame.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility not to violate the maximum frame size
and to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteData(streamID uint32, endStream bool, data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteDataPadded" data-name="WriteDataPadded">
               <h3>
                  WriteDataPadded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteDataPadded" class="anchor" title="Link to WriteDataPadded">#</a>
               </h3>
               
               <p>WriteDataPadded writes a DATA frame with optional padding.
If pad is nil, the padding bit is not sent.
The length of pad must not exceed 255 bytes.
The bytes of pad must all be zero, unless f.AllowIllegalWrites is set.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility not to violate the maximum frame size
and to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteDataPadded(streamID uint32, endStream bool, data []byte, pad []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteGoAway" data-name="WriteGoAway">
               <h3>
                  WriteGoAway 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteGoAway" class="anchor" title="Link to WriteGoAway">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) WriteGoAway(maxStreamID uint32, code http2ErrCode, debugData []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteHeader" data-name="WriteHeader">
               <h3>
                  WriteHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteHeader" class="anchor" title="Link to WriteHeader">#</a>
               </h3>
               
               <pre><code>func (tw *timeoutWriter) WriteHeader(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteHeader" data-name="WriteHeader">
               <h3>
                  WriteHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteHeader" class="anchor" title="Link to WriteHeader">#</a>
               </h3>
               
               <pre><code>func (pr *populateResponse) WriteHeader(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteHeader" data-name="WriteHeader">
               <h3>
                  WriteHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteHeader" class="anchor" title="Link to WriteHeader">#</a>
               </h3>
               
               <pre><code>func (w *response) WriteHeader(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteHeader" data-name="WriteHeader">
               <h3>
                  WriteHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteHeader" class="anchor" title="Link to WriteHeader">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) WriteHeader(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteHeaders" data-name="WriteHeaders">
               <h3>
                  WriteHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteHeaders" class="anchor" title="Link to WriteHeaders">#</a>
               </h3>
               
               <p>WriteHeaders writes a single HEADERS frame.
This is a low-level header writing method. Encoding headers and
splitting them into any necessary CONTINUATION frames is handled
elsewhere.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteHeaders(p http2HeadersFrameParam) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WritePing" data-name="WritePing">
               <h3>
                  WritePing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WritePing" class="anchor" title="Link to WritePing">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) WritePing(ack bool, data [8]byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WritePriority" data-name="WritePriority">
               <h3>
                  WritePriority 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WritePriority" class="anchor" title="Link to WritePriority">#</a>
               </h3>
               
               <p>WritePriority writes a PRIORITY frame.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WritePriority(streamID uint32, p http2PriorityParam) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteProxy" data-name="WriteProxy">
               <h3>
                  WriteProxy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteProxy" class="anchor" title="Link to WriteProxy">#</a>
               </h3>
               
               <p>WriteProxy is like [Request.Write] but writes the request in the form
expected by an HTTP proxy. In particular, [Request.WriteProxy] writes the
initial Request-URI line of the request with an absolute URI, per
section 5.3 of RFC 7230, including the scheme and host.
In either case, WriteProxy also writes a Host header, using
either r.Host or r.URL.Host.</p>
               
               <pre><code>func (r *Request) WriteProxy(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WritePushPromise" data-name="WritePushPromise">
               <h3>
                  WritePushPromise 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WritePushPromise" class="anchor" title="Link to WritePushPromise">#</a>
               </h3>
               
               <p>WritePushPromise writes a single PushPromise Frame.
As with Header Frames, This is the low level call for writing
individual frames. Continuation frames are handled elsewhere.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WritePushPromise(p http2PushPromiseParam) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteRSTStream" data-name="WriteRSTStream">
               <h3>
                  WriteRSTStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteRSTStream" class="anchor" title="Link to WriteRSTStream">#</a>
               </h3>
               
               <p>WriteRSTStream writes a RST_STREAM frame.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteRSTStream(streamID uint32, code http2ErrCode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteRawFrame" data-name="WriteRawFrame">
               <h3>
                  WriteRawFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteRawFrame" class="anchor" title="Link to WriteRawFrame">#</a>
               </h3>
               
               <p>WriteRawFrame writes a raw frame. This can be used to write
extension frames unknown to this package.</p>
               
               <pre><code>func (f *http2Framer) WriteRawFrame(t http2FrameType, flags http2Flags, streamID uint32, payload []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteSettings" data-name="WriteSettings">
               <h3>
                  WriteSettings 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteSettings" class="anchor" title="Link to WriteSettings">#</a>
               </h3>
               
               <p>WriteSettings writes a SETTINGS frame with zero or more settings
specified and the ACK bit not set.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteSettings(settings ...http2Setting) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteSettingsAck" data-name="WriteSettingsAck">
               <h3>
                  WriteSettingsAck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteSettingsAck" class="anchor" title="Link to WriteSettingsAck">#</a>
               </h3>
               
               <p>WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.
It will perform exactly one Write to the underlying Writer.
It is the caller's responsibility to not call other Write methods concurrently.</p>
               
               <pre><code>func (f *http2Framer) WriteSettingsAck() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <pre><code>func (w *response) WriteString(data string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <pre><code>func (w stringWriter) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteSubset" data-name="WriteSubset">
               <h3>
                  WriteSubset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteSubset" class="anchor" title="Link to WriteSubset">#</a>
               </h3>
               
               <p>WriteSubset writes a header in wire format.
If exclude is not nil, keys where exclude[key] == true are not written.
Keys are not canonicalized before checking the exclude map.</p>
               
               <pre><code>func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <pre><code>func (noBody) WriteTo(io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteWindowUpdate" data-name="WriteWindowUpdate">
               <h3>
                  WriteWindowUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteWindowUpdate" class="anchor" title="Link to WriteWindowUpdate">#</a>
               </h3>
               
               <p>WriteWindowUpdate writes a WINDOW_UPDATE frame.
The increment value must be between 1 and 2,147,483,647, inclusive.
If the Stream ID is zero, the window update applies to the
connection as a whole.</p>
               
               <pre><code>func (f *http2Framer) WriteWindowUpdate(streamID uint32, incr uint32) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abortPendingRead" data-name="abortPendingRead">
               <h3>
                  abortPendingRead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#abortPendingRead" class="anchor" title="Link to abortPendingRead">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) abortPendingRead()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abortRequestBodyWrite" data-name="abortRequestBodyWrite">
               <h3>
                  abortRequestBodyWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#abortRequestBodyWrite" class="anchor" title="Link to abortRequestBodyWrite">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) abortRequestBodyWrite()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abortStream" data-name="abortStream">
               <h3>
                  abortStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#abortStream" class="anchor" title="Link to abortStream">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) abortStream(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abortStreamLocked" data-name="abortStreamLocked">
               <h3>
                  abortStreamLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#abortStreamLocked" class="anchor" title="Link to abortStreamLocked">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) abortStreamLocked(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds pc to the head of the linked list.</p>
               
               <pre><code>func (cl *connLRU) add(pc *persistConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds a key-value pair to the mapping.</p>
               
               <pre><code>func (h **ast.IndexListExpr) add(k K, v V)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds n bytes to the window, with a maximum window size of max,
indicating that the peer can now send us more data.
For example, the user read from a {Request,Response} body and consumed
some of the buffered data, so the peer can now send more.
It returns the number of bytes to send in a WINDOW_UPDATE frame to the peer.
Window updates are accumulated and sent when the unsent capacity
is at least inflowMinRefresh or will at least double the peer's available window.</p>
               
               <pre><code>func (f *http2inflow) add(n int) (connAdd int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds n bytes (positive or negative) to the flow control window.
It returns false if the sum would exceed 2^31-1.</p>
               
               <pre><code>func (f *http2outflow) add(n int32) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addBytes" data-name="addBytes">
               <h3>
                  addBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addBytes" class="anchor" title="Link to addBytes">#</a>
               </h3>
               
               <pre><code>func (n *http2priorityNode) addBytes(b int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addChild" data-name="addChild">
               <h3>
                  addChild 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addChild" class="anchor" title="Link to addChild">#</a>
               </h3>
               
               <p>addChild adds a child node with the given key to n
if one does not exist, and returns the child.</p>
               
               <pre><code>func (n *routingNode) addChild(key string) *routingNode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addClosedOrIdleNode" data-name="addClosedOrIdleNode">
               <h3>
                  addClosedOrIdleNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addClosedOrIdleNode" class="anchor" title="Link to addClosedOrIdleNode">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) addClosedOrIdleNode(list *[]*http2priorityNode, maxSize int, n *http2priorityNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addConnIfNeeded" data-name="addConnIfNeeded">
               <h3>
                  addConnIfNeeded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addConnIfNeeded" class="anchor" title="Link to addConnIfNeeded">#</a>
               </h3>
               
               <p>addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't
already exist. It coalesces concurrent calls with the same key.
This is used by the http1 Transport code when it creates a new connection. Because
the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know
the protocol), it can get into a situation where it has multiple TLS connections.
This code decides which ones live or die.
The return value used is whether c was used.
c is never closed.</p>
               
               <pre><code>func (p *http2clientConnPool) addConnIfNeeded(key string, t *http2Transport, c net.Conn) (used bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addConnLocked" data-name="addConnLocked">
               <h3>
                  addConnLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addConnLocked" class="anchor" title="Link to addConnLocked">#</a>
               </h3>
               
               <p>p.mu must be held</p>
               
               <pre><code>func (p *http2clientConnPool) addConnLocked(key string, cc *http2ClientConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addPattern" data-name="addPattern">
               <h3>
                  addPattern 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addPattern" class="anchor" title="Link to addPattern">#</a>
               </h3>
               
               <pre><code>func (idx *routingIndex) addPattern(pat *pattern)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addPattern" data-name="addPattern">
               <h3>
                  addPattern 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addPattern" class="anchor" title="Link to addPattern">#</a>
               </h3>
               
               <p>addPattern adds a pattern and its associated Handler to the tree
at root.</p>
               
               <pre><code>func (root *routingNode) addPattern(p *pattern, h Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addSegments" data-name="addSegments">
               <h3>
                  addSegments 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addSegments" class="anchor" title="Link to addSegments">#</a>
               </h3>
               
               <p>addSegments adds the given segments to the tree rooted at n.
If there are no segments, then n is a leaf node that holds
the given pattern and handler.</p>
               
               <pre><code>func (n *routingNode) addSegments(segs []segment, p *pattern, h Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addStreamLocked" data-name="addStreamLocked">
               <h3>
                  addStreamLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addStreamLocked" class="anchor" title="Link to addStreamLocked">#</a>
               </h3>
               
               <p>requires cc.mu be held.</p>
               
               <pre><code>func (cc *http2ClientConn) addStreamLocked(cs *http2clientStream)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addTLS" data-name="addTLS">
               <h3>
                  addTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addTLS" class="anchor" title="Link to addTLS">#</a>
               </h3>
               
               <p>Add TLS to a persistent connection, i.e. negotiate a TLS session. If pconn is already a TLS
tunnel, this function establishes a nested TLS session inside the encrypted channel.
The remote endpoint's name may be overridden by TLSClientConfig.ServerName.</p>
               
               <pre><code>func (pconn *persistConn) addTLS(ctx context.Context, name string, trace *httptrace.ClientTrace) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addr" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addr" class="anchor" title="Link to addr">#</a>
               </h3>
               
               <p>addr returns the first hop "host:port" to which we need to TCP connect.</p>
               
               <pre><code>func (cm *connectMethod) addr() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="adjustNextProtos" data-name="adjustNextProtos">
               <h3>
                  adjustNextProtos 
                  <span class="badge">function</span>
                  
                  <a href="#adjustNextProtos" class="anchor" title="Link to adjustNextProtos">#</a>
               </h3>
               
               <p>adjustNextProtos adds or removes "http/1.1" and "h2" entries from
a tls.Config.NextProtos list, according to the set of protocols in protos.</p>
               
               <pre><code>func adjustNextProtos(nextProtos []string, protos Protocols) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="afterFunc" data-name="afterFunc">
               <h3>
                  afterFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#afterFunc" class="anchor" title="Link to afterFunc">#</a>
               </h3>
               
               <p>afterFunc creates a new time.AfterFunc timer, or a synthetic timer in tests.</p>
               
               <pre><code>func (s *http2Server) afterFunc(d time.Duration, f func()) http2timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="afterFunc" data-name="afterFunc">
               <h3>
                  afterFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#afterFunc" class="anchor" title="Link to afterFunc">#</a>
               </h3>
               
               <p>afterFunc creates a new time.AfterFunc timer, or a synthetic timer in tests.</p>
               
               <pre><code>func (t *http2Transport) afterFunc(d time.Duration, f func()) http2timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="all" data-name="all">
               <h3>
                  all 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#all" class="anchor" title="Link to all">#</a>
               </h3>
               
               <p>all iterates over all wantConns in the queue.
The caller must not modify the queue while iterating.</p>
               
               <pre><code>func (q *wantConnQueue) all(f func(*wantConn))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alternateRoundTripper" data-name="alternateRoundTripper">
               <h3>
                  alternateRoundTripper 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#alternateRoundTripper" class="anchor" title="Link to alternateRoundTripper">#</a>
               </h3>
               
               <p>alternateRoundTripper returns the alternate RoundTripper to use
for this request if the Request's URL scheme requires one,
or nil for the normal case of using the Transport.</p>
               
               <pre><code>func (t *Transport) alternateRoundTripper(req *Request) RoundTripper</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alwaysFalse" data-name="alwaysFalse">
               <h3>
                  alwaysFalse 
                  <span class="badge">function</span>
                  
                  <a href="#alwaysFalse" class="anchor" title="Link to alwaysFalse">#</a>
               </h3>
               
               <pre><code>func alwaysFalse() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendSorted" data-name="appendSorted">
               <h3>
                  appendSorted 
                  <span class="badge">function</span>
                  
                  <a href="#appendSorted" class="anchor" title="Link to appendSorted">#</a>
               </h3>
               
               <pre><code>func appendSorted(es []muxEntry, e muxEntry) []muxEntry</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTime" data-name="appendTime">
               <h3>
                  appendTime 
                  <span class="badge">function</span>
                  
                  <a href="#appendTime" class="anchor" title="Link to appendTime">#</a>
               </h3>
               
               <p>appendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat))</p>
               
               <pre><code>func appendTime(b []byte, t time.Time) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="available" data-name="available">
               <h3>
                  available 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#available" class="anchor" title="Link to available">#</a>
               </h3>
               
               <pre><code>func (f *http2outflow) available() int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="awaitFlowControl" data-name="awaitFlowControl">
               <h3>
                  awaitFlowControl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#awaitFlowControl" class="anchor" title="Link to awaitFlowControl">#</a>
               </h3>
               
               <p>awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow
control tokens from the server.
It returns either the non-zero number of tokens taken or an error
if the stream is dead.</p>
               
               <pre><code>func (cs *http2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="awaitLegacyCancel" data-name="awaitLegacyCancel">
               <h3>
                  awaitLegacyCancel 
                  <span class="badge">function</span>
                  
                  <a href="#awaitLegacyCancel" class="anchor" title="Link to awaitLegacyCancel">#</a>
               </h3>
               
               <pre><code>func awaitLegacyCancel(ctx context.Context, cancel context.CancelCauseFunc, req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="awaitOpenSlotForStreamLocked" data-name="awaitOpenSlotForStreamLocked">
               <h3>
                  awaitOpenSlotForStreamLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#awaitOpenSlotForStreamLocked" class="anchor" title="Link to awaitOpenSlotForStreamLocked">#</a>
               </h3>
               
               <p>awaitOpenSlotForStreamLocked waits until len(streams) < maxConcurrentStreams.
Must hold cc.mu.</p>
               
               <pre><code>func (cc *http2ClientConn) awaitOpenSlotForStreamLocked(cs *http2clientStream) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="backgroundRead" data-name="backgroundRead">
               <h3>
                  backgroundRead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#backgroundRead" class="anchor" title="Link to backgroundRead">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) backgroundRead()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badRequestError" data-name="badRequestError">
               <h3>
                  badRequestError 
                  <span class="badge">function</span>
                  
                  <a href="#badRequestError" class="anchor" title="Link to badRequestError">#</a>
               </h3>
               
               <p>badRequestError is a literal string (used by in the server in HTML,
unescaped) to tell the user why their request was bad. It should
be plain text without user info or other embedded errors.</p>
               
               <pre><code>func badRequestError(e string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badRoundTrip" data-name="badRoundTrip">
               <h3>
                  badRoundTrip 
                  <span class="badge">function</span>
                  
                  <a href="#badRoundTrip" class="anchor" title="Link to badRoundTrip">#</a>
               </h3>
               
               <p>RoundTrip should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/erda-project/erda-infra
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname badRoundTrip net/http.(*Transport).RoundTrip</p>
               
               <pre><code>func badRoundTrip(*Transport, *Request) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badServeHTTP" data-name="badServeHTTP">
               <h3>
                  badServeHTTP 
                  <span class="badge">function</span>
                  
                  <a href="#badServeHTTP" class="anchor" title="Link to badServeHTTP">#</a>
               </h3>
               
               <pre><code>func badServeHTTP(serverHandler, ResponseWriter, *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badStringError" data-name="badStringError">
               <h3>
                  badStringError 
                  <span class="badge">function</span>
                  
                  <a href="#badStringError" class="anchor" title="Link to badStringError">#</a>
               </h3>
               
               <pre><code>func badStringError(what string, val string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="baseConfig" data-name="baseConfig">
               <h3>
                  baseConfig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#baseConfig" class="anchor" title="Link to baseConfig">#</a>
               </h3>
               
               <pre><code>func (o *http2ServeConnOpts) baseConfig() *Server</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="basicAuth" data-name="basicAuth">
               <h3>
                  basicAuth 
                  <span class="badge">function</span>
                  
                  <a href="#basicAuth" class="anchor" title="Link to basicAuth">#</a>
               </h3>
               
               <p>See 2 (end of page 4) https://www.ietf.org/rfc/rfc2617.txt
"To receive authorization, the client sends the userid and password,
separated by a single colon (":") character, within a base64
encoded string in the credentials."
It is not meant to be urlencoded.</p>
               
               <pre><code>func basicAuth(username string, password string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyAllowed" data-name="bodyAllowed">
               <h3>
                  bodyAllowed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bodyAllowed" class="anchor" title="Link to bodyAllowed">#</a>
               </h3>
               
               <p>bodyAllowed reports whether a Write is allowed for this response type.
It's illegal to call this before the header has been flushed.</p>
               
               <pre><code>func (w *response) bodyAllowed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyAllowedForStatus" data-name="bodyAllowedForStatus">
               <h3>
                  bodyAllowedForStatus 
                  <span class="badge">function</span>
                  
                  <a href="#bodyAllowedForStatus" class="anchor" title="Link to bodyAllowedForStatus">#</a>
               </h3>
               
               <p>bodyAllowedForStatus reports whether a given response status code
permits a body. See RFC 7230, section 3.3.</p>
               
               <pre><code>func bodyAllowedForStatus(status int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyIsWritable" data-name="bodyIsWritable">
               <h3>
                  bodyIsWritable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bodyIsWritable" class="anchor" title="Link to bodyIsWritable">#</a>
               </h3>
               
               <p>bodyIsWritable reports whether the Body supports writing. The
Transport returns Writable bodies for 101 Switching Protocols
responses.
The Transport uses this method to determine whether a persistent
connection is done being managed from its perspective. Once we
return a writable response body to a user, the net/http package is
done managing that connection.</p>
               
               <pre><code>func (r *Response) bodyIsWritable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyRemains" data-name="bodyRemains">
               <h3>
                  bodyRemains 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bodyRemains" class="anchor" title="Link to bodyRemains">#</a>
               </h3>
               
               <p>bodyRemains reports whether future Read calls might
yield data.</p>
               
               <pre><code>func (b *body) bodyRemains() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bufioWriterPool" data-name="bufioWriterPool">
               <h3>
                  bufioWriterPool 
                  <span class="badge">function</span>
                  
                  <a href="#bufioWriterPool" class="anchor" title="Link to bufioWriterPool">#</a>
               </h3>
               
               <pre><code>func bufioWriterPool(size int) *sync.Pool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesFromFirstChunk" data-name="bytesFromFirstChunk">
               <h3>
                  bytesFromFirstChunk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesFromFirstChunk" class="anchor" title="Link to bytesFromFirstChunk">#</a>
               </h3>
               
               <pre><code>func (b *http2dataBuffer) bytesFromFirstChunk() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canTakeNewRequestLocked" data-name="canTakeNewRequestLocked">
               <h3>
                  canTakeNewRequestLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canTakeNewRequestLocked" class="anchor" title="Link to canTakeNewRequestLocked">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) canTakeNewRequestLocked() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cancel" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cancel" class="anchor" title="Link to cancel">#</a>
               </h3>
               
               <p>cancel marks w as no longer wanting a result (for example, due to cancellation).
If a connection has been delivered already, cancel returns it with t.putOrCloseIdleConn.</p>
               
               <pre><code>func (w *wantConn) cancel(t *Transport, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cancelRequest" data-name="cancelRequest">
               <h3>
                  cancelRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cancelRequest" class="anchor" title="Link to cancelRequest">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) cancelRequest(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canceled" data-name="canceled">
               <h3>
                  canceled 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canceled" class="anchor" title="Link to canceled">#</a>
               </h3>
               
               <p>canceled returns non-nil if the connection was closed due to
CancelRequest or due to context cancellation.</p>
               
               <pre><code>func (pc *persistConn) canceled() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canonicalAddr" data-name="canonicalAddr">
               <h3>
                  canonicalAddr 
                  <span class="badge">function</span>
                  
                  <a href="#canonicalAddr" class="anchor" title="Link to canonicalAddr">#</a>
               </h3>
               
               <p>canonicalAddr returns url.Host but always with a ":port" suffix.</p>
               
               <pre><code>func canonicalAddr(url *url.URL) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canonicalHeader" data-name="canonicalHeader">
               <h3>
                  canonicalHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canonicalHeader" class="anchor" title="Link to canonicalHeader">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) canonicalHeader(v string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <pre><code>func (g http2goroutineLock) check()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFrameOrder" data-name="checkFrameOrder">
               <h3>
                  checkFrameOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFrameOrder" class="anchor" title="Link to checkFrameOrder">#</a>
               </h3>
               
               <p>checkFrameOrder reports an error if f is an invalid frame to return
next from ReadFrame. Mostly it checks whether HEADERS and
CONTINUATION frames are contiguous.</p>
               
               <pre><code>func (fr *http2Framer) checkFrameOrder(f http2Frame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkIfMatch" data-name="checkIfMatch">
               <h3>
                  checkIfMatch 
                  <span class="badge">function</span>
                  
                  <a href="#checkIfMatch" class="anchor" title="Link to checkIfMatch">#</a>
               </h3>
               
               <pre><code>func checkIfMatch(w ResponseWriter, r *Request) condResult</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkIfModifiedSince" data-name="checkIfModifiedSince">
               <h3>
                  checkIfModifiedSince 
                  <span class="badge">function</span>
                  
                  <a href="#checkIfModifiedSince" class="anchor" title="Link to checkIfModifiedSince">#</a>
               </h3>
               
               <pre><code>func checkIfModifiedSince(r *Request, modtime time.Time) condResult</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkIfNoneMatch" data-name="checkIfNoneMatch">
               <h3>
                  checkIfNoneMatch 
                  <span class="badge">function</span>
                  
                  <a href="#checkIfNoneMatch" class="anchor" title="Link to checkIfNoneMatch">#</a>
               </h3>
               
               <pre><code>func checkIfNoneMatch(w ResponseWriter, r *Request) condResult</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkIfRange" data-name="checkIfRange">
               <h3>
                  checkIfRange 
                  <span class="badge">function</span>
                  
                  <a href="#checkIfRange" class="anchor" title="Link to checkIfRange">#</a>
               </h3>
               
               <pre><code>func checkIfRange(w ResponseWriter, r *Request, modtime time.Time) condResult</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkIfUnmodifiedSince" data-name="checkIfUnmodifiedSince">
               <h3>
                  checkIfUnmodifiedSince 
                  <span class="badge">function</span>
                  
                  <a href="#checkIfUnmodifiedSince" class="anchor" title="Link to checkIfUnmodifiedSince">#</a>
               </h3>
               
               <pre><code>func checkIfUnmodifiedSince(r *Request, modtime time.Time) condResult</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkNotOn" data-name="checkNotOn">
               <h3>
                  checkNotOn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkNotOn" class="anchor" title="Link to checkNotOn">#</a>
               </h3>
               
               <pre><code>func (g http2goroutineLock) checkNotOn()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPreconditions" data-name="checkPreconditions">
               <h3>
                  checkPreconditions 
                  <span class="badge">function</span>
                  
                  <a href="#checkPreconditions" class="anchor" title="Link to checkPreconditions">#</a>
               </h3>
               
               <p>checkPreconditions evaluates request preconditions and reports whether a precondition
resulted in sending StatusNotModified or StatusPreconditionFailed.</p>
               
               <pre><code>func checkPreconditions(w ResponseWriter, r *Request, modtime time.Time) (done bool, rangeHeader string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPriority" data-name="checkPriority">
               <h3>
                  checkPriority 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkPriority" class="anchor" title="Link to checkPriority">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) checkPriority(streamID uint32, p http2PriorityParam) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPseudos" data-name="checkPseudos">
               <h3>
                  checkPseudos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkPseudos" class="anchor" title="Link to checkPseudos">#</a>
               </h3>
               
               <pre><code>func (mh *http2MetaHeadersFrame) checkPseudos() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkRedirect" data-name="checkRedirect">
               <h3>
                  checkRedirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkRedirect" class="anchor" title="Link to checkRedirect">#</a>
               </h3>
               
               <p>checkRedirect calls either the user's configured CheckRedirect
function, or the default.</p>
               
               <pre><code>func (c *Client) checkRedirect(req *Request, via []*Request) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkValid" data-name="checkValid">
               <h3>
                  checkValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkValid" class="anchor" title="Link to checkValid">#</a>
               </h3>
               
               <pre><code>func (h *http2FrameHeader) checkValid()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkWriteHeaderCode" data-name="checkWriteHeaderCode">
               <h3>
                  checkWriteHeaderCode 
                  <span class="badge">function</span>
                  
                  <a href="#checkWriteHeaderCode" class="anchor" title="Link to checkWriteHeaderCode">#</a>
               </h3>
               
               <pre><code>func checkWriteHeaderCode(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chunked" data-name="chunked">
               <h3>
                  chunked 
                  <span class="badge">function</span>
                  
                  <a href="#chunked" class="anchor" title="Link to chunked">#</a>
               </h3>
               
               <p>Checks whether chunked is part of the encodings stack.</p>
               
               <pre><code>func chunked(te []string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanFrontCanceled" data-name="cleanFrontCanceled">
               <h3>
                  cleanFrontCanceled 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanFrontCanceled" class="anchor" title="Link to cleanFrontCanceled">#</a>
               </h3>
               
               <p>cleanFrontCanceled pops any wantConns with canceled dials from the head of the queue.</p>
               
               <pre><code>func (q *wantConnQueue) cleanFrontCanceled()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanFrontNotWaiting" data-name="cleanFrontNotWaiting">
               <h3>
                  cleanFrontNotWaiting 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanFrontNotWaiting" class="anchor" title="Link to cleanFrontNotWaiting">#</a>
               </h3>
               
               <p>cleanFrontNotWaiting pops any wantConns that are no longer waiting from the head of the
queue, reporting whether any were popped.</p>
               
               <pre><code>func (q *wantConnQueue) cleanFrontNotWaiting() (cleaned bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanPath" data-name="cleanPath">
               <h3>
                  cleanPath 
                  <span class="badge">function</span>
                  
                  <a href="#cleanPath" class="anchor" title="Link to cleanPath">#</a>
               </h3>
               
               <p>cleanPath returns the canonical path for p, eliminating . and .. elements.</p>
               
               <pre><code>func cleanPath(p string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanupWriteRequest" data-name="cleanupWriteRequest">
               <h3>
                  cleanupWriteRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanupWriteRequest" class="anchor" title="Link to cleanupWriteRequest">#</a>
               </h3>
               
               <p>cleanupWriteRequest performs post-request tasks.
If err (the result of writeRequest) is non-nil and the stream is not closed,
cleanupWriteRequest will send a reset to the peer.</p>
               
               <pre><code>func (cs *http2clientStream) cleanupWriteRequest(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneMultipartFileHeader" data-name="cloneMultipartFileHeader">
               <h3>
                  cloneMultipartFileHeader 
                  <span class="badge">function</span>
                  
                  <a href="#cloneMultipartFileHeader" class="anchor" title="Link to cloneMultipartFileHeader">#</a>
               </h3>
               
               <p>cloneMultipartFileHeader should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname cloneMultipartFileHeader</p>
               
               <pre><code>func cloneMultipartFileHeader(fh *multipart.FileHeader) *multipart.FileHeader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneMultipartForm" data-name="cloneMultipartForm">
               <h3>
                  cloneMultipartForm 
                  <span class="badge">function</span>
                  
                  <a href="#cloneMultipartForm" class="anchor" title="Link to cloneMultipartForm">#</a>
               </h3>
               
               <p>cloneMultipartForm should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname cloneMultipartForm</p>
               
               <pre><code>func cloneMultipartForm(f *multipart.Form) *multipart.Form</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneOrMakeHeader" data-name="cloneOrMakeHeader">
               <h3>
                  cloneOrMakeHeader 
                  <span class="badge">function</span>
                  
                  <a href="#cloneOrMakeHeader" class="anchor" title="Link to cloneOrMakeHeader">#</a>
               </h3>
               
               <p>cloneOrMakeHeader invokes Header.Clone but if the
result is nil, it'll instead make and return a non-nil Header.
cloneOrMakeHeader should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname cloneOrMakeHeader</p>
               
               <pre><code>func cloneOrMakeHeader(hdr Header) Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneTLSConfig" data-name="cloneTLSConfig">
               <h3>
                  cloneTLSConfig 
                  <span class="badge">function</span>
                  
                  <a href="#cloneTLSConfig" class="anchor" title="Link to cloneTLSConfig">#</a>
               </h3>
               
               <p>cloneTLSConfig returns a shallow clone of cfg, or a new zero tls.Config if
cfg is nil. This is safe to call even if cfg is in active use by a TLS
client or server.
cloneTLSConfig should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname cloneTLSConfig</p>
               
               <pre><code>func cloneTLSConfig(cfg *tls.Config) *tls.Config</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneURL" data-name="cloneURL">
               <h3>
                  cloneURL 
                  <span class="badge">function</span>
                  
                  <a href="#cloneURL" class="anchor" title="Link to cloneURL">#</a>
               </h3>
               
               <p>cloneURL should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname cloneURL</p>
               
               <pre><code>func cloneURL(u *url.URL) *url.URL</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneURLValues" data-name="cloneURLValues">
               <h3>
                  cloneURLValues 
                  <span class="badge">function</span>
                  
                  <a href="#cloneURLValues" class="anchor" title="Link to cloneURLValues">#</a>
               </h3>
               
               <p>cloneURLValues should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname cloneURLValues</p>
               
               <pre><code>func cloneURLValues(v url.Values) url.Values</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (cw *chunkWriter) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (oc *onceCloseListener) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <p>close closes the underlying TCP connection and closes
the pc.closech channel.
The provided err is only for testing and debugging; in normal
circumstances it should never be seen by users.</p>
               
               <pre><code>func (pc *persistConn) close(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <p>Close the connection.</p>
               
               <pre><code>func (c *conn) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeAllStreamsOnConnClose" data-name="closeAllStreamsOnConnClose">
               <h3>
                  closeAllStreamsOnConnClose 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeAllStreamsOnConnClose" class="anchor" title="Link to closeAllStreamsOnConnClose">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) closeAllStreamsOnConnClose()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeBody" data-name="closeBody">
               <h3>
                  closeBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeBody" class="anchor" title="Link to closeBody">#</a>
               </h3>
               
               <pre><code>func (r *Response) closeBody()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeBody" data-name="closeBody">
               <h3>
                  closeBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeBody" class="anchor" title="Link to closeBody">#</a>
               </h3>
               
               <pre><code>func (r *Request) closeBody() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeConn" data-name="closeConn">
               <h3>
                  closeConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeConn" class="anchor" title="Link to closeConn">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) closeConn()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeConnIfStillIdle" data-name="closeConnIfStillIdle">
               <h3>
                  closeConnIfStillIdle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeConnIfStillIdle" class="anchor" title="Link to closeConnIfStillIdle">#</a>
               </h3>
               
               <p>closeConnIfStillIdle closes the connection if it's still sitting idle.
This is what's called by the persistConn's idleTimer, and is run in its
own goroutine.</p>
               
               <pre><code>func (pc *persistConn) closeConnIfStillIdle()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeDoneLocked" data-name="closeDoneLocked">
               <h3>
                  closeDoneLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeDoneLocked" class="anchor" title="Link to closeDoneLocked">#</a>
               </h3>
               
               <p>requires p.mu be held.</p>
               
               <pre><code>func (p *http2pipe) closeDoneLocked()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeForError" data-name="closeForError">
               <h3>
                  closeForError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeForError" class="anchor" title="Link to closeForError">#</a>
               </h3>
               
               <p>closes the client connection immediately. In-flight requests are interrupted.
err is sent to streams.</p>
               
               <pre><code>func (cc *http2ClientConn) closeForError(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeForLostPing" data-name="closeForLostPing">
               <h3>
                  closeForLostPing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeForLostPing" class="anchor" title="Link to closeForLostPing">#</a>
               </h3>
               
               <p>closes the client connection immediately. In-flight requests are interrupted.</p>
               
               <pre><code>func (cc *http2ClientConn) closeForLostPing()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeIdleConnections" data-name="closeIdleConnections">
               <h3>
                  closeIdleConnections 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeIdleConnections" class="anchor" title="Link to closeIdleConnections">#</a>
               </h3>
               
               <pre><code>func (p *http2clientConnPool) closeIdleConnections()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeIdleConns" data-name="closeIdleConns">
               <h3>
                  closeIdleConns 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeIdleConns" class="anchor" title="Link to closeIdleConns">#</a>
               </h3>
               
               <p>closeIdleConns closes all idle connections and reports whether the
server is quiescent.</p>
               
               <pre><code>func (s *Server) closeIdleConns() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeIfIdle" data-name="closeIfIdle">
               <h3>
                  closeIfIdle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeIfIdle" class="anchor" title="Link to closeIfIdle">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) closeIfIdle()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeListenersLocked" data-name="closeListenersLocked">
               <h3>
                  closeListenersLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeListenersLocked" class="anchor" title="Link to closeListenersLocked">#</a>
               </h3>
               
               <pre><code>func (s *Server) closeListenersLocked() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeLocked" data-name="closeLocked">
               <h3>
                  closeLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeLocked" class="anchor" title="Link to closeLocked">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) closeLocked(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeNotify" data-name="closeNotify">
               <h3>
                  closeNotify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeNotify" class="anchor" title="Link to closeNotify">#</a>
               </h3>
               
               <p>may be called from multiple goroutines.</p>
               
               <pre><code>func (cr *connReader) closeNotify()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeReqBodyLocked" data-name="closeReqBodyLocked">
               <h3>
                  closeReqBodyLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeReqBodyLocked" class="anchor" title="Link to closeReqBodyLocked">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) closeReqBodyLocked()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeStream" data-name="closeStream">
               <h3>
                  closeStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeStream" class="anchor" title="Link to closeStream">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) closeStream(st *http2stream, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeWithError" data-name="closeWithError">
               <h3>
                  closeWithError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeWithError" class="anchor" title="Link to closeWithError">#</a>
               </h3>
               
               <pre><code>func (p *http2pipe) closeWithError(dst *error, err error, fn func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeWithErrorAndCode" data-name="closeWithErrorAndCode">
               <h3>
                  closeWithErrorAndCode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeWithErrorAndCode" class="anchor" title="Link to closeWithErrorAndCode">#</a>
               </h3>
               
               <p>closeWithErrorAndCode is like CloseWithError but also sets some code to run
in the caller's goroutine before returning the error.</p>
               
               <pre><code>func (p *http2pipe) closeWithErrorAndCode(err error, fn func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeWriteAndWait" data-name="closeWriteAndWait">
               <h3>
                  closeWriteAndWait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeWriteAndWait" class="anchor" title="Link to closeWriteAndWait">#</a>
               </h3>
               
               <p>closeWriteAndWait flushes any outstanding data and sends a FIN packet (if
client is connected via TCP), signaling that we're done. We then
pause for a bit, hoping the client processes it before any
subsequent RST.
See https://golang.org/issue/3595</p>
               
               <pre><code>func (c *conn) closeWriteAndWait()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closedRequestBodyEarly" data-name="closedRequestBodyEarly">
               <h3>
                  closedRequestBodyEarly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closedRequestBodyEarly" class="anchor" title="Link to closedRequestBodyEarly">#</a>
               </h3>
               
               <pre><code>func (w *response) closedRequestBodyEarly() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="combineRelationships" data-name="combineRelationships">
               <h3>
                  combineRelationships 
                  <span class="badge">function</span>
                  
                  <a href="#combineRelationships" class="anchor" title="Link to combineRelationships">#</a>
               </h3>
               
               <p>combineRelationships determines the overall relationship of two patterns
given the relationships of a partition of the patterns into two parts.
For example, if p1 is more general than p2 in one way but equivalent
in the other, then it is more general overall.
Or if p1 is more general in one way and more specific in the other, then
they overlap.</p>
               
               <pre><code>func combineRelationships(r1 relationship, r2 relationship) relationship</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commonPath" data-name="commonPath">
               <h3>
                  commonPath 
                  <span class="badge">function</span>
                  
                  <a href="#commonPath" class="anchor" title="Link to commonPath">#</a>
               </h3>
               
               <p>commonPath returns a path that both p1 and p2 match.
It assumes there is such a path.</p>
               
               <pre><code>func commonPath(p1 *pattern, p2 *pattern) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compareMethods" data-name="compareMethods">
               <h3>
                  compareMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compareMethods" class="anchor" title="Link to compareMethods">#</a>
               </h3>
               
               <p>compareMethods determines the relationship between the method
part of patterns p1 and p2.
A method can either be empty, "GET", or something else.
The empty string matches any method, so it is the most general.
"GET" matches both GET and HEAD.
Anything else matches only itself.</p>
               
               <pre><code>func (p1 *pattern) compareMethods(p2 *pattern) relationship</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comparePaths" data-name="comparePaths">
               <h3>
                  comparePaths 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#comparePaths" class="anchor" title="Link to comparePaths">#</a>
               </h3>
               
               <p>comparePaths determines the relationship between the path
part of two patterns.</p>
               
               <pre><code>func (p1 *pattern) comparePaths(p2 *pattern) relationship</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comparePathsAndMethods" data-name="comparePathsAndMethods">
               <h3>
                  comparePathsAndMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#comparePathsAndMethods" class="anchor" title="Link to comparePathsAndMethods">#</a>
               </h3>
               
               <pre><code>func (p1 *pattern) comparePathsAndMethods(p2 *pattern) relationship</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compareSegments" data-name="compareSegments">
               <h3>
                  compareSegments 
                  <span class="badge">function</span>
                  
                  <a href="#compareSegments" class="anchor" title="Link to compareSegments">#</a>
               </h3>
               
               <p>compareSegments determines the relationship between two segments.</p>
               
               <pre><code>func compareSegments(s1 segment, s2 segment) relationship</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="condfn" data-name="condfn">
               <h3>
                  condfn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#condfn" class="anchor" title="Link to condfn">#</a>
               </h3>
               
               <p>caller must hold es.mu.</p>
               
               <pre><code>func (es *bodyEOFSignal) condfn(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="condlogf" data-name="condlogf">
               <h3>
                  condlogf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#condlogf" class="anchor" title="Link to condlogf">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) condlogf(err error, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="conflictsWith" data-name="conflictsWith">
               <h3>
                  conflictsWith 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#conflictsWith" class="anchor" title="Link to conflictsWith">#</a>
               </h3>
               
               <p>conflictsWith reports whether p1 conflicts with p2, that is, whether
there is a request that both match but where neither is higher precedence
than the other.
Precedence is defined by two rules:
1. Patterns with a host win over patterns without a host.
2. Patterns whose method and path is more specific win. One pattern is more
specific than another if the second matches all the (method, path) pairs
of the first and more.
If rule 1 doesn't apply, then two patterns conflict if their relationship
is either equivalence (they match the same set of requests) or overlap
(they both match some requests, but neither is more specific than the other).</p>
               
               <pre><code>func (p1 *pattern) conflictsWith(p2 *pattern) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="connError" data-name="connError">
               <h3>
                  connError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#connError" class="anchor" title="Link to connError">#</a>
               </h3>
               
               <p>connError returns ConnectionError(code) but first
stashes away a public reason to the caller can optionally relay it
to the peer before hanging up on them. This might help others debug
their implementations.</p>
               
               <pre><code>func (fr *http2Framer) connError(code http2ErrCode, reason string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="connPool" data-name="connPool">
               <h3>
                  connPool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#connPool" class="anchor" title="Link to connPool">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) connPool() http2ClientConnPool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="connect" data-name="connect">
               <h3>
                  connect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#connect" class="anchor" title="Link to connect">#</a>
               </h3>
               
               <pre><code>func (d *socksDialer) connect(ctx context.Context, c net.Conn, address string) (_ net.Addr, ctxErr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="connectMethodForRequest" data-name="connectMethodForRequest">
               <h3>
                  connectMethodForRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#connectMethodForRequest" class="anchor" title="Link to connectMethodForRequest">#</a>
               </h3>
               
               <pre><code>func (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="consume" data-name="consume">
               <h3>
                  consume 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#consume" class="anchor" title="Link to consume">#</a>
               </h3>
               
               <p>consume consumes up to n bytes from q.s[0]. If the frame is
entirely consumed, it is removed from the queue. If the frame
is partially consumed, the frame is kept with the consumed
bytes removed. Returns true iff any bytes were consumed.</p>
               
               <pre><code>func (q *http2writeQueue) consume(n int32) (http2FrameWriteRequest, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="containsDotDot" data-name="containsDotDot">
               <h3>
                  containsDotDot 
                  <span class="badge">function</span>
                  
                  <a href="#containsDotDot" class="anchor" title="Link to containsDotDot">#</a>
               </h3>
               
               <pre><code>func containsDotDot(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contentRange" data-name="contentRange">
               <h3>
                  contentRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#contentRange" class="anchor" title="Link to contentRange">#</a>
               </h3>
               
               <pre><code>func (r httpRange) contentRange(size int64) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="context" data-name="context">
               <h3>
                  context 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#context" class="anchor" title="Link to context">#</a>
               </h3>
               
               <pre><code>func (o *http2ServeConnOpts) context() context.Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contextWithTimeout" data-name="contextWithTimeout">
               <h3>
                  contextWithTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#contextWithTimeout" class="anchor" title="Link to contextWithTimeout">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) contextWithTimeout(ctx context.Context, d time.Duration) (context.Context, context.CancelFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyTrailers" data-name="copyTrailers">
               <h3>
                  copyTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyTrailers" class="anchor" title="Link to copyTrailers">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) copyTrailers()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyTrailersToHandlerRequest" data-name="copyTrailersToHandlerRequest">
               <h3>
                  copyTrailersToHandlerRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyTrailersToHandlerRequest" class="anchor" title="Link to copyTrailersToHandlerRequest">#</a>
               </h3>
               
               <p>copyTrailersToHandlerRequest is run in the Handler's goroutine in
its Request.Body.Read just before it gets io.EOF.</p>
               
               <pre><code>func (st *http2stream) copyTrailersToHandlerRequest()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyValues" data-name="copyValues">
               <h3>
                  copyValues 
                  <span class="badge">function</span>
                  
                  <a href="#copyValues" class="anchor" title="Link to copyValues">#</a>
               </h3>
               
               <pre><code>func copyValues(dst url.Values, src url.Values)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="countError" data-name="countError">
               <h3>
                  countError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#countError" class="anchor" title="Link to countError">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) countError(name string, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="countReadFrameError" data-name="countReadFrameError">
               <h3>
                  countReadFrameError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#countReadFrameError" class="anchor" title="Link to countReadFrameError">#</a>
               </h3>
               
               <p>countReadFrameError calls Transport.CountError with a string
representing err.</p>
               
               <pre><code>func (cc *http2ClientConn) countReadFrameError(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="curOpenStreams" data-name="curOpenStreams">
               <h3>
                  curOpenStreams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#curOpenStreams" class="anchor" title="Link to curOpenStreams">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) curOpenStreams() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="currentRequestCountLocked" data-name="currentRequestCountLocked">
               <h3>
                  currentRequestCountLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#currentRequestCountLocked" class="anchor" title="Link to currentRequestCountLocked">#</a>
               </h3>
               
               <p>currentRequestCountLocked reports the number of concurrency slots currently in use,
including active streams, reserved slots, and reset streams waiting for acknowledgement.</p>
               
               <pre><code>func (cc *http2ClientConn) currentRequestCountLocked() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="customDialTLS" data-name="customDialTLS">
               <h3>
                  customDialTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#customDialTLS" class="anchor" title="Link to customDialTLS">#</a>
               </h3>
               
               <pre><code>func (t *Transport) customDialTLS(ctx context.Context, network string, addr string) (conn net.Conn, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deadline" data-name="deadline">
               <h3>
                  deadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deadline" class="anchor" title="Link to deadline">#</a>
               </h3>
               
               <pre><code>func (c *Client) deadline() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decConnsPerHost" data-name="decConnsPerHost">
               <h3>
                  decConnsPerHost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decConnsPerHost" class="anchor" title="Link to decConnsPerHost">#</a>
               </h3>
               
               <p>decConnsPerHost decrements the per-host connection count for key,
which may in turn give a different waiting goroutine permission to dial.</p>
               
               <pre><code>func (t *Transport) decConnsPerHost(key connectMethodKey)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareTrailer" data-name="declareTrailer">
               <h3>
                  declareTrailer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareTrailer" class="anchor" title="Link to declareTrailer">#</a>
               </h3>
               
               <p>declareTrailer is called for each Trailer header when the
response header is written. It notes that a header will need to be
written in the trailers at the end of the response.</p>
               
               <pre><code>func (w *response) declareTrailer(k string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareTrailer" data-name="declareTrailer">
               <h3>
                  declareTrailer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareTrailer" class="anchor" title="Link to declareTrailer">#</a>
               </h3>
               
               <p>declareTrailer is called for each Trailer header when the
response header is written. It notes that a header will need to be
written in the trailers at the end of the response.</p>
               
               <pre><code>func (rws *http2responseWriterState) declareTrailer(k string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decrStreamReservations" data-name="decrStreamReservations">
               <h3>
                  decrStreamReservations 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decrStreamReservations" class="anchor" title="Link to decrStreamReservations">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) decrStreamReservations()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decrStreamReservationsLocked" data-name="decrStreamReservationsLocked">
               <h3>
                  decrStreamReservationsLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decrStreamReservationsLocked" class="anchor" title="Link to decrStreamReservationsLocked">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) decrStreamReservationsLocked()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultCheckRedirect" data-name="defaultCheckRedirect">
               <h3>
                  defaultCheckRedirect 
                  <span class="badge">function</span>
                  
                  <a href="#defaultCheckRedirect" class="anchor" title="Link to defaultCheckRedirect">#</a>
               </h3>
               
               <pre><code>func defaultCheckRedirect(req *Request, via []*Request) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultTransportDialContext" data-name="defaultTransportDialContext">
               <h3>
                  defaultTransportDialContext 
                  <span class="badge">function</span>
                  
                  <a href="#defaultTransportDialContext" class="anchor" title="Link to defaultTransportDialContext">#</a>
               </h3>
               
               <pre><code>func defaultTransportDialContext(dialer *net.Dialer) (func(context.Context, string, string) (net.Conn, error))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultTransportDialContext" data-name="defaultTransportDialContext">
               <h3>
                  defaultTransportDialContext 
                  <span class="badge">function</span>
                  
                  <a href="#defaultTransportDialContext" class="anchor" title="Link to defaultTransportDialContext">#</a>
               </h3>
               
               <pre><code>func defaultTransportDialContext(dialer *net.Dialer) (func(context.Context, string, string) (net.Conn, error))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="describeConflict" data-name="describeConflict">
               <h3>
                  describeConflict 
                  <span class="badge">function</span>
                  
                  <a href="#describeConflict" class="anchor" title="Link to describeConflict">#</a>
               </h3>
               
               <p>describeConflict returns an explanation of why two patterns conflict.</p>
               
               <pre><code>func describeConflict(p1 *pattern, p2 *pattern) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dial" data-name="dial">
               <h3>
                  dial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dial" class="anchor" title="Link to dial">#</a>
               </h3>
               
               <pre><code>func (t *Transport) dial(ctx context.Context, network string, addr string) (net.Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dial" data-name="dial">
               <h3>
                  dial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dial" class="anchor" title="Link to dial">#</a>
               </h3>
               
               <p>run in its own goroutine.</p>
               
               <pre><code>func (c *http2dialCall) dial(ctx context.Context, addr string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dialClientConn" data-name="dialClientConn">
               <h3>
                  dialClientConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dialClientConn" class="anchor" title="Link to dialClientConn">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) dialClientConn(ctx context.Context, addr string, singleUse bool) (*http2ClientConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dialConn" data-name="dialConn">
               <h3>
                  dialConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dialConn" class="anchor" title="Link to dialConn">#</a>
               </h3>
               
               <pre><code>func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dialConnFor" data-name="dialConnFor">
               <h3>
                  dialConnFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dialConnFor" class="anchor" title="Link to dialConnFor">#</a>
               </h3>
               
               <p>dialConnFor dials on behalf of w and delivers the result to w.
dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()].
If the dial is canceled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()].</p>
               
               <pre><code>func (t *Transport) dialConnFor(w *wantConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dialTLS" data-name="dialTLS">
               <h3>
                  dialTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dialTLS" class="anchor" title="Link to dialTLS">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) dialTLS(ctx context.Context, network string, addr string, tlsCfg *tls.Config) (net.Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dialTLSWithContext" data-name="dialTLSWithContext">
               <h3>
                  dialTLSWithContext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dialTLSWithContext" class="anchor" title="Link to dialTLSWithContext">#</a>
               </h3>
               
               <p>dialTLSWithContext uses tls.Dialer, added in Go 1.15, to open a TLS
connection.</p>
               
               <pre><code>func (t *http2Transport) dialTLSWithContext(ctx context.Context, network string, addr string, cfg *tls.Config) (*tls.Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="didEarlyClose" data-name="didEarlyClose">
               <h3>
                  didEarlyClose 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#didEarlyClose" class="anchor" title="Link to didEarlyClose">#</a>
               </h3>
               
               <pre><code>func (b *body) didEarlyClose() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="differencePath" data-name="differencePath">
               <h3>
                  differencePath 
                  <span class="badge">function</span>
                  
                  <a href="#differencePath" class="anchor" title="Link to differencePath">#</a>
               </h3>
               
               <p>differencePath returns a path that p1 matches and p2 doesn't.
It assumes there is such a path.</p>
               
               <pre><code>func differencePath(p1 *pattern, p2 *pattern) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirList" data-name="dirList">
               <h3>
                  dirList 
                  <span class="badge">function</span>
                  
                  <a href="#dirList" class="anchor" title="Link to dirList">#</a>
               </h3>
               
               <pre><code>func dirList(w ResponseWriter, r *Request, f File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disableCompression" data-name="disableCompression">
               <h3>
                  disableCompression 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disableCompression" class="anchor" title="Link to disableCompression">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) disableCompression() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disableKeepAlives" data-name="disableKeepAlives">
               <h3>
                  disableKeepAlives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disableKeepAlives" class="anchor" title="Link to disableKeepAlives">#</a>
               </h3>
               
               <p>disableKeepAlives reports whether connections should be closed as
soon as possible after handling the first request.</p>
               
               <pre><code>func (t *http2Transport) disableKeepAlives() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disableWriteContinue" data-name="disableWriteContinue">
               <h3>
                  disableWriteContinue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disableWriteContinue" class="anchor" title="Link to disableWriteContinue">#</a>
               </h3>
               
               <p>disableWriteContinue stops Request.Body.Read from sending an automatic 100-Continue.
If a 100-Continue is being written, it waits for it to complete before continuing.</p>
               
               <pre><code>func (w *response) disableWriteContinue()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="do" data-name="do">
               <h3>
                  do 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#do" class="anchor" title="Link to do">#</a>
               </h3>
               
               <pre><code>func (c *Client) do(req *Request) (retres *Response, reterr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doBodyCopy" data-name="doBodyCopy">
               <h3>
                  doBodyCopy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doBodyCopy" class="anchor" title="Link to doBodyCopy">#</a>
               </h3>
               
               <p>doBodyCopy wraps a copy operation, with any resulting error also
being saved in bodyReadError.
This function is only intended for use in writeBody.</p>
               
               <pre><code>func (t *transferWriter) doBodyCopy(dst io.Writer, src io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doKeepAlives" data-name="doKeepAlives">
               <h3>
                  doKeepAlives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doKeepAlives" class="anchor" title="Link to doKeepAlives">#</a>
               </h3>
               
               <pre><code>func (s *Server) doKeepAlives() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doRequest" data-name="doRequest">
               <h3>
                  doRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doRequest" class="anchor" title="Link to doRequest">#</a>
               </h3>
               
               <p>doRequest runs for the duration of the request lifetime.
It sends the request and performs post-request cleanup (closing Request.Body, etc.).</p>
               
               <pre><code>func (cs *http2clientStream) doRequest(req *Request, streamf func(*http2clientStream))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eachPair" data-name="eachPair">
               <h3>
                  eachPair 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#eachPair" class="anchor" title="Link to eachPair">#</a>
               </h3>
               
               <p>eachPair calls f for each pair in the mapping.
If f returns false, pairs returns immediately.</p>
               
               <pre><code>func (h **ast.IndexListExpr) eachPair(f func(k K, v V) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="empty" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#empty" class="anchor" title="Link to empty">#</a>
               </h3>
               
               <pre><code>func (q *http2writeQueue) empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeAndWriteHeaders" data-name="encodeAndWriteHeaders">
               <h3>
                  encodeAndWriteHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#encodeAndWriteHeaders" class="anchor" title="Link to encodeAndWriteHeaders">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) encodeAndWriteHeaders(req *Request) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeHeaders" data-name="encodeHeaders">
               <h3>
                  encodeHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#encodeHeaders" class="anchor" title="Link to encodeHeaders">#</a>
               </h3>
               
               <p>requires cc.wmu be held.</p>
               
               <pre><code>func (cc *http2ClientConn) encodeHeaders(req *Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeTrailers" data-name="encodeTrailers">
               <h3>
                  encodeTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#encodeTrailers" class="anchor" title="Link to encodeTrailers">#</a>
               </h3>
               
               <p>requires cc.wmu be held.</p>
               
               <pre><code>func (cc *http2ClientConn) encodeTrailers(trailer Header) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endStream" data-name="endStream">
               <h3>
                  endStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endStream" class="anchor" title="Link to endStream">#</a>
               </h3>
               
               <p>endStream closes a Request.Body's pipe. It is called when a DATA
frame says a request body is over (or after trailers).</p>
               
               <pre><code>func (st *http2stream) endStream()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endStream" data-name="endStream">
               <h3>
                  endStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endStream" class="anchor" title="Link to endStream">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) endStream(cs *http2clientStream)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endStreamError" data-name="endStreamError">
               <h3>
                  endStreamError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endStreamError" class="anchor" title="Link to endStreamError">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) endStreamError(cs *http2clientStream, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endWrite" data-name="endWrite">
               <h3>
                  endWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endWrite" class="anchor" title="Link to endWrite">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) endWrite() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="envProxyFunc" data-name="envProxyFunc">
               <h3>
                  envProxyFunc 
                  <span class="badge">function</span>
                  
                  <a href="#envProxyFunc" class="anchor" title="Link to envProxyFunc">#</a>
               </h3>
               
               <p>envProxyFunc returns a function that reads the
environment variable to determine the proxy address.</p>
               
               <pre><code>func envProxyFunc() (func(*url.URL) (*url.URL, error))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errNotSupported" data-name="errNotSupported">
               <h3>
                  errNotSupported 
                  <span class="badge">function</span>
                  
                  <a href="#errNotSupported" class="anchor" title="Link to errNotSupported">#</a>
               </h3>
               
               <p>errNotSupported returns an error that Is ErrNotSupported,
but is not == to it.</p>
               
               <pre><code>func errNotSupported() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorBody" data-name="errorBody">
               <h3>
                  errorBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorBody" class="anchor" title="Link to errorBody">#</a>
               </h3>
               
               <pre><code>func (h *timeoutHandler) errorBody() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="etagStrongMatch" data-name="etagStrongMatch">
               <h3>
                  etagStrongMatch 
                  <span class="badge">function</span>
                  
                  <a href="#etagStrongMatch" class="anchor" title="Link to etagStrongMatch">#</a>
               </h3>
               
               <p>etagStrongMatch reports whether a and b match using strong ETag comparison.
Assumes a and b are valid ETags.</p>
               
               <pre><code>func etagStrongMatch(a string, b string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="etagWeakMatch" data-name="etagWeakMatch">
               <h3>
                  etagWeakMatch 
                  <span class="badge">function</span>
                  
                  <a href="#etagWeakMatch" class="anchor" title="Link to etagWeakMatch">#</a>
               </h3>
               
               <p>etagWeakMatch reports whether a and b match using weak ETag comparison.
Assumes a and b are valid ETags.</p>
               
               <pre><code>func etagWeakMatch(a string, b string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exactMatch" data-name="exactMatch">
               <h3>
                  exactMatch 
                  <span class="badge">function</span>
                  
                  <a href="#exactMatch" class="anchor" title="Link to exactMatch">#</a>
               </h3>
               
               <p>exactMatch reports whether the node's pattern exactly matches the path.
As a special case, if the node is nil, exactMatch return false.
Before wildcards were introduced, it was clear that an exact match meant
that the pattern and path were the same string. The only other possibility
was that a trailing-slash pattern, like "/", matched a path longer than
it, like "/a".
With wildcards, we define an inexact match as any one where a multi wildcard
matches a non-empty string. All other matches are exact.
For example, these are all exact matches:
pattern   path
/a        /a
/{x}      /a
/a/{$}    /a/
/a/       /a/
The last case has a multi wildcard (implicitly), but the match is exact because
the wildcard matches the empty string.
Examples of matches that are not exact:
pattern   path
/         /a
/a/{x...} /a/b</p>
               
               <pre><code>func exactMatch(n *routingNode, path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expectContinueTimeout" data-name="expectContinueTimeout">
               <h3>
                  expectContinueTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expectContinueTimeout" class="anchor" title="Link to expectContinueTimeout">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) expectContinueTimeout() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expectsContinue" data-name="expectsContinue">
               <h3>
                  expectsContinue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expectsContinue" class="anchor" title="Link to expectsContinue">#</a>
               </h3>
               
               <pre><code>func (r *Request) expectsContinue() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extraHeaders" data-name="extraHeaders">
               <h3>
                  extraHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#extraHeaders" class="anchor" title="Link to extraHeaders">#</a>
               </h3>
               
               <pre><code>func (tr *transportRequest) extraHeaders() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finalFlush" data-name="finalFlush">
               <h3>
                  finalFlush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finalFlush" class="anchor" title="Link to finalFlush">#</a>
               </h3>
               
               <pre><code>func (c *conn) finalFlush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finalTrailers" data-name="finalTrailers">
               <h3>
                  finalTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finalTrailers" class="anchor" title="Link to finalTrailers">#</a>
               </h3>
               
               <p>finalTrailers is called after the Handler exits and returns a non-nil
value if the Handler set any trailers.</p>
               
               <pre><code>func (w *response) finalTrailers() Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="find" data-name="find">
               <h3>
                  find 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#find" class="anchor" title="Link to find">#</a>
               </h3>
               
               <p>find returns the value corresponding to the given key.
The second return value is false if there is no value
with that key.</p>
               
               <pre><code>func (h **ast.IndexListExpr) find(k K) (v V, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findChild" data-name="findChild">
               <h3>
                  findChild 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findChild" class="anchor" title="Link to findChild">#</a>
               </h3>
               
               <p>findChild returns the child of n with the given key, or nil
if there is no child with that key.</p>
               
               <pre><code>func (n *routingNode) findChild(key string) *routingNode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findHandler" data-name="findHandler">
               <h3>
                  findHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findHandler" class="anchor" title="Link to findHandler">#</a>
               </h3>
               
               <p>findHandler finds a handler for a request.
If there is a matching handler, it returns it and the pattern that matched.
Otherwise it returns a Redirect or NotFound handler with the path that would match
after the redirect.</p>
               
               <pre><code>func (mux *ServeMux) findHandler(r *Request) (h Handler, patStr string, _ *pattern, matches []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findHandler" data-name="findHandler">
               <h3>
                  findHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findHandler" class="anchor" title="Link to findHandler">#</a>
               </h3>
               
               <p>Formerly ServeMux.Handler.</p>
               
               <pre><code>func (mux *serveMux121) findHandler(r *Request) (h Handler, pattern string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finish" data-name="finish">
               <h3>
                  finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finish" class="anchor" title="Link to finish">#</a>
               </h3>
               
               <pre><code>func (pr *populateResponse) finish()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finishRequest" data-name="finishRequest">
               <h3>
                  finishRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finishRequest" class="anchor" title="Link to finishRequest">#</a>
               </h3>
               
               <pre><code>func (w *response) finishRequest()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="firstSegment" data-name="firstSegment">
               <h3>
                  firstSegment 
                  <span class="badge">function</span>
                  
                  <a href="#firstSegment" class="anchor" title="Link to firstSegment">#</a>
               </h3>
               
               <p>firstSegment splits path into its first segment, and the rest.
The path must begin with "/".
If path consists of only a slash, firstSegment returns ("/", "").
The segment is returned unescaped, if possible.</p>
               
               <pre><code>func firstSegment(path string) (seg string, rest string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixLength" data-name="fixLength">
               <h3>
                  fixLength 
                  <span class="badge">function</span>
                  
                  <a href="#fixLength" class="anchor" title="Link to fixLength">#</a>
               </h3>
               
               <p>Determine the expected body length, using RFC 7230 Section 3.3. This
function is not a method, because ultimately it should be shared by
ReadResponse and ReadRequest.</p>
               
               <pre><code>func fixLength(isResponse bool, status int, requestMethod string, header Header, chunked bool) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixPragmaCacheControl" data-name="fixPragmaCacheControl">
               <h3>
                  fixPragmaCacheControl 
                  <span class="badge">function</span>
                  
                  <a href="#fixPragmaCacheControl" class="anchor" title="Link to fixPragmaCacheControl">#</a>
               </h3>
               
               <p>RFC 7234, section 5.4: Should treat
Pragma: no-cache
like
Cache-Control: no-cache</p>
               
               <pre><code>func fixPragmaCacheControl(header Header)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixTrailer" data-name="fixTrailer">
               <h3>
                  fixTrailer 
                  <span class="badge">function</span>
                  
                  <a href="#fixTrailer" class="anchor" title="Link to fixTrailer">#</a>
               </h3>
               
               <p>Parse the trailer header.</p>
               
               <pre><code>func fixTrailer(header Header, chunked bool) (Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <pre><code>func (cw *chunkWriter) flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forceCloseConn" data-name="forceCloseConn">
               <h3>
                  forceCloseConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#forceCloseConn" class="anchor" title="Link to forceCloseConn">#</a>
               </h3>
               
               <p>A tls.Conn.Close can hang for a long time if the peer is unresponsive.
Try to shut it down more aggressively.</p>
               
               <pre><code>func (cc *http2ClientConn) forceCloseConn()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="foreachHeaderElement" data-name="foreachHeaderElement">
               <h3>
                  foreachHeaderElement 
                  <span class="badge">function</span>
                  
                  <a href="#foreachHeaderElement" class="anchor" title="Link to foreachHeaderElement">#</a>
               </h3>
               
               <p>foreachHeaderElement splits v according to the "#rule" construction
in RFC 7230 section 7 and calls fn for each non-empty element.</p>
               
               <pre><code>func foreachHeaderElement(v string, fn func(string))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forgetStreamID" data-name="forgetStreamID">
               <h3>
                  forgetStreamID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#forgetStreamID" class="anchor" title="Link to forgetStreamID">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) forgetStreamID(id uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="frameScratchBufferLen" data-name="frameScratchBufferLen">
               <h3>
                  frameScratchBufferLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#frameScratchBufferLen" class="anchor" title="Link to frameScratchBufferLen">#</a>
               </h3>
               
               <p>frameScratchBufferLen returns the length of a buffer to use for
outgoing request bodies to read/write to/from.
It returns max(1, min(peer's advertised max frame size,
Request.ContentLength+1, 512KB)).</p>
               
               <pre><code>func (cs *http2clientStream) frameScratchBufferLen(maxFrameSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get" class="anchor" title="Link to get">#</a>
               </h3>
               
               <p>get is like Get, but key must already be in CanonicalHeaderKey form.</p>
               
               <pre><code>func (h Header) get(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get" class="anchor" title="Link to get">#</a>
               </h3>
               
               <p>get returns an empty writeQueue.</p>
               
               <pre><code>func (p *http2writeQueuePool) get() *http2writeQueue</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get1xxTraceFunc" data-name="get1xxTraceFunc">
               <h3>
                  get1xxTraceFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get1xxTraceFunc" class="anchor" title="Link to get1xxTraceFunc">#</a>
               </h3>
               
               <p>get1xxTraceFunc returns the value of request's httptrace.ClientTrace.Got1xxResponse func,
if any. It returns nil if not set or if the Go version is too old.</p>
               
               <pre><code>func (cs *http2clientStream) get1xxTraceFunc() (func(int, textproto.MIMEHeader) error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getClientConn" data-name="getClientConn">
               <h3>
                  getClientConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getClientConn" class="anchor" title="Link to getClientConn">#</a>
               </h3>
               
               <pre><code>func (p *http2clientConnPool) getClientConn(req *Request, addr string, dialOnMiss bool) (*http2ClientConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getConn" data-name="getConn">
               <h3>
                  getConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getConn" class="anchor" title="Link to getConn">#</a>
               </h3>
               
               <p>getConn dials and creates a new persistConn to the target as
specified in the connectMethod. This includes doing a proxy CONNECT
and/or setting up TLS.  If this doesn't return an error, the persistConn
is ready to write requests to.</p>
               
               <pre><code>func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (_ *persistConn, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getCopyBuf" data-name="getCopyBuf">
               <h3>
                  getCopyBuf 
                  <span class="badge">function</span>
                  
                  <a href="#getCopyBuf" class="anchor" title="Link to getCopyBuf">#</a>
               </h3>
               
               <pre><code>func getCopyBuf() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getCtxForDial" data-name="getCtxForDial">
               <h3>
                  getCtxForDial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getCtxForDial" class="anchor" title="Link to getCtxForDial">#</a>
               </h3>
               
               <p>getCtxForDial returns context for dial or nil if connection was delivered or canceled.</p>
               
               <pre><code>func (w *wantConn) getCtxForDial() context.Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getDataFrame" data-name="getDataFrame">
               <h3>
                  getDataFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getDataFrame" class="anchor" title="Link to getDataFrame">#</a>
               </h3>
               
               <pre><code>func (fc *http2frameCache) getDataFrame() *http2DataFrame</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getStartDialLocked" data-name="getStartDialLocked">
               <h3>
                  getStartDialLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getStartDialLocked" class="anchor" title="Link to getStartDialLocked">#</a>
               </h3>
               
               <p>requires p.mu is held.</p>
               
               <pre><code>func (p *http2clientConnPool) getStartDialLocked(ctx context.Context, addr string) *http2dialCall</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getState" data-name="getState">
               <h3>
                  getState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getState" class="anchor" title="Link to getState">#</a>
               </h3>
               
               <pre><code>func (c *conn) getState() (state ConnState, unixSec int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goAway" data-name="goAway">
               <h3>
                  goAway 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#goAway" class="anchor" title="Link to goAway">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) goAway(code http2ErrCode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handle" data-name="handle">
               <h3>
                  handle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handle" class="anchor" title="Link to handle">#</a>
               </h3>
               
               <p>Formerly ServeMux.Handle.</p>
               
               <pre><code>func (mux *serveMux121) handle(pattern string, handler Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleFunc" data-name="handleFunc">
               <h3>
                  handleFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleFunc" class="anchor" title="Link to handleFunc">#</a>
               </h3>
               
               <p>Formerly ServeMux.HandleFunc.</p>
               
               <pre><code>func (mux *serveMux121) handleFunc(pattern string, handler func(ResponseWriter, *Request))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handlePingTimer" data-name="handlePingTimer">
               <h3>
                  handlePingTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handlePingTimer" class="anchor" title="Link to handlePingTimer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) handlePingTimer(lastFrameReadTime time.Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleReadError" data-name="handleReadError">
               <h3>
                  handleReadError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleReadError" class="anchor" title="Link to handleReadError">#</a>
               </h3>
               
               <p>handleReadError is called whenever a Read from the client returns a
non-nil error.
The provided non-nil err is almost always io.EOF or a "use of
closed network connection". In any case, the error is not
particularly interesting, except perhaps for debugging during
development. Any error means the connection is dead and we should
down its context.
It may be called from multiple goroutines.</p>
               
               <pre><code>func (cr *connReader) handleReadError(_ error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleResponse" data-name="handleResponse">
               <h3>
                  handleResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleResponse" class="anchor" title="Link to handleResponse">#</a>
               </h3>
               
               <p>may return error types nil, or ConnectionError. Any other error value
is a StreamError of type ErrCodeProtocol. The returned error in that case
is the detail.
As a special case, handleResponse may return (nil, nil) to skip the
frame (currently only used for 1xx responses).</p>
               
               <pre><code>func (rl *http2clientConnReadLoop) handleResponse(cs *http2clientStream, f *http2MetaHeadersFrame) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handler" data-name="handler">
               <h3>
                  handler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handler" class="anchor" title="Link to handler">#</a>
               </h3>
               
               <pre><code>func (o *http2ServeConnOpts) handler() Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handler" data-name="handler">
               <h3>
                  handler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handler" class="anchor" title="Link to handler">#</a>
               </h3>
               
               <p>handler is the main implementation of findHandler.
The path is known to be in canonical form, except for CONNECT methods.</p>
               
               <pre><code>func (mux *serveMux121) handler(host string, path string) (h Handler, pattern string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handlerDone" data-name="handlerDone">
               <h3>
                  handlerDone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handlerDone" class="anchor" title="Link to handlerDone">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) handlerDone()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handlerDone" data-name="handlerDone">
               <h3>
                  handlerDone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handlerDone" class="anchor" title="Link to handlerDone">#</a>
               </h3>
               
               <pre><code>func (w *http2responseWriter) handlerDone()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="has" data-name="has">
               <h3>
                  has 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#has" class="anchor" title="Link to has">#</a>
               </h3>
               
               <p>has reports whether h has the provided key defined, even if it's
set to 0-length slice.</p>
               
               <pre><code>func (h Header) has(key string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasCustomTLSDialer" data-name="hasCustomTLSDialer">
               <h3>
                  hasCustomTLSDialer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasCustomTLSDialer" class="anchor" title="Link to hasCustomTLSDialer">#</a>
               </h3>
               
               <pre><code>func (t *Transport) hasCustomTLSDialer() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasNonemptyTrailers" data-name="hasNonemptyTrailers">
               <h3>
                  hasNonemptyTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasNonemptyTrailers" class="anchor" title="Link to hasNonemptyTrailers">#</a>
               </h3>
               
               <pre><code>func (rws *http2responseWriterState) hasNonemptyTrailers() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasPort" data-name="hasPort">
               <h3>
                  hasPort 
                  <span class="badge">function</span>
                  
                  <a href="#hasPort" class="anchor" title="Link to hasPort">#</a>
               </h3>
               
               <p>Given a string of the form "host", "host:port", or "[ipv6::address]:port",
return true if the string includes a port.</p>
               
               <pre><code>func hasPort(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasToken" data-name="hasToken">
               <h3>
                  hasToken 
                  <span class="badge">function</span>
                  
                  <a href="#hasToken" class="anchor" title="Link to hasToken">#</a>
               </h3>
               
               <p>hasToken reports whether token appears with v, ASCII
case-insensitive, with space or comma boundaries.
token must be all lowercase.
v may contain mixed cased.</p>
               
               <pre><code>func hasToken(v string, token string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasTrailers" data-name="hasTrailers">
               <h3>
                  hasTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasTrailers" class="anchor" title="Link to hasTrailers">#</a>
               </h3>
               
               <pre><code>func (rws *http2responseWriterState) hasTrailers() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="healthCheck" data-name="healthCheck">
               <h3>
                  healthCheck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#healthCheck" class="anchor" title="Link to healthCheck">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) healthCheck()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hexEscapeNonASCII" data-name="hexEscapeNonASCII">
               <h3>
                  hexEscapeNonASCII 
                  <span class="badge">function</span>
                  
                  <a href="#hexEscapeNonASCII" class="anchor" title="Link to hexEscapeNonASCII">#</a>
               </h3>
               
               <pre><code>func hexEscapeNonASCII(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hijackLocked" data-name="hijackLocked">
               <h3>
                  hijackLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hijackLocked" class="anchor" title="Link to hijackLocked">#</a>
               </h3>
               
               <p>c.mu must be held.</p>
               
               <pre><code>func (c *conn) hijackLocked() (rwc net.Conn, buf *bufio.ReadWriter, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hijacked" data-name="hijacked">
               <h3>
                  hijacked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hijacked" class="anchor" title="Link to hijacked">#</a>
               </h3>
               
               <pre><code>func (c *conn) hijacked() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hitReadLimit" data-name="hitReadLimit">
               <h3>
                  hitReadLimit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hitReadLimit" class="anchor" title="Link to hitReadLimit">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) hitReadLimit() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="htmlEscape" data-name="htmlEscape">
               <h3>
                  htmlEscape 
                  <span class="badge">function</span>
                  
                  <a href="#htmlEscape" class="anchor" title="Link to htmlEscape">#</a>
               </h3>
               
               <pre><code>func htmlEscape(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http1ServerSupportsRequest" data-name="http1ServerSupportsRequest">
               <h3>
                  http1ServerSupportsRequest 
                  <span class="badge">function</span>
                  
                  <a href="#http1ServerSupportsRequest" class="anchor" title="Link to http1ServerSupportsRequest">#</a>
               </h3>
               
               <p>http1ServerSupportsRequest reports whether Go's HTTP/1.x server
supports the given request.</p>
               
               <pre><code>func http1ServerSupportsRequest(req *Request) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2ConfigureServer" data-name="http2ConfigureServer">
               <h3>
                  http2ConfigureServer 
                  <span class="badge">function</span>
                  
                  <a href="#http2ConfigureServer" class="anchor" title="Link to http2ConfigureServer">#</a>
               </h3>
               
               <pre><code>func http2ConfigureServer(s *Server, conf *http2Server) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2ConfigureServer" data-name="http2ConfigureServer">
               <h3>
                  http2ConfigureServer 
                  <span class="badge">function</span>
                  
                  <a href="#http2ConfigureServer" class="anchor" title="Link to http2ConfigureServer">#</a>
               </h3>
               
               <p>ConfigureServer adds HTTP/2 support to a net/http Server.
The configuration conf may be nil.
ConfigureServer must be called before s begins serving.</p>
               
               <pre><code>func http2ConfigureServer(s *Server, conf *http2Server) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2ConfigureTransport" data-name="http2ConfigureTransport">
               <h3>
                  http2ConfigureTransport 
                  <span class="badge">function</span>
                  
                  <a href="#http2ConfigureTransport" class="anchor" title="Link to http2ConfigureTransport">#</a>
               </h3>
               
               <p>ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
It returns an error if t1 has already been HTTP/2-enabled.
Use ConfigureTransports instead to configure the HTTP/2 Transport.</p>
               
               <pre><code>func http2ConfigureTransport(t1 *Transport) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2ConfigureTransports" data-name="http2ConfigureTransports">
               <h3>
                  http2ConfigureTransports 
                  <span class="badge">function</span>
                  
                  <a href="#http2ConfigureTransports" class="anchor" title="Link to http2ConfigureTransports">#</a>
               </h3>
               
               <p>ConfigureTransports configures a net/http HTTP/1 Transport to use HTTP/2.
It returns a new HTTP/2 Transport for further configuration.
It returns an error if t1 has already been HTTP/2-enabled.</p>
               
               <pre><code>func http2ConfigureTransports(t1 *Transport) (*http2Transport, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2NewFramer" data-name="http2NewFramer">
               <h3>
                  http2NewFramer 
                  <span class="badge">function</span>
                  
                  <a href="#http2NewFramer" class="anchor" title="Link to http2NewFramer">#</a>
               </h3>
               
               <p>NewFramer returns a Framer that writes frames to w and reads them from r.</p>
               
               <pre><code>func http2NewFramer(w io.Writer, r io.Reader) *http2Framer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2NewPriorityWriteScheduler" data-name="http2NewPriorityWriteScheduler">
               <h3>
                  http2NewPriorityWriteScheduler 
                  <span class="badge">function</span>
                  
                  <a href="#http2NewPriorityWriteScheduler" class="anchor" title="Link to http2NewPriorityWriteScheduler">#</a>
               </h3>
               
               <p>NewPriorityWriteScheduler constructs a WriteScheduler that schedules
frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3.
If cfg is nil, default options are used.</p>
               
               <pre><code>func http2NewPriorityWriteScheduler(cfg *http2PriorityWriteSchedulerConfig) http2WriteScheduler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2NewPriorityWriteScheduler" data-name="http2NewPriorityWriteScheduler">
               <h3>
                  http2NewPriorityWriteScheduler 
                  <span class="badge">function</span>
                  
                  <a href="#http2NewPriorityWriteScheduler" class="anchor" title="Link to http2NewPriorityWriteScheduler">#</a>
               </h3>
               
               <pre><code>func http2NewPriorityWriteScheduler(any) http2WriteScheduler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2NewRandomWriteScheduler" data-name="http2NewRandomWriteScheduler">
               <h3>
                  http2NewRandomWriteScheduler 
                  <span class="badge">function</span>
                  
                  <a href="#http2NewRandomWriteScheduler" class="anchor" title="Link to http2NewRandomWriteScheduler">#</a>
               </h3>
               
               <p>NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2
priorities. Control frames like SETTINGS and PING are written before DATA
frames, but if no control frames are queued and multiple streams have queued
HEADERS or DATA frames, Pop selects a ready stream arbitrarily.</p>
               
               <pre><code>func http2NewRandomWriteScheduler() http2WriteScheduler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2ReadFrameHeader" data-name="http2ReadFrameHeader">
               <h3>
                  http2ReadFrameHeader 
                  <span class="badge">function</span>
                  
                  <a href="#http2ReadFrameHeader" class="anchor" title="Link to http2ReadFrameHeader">#</a>
               </h3>
               
               <p>ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
Most users should use Framer.ReadFrame instead.</p>
               
               <pre><code>func http2ReadFrameHeader(r io.Reader) (http2FrameHeader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2actualContentLength" data-name="http2actualContentLength">
               <h3>
                  http2actualContentLength 
                  <span class="badge">function</span>
                  
                  <a href="#http2actualContentLength" class="anchor" title="Link to http2actualContentLength">#</a>
               </h3>
               
               <p>actualContentLength returns a sanitized version of
req.ContentLength, where 0 actually means zero (not unknown) and -1
means unknown.</p>
               
               <pre><code>func http2actualContentLength(req *Request) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2adjustHTTP1MaxHeaderSize" data-name="http2adjustHTTP1MaxHeaderSize">
               <h3>
                  http2adjustHTTP1MaxHeaderSize 
                  <span class="badge">function</span>
                  
                  <a href="#http2adjustHTTP1MaxHeaderSize" class="anchor" title="Link to http2adjustHTTP1MaxHeaderSize">#</a>
               </h3>
               
               <p>adjustHTTP1MaxHeaderSize converts a limit in bytes on the size of an HTTP/1 header
to an HTTP/2 MAX_HEADER_LIST_SIZE value.</p>
               
               <pre><code>func http2adjustHTTP1MaxHeaderSize(n int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2asciiEqualFold" data-name="http2asciiEqualFold">
               <h3>
                  http2asciiEqualFold 
                  <span class="badge">function</span>
                  
                  <a href="#http2asciiEqualFold" class="anchor" title="Link to http2asciiEqualFold">#</a>
               </h3>
               
               <p>asciiEqualFold is strings.EqualFold, ASCII only. It reports whether s and t
are equal, ASCII-case-insensitively.</p>
               
               <pre><code>func http2asciiEqualFold(s string, t string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2asciiToLower" data-name="http2asciiToLower">
               <h3>
                  http2asciiToLower 
                  <span class="badge">function</span>
                  
                  <a href="#http2asciiToLower" class="anchor" title="Link to http2asciiToLower">#</a>
               </h3>
               
               <p>asciiToLower returns the lowercase version of s if s is ASCII and printable,
and whether or not it was.</p>
               
               <pre><code>func http2asciiToLower(s string) (lower string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2authorityAddr" data-name="http2authorityAddr">
               <h3>
                  http2authorityAddr 
                  <span class="badge">function</span>
                  
                  <a href="#http2authorityAddr" class="anchor" title="Link to http2authorityAddr">#</a>
               </h3>
               
               <p>authorityAddr returns a given authority (a host/IP, or host:port / ip:port)
and returns a host:port. The port 443 is added if needed.</p>
               
               <pre><code>func http2authorityAddr(scheme string, authority string) (addr string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2bodyAllowedForStatus" data-name="http2bodyAllowedForStatus">
               <h3>
                  http2bodyAllowedForStatus 
                  <span class="badge">function</span>
                  
                  <a href="#http2bodyAllowedForStatus" class="anchor" title="Link to http2bodyAllowedForStatus">#</a>
               </h3>
               
               <p>bodyAllowedForStatus reports whether a given response status code
permits a body. See RFC 7230, section 3.3.</p>
               
               <pre><code>func http2bodyAllowedForStatus(status int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2bufPoolIndex" data-name="http2bufPoolIndex">
               <h3>
                  http2bufPoolIndex 
                  <span class="badge">function</span>
                  
                  <a href="#http2bufPoolIndex" class="anchor" title="Link to http2bufPoolIndex">#</a>
               </h3>
               
               <pre><code>func http2bufPoolIndex(size int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2buildCommonHeaderMaps" data-name="http2buildCommonHeaderMaps">
               <h3>
                  http2buildCommonHeaderMaps 
                  <span class="badge">function</span>
                  
                  <a href="#http2buildCommonHeaderMaps" class="anchor" title="Link to http2buildCommonHeaderMaps">#</a>
               </h3>
               
               <pre><code>func http2buildCommonHeaderMaps()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2buildCommonHeaderMapsOnce" data-name="http2buildCommonHeaderMapsOnce">
               <h3>
                  http2buildCommonHeaderMapsOnce 
                  <span class="badge">function</span>
                  
                  <a href="#http2buildCommonHeaderMapsOnce" class="anchor" title="Link to http2buildCommonHeaderMapsOnce">#</a>
               </h3>
               
               <pre><code>func http2buildCommonHeaderMapsOnce()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2canRetryError" data-name="http2canRetryError">
               <h3>
                  http2canRetryError 
                  <span class="badge">function</span>
                  
                  <a href="#http2canRetryError" class="anchor" title="Link to http2canRetryError">#</a>
               </h3>
               
               <pre><code>func http2canRetryError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2canonicalHeader" data-name="http2canonicalHeader">
               <h3>
                  http2canonicalHeader 
                  <span class="badge">function</span>
                  
                  <a href="#http2canonicalHeader" class="anchor" title="Link to http2canonicalHeader">#</a>
               </h3>
               
               <pre><code>func http2canonicalHeader(v string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2checkConnHeaders" data-name="http2checkConnHeaders">
               <h3>
                  http2checkConnHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#http2checkConnHeaders" class="anchor" title="Link to http2checkConnHeaders">#</a>
               </h3>
               
               <p>checkConnHeaders checks whether req has any invalid connection-level headers.
per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.
Certain headers are special-cased as okay but not transmitted later.</p>
               
               <pre><code>func http2checkConnHeaders(req *Request) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2checkValidHTTP2RequestHeaders" data-name="http2checkValidHTTP2RequestHeaders">
               <h3>
                  http2checkValidHTTP2RequestHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#http2checkValidHTTP2RequestHeaders" class="anchor" title="Link to http2checkValidHTTP2RequestHeaders">#</a>
               </h3>
               
               <p>checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,
per RFC 7540 Section 8.1.2.2.
The returned error is reported to users.</p>
               
               <pre><code>func http2checkValidHTTP2RequestHeaders(h Header) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2checkWriteHeaderCode" data-name="http2checkWriteHeaderCode">
               <h3>
                  http2checkWriteHeaderCode 
                  <span class="badge">function</span>
                  
                  <a href="#http2checkWriteHeaderCode" class="anchor" title="Link to http2checkWriteHeaderCode">#</a>
               </h3>
               
               <p>checkWriteHeaderCode is a copy of net/http's checkWriteHeaderCode.</p>
               
               <pre><code>func http2checkWriteHeaderCode(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2cloneHeader" data-name="http2cloneHeader">
               <h3>
                  http2cloneHeader 
                  <span class="badge">function</span>
                  
                  <a href="#http2cloneHeader" class="anchor" title="Link to http2cloneHeader">#</a>
               </h3>
               
               <pre><code>func http2cloneHeader(h Header) Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2commaSeparatedTrailers" data-name="http2commaSeparatedTrailers">
               <h3>
                  http2commaSeparatedTrailers 
                  <span class="badge">function</span>
                  
                  <a href="#http2commaSeparatedTrailers" class="anchor" title="Link to http2commaSeparatedTrailers">#</a>
               </h3>
               
               <pre><code>func http2commaSeparatedTrailers(req *Request) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2configFromServer" data-name="http2configFromServer">
               <h3>
                  http2configFromServer 
                  <span class="badge">function</span>
                  
                  <a href="#http2configFromServer" class="anchor" title="Link to http2configFromServer">#</a>
               </h3>
               
               <p>configFromServer merges configuration settings from
net/http.Server.HTTP2Config and http2.Server.</p>
               
               <pre><code>func http2configFromServer(h1 *Server, h2 *http2Server) http2http2Config</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2configFromTransport" data-name="http2configFromTransport">
               <h3>
                  http2configFromTransport 
                  <span class="badge">function</span>
                  
                  <a href="#http2configFromTransport" class="anchor" title="Link to http2configFromTransport">#</a>
               </h3>
               
               <p>configFromServer merges configuration settings from h2 and h2.t1.HTTP2
(the net/http Transport).</p>
               
               <pre><code>func http2configFromTransport(h2 *http2Transport) http2http2Config</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2configureTransports" data-name="http2configureTransports">
               <h3>
                  http2configureTransports 
                  <span class="badge">function</span>
                  
                  <a href="#http2configureTransports" class="anchor" title="Link to http2configureTransports">#</a>
               </h3>
               
               <pre><code>func http2configureTransports(*Transport) (*http2Transport, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2configureTransports" data-name="http2configureTransports">
               <h3>
                  http2configureTransports 
                  <span class="badge">function</span>
                  
                  <a href="#http2configureTransports" class="anchor" title="Link to http2configureTransports">#</a>
               </h3>
               
               <pre><code>func http2configureTransports(t1 *Transport) (*http2Transport, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2curGoroutineID" data-name="http2curGoroutineID">
               <h3>
                  http2curGoroutineID 
                  <span class="badge">function</span>
                  
                  <a href="#http2curGoroutineID" class="anchor" title="Link to http2curGoroutineID">#</a>
               </h3>
               
               <pre><code>func http2curGoroutineID() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2cutoff64" data-name="http2cutoff64">
               <h3>
                  http2cutoff64 
                  <span class="badge">function</span>
                  
                  <a href="#http2cutoff64" class="anchor" title="Link to http2cutoff64">#</a>
               </h3>
               
               <p>Return the first number n such that n*base >= 1<<64.</p>
               
               <pre><code>func http2cutoff64(base int) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2encKV" data-name="http2encKV">
               <h3>
                  http2encKV 
                  <span class="badge">function</span>
                  
                  <a href="#http2encKV" class="anchor" title="Link to http2encKV">#</a>
               </h3>
               
               <pre><code>func http2encKV(enc *hpack.Encoder, k string, v string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2encodeHeaders" data-name="http2encodeHeaders">
               <h3>
                  http2encodeHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#http2encodeHeaders" class="anchor" title="Link to http2encodeHeaders">#</a>
               </h3>
               
               <p>encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])
is encoded only if k is in keys.</p>
               
               <pre><code>func http2encodeHeaders(enc *hpack.Encoder, h Header, keys []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2errno" data-name="http2errno">
               <h3>
                  http2errno 
                  <span class="badge">function</span>
                  
                  <a href="#http2errno" class="anchor" title="Link to http2errno">#</a>
               </h3>
               
               <p>errno returns v's underlying uintptr, else 0.
TODO: remove this helper function once http2 can use build
tags. See comment in isClosedConnError.</p>
               
               <pre><code>func http2errno(v error) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2fillNetHTTPConfig" data-name="http2fillNetHTTPConfig">
               <h3>
                  http2fillNetHTTPConfig 
                  <span class="badge">function</span>
                  
                  <a href="#http2fillNetHTTPConfig" class="anchor" title="Link to http2fillNetHTTPConfig">#</a>
               </h3>
               
               <pre><code>func http2fillNetHTTPConfig(conf *http2http2Config, h2 *HTTP2Config)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2fillNetHTTPServerConfig" data-name="http2fillNetHTTPServerConfig">
               <h3>
                  http2fillNetHTTPServerConfig 
                  <span class="badge">function</span>
                  
                  <a href="#http2fillNetHTTPServerConfig" class="anchor" title="Link to http2fillNetHTTPServerConfig">#</a>
               </h3>
               
               <p>fillNetHTTPServerConfig sets fields in conf from srv.HTTP2.</p>
               
               <pre><code>func http2fillNetHTTPServerConfig(conf *http2http2Config, srv *Server)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2fillNetHTTPTransportConfig" data-name="http2fillNetHTTPTransportConfig">
               <h3>
                  http2fillNetHTTPTransportConfig 
                  <span class="badge">function</span>
                  
                  <a href="#http2fillNetHTTPTransportConfig" class="anchor" title="Link to http2fillNetHTTPTransportConfig">#</a>
               </h3>
               
               <p>fillNetHTTPServerConfig sets fields in conf from tr.HTTP2.</p>
               
               <pre><code>func http2fillNetHTTPTransportConfig(conf *http2http2Config, tr *Transport)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2filterOutClientConn" data-name="http2filterOutClientConn">
               <h3>
                  http2filterOutClientConn 
                  <span class="badge">function</span>
                  
                  <a href="#http2filterOutClientConn" class="anchor" title="Link to http2filterOutClientConn">#</a>
               </h3>
               
               <pre><code>func http2filterOutClientConn(in []*http2ClientConn, exclude *http2ClientConn) []*http2ClientConn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2foreachHeaderElement" data-name="http2foreachHeaderElement">
               <h3>
                  http2foreachHeaderElement 
                  <span class="badge">function</span>
                  
                  <a href="#http2foreachHeaderElement" class="anchor" title="Link to http2foreachHeaderElement">#</a>
               </h3>
               
               <p>foreachHeaderElement splits v according to the "#rule" construction
in RFC 7230 section 7 and calls fn for each non-empty element.</p>
               
               <pre><code>func http2foreachHeaderElement(v string, fn func(string))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2getDataBufferChunk" data-name="http2getDataBufferChunk">
               <h3>
                  http2getDataBufferChunk 
                  <span class="badge">function</span>
                  
                  <a href="#http2getDataBufferChunk" class="anchor" title="Link to http2getDataBufferChunk">#</a>
               </h3>
               
               <pre><code>func http2getDataBufferChunk(size int64) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2h1ServerKeepAlivesDisabled" data-name="http2h1ServerKeepAlivesDisabled">
               <h3>
                  http2h1ServerKeepAlivesDisabled 
                  <span class="badge">function</span>
                  
                  <a href="#http2h1ServerKeepAlivesDisabled" class="anchor" title="Link to http2h1ServerKeepAlivesDisabled">#</a>
               </h3>
               
               <p>h1ServerKeepAlivesDisabled reports whether hs has its keep-alives
disabled. See comments on h1ServerShutdownChan above for why
the code is written this way.</p>
               
               <pre><code>func http2h1ServerKeepAlivesDisabled(hs *Server) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2handleHeaderListTooLong" data-name="http2handleHeaderListTooLong">
               <h3>
                  http2handleHeaderListTooLong 
                  <span class="badge">function</span>
                  
                  <a href="#http2handleHeaderListTooLong" class="anchor" title="Link to http2handleHeaderListTooLong">#</a>
               </h3>
               
               <pre><code>func http2handleHeaderListTooLong(w ResponseWriter, r *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2httpCodeString" data-name="http2httpCodeString">
               <h3>
                  http2httpCodeString 
                  <span class="badge">function</span>
                  
                  <a href="#http2httpCodeString" class="anchor" title="Link to http2httpCodeString">#</a>
               </h3>
               
               <pre><code>func http2httpCodeString(code int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isASCIIPrint" data-name="http2isASCIIPrint">
               <h3>
                  http2isASCIIPrint 
                  <span class="badge">function</span>
                  
                  <a href="#http2isASCIIPrint" class="anchor" title="Link to http2isASCIIPrint">#</a>
               </h3>
               
               <p>isASCIIPrint returns whether s is ASCII and printable according to
https://tools.ietf.org/html/rfc20#section-4.2.</p>
               
               <pre><code>func http2isASCIIPrint(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isBadCipher" data-name="http2isBadCipher">
               <h3>
                  http2isBadCipher 
                  <span class="badge">function</span>
                  
                  <a href="#http2isBadCipher" class="anchor" title="Link to http2isBadCipher">#</a>
               </h3>
               
               <p>isBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec.
References:
https://tools.ietf.org/html/rfc7540#appendix-A
Reject cipher suites from Appendix A.
"This list includes those cipher suites that do not
offer an ephemeral key exchange and those that are
based on the TLS null, stream or block cipher type"</p>
               
               <pre><code>func http2isBadCipher(cipher uint16) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isClosedConnError" data-name="http2isClosedConnError">
               <h3>
                  http2isClosedConnError 
                  <span class="badge">function</span>
                  
                  <a href="#http2isClosedConnError" class="anchor" title="Link to http2isClosedConnError">#</a>
               </h3>
               
               <p>isClosedConnError reports whether err is an error from use of a closed
network connection.</p>
               
               <pre><code>func http2isClosedConnError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isConnectionCloseRequest" data-name="http2isConnectionCloseRequest">
               <h3>
                  http2isConnectionCloseRequest 
                  <span class="badge">function</span>
                  
                  <a href="#http2isConnectionCloseRequest" class="anchor" title="Link to http2isConnectionCloseRequest">#</a>
               </h3>
               
               <p>isConnectionCloseRequest reports whether req should use its own
connection for a single request and then close the connection.</p>
               
               <pre><code>func http2isConnectionCloseRequest(req *Request) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isEOFOrNetReadError" data-name="http2isEOFOrNetReadError">
               <h3>
                  http2isEOFOrNetReadError 
                  <span class="badge">function</span>
                  
                  <a href="#http2isEOFOrNetReadError" class="anchor" title="Link to http2isEOFOrNetReadError">#</a>
               </h3>
               
               <pre><code>func http2isEOFOrNetReadError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isNoCachedConnError" data-name="http2isNoCachedConnError">
               <h3>
                  http2isNoCachedConnError 
                  <span class="badge">function</span>
                  
                  <a href="#http2isNoCachedConnError" class="anchor" title="Link to http2isNoCachedConnError">#</a>
               </h3>
               
               <pre><code>func http2isNoCachedConnError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2isNoCachedConnError" data-name="http2isNoCachedConnError">
               <h3>
                  http2isNoCachedConnError 
                  <span class="badge">function</span>
                  
                  <a href="#http2isNoCachedConnError" class="anchor" title="Link to http2isNoCachedConnError">#</a>
               </h3>
               
               <p>isNoCachedConnError reports whether err is of type noCachedConnError
or its equivalent renamed type in net/http2's h2_bundle.go. Both types
may coexist in the same running program.</p>
               
               <pre><code>func http2isNoCachedConnError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2lower" data-name="http2lower">
               <h3>
                  http2lower 
                  <span class="badge">function</span>
                  
                  <a href="#http2lower" class="anchor" title="Link to http2lower">#</a>
               </h3>
               
               <p>lower returns the ASCII lowercase version of b.</p>
               
               <pre><code>func http2lower(b byte) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2lowerHeader" data-name="http2lowerHeader">
               <h3>
                  http2lowerHeader 
                  <span class="badge">function</span>
                  
                  <a href="#http2lowerHeader" class="anchor" title="Link to http2lowerHeader">#</a>
               </h3>
               
               <pre><code>func http2lowerHeader(v string) (lower string, ascii bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2mustUint31" data-name="http2mustUint31">
               <h3>
                  http2mustUint31 
                  <span class="badge">function</span>
                  
                  <a href="#http2mustUint31" class="anchor" title="Link to http2mustUint31">#</a>
               </h3>
               
               <pre><code>func http2mustUint31(v int32) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2new400Handler" data-name="http2new400Handler">
               <h3>
                  http2new400Handler 
                  <span class="badge">function</span>
                  
                  <a href="#http2new400Handler" class="anchor" title="Link to http2new400Handler">#</a>
               </h3>
               
               <pre><code>func http2new400Handler(err error) HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2newBufferedWriter" data-name="http2newBufferedWriter">
               <h3>
                  http2newBufferedWriter 
                  <span class="badge">function</span>
                  
                  <a href="#http2newBufferedWriter" class="anchor" title="Link to http2newBufferedWriter">#</a>
               </h3>
               
               <pre><code>func http2newBufferedWriter(group http2synctestGroupInterface, conn net.Conn, timeout time.Duration) *http2bufferedWriter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2newGoroutineLock" data-name="http2newGoroutineLock">
               <h3>
                  http2newGoroutineLock 
                  <span class="badge">function</span>
                  
                  <a href="#http2newGoroutineLock" class="anchor" title="Link to http2newGoroutineLock">#</a>
               </h3>
               
               <pre><code>func http2newGoroutineLock() http2goroutineLock</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2newRoundRobinWriteScheduler" data-name="http2newRoundRobinWriteScheduler">
               <h3>
                  http2newRoundRobinWriteScheduler 
                  <span class="badge">function</span>
                  
                  <a href="#http2newRoundRobinWriteScheduler" class="anchor" title="Link to http2newRoundRobinWriteScheduler">#</a>
               </h3>
               
               <p>newRoundRobinWriteScheduler constructs a new write scheduler.
The round robin scheduler priorizes control frames
like SETTINGS and PING over DATA frames.
When there are no control frames to send, it performs a round-robin
selection from the ready streams.</p>
               
               <pre><code>func http2newRoundRobinWriteScheduler() http2WriteScheduler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseContinuationFrame" data-name="http2parseContinuationFrame">
               <h3>
                  http2parseContinuationFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseContinuationFrame" class="anchor" title="Link to http2parseContinuationFrame">#</a>
               </h3>
               
               <pre><code>func http2parseContinuationFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseDataFrame" data-name="http2parseDataFrame">
               <h3>
                  http2parseDataFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseDataFrame" class="anchor" title="Link to http2parseDataFrame">#</a>
               </h3>
               
               <pre><code>func http2parseDataFrame(fc *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseGoAwayFrame" data-name="http2parseGoAwayFrame">
               <h3>
                  http2parseGoAwayFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseGoAwayFrame" class="anchor" title="Link to http2parseGoAwayFrame">#</a>
               </h3>
               
               <pre><code>func http2parseGoAwayFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseHeadersFrame" data-name="http2parseHeadersFrame">
               <h3>
                  http2parseHeadersFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseHeadersFrame" class="anchor" title="Link to http2parseHeadersFrame">#</a>
               </h3>
               
               <pre><code>func http2parseHeadersFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (_ http2Frame, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parsePingFrame" data-name="http2parsePingFrame">
               <h3>
                  http2parsePingFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parsePingFrame" class="anchor" title="Link to http2parsePingFrame">#</a>
               </h3>
               
               <pre><code>func http2parsePingFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parsePriorityFrame" data-name="http2parsePriorityFrame">
               <h3>
                  http2parsePriorityFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parsePriorityFrame" class="anchor" title="Link to http2parsePriorityFrame">#</a>
               </h3>
               
               <pre><code>func http2parsePriorityFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parsePushPromise" data-name="http2parsePushPromise">
               <h3>
                  http2parsePushPromise 
                  <span class="badge">function</span>
                  
                  <a href="#http2parsePushPromise" class="anchor" title="Link to http2parsePushPromise">#</a>
               </h3>
               
               <pre><code>func http2parsePushPromise(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (_ http2Frame, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseRSTStreamFrame" data-name="http2parseRSTStreamFrame">
               <h3>
                  http2parseRSTStreamFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseRSTStreamFrame" class="anchor" title="Link to http2parseRSTStreamFrame">#</a>
               </h3>
               
               <pre><code>func http2parseRSTStreamFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseSettingsFrame" data-name="http2parseSettingsFrame">
               <h3>
                  http2parseSettingsFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseSettingsFrame" class="anchor" title="Link to http2parseSettingsFrame">#</a>
               </h3>
               
               <pre><code>func http2parseSettingsFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseUintBytes" data-name="http2parseUintBytes">
               <h3>
                  http2parseUintBytes 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseUintBytes" class="anchor" title="Link to http2parseUintBytes">#</a>
               </h3>
               
               <p>parseUintBytes is like strconv.ParseUint, but using a []byte.</p>
               
               <pre><code>func http2parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseUnknownFrame" data-name="http2parseUnknownFrame">
               <h3>
                  http2parseUnknownFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseUnknownFrame" class="anchor" title="Link to http2parseUnknownFrame">#</a>
               </h3>
               
               <pre><code>func http2parseUnknownFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2parseWindowUpdateFrame" data-name="http2parseWindowUpdateFrame">
               <h3>
                  http2parseWindowUpdateFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2parseWindowUpdateFrame" class="anchor" title="Link to http2parseWindowUpdateFrame">#</a>
               </h3>
               
               <pre><code>func http2parseWindowUpdateFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2putDataBufferChunk" data-name="http2putDataBufferChunk">
               <h3>
                  http2putDataBufferChunk 
                  <span class="badge">function</span>
                  
                  <a href="#http2putDataBufferChunk" class="anchor" title="Link to http2putDataBufferChunk">#</a>
               </h3>
               
               <pre><code>func http2putDataBufferChunk(p []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2readByte" data-name="http2readByte">
               <h3>
                  http2readByte 
                  <span class="badge">function</span>
                  
                  <a href="#http2readByte" class="anchor" title="Link to http2readByte">#</a>
               </h3>
               
               <pre><code>func http2readByte(p []byte) (remain []byte, b byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2readFrameHeader" data-name="http2readFrameHeader">
               <h3>
                  http2readFrameHeader 
                  <span class="badge">function</span>
                  
                  <a href="#http2readFrameHeader" class="anchor" title="Link to http2readFrameHeader">#</a>
               </h3>
               
               <pre><code>func http2readFrameHeader(buf []byte, r io.Reader) (http2FrameHeader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2readUint32" data-name="http2readUint32">
               <h3>
                  http2readUint32 
                  <span class="badge">function</span>
                  
                  <a href="#http2readUint32" class="anchor" title="Link to http2readUint32">#</a>
               </h3>
               
               <pre><code>func http2readUint32(p []byte) (remain []byte, v uint32, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2registerHTTPSProtocol" data-name="http2registerHTTPSProtocol">
               <h3>
                  http2registerHTTPSProtocol 
                  <span class="badge">function</span>
                  
                  <a href="#http2registerHTTPSProtocol" class="anchor" title="Link to http2registerHTTPSProtocol">#</a>
               </h3>
               
               <p>registerHTTPSProtocol calls Transport.RegisterProtocol but
converting panics into errors.</p>
               
               <pre><code>func http2registerHTTPSProtocol(t *Transport, rt http2noDialH2RoundTripper) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2serverConnBaseContext" data-name="http2serverConnBaseContext">
               <h3>
                  http2serverConnBaseContext 
                  <span class="badge">function</span>
                  
                  <a href="#http2serverConnBaseContext" class="anchor" title="Link to http2serverConnBaseContext">#</a>
               </h3>
               
               <pre><code>func http2serverConnBaseContext(c net.Conn, opts *http2ServeConnOpts) (ctx context.Context, cancel func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2setConfigDefaults" data-name="http2setConfigDefaults">
               <h3>
                  http2setConfigDefaults 
                  <span class="badge">function</span>
                  
                  <a href="#http2setConfigDefaults" class="anchor" title="Link to http2setConfigDefaults">#</a>
               </h3>
               
               <pre><code>func http2setConfigDefaults(conf *http2http2Config, server bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2setDefault" data-name="http2setDefault">
               <h3>
                  http2setDefault 
                  <span class="badge">function</span>
                  
                  <a href="#http2setDefault" class="anchor" title="Link to http2setDefault">#</a>
               </h3>
               
               <pre><code>func http2setDefault(v *T, minval T, maxval T, defval T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2shouldRetryDial" data-name="http2shouldRetryDial">
               <h3>
                  http2shouldRetryDial 
                  <span class="badge">function</span>
                  
                  <a href="#http2shouldRetryDial" class="anchor" title="Link to http2shouldRetryDial">#</a>
               </h3>
               
               <p>shouldRetryDial reports whether the current request should
retry dialing after the call finished unsuccessfully, for example
if the dial was canceled because of a context cancellation or
deadline expiry.</p>
               
               <pre><code>func http2shouldRetryDial(call *http2dialCall, req *Request) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2shouldRetryRequest" data-name="http2shouldRetryRequest">
               <h3>
                  http2shouldRetryRequest 
                  <span class="badge">function</span>
                  
                  <a href="#http2shouldRetryRequest" class="anchor" title="Link to http2shouldRetryRequest">#</a>
               </h3>
               
               <p>shouldRetryRequest is called by RoundTrip when a request fails to get
response headers. It is always called with a non-nil error.
It returns either a request to retry (either the same request, or a
modified clone), or an error if the request can't be replayed.</p>
               
               <pre><code>func http2shouldRetryRequest(req *Request, err error) (*Request, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2shouldSendReqContentLength" data-name="http2shouldSendReqContentLength">
               <h3>
                  http2shouldSendReqContentLength 
                  <span class="badge">function</span>
                  
                  <a href="#http2shouldSendReqContentLength" class="anchor" title="Link to http2shouldSendReqContentLength">#</a>
               </h3>
               
               <p>shouldSendReqContentLength reports whether the http2.Transport should send
a "content-length" request header. This logic is basically a copy of the net/http
transferWriter.shouldSendContentLength.
The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).
-1 means unknown.</p>
               
               <pre><code>func http2shouldSendReqContentLength(method string, contentLength int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2splitHeaderBlock" data-name="http2splitHeaderBlock">
               <h3>
                  http2splitHeaderBlock 
                  <span class="badge">function</span>
                  
                  <a href="#http2splitHeaderBlock" class="anchor" title="Link to http2splitHeaderBlock">#</a>
               </h3>
               
               <p>splitHeaderBlock splits headerBlock into fragments so that each fragment fits
in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true
for the first/last fragment, respectively.</p>
               
               <pre><code>func http2splitHeaderBlock(ctx http2writeContext, headerBlock []byte, fn func(ctx http2writeContext, frag []byte, firstFrag bool, lastFrag bool) error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2strSliceContains" data-name="http2strSliceContains">
               <h3>
                  http2strSliceContains 
                  <span class="badge">function</span>
                  
                  <a href="#http2strSliceContains" class="anchor" title="Link to http2strSliceContains">#</a>
               </h3>
               
               <pre><code>func http2strSliceContains(ss []string, s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2streamError" data-name="http2streamError">
               <h3>
                  http2streamError 
                  <span class="badge">function</span>
                  
                  <a href="#http2streamError" class="anchor" title="Link to http2streamError">#</a>
               </h3>
               
               <pre><code>func http2streamError(id uint32, code http2ErrCode) http2StreamError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2summarizeFrame" data-name="http2summarizeFrame">
               <h3>
                  http2summarizeFrame 
                  <span class="badge">function</span>
                  
                  <a href="#http2summarizeFrame" class="anchor" title="Link to http2summarizeFrame">#</a>
               </h3>
               
               <pre><code>func http2summarizeFrame(f http2Frame) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2takeInflows" data-name="http2takeInflows">
               <h3>
                  http2takeInflows 
                  <span class="badge">function</span>
                  
                  <a href="#http2takeInflows" class="anchor" title="Link to http2takeInflows">#</a>
               </h3>
               
               <p>takeInflows attempts to take n bytes from two inflows,
typically connection-level and stream-level flows.
It reports whether both windows have available capacity.</p>
               
               <pre><code>func http2takeInflows(f1 *http2inflow, f2 *http2inflow, n uint32) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2terminalReadFrameError" data-name="http2terminalReadFrameError">
               <h3>
                  http2terminalReadFrameError 
                  <span class="badge">function</span>
                  
                  <a href="#http2terminalReadFrameError" class="anchor" title="Link to http2terminalReadFrameError">#</a>
               </h3>
               
               <p>terminalReadFrameError reports whether err is an unrecoverable
error from ReadFrame and no other frames should be read.</p>
               
               <pre><code>func http2terminalReadFrameError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceFirstResponseByte" data-name="http2traceFirstResponseByte">
               <h3>
                  http2traceFirstResponseByte 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceFirstResponseByte" class="anchor" title="Link to http2traceFirstResponseByte">#</a>
               </h3>
               
               <pre><code>func http2traceFirstResponseByte(trace *httptrace.ClientTrace)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceGetConn" data-name="http2traceGetConn">
               <h3>
                  http2traceGetConn 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceGetConn" class="anchor" title="Link to http2traceGetConn">#</a>
               </h3>
               
               <pre><code>func http2traceGetConn(req *Request, hostPort string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceGot100Continue" data-name="http2traceGot100Continue">
               <h3>
                  http2traceGot100Continue 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceGot100Continue" class="anchor" title="Link to http2traceGot100Continue">#</a>
               </h3>
               
               <pre><code>func http2traceGot100Continue(trace *httptrace.ClientTrace)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceGot1xxResponseFunc" data-name="http2traceGot1xxResponseFunc">
               <h3>
                  http2traceGot1xxResponseFunc 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceGot1xxResponseFunc" class="anchor" title="Link to http2traceGot1xxResponseFunc">#</a>
               </h3>
               
               <pre><code>func http2traceGot1xxResponseFunc(trace *httptrace.ClientTrace) (func(int, textproto.MIMEHeader) error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceGotConn" data-name="http2traceGotConn">
               <h3>
                  http2traceGotConn 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceGotConn" class="anchor" title="Link to http2traceGotConn">#</a>
               </h3>
               
               <pre><code>func http2traceGotConn(req *Request, cc *http2ClientConn, reused bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceHasWroteHeaderField" data-name="http2traceHasWroteHeaderField">
               <h3>
                  http2traceHasWroteHeaderField 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceHasWroteHeaderField" class="anchor" title="Link to http2traceHasWroteHeaderField">#</a>
               </h3>
               
               <pre><code>func http2traceHasWroteHeaderField(trace *httptrace.ClientTrace) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceWait100Continue" data-name="http2traceWait100Continue">
               <h3>
                  http2traceWait100Continue 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceWait100Continue" class="anchor" title="Link to http2traceWait100Continue">#</a>
               </h3>
               
               <pre><code>func http2traceWait100Continue(trace *httptrace.ClientTrace)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceWroteHeaderField" data-name="http2traceWroteHeaderField">
               <h3>
                  http2traceWroteHeaderField 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceWroteHeaderField" class="anchor" title="Link to http2traceWroteHeaderField">#</a>
               </h3>
               
               <pre><code>func http2traceWroteHeaderField(trace *httptrace.ClientTrace, k string, v string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceWroteHeaders" data-name="http2traceWroteHeaders">
               <h3>
                  http2traceWroteHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceWroteHeaders" class="anchor" title="Link to http2traceWroteHeaders">#</a>
               </h3>
               
               <pre><code>func http2traceWroteHeaders(trace *httptrace.ClientTrace)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2traceWroteRequest" data-name="http2traceWroteRequest">
               <h3>
                  http2traceWroteRequest 
                  <span class="badge">function</span>
                  
                  <a href="#http2traceWroteRequest" class="anchor" title="Link to http2traceWroteRequest">#</a>
               </h3>
               
               <pre><code>func http2traceWroteRequest(trace *httptrace.ClientTrace, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2typeFrameParser" data-name="http2typeFrameParser">
               <h3>
                  http2typeFrameParser 
                  <span class="badge">function</span>
                  
                  <a href="#http2typeFrameParser" class="anchor" title="Link to http2typeFrameParser">#</a>
               </h3>
               
               <pre><code>func http2typeFrameParser(t http2FrameType) http2frameParser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2unencryptedNetConnFromTLSConn" data-name="http2unencryptedNetConnFromTLSConn">
               <h3>
                  http2unencryptedNetConnFromTLSConn 
                  <span class="badge">function</span>
                  
                  <a href="#http2unencryptedNetConnFromTLSConn" class="anchor" title="Link to http2unencryptedNetConnFromTLSConn">#</a>
               </h3>
               
               <p>unencryptedNetConnFromTLSConn retrieves a net.Conn wrapped in a *tls.Conn.
TLSNextProto functions accept a *tls.Conn.
When passing an unencrypted HTTP/2 connection to a TLSNextProto function,
we pass a *tls.Conn with an underlying net.Conn containing the unencrypted connection.
To be extra careful about mistakes (accidentally dropping TLS encryption in a place
where we want it), the tls.Conn contains a net.Conn with an UnencryptedNetConn method
that returns the actual connection we want to use.</p>
               
               <pre><code>func http2unencryptedNetConnFromTLSConn(tc *tls.Conn) (net.Conn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2validPseudoPath" data-name="http2validPseudoPath">
               <h3>
                  http2validPseudoPath 
                  <span class="badge">function</span>
                  
                  <a href="#http2validPseudoPath" class="anchor" title="Link to http2validPseudoPath">#</a>
               </h3>
               
               <p>validPseudoPath reports whether v is a valid :path pseudo-header
value. It must be either:
- a non-empty string starting with '/'
- the string '*', for OPTIONS requests.
For now this is only used a quick check for deciding when to clean
up Opaque URLs before sending requests from the Transport.
See golang.org/issue/16847
We used to enforce that the path also didn't start with "//", but
Google's GFE accepts such paths and Chrome sends them, so ignore
that part of the spec. See golang.org/issue/19103.</p>
               
               <pre><code>func http2validPseudoPath(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2validStreamID" data-name="http2validStreamID">
               <h3>
                  http2validStreamID 
                  <span class="badge">function</span>
                  
                  <a href="#http2validStreamID" class="anchor" title="Link to http2validStreamID">#</a>
               </h3>
               
               <pre><code>func http2validStreamID(streamID uint32) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2validStreamIDOrZero" data-name="http2validStreamIDOrZero">
               <h3>
                  http2validStreamIDOrZero 
                  <span class="badge">function</span>
                  
                  <a href="#http2validStreamIDOrZero" class="anchor" title="Link to http2validStreamIDOrZero">#</a>
               </h3>
               
               <pre><code>func http2validStreamIDOrZero(streamID uint32) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2validWireHeaderFieldName" data-name="http2validWireHeaderFieldName">
               <h3>
                  http2validWireHeaderFieldName 
                  <span class="badge">function</span>
                  
                  <a href="#http2validWireHeaderFieldName" class="anchor" title="Link to http2validWireHeaderFieldName">#</a>
               </h3>
               
               <p>validWireHeaderFieldName reports whether v is a valid header field
name (key). See httpguts.ValidHeaderName for the base rules.
Further, http2 says:
"Just as in HTTP/1.x, header field names are strings of ASCII
characters that are compared in a case-insensitive
fashion. However, header field names MUST be converted to
lowercase prior to their encoding in HTTP/2. "</p>
               
               <pre><code>func http2validWireHeaderFieldName(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2validateHeaders" data-name="http2validateHeaders">
               <h3>
                  http2validateHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#http2validateHeaders" class="anchor" title="Link to http2validateHeaders">#</a>
               </h3>
               
               <pre><code>func http2validateHeaders(hdrs Header) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2writeEndsStream" data-name="http2writeEndsStream">
               <h3>
                  http2writeEndsStream 
                  <span class="badge">function</span>
                  
                  <a href="#http2writeEndsStream" class="anchor" title="Link to http2writeEndsStream">#</a>
               </h3>
               
               <p>writeEndsStream reports whether w writes a frame that will transition
the stream to a half-closed local state. This returns false for RST_STREAM,
which closes the entire stream (not just the local half).</p>
               
               <pre><code>func http2writeEndsStream(w http2writeFramer) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="http2writeWithByteTimeout" data-name="http2writeWithByteTimeout">
               <h3>
                  http2writeWithByteTimeout 
                  <span class="badge">function</span>
                  
                  <a href="#http2writeWithByteTimeout" class="anchor" title="Link to http2writeWithByteTimeout">#</a>
               </h3>
               
               <p>writeWithByteTimeout writes to conn.
If more than timeout passes without any bytes being written to the connection,
the write fails.</p>
               
               <pre><code>func http2writeWithByteTimeout(group http2synctestGroupInterface, conn net.Conn, timeout time.Duration, p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idleConnTimeout" data-name="idleConnTimeout">
               <h3>
                  idleConnTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idleConnTimeout" class="anchor" title="Link to idleConnTimeout">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) idleConnTimeout() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idleState" data-name="idleState">
               <h3>
                  idleState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idleState" class="anchor" title="Link to idleState">#</a>
               </h3>
               
               <pre><code>func (cc *http2clientConn) idleState() http2clientConnIdleState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idleState" data-name="idleState">
               <h3>
                  idleState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idleState" class="anchor" title="Link to idleState">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) idleState() http2clientConnIdleState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idleStateLocked" data-name="idleStateLocked">
               <h3>
                  idleStateLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idleStateLocked" class="anchor" title="Link to idleStateLocked">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) idleStateLocked() (st http2clientConnIdleState)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idleTimeout" data-name="idleTimeout">
               <h3>
                  idleTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idleTimeout" class="anchor" title="Link to idleTimeout">#</a>
               </h3>
               
               <pre><code>func (s *Server) idleTimeout() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idnaASCII" data-name="idnaASCII">
               <h3>
                  idnaASCII 
                  <span class="badge">function</span>
                  
                  <a href="#idnaASCII" class="anchor" title="Link to idnaASCII">#</a>
               </h3>
               
               <pre><code>func idnaASCII(v string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idnaASCIIFromURL" data-name="idnaASCIIFromURL">
               <h3>
                  idnaASCIIFromURL 
                  <span class="badge">function</span>
                  
                  <a href="#idnaASCIIFromURL" class="anchor" title="Link to idnaASCIIFromURL">#</a>
               </h3>
               
               <pre><code>func idnaASCIIFromURL(url *url.URL) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>Read httpmuxgo121 once at startup, since dealing with changes to it during
program execution is too complex and error-prone.</p>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>init sets the initial window.</p>
               
               <pre><code>func (f *http2inflow) init(n int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initConnPool" data-name="initConnPool">
               <h3>
                  initConnPool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initConnPool" class="anchor" title="Link to initConnPool">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) initConnPool()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initialReadLimitSize" data-name="initialReadLimitSize">
               <h3>
                  initialReadLimitSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initialReadLimitSize" class="anchor" title="Link to initialReadLimitSize">#</a>
               </h3>
               
               <pre><code>func (s *Server) initialReadLimitSize() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="invalidate" data-name="invalidate">
               <h3>
                  invalidate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#invalidate" class="anchor" title="Link to invalidate">#</a>
               </h3>
               
               <pre><code>func (h *http2FrameHeader) invalidate()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inverseRelationship" data-name="inverseRelationship">
               <h3>
                  inverseRelationship 
                  <span class="badge">function</span>
                  
                  <a href="#inverseRelationship" class="anchor" title="Link to inverseRelationship">#</a>
               </h3>
               
               <p>If p1 has relationship `r` to p2, then
p2 has inverseRelationship(r) to p1.</p>
               
               <pre><code>func inverseRelationship(r relationship) relationship</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="is408Message" data-name="is408Message">
               <h3>
                  is408Message 
                  <span class="badge">function</span>
                  
                  <a href="#is408Message" class="anchor" title="Link to is408Message">#</a>
               </h3>
               
               <p>is408Message reports whether buf has the prefix of an
HTTP 408 Request Timeout response.
See golang.org/issue/32310.</p>
               
               <pre><code>func is408Message(buf []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBroken" data-name="isBroken">
               <h3>
                  isBroken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isBroken" class="anchor" title="Link to isBroken">#</a>
               </h3>
               
               <p>isBroken reports whether this connection is in a known broken state.</p>
               
               <pre><code>func (pc *persistConn) isBroken() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCommonNetReadError" data-name="isCommonNetReadError">
               <h3>
                  isCommonNetReadError 
                  <span class="badge">function</span>
                  
                  <a href="#isCommonNetReadError" class="anchor" title="Link to isCommonNetReadError">#</a>
               </h3>
               
               <p>isCommonNetReadError reports whether err is a common error
encountered during reading a request off the network when the
client has gone away or had its read fail somehow. This is used to
determine which logs are interesting enough to log about.</p>
               
               <pre><code>func isCommonNetReadError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isControl" data-name="isControl">
               <h3>
                  isControl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isControl" class="anchor" title="Link to isControl">#</a>
               </h3>
               
               <p>isControl reports whether wr is a control frame for MaxQueuedControlFrames
purposes. That includes non-stream frames and RST_STREAM frames.</p>
               
               <pre><code>func (wr http2FrameWriteRequest) isControl() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCookieDomainName" data-name="isCookieDomainName">
               <h3>
                  isCookieDomainName 
                  <span class="badge">function</span>
                  
                  <a href="#isCookieDomainName" class="anchor" title="Link to isCookieDomainName">#</a>
               </h3>
               
               <p>isCookieDomainName reports whether s is a valid domain name or a valid
domain name with a leading dot '.'.  It is almost a direct copy of
package net's isDomainName.</p>
               
               <pre><code>func isCookieDomainName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCookieNameValid" data-name="isCookieNameValid">
               <h3>
                  isCookieNameValid 
                  <span class="badge">function</span>
                  
                  <a href="#isCookieNameValid" class="anchor" title="Link to isCookieNameValid">#</a>
               </h3>
               
               <pre><code>func isCookieNameValid(raw string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDir" data-name="isDir">
               <h3>
                  isDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDir" class="anchor" title="Link to isDir">#</a>
               </h3>
               
               <pre><code>func (d dirEntryDirs) isDir(i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDir" data-name="isDir">
               <h3>
                  isDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDir" class="anchor" title="Link to isDir">#</a>
               </h3>
               
               <pre><code>func (d fileInfoDirs) isDir(i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDoNotReuseAndIdle" data-name="isDoNotReuseAndIdle">
               <h3>
                  isDoNotReuseAndIdle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDoNotReuseAndIdle" class="anchor" title="Link to isDoNotReuseAndIdle">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) isDoNotReuseAndIdle() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDomainOrSubdomain" data-name="isDomainOrSubdomain">
               <h3>
                  isDomainOrSubdomain 
                  <span class="badge">function</span>
                  
                  <a href="#isDomainOrSubdomain" class="anchor" title="Link to isDomainOrSubdomain">#</a>
               </h3>
               
               <p>isDomainOrSubdomain reports whether sub is a subdomain (or exact
match) of the parent domain.
Both domains must already be in canonical form.</p>
               
               <pre><code>func isDomainOrSubdomain(sub string, parent string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isH2Upgrade" data-name="isH2Upgrade">
               <h3>
                  isH2Upgrade 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isH2Upgrade" class="anchor" title="Link to isH2Upgrade">#</a>
               </h3>
               
               <p>isH2Upgrade reports whether r represents the http2 "client preface"
magic string.</p>
               
               <pre><code>func (r *Request) isH2Upgrade() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIdentity" data-name="isIdentity">
               <h3>
                  isIdentity 
                  <span class="badge">function</span>
                  
                  <a href="#isIdentity" class="anchor" title="Link to isIdentity">#</a>
               </h3>
               
               <p>Checks whether the encoding is explicitly "identity".</p>
               
               <pre><code>func isIdentity(te []string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isKnownInMemoryReader" data-name="isKnownInMemoryReader">
               <h3>
                  isKnownInMemoryReader 
                  <span class="badge">function</span>
                  
                  <a href="#isKnownInMemoryReader" class="anchor" title="Link to isKnownInMemoryReader">#</a>
               </h3>
               
               <p>isKnownInMemoryReader reports whether r is a type known to not
block on Read. Its caller uses this as an optional optimization to
send fewer TCP packets.</p>
               
               <pre><code>func isKnownInMemoryReader(r io.Reader) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isLitOrSingle" data-name="isLitOrSingle">
               <h3>
                  isLitOrSingle 
                  <span class="badge">function</span>
                  
                  <a href="#isLitOrSingle" class="anchor" title="Link to isLitOrSingle">#</a>
               </h3>
               
               <p>isLitOrSingle reports whether the segment is a non-dollar literal or a single wildcard.</p>
               
               <pre><code>func isLitOrSingle(seg segment) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNotToken" data-name="isNotToken">
               <h3>
                  isNotToken 
                  <span class="badge">function</span>
                  
                  <a href="#isNotToken" class="anchor" title="Link to isNotToken">#</a>
               </h3>
               
               <pre><code>func isNotToken(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isProtocolSwitch" data-name="isProtocolSwitch">
               <h3>
                  isProtocolSwitch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isProtocolSwitch" class="anchor" title="Link to isProtocolSwitch">#</a>
               </h3>
               
               <p>isProtocolSwitch reports whether the response code and header
indicate a successful protocol upgrade response.</p>
               
               <pre><code>func (r *Response) isProtocolSwitch() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isProtocolSwitchHeader" data-name="isProtocolSwitchHeader">
               <h3>
                  isProtocolSwitchHeader 
                  <span class="badge">function</span>
                  
                  <a href="#isProtocolSwitchHeader" class="anchor" title="Link to isProtocolSwitchHeader">#</a>
               </h3>
               
               <p>isProtocolSwitchHeader reports whether the request or response header
is for a protocol switch.</p>
               
               <pre><code>func isProtocolSwitchHeader(h Header) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isProtocolSwitchResponse" data-name="isProtocolSwitchResponse">
               <h3>
                  isProtocolSwitchResponse 
                  <span class="badge">function</span>
                  
                  <a href="#isProtocolSwitchResponse" class="anchor" title="Link to isProtocolSwitchResponse">#</a>
               </h3>
               
               <p>isProtocolSwitchResponse reports whether the response code and
response header indicate a successful protocol upgrade response.</p>
               
               <pre><code>func isProtocolSwitchResponse(code int, h Header) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPushed" data-name="isPushed">
               <h3>
                  isPushed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isPushed" class="anchor" title="Link to isPushed">#</a>
               </h3>
               
               <p>isPushed reports whether the stream is server-initiated.</p>
               
               <pre><code>func (st *http2stream) isPushed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isReplayable" data-name="isReplayable">
               <h3>
                  isReplayable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isReplayable" class="anchor" title="Link to isReplayable">#</a>
               </h3>
               
               <pre><code>func (r *Request) isReplayable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isReused" data-name="isReused">
               <h3>
                  isReused 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isReused" class="anchor" title="Link to isReused">#</a>
               </h3>
               
               <p>isReused reports whether this connection has been used before.</p>
               
               <pre><code>func (pc *persistConn) isReused() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSlashRune" data-name="isSlashRune">
               <h3>
                  isSlashRune 
                  <span class="badge">function</span>
                  
                  <a href="#isSlashRune" class="anchor" title="Link to isSlashRune">#</a>
               </h3>
               
               <pre><code>func isSlashRune(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTT" data-name="isTT">
               <h3>
                  isTT 
                  <span class="badge">function</span>
                  
                  <a href="#isTT" class="anchor" title="Link to isTT">#</a>
               </h3>
               
               <p>isTT reports whether the provided byte is a tag-terminating byte (0xTT)
as defined in https://mimesniff.spec.whatwg.org/#terminology.</p>
               
               <pre><code>func isTT(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTokenBoundary" data-name="isTokenBoundary">
               <h3>
                  isTokenBoundary 
                  <span class="badge">function</span>
                  
                  <a href="#isTokenBoundary" class="anchor" title="Link to isTokenBoundary">#</a>
               </h3>
               
               <pre><code>func isTokenBoundary(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUnsupportedTEError" data-name="isUnsupportedTEError">
               <h3>
                  isUnsupportedTEError 
                  <span class="badge">function</span>
                  
                  <a href="#isUnsupportedTEError" class="anchor" title="Link to isUnsupportedTEError">#</a>
               </h3>
               
               <p>isUnsupportedTEError checks if the error is of type
unsupportedTEError. It is usually invoked with a non-nil err.</p>
               
               <pre><code>func isUnsupportedTEError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidWildcardName" data-name="isValidWildcardName">
               <h3>
                  isValidWildcardName 
                  <span class="badge">function</span>
                  
                  <a href="#isValidWildcardName" class="anchor" title="Link to isValidWildcardName">#</a>
               </h3>
               
               <pre><code>func isValidWildcardName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isWS" data-name="isWS">
               <h3>
                  isWS 
                  <span class="badge">function</span>
                  
                  <a href="#isWS" class="anchor" title="Link to isWS">#</a>
               </h3>
               
               <p>isWS reports whether the provided byte is a whitespace byte (0xWS)
as defined in https://mimesniff.spec.whatwg.org/#terminology.</p>
               
               <pre><code>func isWS(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isZeroTime" data-name="isZeroTime">
               <h3>
                  isZeroTime 
                  <span class="badge">function</span>
                  
                  <a href="#isZeroTime" class="anchor" title="Link to isZeroTime">#</a>
               </h3>
               
               <p>isZeroTime reports whether t is obviously unspecified (either zero or Unix()=0).</p>
               
               <pre><code>func isZeroTime(t time.Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="key" data-name="key">
               <h3>
                  key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#key" class="anchor" title="Link to key">#</a>
               </h3>
               
               <pre><code>func (cm *connectMethod) key() connectMethodKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="knownRoundTripperImpl" data-name="knownRoundTripperImpl">
               <h3>
                  knownRoundTripperImpl 
                  <span class="badge">function</span>
                  
                  <a href="#knownRoundTripperImpl" class="anchor" title="Link to knownRoundTripperImpl">#</a>
               </h3>
               
               <p>knownRoundTripperImpl reports whether rt is a RoundTripper that's
maintained by the Go team and known to implement the latest
optional semantics (notably contexts). The Request is used
to check whether this particular request is using an alternate protocol,
in which case we need to check the RoundTripper for that protocol.</p>
               
               <pre><code>func knownRoundTripperImpl(rt RoundTripper, req *Request) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastChunkOrAlloc" data-name="lastChunkOrAlloc">
               <h3>
                  lastChunkOrAlloc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lastChunkOrAlloc" class="anchor" title="Link to lastChunkOrAlloc">#</a>
               </h3>
               
               <pre><code>func (b *http2dataBuffer) lastChunkOrAlloc(want int64) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastSegment" data-name="lastSegment">
               <h3>
                  lastSegment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lastSegment" class="anchor" title="Link to lastSegment">#</a>
               </h3>
               
               <pre><code>func (p *pattern) lastSegment() segment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <p>len returns the number of items in the queue.</p>
               
               <pre><code>func (q *wantConnQueue) len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <pre><code>func (d fileInfoDirs) len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <pre><code>func (d dirEntryDirs) len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <p>len returns the number of items in the cache.</p>
               
               <pre><code>func (cl *connLRU) len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="localRedirect" data-name="localRedirect">
               <h3>
                  localRedirect 
                  <span class="badge">function</span>
                  
                  <a href="#localRedirect" class="anchor" title="Link to localRedirect">#</a>
               </h3>
               
               <p>localRedirect gives a Moved Permanently response.
It does not convert relative paths to absolute paths like Redirect does.</p>
               
               <pre><code>func localRedirect(w ResponseWriter, r *Request, newPath string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lock" data-name="lock">
               <h3>
                  lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lock" class="anchor" title="Link to lock">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logWrite" data-name="logWrite">
               <h3>
                  logWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logWrite" class="anchor" title="Link to logWrite">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) logWrite()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logf" data-name="logf">
               <h3>
                  logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logf" class="anchor" title="Link to logf">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logf" data-name="logf">
               <h3>
                  logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logf" class="anchor" title="Link to logf">#</a>
               </h3>
               
               <pre><code>func (tr *transportRequest) logf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logf" data-name="logf">
               <h3>
                  logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logf" class="anchor" title="Link to logf">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logf" data-name="logf">
               <h3>
                  logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logf" class="anchor" title="Link to logf">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logf" data-name="logf">
               <h3>
                  logf 
                  <span class="badge">function</span>
                  
                  <a href="#logf" class="anchor" title="Link to logf">#</a>
               </h3>
               
               <p>logf prints to the ErrorLog of the *Server associated with request r
via ServerContextKey. If there's no associated server, or if ErrorLog
is nil, logging is done via the log package's standard logger.</p>
               
               <pre><code>func logf(r *Request, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logf" data-name="logf">
               <h3>
                  logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logf" class="anchor" title="Link to logf">#</a>
               </h3>
               
               <pre><code>func (s *Server) logf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeHeadersCopier" data-name="makeHeadersCopier">
               <h3>
                  makeHeadersCopier 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeHeadersCopier" class="anchor" title="Link to makeHeadersCopier">#</a>
               </h3>
               
               <p>makeHeadersCopier makes a function that copies headers from the
initial Request, ireq. For every redirect, this function must be called
so that it can copy headers into the upcoming Request.</p>
               
               <pre><code>func (c *Client) makeHeadersCopier(ireq *Request) (func(req *Request, stripSensitiveHeaders bool))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapOpenError" data-name="mapOpenError">
               <h3>
                  mapOpenError 
                  <span class="badge">function</span>
                  
                  <a href="#mapOpenError" class="anchor" title="Link to mapOpenError">#</a>
               </h3>
               
               <p>mapOpenError maps the provided non-nil error from opening name
to a possibly better non-nil error. In particular, it turns OS-specific errors
about opening files in non-directories into fs.ErrNotExist. See Issues 18984 and 49552.</p>
               
               <pre><code>func mapOpenError(originalErr error, name string, sep rune, stat func(string) (fs.FileInfo, error)) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapRoundTripError" data-name="mapRoundTripError">
               <h3>
                  mapRoundTripError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mapRoundTripError" class="anchor" title="Link to mapRoundTripError">#</a>
               </h3>
               
               <p>mapRoundTripError returns the appropriate error value for
persistConn.roundTrip.
The provided err is the first error that (*persistConn).roundTrip
happened to receive from its select statement.
The startBytesWritten value should be the value of pc.nwrite before the roundTrip
started writing the request.</p>
               
               <pre><code>func (pc *persistConn) mapRoundTripError(req *transportRequest, startBytesWritten int64, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markNewGoroutine" data-name="markNewGoroutine">
               <h3>
                  markNewGoroutine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markNewGoroutine" class="anchor" title="Link to markNewGoroutine">#</a>
               </h3>
               
               <pre><code>func (s *http2Server) markNewGoroutine()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markNewGoroutine" data-name="markNewGoroutine">
               <h3>
                  markNewGoroutine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markNewGoroutine" class="anchor" title="Link to markNewGoroutine">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) markNewGoroutine()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markReused" data-name="markReused">
               <h3>
                  markReused 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markReused" class="anchor" title="Link to markReused">#</a>
               </h3>
               
               <p>markReused marks this connection as having been successfully used for a
request and response.</p>
               
               <pre><code>func (pc *persistConn) markReused()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>match returns the leaf node under root that matches the arguments, and a list
of values for pattern wildcards in the order that the wildcards appear.
For example, if the request path is "/a/b/c" and the pattern is "/{x}/b/{y}",
then the second return value will be []string{"a", "c"}.</p>
               
               <pre><code>func (root *routingNode) match(host string, method string, path string) (*routingNode, []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code>func (textSig) match(data []byte, firstNonWS int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code>func (h htmlSig) match(data []byte, firstNonWS int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code>func (e *exactSig) match(data []byte, firstNonWS int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code>func (mp4Sig) match(data []byte, firstNonWS int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code>func (m *maskedSig) match(data []byte, firstNonWS int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>Find a handler on a handler map given a path string.
Most-specific (longest) pattern wins.</p>
               
               <pre><code>func (mux *serveMux121) match(path string) (h Handler, pattern string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchMethodAndPath" data-name="matchMethodAndPath">
               <h3>
                  matchMethodAndPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchMethodAndPath" class="anchor" title="Link to matchMethodAndPath">#</a>
               </h3>
               
               <p>matchMethodAndPath matches the method and path.
Its return values are the same as [routingNode.match].
The receiver should be a child of the root.</p>
               
               <pre><code>func (n *routingNode) matchMethodAndPath(method string, path string) (*routingNode, []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchOrRedirect" data-name="matchOrRedirect">
               <h3>
                  matchOrRedirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchOrRedirect" class="anchor" title="Link to matchOrRedirect">#</a>
               </h3>
               
               <p>matchOrRedirect looks up a node in the tree that matches the host, method and path.
If the url argument is non-nil, handler also deals with trailing-slash
redirection: when a path doesn't match exactly, the match is tried again
after appending "/" to the path. If that second match succeeds, the last
return value is the URL to redirect to.</p>
               
               <pre><code>func (mux *ServeMux) matchOrRedirect(host string, method string, path string, u *url.URL) (_ *routingNode, matches []string, redirectTo *url.URL)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchPath" data-name="matchPath">
               <h3>
                  matchPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchPath" class="anchor" title="Link to matchPath">#</a>
               </h3>
               
               <p>matchPath matches a path.
Its return values are the same as [routingNode.match].
matchPath calls itself recursively. The matches argument holds the wildcard matches
found so far.</p>
               
               <pre><code>func (n *routingNode) matchPath(path string, matches []string) (*routingNode, []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchingMethods" data-name="matchingMethods">
               <h3>
                  matchingMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchingMethods" class="anchor" title="Link to matchingMethods">#</a>
               </h3>
               
               <p>matchingMethods adds to methodSet all the methods that would result in a
match if passed to routingNode.match with the given host and path.</p>
               
               <pre><code>func (root *routingNode) matchingMethods(host string, path string, methodSet map[string]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchingMethods" data-name="matchingMethods">
               <h3>
                  matchingMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchingMethods" class="anchor" title="Link to matchingMethods">#</a>
               </h3>
               
               <p>matchingMethods return a sorted list of all methods that would match with the given host and path.</p>
               
               <pre><code>func (mux *ServeMux) matchingMethods(host string, path string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchingMethodsPath" data-name="matchingMethodsPath">
               <h3>
                  matchingMethodsPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchingMethodsPath" class="anchor" title="Link to matchingMethodsPath">#</a>
               </h3>
               
               <pre><code>func (n *routingNode) matchingMethodsPath(path string, set map[string]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxHeaderBytes" data-name="maxHeaderBytes">
               <h3>
                  maxHeaderBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxHeaderBytes" class="anchor" title="Link to maxHeaderBytes">#</a>
               </h3>
               
               <pre><code>func (s *Server) maxHeaderBytes() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxHeaderListSize" data-name="maxHeaderListSize">
               <h3>
                  maxHeaderListSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxHeaderListSize" class="anchor" title="Link to maxHeaderListSize">#</a>
               </h3>
               
               <pre><code>func (fr *http2Framer) maxHeaderListSize() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxHeaderListSize" data-name="maxHeaderListSize">
               <h3>
                  maxHeaderListSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxHeaderListSize" class="anchor" title="Link to maxHeaderListSize">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) maxHeaderListSize() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxHeaderListSize" data-name="maxHeaderListSize">
               <h3>
                  maxHeaderListSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxHeaderListSize" class="anchor" title="Link to maxHeaderListSize">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) maxHeaderListSize() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxHeaderResponseSize" data-name="maxHeaderResponseSize">
               <h3>
                  maxHeaderResponseSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxHeaderResponseSize" class="anchor" title="Link to maxHeaderResponseSize">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) maxHeaderResponseSize() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxHeaderStringLen" data-name="maxHeaderStringLen">
               <h3>
                  maxHeaderStringLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxHeaderStringLen" class="anchor" title="Link to maxHeaderStringLen">#</a>
               </h3>
               
               <pre><code>func (fr *http2Framer) maxHeaderStringLen() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxIdleConnsPerHost" data-name="maxIdleConnsPerHost">
               <h3>
                  maxIdleConnsPerHost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxIdleConnsPerHost" class="anchor" title="Link to maxIdleConnsPerHost">#</a>
               </h3>
               
               <pre><code>func (t *Transport) maxIdleConnsPerHost() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeServeUnencryptedHTTP2" data-name="maybeServeUnencryptedHTTP2">
               <h3>
                  maybeServeUnencryptedHTTP2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybeServeUnencryptedHTTP2" class="anchor" title="Link to maybeServeUnencryptedHTTP2">#</a>
               </h3>
               
               <pre><code>func (c *conn) maybeServeUnencryptedHTTP2(ctx context.Context) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeSetHeader" data-name="mergeSetHeader">
               <h3>
                  mergeSetHeader 
                  <span class="badge">function</span>
                  
                  <a href="#mergeSetHeader" class="anchor" title="Link to mergeSetHeader">#</a>
               </h3>
               
               <pre><code>func mergeSetHeader(dst *Header, src Header)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mimeHeader" data-name="mimeHeader">
               <h3>
                  mimeHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mimeHeader" class="anchor" title="Link to mimeHeader">#</a>
               </h3>
               
               <pre><code>func (r httpRange) mimeHeader(contentType string, size int64) textproto.MIMEHeader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multipartReader" data-name="multipartReader">
               <h3>
                  multipartReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#multipartReader" class="anchor" title="Link to multipartReader">#</a>
               </h3>
               
               <pre><code>func (r *Request) multipartReader(allowMixed bool) (*multipart.Reader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <pre><code>func (d dirEntryDirs) name(i int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <pre><code>func (d fileInfoDirs) name(i int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newBufioReader" data-name="newBufioReader">
               <h3>
                  newBufioReader 
                  <span class="badge">function</span>
                  
                  <a href="#newBufioReader" class="anchor" title="Link to newBufioReader">#</a>
               </h3>
               
               <p>newBufioReader should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/gobwas/ws
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname newBufioReader</p>
               
               <pre><code>func newBufioReader(r io.Reader) *bufio.Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newBufioWriterSize" data-name="newBufioWriterSize">
               <h3>
                  newBufioWriterSize 
                  <span class="badge">function</span>
                  
                  <a href="#newBufioWriterSize" class="anchor" title="Link to newBufioWriterSize">#</a>
               </h3>
               
               <p>newBufioWriterSize should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/gobwas/ws
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname newBufioWriterSize</p>
               
               <pre><code>func newBufioWriterSize(w io.Writer, size int) *bufio.Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newClientConn" data-name="newClientConn">
               <h3>
                  newClientConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newClientConn" class="anchor" title="Link to newClientConn">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2ClientConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newConn" data-name="newConn">
               <h3>
                  newConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newConn" class="anchor" title="Link to newConn">#</a>
               </h3>
               
               <p>Create new connection from rwc.</p>
               
               <pre><code>func (s *Server) newConn(rwc net.Conn) *conn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newLoggingConn" data-name="newLoggingConn">
               <h3>
                  newLoggingConn 
                  <span class="badge">function</span>
                  
                  <a href="#newLoggingConn" class="anchor" title="Link to newLoggingConn">#</a>
               </h3>
               
               <pre><code>func newLoggingConn(baseName string, c net.Conn) net.Conn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPopulateResponseWriter" data-name="newPopulateResponseWriter">
               <h3>
                  newPopulateResponseWriter 
                  <span class="badge">function</span>
                  
                  <a href="#newPopulateResponseWriter" class="anchor" title="Link to newPopulateResponseWriter">#</a>
               </h3>
               
               <pre><code>func newPopulateResponseWriter() (*populateResponse, <-chan *Response)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newReadWriteCloserBody" data-name="newReadWriteCloserBody">
               <h3>
                  newReadWriteCloserBody 
                  <span class="badge">function</span>
                  
                  <a href="#newReadWriteCloserBody" class="anchor" title="Link to newReadWriteCloserBody">#</a>
               </h3>
               
               <pre><code>func newReadWriteCloserBody(br *bufio.Reader, rwc io.ReadWriteCloser) io.ReadWriteCloser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newResponseWriter" data-name="newResponseWriter">
               <h3>
                  newResponseWriter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newResponseWriter" class="anchor" title="Link to newResponseWriter">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) newResponseWriter(st *http2stream, req *Request) *http2responseWriter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newStream" data-name="newStream">
               <h3>
                  newStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newStream" class="anchor" title="Link to newStream">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) newStream(id uint32, pusherID uint32, state http2streamState) *http2stream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTLSConfig" data-name="newTLSConfig">
               <h3>
                  newTLSConfig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newTLSConfig" class="anchor" title="Link to newTLSConfig">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) newTLSConfig(host string) *tls.Config</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTextprotoReader" data-name="newTextprotoReader">
               <h3>
                  newTextprotoReader 
                  <span class="badge">function</span>
                  
                  <a href="#newTextprotoReader" class="anchor" title="Link to newTextprotoReader">#</a>
               </h3>
               
               <pre><code>func newTextprotoReader(br *bufio.Reader) *textproto.Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTimer" data-name="newTimer">
               <h3>
                  newTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newTimer" class="anchor" title="Link to newTimer">#</a>
               </h3>
               
               <p>newTimer creates a new time.Timer, or a synthetic timer in tests.</p>
               
               <pre><code>func (s *http2Server) newTimer(d time.Duration) http2timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTimer" data-name="newTimer">
               <h3>
                  newTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newTimer" class="anchor" title="Link to newTimer">#</a>
               </h3>
               
               <p>newTimer creates a new time.Timer, or a synthetic timer in tests.</p>
               
               <pre><code>func (t *http2Transport) newTimer(d time.Duration) http2timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTransferWriter" data-name="newTransferWriter">
               <h3>
                  newTransferWriter 
                  <span class="badge">function</span>
                  
                  <a href="#newTransferWriter" class="anchor" title="Link to newTransferWriter">#</a>
               </h3>
               
               <pre><code>func newTransferWriter(r any) (t *transferWriter, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWriterAndRequest" data-name="newWriterAndRequest">
               <h3>
                  newWriterAndRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newWriterAndRequest" class="anchor" title="Link to newWriterAndRequest">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHeadersFrame) (*http2responseWriter, *Request, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWriterAndRequestNoBody" data-name="newWriterAndRequestNoBody">
               <h3>
                  newWriterAndRequestNoBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newWriterAndRequestNoBody" class="anchor" title="Link to newWriterAndRequestNoBody">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2requestParam) (*http2responseWriter, *Request, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noResponseBodyExpected" data-name="noResponseBodyExpected">
               <h3>
                  noResponseBodyExpected 
                  <span class="badge">function</span>
                  
                  <a href="#noResponseBodyExpected" class="anchor" title="Link to noResponseBodyExpected">#</a>
               </h3>
               
               <pre><code>func noResponseBodyExpected(requestMethod string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nop" data-name="nop">
               <h3>
                  nop 
                  <span class="badge">function</span>
                  
                  <a href="#nop" class="anchor" title="Link to nop">#</a>
               </h3>
               
               <pre><code>func nop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noteBodyRead" data-name="noteBodyRead">
               <h3>
                  noteBodyRead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#noteBodyRead" class="anchor" title="Link to noteBodyRead">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) noteBodyRead(st *http2stream, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noteBodyReadFromHandler" data-name="noteBodyReadFromHandler">
               <h3>
                  noteBodyReadFromHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#noteBodyReadFromHandler" class="anchor" title="Link to noteBodyReadFromHandler">#</a>
               </h3>
               
               <p>called from handler goroutines.
Notes that the handler for the given stream ID read n bytes of its body
and schedules flow control tokens to be sent.</p>
               
               <pre><code>func (sc *http2serverConn) noteBodyReadFromHandler(st *http2stream, n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="notePanic" data-name="notePanic">
               <h3>
                  notePanic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#notePanic" class="anchor" title="Link to notePanic">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) notePanic()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="now" data-name="now">
               <h3>
                  now 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#now" class="anchor" title="Link to now">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) now() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="now" data-name="now">
               <h3>
                  now 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#now" class="anchor" title="Link to now">#</a>
               </h3>
               
               <pre><code>func (s *http2Server) now() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="numLeadingCRorLF" data-name="numLeadingCRorLF">
               <h3>
                  numLeadingCRorLF 
                  <span class="badge">function</span>
                  
                  <a href="#numLeadingCRorLF" class="anchor" title="Link to numLeadingCRorLF">#</a>
               </h3>
               
               <pre><code>func numLeadingCRorLF(v []byte) (n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onIdleTimeout" data-name="onIdleTimeout">
               <h3>
                  onIdleTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onIdleTimeout" class="anchor" title="Link to onIdleTimeout">#</a>
               </h3>
               
               <p>onIdleTimeout is called from a time.AfterFunc goroutine. It will
only be called when we're idle, but because we're coming from a new
goroutine, there could be a new request coming in at the same time,
so this simply calls the synchronized closeIfIdle to shut down this
connection. The timer could just call closeIfIdle, but this is more
clear.</p>
               
               <pre><code>func (cc *http2ClientConn) onIdleTimeout()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onIdleTimer" data-name="onIdleTimer">
               <h3>
                  onIdleTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onIdleTimer" class="anchor" title="Link to onIdleTimer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) onIdleTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onReadIdleTimer" data-name="onReadIdleTimer">
               <h3>
                  onReadIdleTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onReadIdleTimer" class="anchor" title="Link to onReadIdleTimer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) onReadIdleTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onReadTimeout" data-name="onReadTimeout">
               <h3>
                  onReadTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onReadTimeout" class="anchor" title="Link to onReadTimeout">#</a>
               </h3>
               
               <p>onReadTimeout is run on its own goroutine (from time.AfterFunc)
when the stream's ReadTimeout has fired.</p>
               
               <pre><code>func (st *http2stream) onReadTimeout()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onSettingsTimer" data-name="onSettingsTimer">
               <h3>
                  onSettingsTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onSettingsTimer" class="anchor" title="Link to onSettingsTimer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) onSettingsTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onShutdownTimer" data-name="onShutdownTimer">
               <h3>
                  onShutdownTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onShutdownTimer" class="anchor" title="Link to onShutdownTimer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) onShutdownTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onWriteTimeout" data-name="onWriteTimeout">
               <h3>
                  onWriteTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onWriteTimeout" class="anchor" title="Link to onWriteTimeout">#</a>
               </h3>
               
               <p>onWriteTimeout is run on its own goroutine (from time.AfterFunc)
when the stream's WriteTimeout has fired.</p>
               
               <pre><code>func (st *http2stream) onWriteTimeout()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onceSetNextProtoDefaults" data-name="onceSetNextProtoDefaults">
               <h3>
                  onceSetNextProtoDefaults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onceSetNextProtoDefaults" class="anchor" title="Link to onceSetNextProtoDefaults">#</a>
               </h3>
               
               <p>onceSetNextProtoDefaults initializes TLSNextProto.
It must be called via t.nextProtoOnce.Do.</p>
               
               <pre><code>func (t *Transport) onceSetNextProtoDefaults()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onceSetNextProtoDefaults" data-name="onceSetNextProtoDefaults">
               <h3>
                  onceSetNextProtoDefaults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onceSetNextProtoDefaults" class="anchor" title="Link to onceSetNextProtoDefaults">#</a>
               </h3>
               
               <p>onceSetNextProtoDefaults configures HTTP/2, if the user hasn't
configured otherwise. (by setting s.TLSNextProto non-nil)
It must only be called via s.nextProtoOnce (use s.setupHTTP2_*).</p>
               
               <pre><code>func (s *Server) onceSetNextProtoDefaults()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="onceSetNextProtoDefaults_Serve" data-name="onceSetNextProtoDefaults_Serve">
               <h3>
                  onceSetNextProtoDefaults_Serve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#onceSetNextProtoDefaults_Serve" class="anchor" title="Link to onceSetNextProtoDefaults_Serve">#</a>
               </h3>
               
               <pre><code>func (s *Server) onceSetNextProtoDefaults_Serve()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="outgoingLength" data-name="outgoingLength">
               <h3>
                  outgoingLength 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#outgoingLength" class="anchor" title="Link to outgoingLength">#</a>
               </h3>
               
               <p>outgoingLength reports the Content-Length of this outgoing (Client) request.
It maps 0 into -1 (unknown) when the Body is non-nil.</p>
               
               <pre><code>func (r *Request) outgoingLength() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseBasicAuth" data-name="parseBasicAuth">
               <h3>
                  parseBasicAuth 
                  <span class="badge">function</span>
                  
                  <a href="#parseBasicAuth" class="anchor" title="Link to parseBasicAuth">#</a>
               </h3>
               
               <p>parseBasicAuth parses an HTTP Basic Authentication string.
"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==" returns ("Aladdin", "open sesame", true).
parseBasicAuth should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/sagernet/sing
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname parseBasicAuth</p>
               
               <pre><code>func parseBasicAuth(auth string) (username string, password string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseContentLength" data-name="parseContentLength">
               <h3>
                  parseContentLength 
                  <span class="badge">function</span>
                  
                  <a href="#parseContentLength" class="anchor" title="Link to parseContentLength">#</a>
               </h3>
               
               <p>parseContentLength checks that the header is valid and then trims
whitespace. It returns -1 if no value is set otherwise the value
if it's >= 0.</p>
               
               <pre><code>func parseContentLength(clHeaders []string) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseCookieValue" data-name="parseCookieValue">
               <h3>
                  parseCookieValue 
                  <span class="badge">function</span>
                  
                  <a href="#parseCookieValue" class="anchor" title="Link to parseCookieValue">#</a>
               </h3>
               
               <p>parseCookieValue parses a cookie value according to RFC 6265.
If allowDoubleQuote is true, parseCookieValue will consider that it
is parsing the cookie-value;
otherwise, it will consider that it is parsing a cookie-av value
(cookie attribute-value).
It returns the parsed cookie value, a boolean indicating whether the
parsing was successful, and a boolean indicating whether the parsed
value was enclosed in double quotes.</p>
               
               <pre><code>func parseCookieValue(raw string, allowDoubleQuote bool) (value string, quoted bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePattern" data-name="parsePattern">
               <h3>
                  parsePattern 
                  <span class="badge">function</span>
                  
                  <a href="#parsePattern" class="anchor" title="Link to parsePattern">#</a>
               </h3>
               
               <p>parsePattern parses a string into a Pattern.
The string's syntax is
[METHOD] [HOST]/[PATH]
where:
- METHOD is an HTTP method
- HOST is a hostname
- PATH consists of slash-separated segments, where each segment is either
a literal or a wildcard of the form "{name}", "{name...}", or "{$}".
METHOD, HOST and PATH are all optional; that is, the string can be "/".
If METHOD is present, it must be followed by at least one space or tab.
Wildcard names must be valid Go identifiers.
The "{$}" and "{name...}" wildcard must occur at the end of PATH.
PATH may end with a '/'.
Wildcard names in a path must be distinct.</p>
               
               <pre><code>func parsePattern(s string) (_ *pattern, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePostForm" data-name="parsePostForm">
               <h3>
                  parsePostForm 
                  <span class="badge">function</span>
                  
                  <a href="#parsePostForm" class="anchor" title="Link to parsePostForm">#</a>
               </h3>
               
               <pre><code>func parsePostForm(r *Request) (vs url.Values, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseRange" data-name="parseRange">
               <h3>
                  parseRange 
                  <span class="badge">function</span>
                  
                  <a href="#parseRange" class="anchor" title="Link to parseRange">#</a>
               </h3>
               
               <p>parseRange parses a Range header string as per RFC 7233.
errNoOverlap is returned if none of the ranges overlap.</p>
               
               <pre><code>func parseRange(s string, size int64) ([]httpRange, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseRequestLine" data-name="parseRequestLine">
               <h3>
                  parseRequestLine 
                  <span class="badge">function</span>
                  
                  <a href="#parseRequestLine" class="anchor" title="Link to parseRequestLine">#</a>
               </h3>
               
               <p>parseRequestLine parses "GET /foo HTTP/1.1" into its three parts.</p>
               
               <pre><code>func parseRequestLine(line string) (method string, requestURI string, proto string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTransferEncoding" data-name="parseTransferEncoding">
               <h3>
                  parseTransferEncoding 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseTransferEncoding" class="anchor" title="Link to parseTransferEncoding">#</a>
               </h3>
               
               <p>parseTransferEncoding sets t.Chunked based on the Transfer-Encoding header.</p>
               
               <pre><code>func (t *transferReader) parseTransferEncoding() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="patIndex" data-name="patIndex">
               <h3>
                  patIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#patIndex" class="anchor" title="Link to patIndex">#</a>
               </h3>
               
               <p>patIndex returns the index of name in the list of named wildcards of the
request's pattern, or -1 if there is no such name.</p>
               
               <pre><code>func (r *Request) patIndex(name string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathAddrs" data-name="pathAddrs">
               <h3>
                  pathAddrs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pathAddrs" class="anchor" title="Link to pathAddrs">#</a>
               </h3>
               
               <pre><code>func (d *socksDialer) pathAddrs(address string) (proxy net.Addr, dst net.Addr, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathUnescape" data-name="pathUnescape">
               <h3>
                  pathUnescape 
                  <span class="badge">function</span>
                  
                  <a href="#pathUnescape" class="anchor" title="Link to pathUnescape">#</a>
               </h3>
               
               <pre><code>func pathUnescape(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekFront" data-name="peekFront">
               <h3>
                  peekFront 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekFront" class="anchor" title="Link to peekFront">#</a>
               </h3>
               
               <p>peekFront returns the wantConn at the front of the queue without removing it.</p>
               
               <pre><code>func (q *wantConnQueue) peekFront() *wantConn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popFront" data-name="popFront">
               <h3>
                  popFront 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popFront" class="anchor" title="Link to popFront">#</a>
               </h3>
               
               <p>popFront removes and returns the wantConn at the front of the queue.</p>
               
               <pre><code>func (q *wantConnQueue) popFront() *wantConn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="possiblyConflictingPatterns" data-name="possiblyConflictingPatterns">
               <h3>
                  possiblyConflictingPatterns 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#possiblyConflictingPatterns" class="anchor" title="Link to possiblyConflictingPatterns">#</a>
               </h3>
               
               <p>possiblyConflictingPatterns calls f on all patterns that might conflict with
pat. If f returns a non-nil error, possiblyConflictingPatterns returns immediately
with that error.
To be correct, possiblyConflictingPatterns must include all patterns that
might conflict. But it may also include patterns that cannot conflict.
For instance, an implementation that returns all registered patterns is correct.
We use this fact throughout, simplifying the implementation by returning more
patterns that we might need to.</p>
               
               <pre><code>func (idx *routingIndex) possiblyConflictingPatterns(pat *pattern, f func(*pattern) error) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prepareTransportCancel" data-name="prepareTransportCancel">
               <h3>
                  prepareTransportCancel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prepareTransportCancel" class="anchor" title="Link to prepareTransportCancel">#</a>
               </h3>
               
               <p>prepareTransportCancel sets up state to convert Transport.CancelRequest into context cancelation.</p>
               
               <pre><code>func (t *Transport) prepareTransportCancel(req *Request, origCancel context.CancelCauseFunc) context.CancelCauseFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="probeRequestBody" data-name="probeRequestBody">
               <h3>
                  probeRequestBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#probeRequestBody" class="anchor" title="Link to probeRequestBody">#</a>
               </h3>
               
               <p>probeRequestBody reads a byte from t.Body to see whether it's empty
(returns io.EOF right away).
But because we've had problems with this blocking users in the past
(issue 17480) when the body is a pipe (perhaps waiting on the response
headers before the pipe is fed data), we need to be careful and bound how
long we wait for it. This delay will only affect users if all the following
are true:
- the request body blocks
- the content length is not set (or set to -1)
- the method doesn't usually have a body (GET, HEAD, DELETE, ...)
- there is no transfer-encoding=chunked already set.
In other words, this delay will not normally affect anybody, and there
are workarounds if it does.</p>
               
               <pre><code>func (t *transferWriter) probeRequestBody()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processData" data-name="processData">
               <h3>
                  processData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processData" class="anchor" title="Link to processData">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processData" data-name="processData">
               <h3>
                  processData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processData" class="anchor" title="Link to processData">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processData(f *http2DataFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processFrame" data-name="processFrame">
               <h3>
                  processFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processFrame" class="anchor" title="Link to processFrame">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processFrame(f http2Frame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processFrameFromReader" data-name="processFrameFromReader">
               <h3>
                  processFrameFromReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processFrameFromReader" class="anchor" title="Link to processFrameFromReader">#</a>
               </h3>
               
               <p>processFrameFromReader processes the serve loop's read from readFrameCh from the
frame-reading goroutine.
processFrameFromReader returns whether the connection should be kept open.</p>
               
               <pre><code>func (sc *http2serverConn) processFrameFromReader(res http2readFrameResult) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processGoAway" data-name="processGoAway">
               <h3>
                  processGoAway 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processGoAway" class="anchor" title="Link to processGoAway">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processGoAway(f *http2GoAwayFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processGoAway" data-name="processGoAway">
               <h3>
                  processGoAway 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processGoAway" class="anchor" title="Link to processGoAway">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processGoAway(f *http2GoAwayFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processHeaders" data-name="processHeaders">
               <h3>
                  processHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processHeaders" class="anchor" title="Link to processHeaders">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processHeaders(f *http2MetaHeadersFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processHeaders" data-name="processHeaders">
               <h3>
                  processHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processHeaders" class="anchor" title="Link to processHeaders">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processPing" data-name="processPing">
               <h3>
                  processPing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processPing" class="anchor" title="Link to processPing">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processPing(f *http2PingFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processPing" data-name="processPing">
               <h3>
                  processPing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processPing" class="anchor" title="Link to processPing">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processPing(f *http2PingFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processPriority" data-name="processPriority">
               <h3>
                  processPriority 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processPriority" class="anchor" title="Link to processPriority">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processPriority(f *http2PriorityFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processPushPromise" data-name="processPushPromise">
               <h3>
                  processPushPromise 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processPushPromise" class="anchor" title="Link to processPushPromise">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processPushPromise(f *http2PushPromiseFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processResetStream" data-name="processResetStream">
               <h3>
                  processResetStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processResetStream" class="anchor" title="Link to processResetStream">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processResetStream" data-name="processResetStream">
               <h3>
                  processResetStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processResetStream" class="anchor" title="Link to processResetStream">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processResetStream(f *http2RSTStreamFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processSetting" data-name="processSetting">
               <h3>
                  processSetting 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processSetting" class="anchor" title="Link to processSetting">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processSetting(s http2Setting) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processSettingInitialWindowSize" data-name="processSettingInitialWindowSize">
               <h3>
                  processSettingInitialWindowSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processSettingInitialWindowSize" class="anchor" title="Link to processSettingInitialWindowSize">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processSettingInitialWindowSize(val uint32) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processSettings" data-name="processSettings">
               <h3>
                  processSettings 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processSettings" class="anchor" title="Link to processSettings">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processSettings" data-name="processSettings">
               <h3>
                  processSettings 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processSettings" class="anchor" title="Link to processSettings">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processSettings(f *http2SettingsFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processSettingsNoWrite" data-name="processSettingsNoWrite">
               <h3>
                  processSettingsNoWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processSettingsNoWrite" class="anchor" title="Link to processSettingsNoWrite">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processSettingsNoWrite(f *http2SettingsFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processTrailerHeaders" data-name="processTrailerHeaders">
               <h3>
                  processTrailerHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processTrailerHeaders" class="anchor" title="Link to processTrailerHeaders">#</a>
               </h3>
               
               <pre><code>func (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processTrailers" data-name="processTrailers">
               <h3>
                  processTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processTrailers" class="anchor" title="Link to processTrailers">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processTrailers(cs *http2clientStream, f *http2MetaHeadersFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processWindowUpdate" data-name="processWindowUpdate">
               <h3>
                  processWindowUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processWindowUpdate" class="anchor" title="Link to processWindowUpdate">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processWindowUpdate" data-name="processWindowUpdate">
               <h3>
                  processWindowUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processWindowUpdate" class="anchor" title="Link to processWindowUpdate">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="promoteUndeclaredTrailers" data-name="promoteUndeclaredTrailers">
               <h3>
                  promoteUndeclaredTrailers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#promoteUndeclaredTrailers" class="anchor" title="Link to promoteUndeclaredTrailers">#</a>
               </h3>
               
               <p>promoteUndeclaredTrailers permits http.Handlers to set trailers
after the header has already been flushed. Because the Go
ResponseWriter interface has no way to set Trailers (only the
Header), and because we didn't want to expand the ResponseWriter
interface, and because nobody used trailers, and because RFC 7230
says you SHOULD (but not must) predeclare any trailers in the
header, the official ResponseWriter rules said trailers in Go must
be predeclared, and then we reuse the same ResponseWriter.Header()
map to mean both Headers and Trailers. When it's time to write the
Trailers, we pick out the fields of Headers that were declared as
trailers. That worked for a while, until we found the first major
user of Trailers in the wild: gRPC (using them only over http2),
and gRPC libraries permit setting trailers mid-stream without
predeclaring them. So: change of plans. We still permit the old
way, but we also permit this hack: if a Header() key begins with
"Trailer:", the suffix of that key is a Trailer. Because ':' is an
invalid token byte anyway, there is no ambiguity. (And it's already
filtered out) It's mildly hacky, but not terrible.
This method runs after the Handler is done and promotes any Header
fields to be trailers.</p>
               
               <pre><code>func (rws *http2responseWriterState) promoteUndeclaredTrailers()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="protoAtLeast" data-name="protoAtLeast">
               <h3>
                  protoAtLeast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#protoAtLeast" class="anchor" title="Link to protoAtLeast">#</a>
               </h3>
               
               <pre><code>func (t *transferReader) protoAtLeast(m int, n int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="protocols" data-name="protocols">
               <h3>
                  protocols 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#protocols" class="anchor" title="Link to protocols">#</a>
               </h3>
               
               <pre><code>func (t *Transport) protocols() Protocols</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="protocols" data-name="protocols">
               <h3>
                  protocols 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#protocols" class="anchor" title="Link to protocols">#</a>
               </h3>
               
               <pre><code>func (s *Server) protocols() Protocols</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="proxyAuth" data-name="proxyAuth">
               <h3>
                  proxyAuth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#proxyAuth" class="anchor" title="Link to proxyAuth">#</a>
               </h3>
               
               <p>proxyAuth returns the Proxy-Authorization header to set
on requests, if applicable.</p>
               
               <pre><code>func (cm *connectMethod) proxyAuth() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <pre><code>func (q *http2writeQueue) push(wr http2FrameWriteRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushBack" data-name="pushBack">
               <h3>
                  pushBack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushBack" class="anchor" title="Link to pushBack">#</a>
               </h3>
               
               <p>pushBack adds w to the back of the queue.</p>
               
               <pre><code>func (q *wantConnQueue) pushBack(w *wantConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="put" data-name="put">
               <h3>
                  put 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#put" class="anchor" title="Link to put">#</a>
               </h3>
               
               <p>put inserts an unused writeQueue into the pool.</p>
               
               <pre><code>func (p *http2writeQueuePool) put(q *http2writeQueue)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putBufioReader" data-name="putBufioReader">
               <h3>
                  putBufioReader 
                  <span class="badge">function</span>
                  
                  <a href="#putBufioReader" class="anchor" title="Link to putBufioReader">#</a>
               </h3>
               
               <p>putBufioReader should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/gobwas/ws
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname putBufioReader</p>
               
               <pre><code>func putBufioReader(br *bufio.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putBufioWriter" data-name="putBufioWriter">
               <h3>
                  putBufioWriter 
                  <span class="badge">function</span>
                  
                  <a href="#putBufioWriter" class="anchor" title="Link to putBufioWriter">#</a>
               </h3>
               
               <p>putBufioWriter should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/gobwas/ws
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname putBufioWriter</p>
               
               <pre><code>func putBufioWriter(bw *bufio.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putCopyBuf" data-name="putCopyBuf">
               <h3>
                  putCopyBuf 
                  <span class="badge">function</span>
                  
                  <a href="#putCopyBuf" class="anchor" title="Link to putCopyBuf">#</a>
               </h3>
               
               <pre><code>func putCopyBuf(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putOrCloseIdleConn" data-name="putOrCloseIdleConn">
               <h3>
                  putOrCloseIdleConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putOrCloseIdleConn" class="anchor" title="Link to putOrCloseIdleConn">#</a>
               </h3>
               
               <pre><code>func (t *Transport) putOrCloseIdleConn(pconn *persistConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putTextprotoReader" data-name="putTextprotoReader">
               <h3>
                  putTextprotoReader 
                  <span class="badge">function</span>
                  
                  <a href="#putTextprotoReader" class="anchor" title="Link to putTextprotoReader">#</a>
               </h3>
               
               <pre><code>func putTextprotoReader(r *textproto.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queueForDial" data-name="queueForDial">
               <h3>
                  queueForDial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queueForDial" class="anchor" title="Link to queueForDial">#</a>
               </h3>
               
               <p>queueForDial queues w to wait for permission to begin dialing.
Once w receives permission to dial, it will do so in a separate goroutine.</p>
               
               <pre><code>func (t *Transport) queueForDial(w *wantConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queueForIdleConn" data-name="queueForIdleConn">
               <h3>
                  queueForIdleConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queueForIdleConn" class="anchor" title="Link to queueForIdleConn">#</a>
               </h3>
               
               <p>queueForIdleConn queues w to receive the next idle connection for w.cm.
As an optimization hint to the caller, queueForIdleConn reports whether
it successfully delivered an already-idle connection.</p>
               
               <pre><code>func (t *Transport) queueForIdleConn(w *wantConn) (delivered bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangesMIMESize" data-name="rangesMIMESize">
               <h3>
                  rangesMIMESize 
                  <span class="badge">function</span>
                  
                  <a href="#rangesMIMESize" class="anchor" title="Link to rangesMIMESize">#</a>
               </h3>
               
               <p>rangesMIMESize returns the number of bytes it takes to encode the
provided ranges as a multipart response.</p>
               
               <pre><code>func rangesMIMESize(ranges []httpRange, contentType string, contentSize int64) (encSize int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readBufferSize" data-name="readBufferSize">
               <h3>
                  readBufferSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readBufferSize" class="anchor" title="Link to readBufferSize">#</a>
               </h3>
               
               <pre><code>func (t *Transport) readBufferSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readCookies" data-name="readCookies">
               <h3>
                  readCookies 
                  <span class="badge">function</span>
                  
                  <a href="#readCookies" class="anchor" title="Link to readCookies">#</a>
               </h3>
               
               <p>readCookies parses all "Cookie" values from the header h and
returns the successfully parsed Cookies.
if filter isn't empty, only cookies of that name are returned.</p>
               
               <pre><code>func readCookies(h Header, filter string) []*Cookie</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrames" data-name="readFrames">
               <h3>
                  readFrames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrames" class="anchor" title="Link to readFrames">#</a>
               </h3>
               
               <p>readFrames is the loop that reads incoming frames.
It takes care to only read one frame at a time, blocking until the
consumer is done with the frame.
It's run on its own goroutine.</p>
               
               <pre><code>func (sc *http2serverConn) readFrames()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readHeaderTimeout" data-name="readHeaderTimeout">
               <h3>
                  readHeaderTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readHeaderTimeout" class="anchor" title="Link to readHeaderTimeout">#</a>
               </h3>
               
               <pre><code>func (s *Server) readHeaderTimeout() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLocked" data-name="readLocked">
               <h3>
                  readLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLocked" class="anchor" title="Link to readLocked">#</a>
               </h3>
               
               <p>Must hold b.mu.</p>
               
               <pre><code>func (b *body) readLocked(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLoop" data-name="readLoop">
               <h3>
                  readLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLoop" class="anchor" title="Link to readLoop">#</a>
               </h3>
               
               <p>readLoop runs in its own goroutine and reads and dispatches frames.</p>
               
               <pre><code>func (cc *http2ClientConn) readLoop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLoop" data-name="readLoop">
               <h3>
                  readLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLoop" class="anchor" title="Link to readLoop">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) readLoop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLoopPeekFailLocked" data-name="readLoopPeekFailLocked">
               <h3>
                  readLoopPeekFailLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLoopPeekFailLocked" class="anchor" title="Link to readLoopPeekFailLocked">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) readLoopPeekFailLocked(peekErr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readMetaFrame" data-name="readMetaFrame">
               <h3>
                  readMetaFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readMetaFrame" class="anchor" title="Link to readMetaFrame">#</a>
               </h3>
               
               <p>readMetaFrame returns 0 or more CONTINUATION frames from fr and
merge them into the provided hf and returns a MetaHeadersFrame
with the decoded hpack values.</p>
               
               <pre><code>func (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (http2Frame, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readPreface" data-name="readPreface">
               <h3>
                  readPreface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readPreface" class="anchor" title="Link to readPreface">#</a>
               </h3>
               
               <p>readPreface reads the ClientPreface greeting from the peer or
returns errPrefaceTimeout on timeout, or an error if the greeting
is invalid.</p>
               
               <pre><code>func (sc *http2serverConn) readPreface() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRequest" data-name="readRequest">
               <h3>
                  readRequest 
                  <span class="badge">function</span>
                  
                  <a href="#readRequest" class="anchor" title="Link to readRequest">#</a>
               </h3>
               
               <p>readRequest should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/sagernet/sing
- github.com/v2fly/v2ray-core/v4
- github.com/v2fly/v2ray-core/v5
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname readRequest</p>
               
               <pre><code>func readRequest(b *bufio.Reader) (req *Request, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRequest" data-name="readRequest">
               <h3>
                  readRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readRequest" class="anchor" title="Link to readRequest">#</a>
               </h3>
               
               <p>Read next request from connection.</p>
               
               <pre><code>func (c *conn) readRequest(ctx context.Context) (w *response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readResponse" data-name="readResponse">
               <h3>
                  readResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readResponse" class="anchor" title="Link to readResponse">#</a>
               </h3>
               
               <p>readResponse reads an HTTP response (or two, in the case of "Expect:
100-continue") from the server. It returns the final non-100 one.
trace is optional.</p>
               
               <pre><code>func (pc *persistConn) readResponse(rc requestAndChan, trace *httptrace.ClientTrace) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readSetCookies" data-name="readSetCookies">
               <h3>
                  readSetCookies 
                  <span class="badge">function</span>
                  
                  <a href="#readSetCookies" class="anchor" title="Link to readSetCookies">#</a>
               </h3>
               
               <p>readSetCookies parses all "Set-Cookie" values from
the header h and returns the successfully parsed Cookies.</p>
               
               <pre><code>func readSetCookies(h Header) []*Cookie</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readTrailer" data-name="readTrailer">
               <h3>
                  readTrailer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readTrailer" class="anchor" title="Link to readTrailer">#</a>
               </h3>
               
               <pre><code>func (b *body) readTrailer() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readTransfer" data-name="readTransfer">
               <h3>
                  readTransfer 
                  <span class="badge">function</span>
                  
                  <a href="#readTransfer" class="anchor" title="Link to readTransfer">#</a>
               </h3>
               
               <p>msg is *Request or *Response.</p>
               
               <pre><code>func readTransfer(msg any, r *bufio.Reader) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="redirectBehavior" data-name="redirectBehavior">
               <h3>
                  redirectBehavior 
                  <span class="badge">function</span>
                  
                  <a href="#redirectBehavior" class="anchor" title="Link to redirectBehavior">#</a>
               </h3>
               
               <p>redirectBehavior describes what should happen when the
client encounters a 3xx status code from the server.</p>
               
               <pre><code>func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirectMethod string, shouldRedirect bool, includeBody bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="redirectToPathSlash" data-name="redirectToPathSlash">
               <h3>
                  redirectToPathSlash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#redirectToPathSlash" class="anchor" title="Link to redirectToPathSlash">#</a>
               </h3>
               
               <p>redirectToPathSlash determines if the given path needs appending "/" to it.
This occurs when a handler for path + "/" was already registered, but
not for path itself. If the path needs appending to, it creates a new
URL, setting the path to u.Path + "/" and returning true to indicate so.</p>
               
               <pre><code>func (mux *serveMux121) redirectToPathSlash(host string, path string, u *url.URL) (*url.URL, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refererForURL" data-name="refererForURL">
               <h3>
                  refererForURL 
                  <span class="badge">function</span>
                  
                  <a href="#refererForURL" class="anchor" title="Link to refererForURL">#</a>
               </h3>
               
               <p>refererForURL returns a referer without any authentication info or
an empty string if lastReq scheme is https and newReq scheme is http.
If the referer was explicitly set, then it will continue to be used.</p>
               
               <pre><code>func refererForURL(lastReq *url.URL, newReq *url.URL, explicitRef string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="register" data-name="register">
               <h3>
                  register 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#register" class="anchor" title="Link to register">#</a>
               </h3>
               
               <pre><code>func (mux *ServeMux) register(pattern string, handler Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerConn" data-name="registerConn">
               <h3>
                  registerConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#registerConn" class="anchor" title="Link to registerConn">#</a>
               </h3>
               
               <pre><code>func (s *http2serverInternalState) registerConn(sc *http2serverConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerErr" data-name="registerErr">
               <h3>
                  registerErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#registerErr" class="anchor" title="Link to registerErr">#</a>
               </h3>
               
               <pre><code>func (mux *ServeMux) registerErr(patstr string, handler Handler) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerOnHitEOF" data-name="registerOnHitEOF">
               <h3>
                  registerOnHitEOF 
                  <span class="badge">function</span>
                  
                  <a href="#registerOnHitEOF" class="anchor" title="Link to registerOnHitEOF">#</a>
               </h3>
               
               <pre><code>func registerOnHitEOF(rc io.ReadCloser, fn func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerOnHitEOF" data-name="registerOnHitEOF">
               <h3>
                  registerOnHitEOF 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#registerOnHitEOF" class="anchor" title="Link to registerOnHitEOF">#</a>
               </h3>
               
               <pre><code>func (b *body) registerOnHitEOF(fn func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rejectConn" data-name="rejectConn">
               <h3>
                  rejectConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rejectConn" class="anchor" title="Link to rejectConn">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) rejectConn(err http2ErrCode, debug string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relevantCaller" data-name="relevantCaller">
               <h3>
                  relevantCaller 
                  <span class="badge">function</span>
                  
                  <a href="#relevantCaller" class="anchor" title="Link to relevantCaller">#</a>
               </h3>
               
               <p>relevantCaller searches the call stack for the first function outside of net/http.
The purpose of this function is to provide more helpful error messages.</p>
               
               <pre><code>func relevantCaller() runtime.Frame</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="remove" data-name="remove">
               <h3>
                  remove 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#remove" class="anchor" title="Link to remove">#</a>
               </h3>
               
               <p>remove removes pc from cl.</p>
               
               <pre><code>func (cl *connLRU) remove(pc *persistConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeEmptyPort" data-name="removeEmptyPort">
               <h3>
                  removeEmptyPort 
                  <span class="badge">function</span>
                  
                  <a href="#removeEmptyPort" class="anchor" title="Link to removeEmptyPort">#</a>
               </h3>
               
               <p>removeEmptyPort strips the empty port in ":port" to ""
as mandated by RFC 3986 Section 6.2.3.</p>
               
               <pre><code>func removeEmptyPort(host string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeIdleConn" data-name="removeIdleConn">
               <h3>
                  removeIdleConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeIdleConn" class="anchor" title="Link to removeIdleConn">#</a>
               </h3>
               
               <p>removeIdleConn marks pconn as dead.</p>
               
               <pre><code>func (t *Transport) removeIdleConn(pconn *persistConn) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeIdleConnLocked" data-name="removeIdleConnLocked">
               <h3>
                  removeIdleConnLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeIdleConnLocked" class="anchor" title="Link to removeIdleConnLocked">#</a>
               </h3>
               
               <p>t.idleMu must be held.</p>
               
               <pre><code>func (t *Transport) removeIdleConnLocked(pconn *persistConn) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeNode" data-name="removeNode">
               <h3>
                  removeNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeNode" class="anchor" title="Link to removeNode">#</a>
               </h3>
               
               <pre><code>func (ws *http2priorityWriteScheduler) removeNode(n *http2priorityNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeOldest" data-name="removeOldest">
               <h3>
                  removeOldest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeOldest" class="anchor" title="Link to removeOldest">#</a>
               </h3>
               
               <pre><code>func (cl *connLRU) removeOldest() *persistConn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeZone" data-name="removeZone">
               <h3>
                  removeZone 
                  <span class="badge">function</span>
                  
                  <a href="#removeZone" class="anchor" title="Link to removeZone">#</a>
               </h3>
               
               <p>removeZone removes IPv6 zone identifier from host.
E.g., "[fe80::1%en0]:8080" to "[fe80::1]:8080"</p>
               
               <pre><code>func removeZone(host string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replyToWriter" data-name="replyToWriter">
               <h3>
                  replyToWriter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#replyToWriter" class="anchor" title="Link to replyToWriter">#</a>
               </h3>
               
               <p>replyToWriter sends err to wr.done and panics if the send must block
This does nothing if wr.done is nil.</p>
               
               <pre><code>func (wr *http2FrameWriteRequest) replyToWriter(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="requestBodyRemains" data-name="requestBodyRemains">
               <h3>
                  requestBodyRemains 
                  <span class="badge">function</span>
                  
                  <a href="#requestBodyRemains" class="anchor" title="Link to requestBodyRemains">#</a>
               </h3>
               
               <p>requestBodyRemains reports whether future calls to Read
on rc might yield more data.</p>
               
               <pre><code>func requestBodyRemains(rc io.ReadCloser) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="requestMethodUsuallyLacksBody" data-name="requestMethodUsuallyLacksBody">
               <h3>
                  requestMethodUsuallyLacksBody 
                  <span class="badge">function</span>
                  
                  <a href="#requestMethodUsuallyLacksBody" class="anchor" title="Link to requestMethodUsuallyLacksBody">#</a>
               </h3>
               
               <p>requestMethodUsuallyLacksBody reports whether the given request
method is one that typically does not involve a request body.
This is used by the Transport (via
transferWriter.shouldSendChunkedRequestBody) to determine whether
we try to test-read a byte from a non-nil Request.Body when
Request.outgoingLength() returns -1. See the comments in
shouldSendChunkedRequestBody.</p>
               
               <pre><code>func requestMethodUsuallyLacksBody(method string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="requestTooLarge" data-name="requestTooLarge">
               <h3>
                  requestTooLarge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#requestTooLarge" class="anchor" title="Link to requestTooLarge">#</a>
               </h3>
               
               <p>requestTooLarge is called by maxBytesReader when too much input has
been read from the client.</p>
               
               <pre><code>func (w *response) requestTooLarge()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="requiresHTTP1" data-name="requiresHTTP1">
               <h3>
                  requiresHTTP1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#requiresHTTP1" class="anchor" title="Link to requiresHTTP1">#</a>
               </h3>
               
               <p>requiresHTTP1 reports whether this request requires being sent on
an HTTP/1 connection.</p>
               
               <pre><code>func (r *Request) requiresHTTP1() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetProxyConfig" data-name="resetProxyConfig">
               <h3>
                  resetProxyConfig 
                  <span class="badge">function</span>
                  
                  <a href="#resetProxyConfig" class="anchor" title="Link to resetProxyConfig">#</a>
               </h3>
               
               <p>resetProxyConfig is used by tests.</p>
               
               <pre><code>func resetProxyConfig()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetStream" data-name="resetStream">
               <h3>
                  resetStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resetStream" class="anchor" title="Link to resetStream">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) resetStream(se http2StreamError)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="responseHeaderTimeout" data-name="responseHeaderTimeout">
               <h3>
                  responseHeaderTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#responseHeaderTimeout" class="anchor" title="Link to responseHeaderTimeout">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) responseHeaderTimeout() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewindBody" data-name="rewindBody">
               <h3>
                  rewindBody 
                  <span class="badge">function</span>
                  
                  <a href="#rewindBody" class="anchor" title="Link to rewindBody">#</a>
               </h3>
               
               <p>rewindBody returns a new request with the body rewound.
It returns req unmodified if the body does not need rewinding.
rewindBody takes care of closing req.Body when appropriate
(in all cases except when rewindBody returns req unmodified).</p>
               
               <pre><code>func rewindBody(req *Request) (rewound *Request, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundTrip" data-name="roundTrip">
               <h3>
                  roundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#roundTrip" class="anchor" title="Link to roundTrip">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) roundTrip(req *Request, streamf func(*http2clientStream)) (*Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundTrip" data-name="roundTrip">
               <h3>
                  roundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#roundTrip" class="anchor" title="Link to roundTrip">#</a>
               </h3>
               
               <p>roundTrip implements a RoundTripper over HTTP.</p>
               
               <pre><code>func (t *Transport) roundTrip(req *Request) (_ *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundTrip" data-name="roundTrip">
               <h3>
                  roundTrip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#roundTrip" class="anchor" title="Link to roundTrip">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <pre><code>func (rl *http2clientConnReadLoop) run() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <pre><code>func (c *http2addConnCall) run(t *http2Transport, key string, nc net.Conn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runHandler" data-name="runHandler">
               <h3>
                  runHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runHandler" class="anchor" title="Link to runHandler">#</a>
               </h3>
               
               <p>Run on its own goroutine.</p>
               
               <pre><code>func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sanitizeCookieName" data-name="sanitizeCookieName">
               <h3>
                  sanitizeCookieName 
                  <span class="badge">function</span>
                  
                  <a href="#sanitizeCookieName" class="anchor" title="Link to sanitizeCookieName">#</a>
               </h3>
               
               <pre><code>func sanitizeCookieName(n string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sanitizeCookiePath" data-name="sanitizeCookiePath">
               <h3>
                  sanitizeCookiePath 
                  <span class="badge">function</span>
                  
                  <a href="#sanitizeCookiePath" class="anchor" title="Link to sanitizeCookiePath">#</a>
               </h3>
               
               <p>path-av           = "Path=" path-value
path-value        = <any CHAR except CTLs or ";"></p>
               
               <pre><code>func sanitizeCookiePath(v string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sanitizeCookieValue" data-name="sanitizeCookieValue">
               <h3>
                  sanitizeCookieValue 
                  <span class="badge">function</span>
                  
                  <a href="#sanitizeCookieValue" class="anchor" title="Link to sanitizeCookieValue">#</a>
               </h3>
               
               <p>sanitizeCookieValue produces a suitable cookie-value from v.
It receives a quoted bool indicating whether the value was originally
quoted.
https://tools.ietf.org/html/rfc6265#section-4.1.1
cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
; US-ASCII characters excluding CTLs,
; whitespace DQUOTE, comma, semicolon,
; and backslash
We loosen this as spaces and commas are common in cookie values
thus we produce a quoted cookie-value if v contains commas or spaces.
See https://golang.org/issue/7243 for the discussion.</p>
               
               <pre><code>func sanitizeCookieValue(v string, quoted bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sanitizeOrWarn" data-name="sanitizeOrWarn">
               <h3>
                  sanitizeOrWarn 
                  <span class="badge">function</span>
                  
                  <a href="#sanitizeOrWarn" class="anchor" title="Link to sanitizeOrWarn">#</a>
               </h3>
               
               <pre><code>func sanitizeOrWarn(fieldName string, valid func(byte) bool, v string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanETag" data-name="scanETag">
               <h3>
                  scanETag 
                  <span class="badge">function</span>
                  
                  <a href="#scanETag" class="anchor" title="Link to scanETag">#</a>
               </h3>
               
               <p>scanETag determines if a syntactically valid ETag is present at s. If so,
the ETag and remaining text after consuming ETag is returned. Otherwise,
it returns "", "".</p>
               
               <pre><code>func scanETag(s string) (etag string, remain string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scheduleFrameWrite" data-name="scheduleFrameWrite">
               <h3>
                  scheduleFrameWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scheduleFrameWrite" class="anchor" title="Link to scheduleFrameWrite">#</a>
               </h3>
               
               <p>scheduleFrameWrite tickles the frame writing scheduler.
If a frame is already being written, nothing happens. This will be called again
when the frame is done being written.
If a frame isn't being written and we need to send one, the best frame
to send is selected by writeSched.
If a frame isn't being written and there's nothing else to send, we
flush the write buffer.</p>
               
               <pre><code>func (sc *http2serverConn) scheduleFrameWrite()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scheduleHandler" data-name="scheduleHandler">
               <h3>
                  scheduleHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scheduleHandler" class="anchor" title="Link to scheduleHandler">#</a>
               </h3>
               
               <p>scheduleHandler starts a handler goroutine,
or schedules one to start as soon as an existing handler finishes.</p>
               
               <pre><code>func (sc *http2serverConn) scheduleHandler(streamID uint32, rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request)) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scheme" data-name="scheme">
               <h3>
                  scheme 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scheme" class="anchor" title="Link to scheme">#</a>
               </h3>
               
               <p>scheme returns the first hop scheme: http, https, or socks5</p>
               
               <pre><code>func (cm *connectMethod) scheme() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="seeUpcomingDoubleCRLF" data-name="seeUpcomingDoubleCRLF">
               <h3>
                  seeUpcomingDoubleCRLF 
                  <span class="badge">function</span>
                  
                  <a href="#seeUpcomingDoubleCRLF" class="anchor" title="Link to seeUpcomingDoubleCRLF">#</a>
               </h3>
               
               <pre><code>func seeUpcomingDoubleCRLF(r *bufio.Reader) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="send" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#send" class="anchor" title="Link to send">#</a>
               </h3>
               
               <p>didTimeout is non-nil only if err != nil.</p>
               
               <pre><code>func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="send" data-name="send">
               <h3>
                  send 
                  <span class="badge">function</span>
                  
                  <a href="#send" class="anchor" title="Link to send">#</a>
               </h3>
               
               <p>send issues an HTTP request.
Caller should close resp.Body when done reading from it.</p>
               
               <pre><code>func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendExpectationFailed" data-name="sendExpectationFailed">
               <h3>
                  sendExpectationFailed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendExpectationFailed" class="anchor" title="Link to sendExpectationFailed">#</a>
               </h3>
               
               <pre><code>func (w *response) sendExpectationFailed()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendGoAway" data-name="sendGoAway">
               <h3>
                  sendGoAway 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendGoAway" class="anchor" title="Link to sendGoAway">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) sendGoAway() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendResponse" data-name="sendResponse">
               <h3>
                  sendResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendResponse" class="anchor" title="Link to sendResponse">#</a>
               </h3>
               
               <pre><code>func (pr *populateResponse) sendResponse()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendServeMsg" data-name="sendServeMsg">
               <h3>
                  sendServeMsg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendServeMsg" class="anchor" title="Link to sendServeMsg">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) sendServeMsg(msg interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendWindowUpdate" data-name="sendWindowUpdate">
               <h3>
                  sendWindowUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendWindowUpdate" class="anchor" title="Link to sendWindowUpdate">#</a>
               </h3>
               
               <p>st may be nil for conn-level</p>
               
               <pre><code>func (sc *http2serverConn) sendWindowUpdate(st *http2stream, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendWindowUpdate32" data-name="sendWindowUpdate32">
               <h3>
                  sendWindowUpdate32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendWindowUpdate32" class="anchor" title="Link to sendWindowUpdate32">#</a>
               </h3>
               
               <p>st may be nil for conn-level</p>
               
               <pre><code>func (sc *http2serverConn) sendWindowUpdate32(st *http2stream, n int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serve" data-name="serve">
               <h3>
                  serve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#serve" class="anchor" title="Link to serve">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) serve(conf http2http2Config)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serve" data-name="serve">
               <h3>
                  serve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#serve" class="anchor" title="Link to serve">#</a>
               </h3>
               
               <p>Serve a new connection.</p>
               
               <pre><code>func (c *conn) serve(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serveConn" data-name="serveConn">
               <h3>
                  serveConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#serveConn" class="anchor" title="Link to serveConn">#</a>
               </h3>
               
               <pre><code>func (s *http2Server) serveConn(c net.Conn, opts *http2ServeConnOpts, newf func(*http2serverConn))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serveContent" data-name="serveContent">
               <h3>
                  serveContent 
                  <span class="badge">function</span>
                  
                  <a href="#serveContent" class="anchor" title="Link to serveContent">#</a>
               </h3>
               
               <p>if name is empty, filename is unknown. (used for mime type, before sniffing)
if modtime.IsZero(), modtime is unknown.
content must be seeked to the beginning of the file.
The sizeFunc is called at most once. Its error, if any, is sent in the HTTP response.</p>
               
               <pre><code>func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time, sizeFunc func() (int64, error), content io.ReadSeeker)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serveError" data-name="serveError">
               <h3>
                  serveError 
                  <span class="badge">function</span>
                  
                  <a href="#serveError" class="anchor" title="Link to serveError">#</a>
               </h3>
               
               <p>serveError serves an error from ServeFile, ServeFileFS, and ServeContent.
Because those can all be configured by the caller by setting headers like
Etag, Last-Modified, and Cache-Control to send on a successful response,
the error path needs to clear them, since they may not be meant for errors.</p>
               
               <pre><code>func serveError(w ResponseWriter, text string, code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serveFile" data-name="serveFile">
               <h3>
                  serveFile 
                  <span class="badge">function</span>
                  
                  <a href="#serveFile" class="anchor" title="Link to serveFile">#</a>
               </h3>
               
               <p>name is '/'-separated, not filepath.Separator.</p>
               
               <pre><code>func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <p>set sets the pattern and handler for n, which
must be a leaf node.</p>
               
               <pre><code>func (n *routingNode) set(p *pattern, h Handler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBit" data-name="setBit">
               <h3>
                  setBit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBit" class="anchor" title="Link to setBit">#</a>
               </h3>
               
               <pre><code>func (p *Protocols) setBit(bit uint8, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBuffer" data-name="setBuffer">
               <h3>
                  setBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBuffer" class="anchor" title="Link to setBuffer">#</a>
               </h3>
               
               <p>setBuffer initializes the pipe buffer.
It has no effect if the pipe is already closed.</p>
               
               <pre><code>func (p *http2pipe) setBuffer(b http2pipeBuffer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setConnFlow" data-name="setConnFlow">
               <h3>
                  setConnFlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setConnFlow" class="anchor" title="Link to setConnFlow">#</a>
               </h3>
               
               <pre><code>func (f *http2outflow) setConnFlow(cf *http2outflow)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setConnState" data-name="setConnState">
               <h3>
                  setConnState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setConnState" class="anchor" title="Link to setConnState">#</a>
               </h3>
               
               <p>setConnState calls the net/http ConnState hook for this connection, if configured.
Note that the net/http package does StateNew and StateClosed for us.
There is currently no plan for StateHijacked or hijacking HTTP/2 connections.</p>
               
               <pre><code>func (sc *http2serverConn) setConnState(state ConnState)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setError" data-name="setError">
               <h3>
                  setError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setError" class="anchor" title="Link to setError">#</a>
               </h3>
               
               <pre><code>func (tr *transportRequest) setError(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setGoAway" data-name="setGoAway">
               <h3>
                  setGoAway 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setGoAway" class="anchor" title="Link to setGoAway">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) setGoAway(f *http2GoAwayFrame)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setInfiniteReadLimit" data-name="setInfiniteReadLimit">
               <h3>
                  setInfiniteReadLimit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setInfiniteReadLimit" class="anchor" title="Link to setInfiniteReadLimit">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) setInfiniteReadLimit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLastModified" data-name="setLastModified">
               <h3>
                  setLastModified 
                  <span class="badge">function</span>
                  
                  <a href="#setLastModified" class="anchor" title="Link to setLastModified">#</a>
               </h3>
               
               <pre><code>func setLastModified(w ResponseWriter, modtime time.Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setParent" data-name="setParent">
               <h3>
                  setParent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setParent" class="anchor" title="Link to setParent">#</a>
               </h3>
               
               <pre><code>func (n *http2priorityNode) setParent(parent *http2priorityNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setReadLimit" data-name="setReadLimit">
               <h3>
                  setReadLimit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setReadLimit" class="anchor" title="Link to setReadLimit">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) setReadLimit(remain int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setRequestCancel" data-name="setRequestCancel">
               <h3>
                  setRequestCancel 
                  <span class="badge">function</span>
                  
                  <a href="#setRequestCancel" class="anchor" title="Link to setRequestCancel">#</a>
               </h3>
               
               <p>setRequestCancel sets req.Cancel and adds a deadline context to req
if deadline is non-zero. The RoundTripper's type is used to
determine whether the legacy CancelRequest behavior should be used.
As background, there are three ways to cancel a request:
First was Transport.CancelRequest. (deprecated)
Second was Request.Cancel.
Third was Request.Context.
This function populates the second and third, and uses the first if it really needs to.</p>
               
               <pre><code>func setRequestCancel(req *Request, rt RoundTripper, deadline time.Time) (stopTimer func(), didTimeout func() bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setState" data-name="setState">
               <h3>
                  setState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setState" class="anchor" title="Link to setState">#</a>
               </h3>
               
               <pre><code>func (c *conn) setState(nc net.Conn, state ConnState, runHook bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupHTTP2_Serve" data-name="setupHTTP2_Serve">
               <h3>
                  setupHTTP2_Serve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setupHTTP2_Serve" class="anchor" title="Link to setupHTTP2_Serve">#</a>
               </h3>
               
               <p>setupHTTP2_Serve is called from (*Server).Serve and conditionally
configures HTTP/2 on s using a more conservative policy than
setupHTTP2_ServeTLS because Serve is called after tls.Listen,
and may be called concurrently. See shouldConfigureHTTP2ForServe.
The tests named TestTransportAutomaticHTTP2* and
TestConcurrentServerServe in server_test.go demonstrate some
of the supported use cases and motivations.</p>
               
               <pre><code>func (s *Server) setupHTTP2_Serve() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupHTTP2_ServeTLS" data-name="setupHTTP2_ServeTLS">
               <h3>
                  setupHTTP2_ServeTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setupHTTP2_ServeTLS" class="anchor" title="Link to setupHTTP2_ServeTLS">#</a>
               </h3>
               
               <p>setupHTTP2_ServeTLS conditionally configures HTTP/2 on
s and reports whether there was an error setting it up. If it is
not configured for policy reasons, nil is returned.</p>
               
               <pre><code>func (s *Server) setupHTTP2_ServeTLS() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupRewindBody" data-name="setupRewindBody">
               <h3>
                  setupRewindBody 
                  <span class="badge">function</span>
                  
                  <a href="#setupRewindBody" class="anchor" title="Link to setupRewindBody">#</a>
               </h3>
               
               <p>setupRewindBody returns a new request with a custom body wrapper
that can report whether the body needs rewinding.
This lets rewindBody avoid an error result when the request
does not have GetBody but the body hasn't been read at all yet.</p>
               
               <pre><code>func setupRewindBody(req *Request) *Request</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shift" data-name="shift">
               <h3>
                  shift 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shift" class="anchor" title="Link to shift">#</a>
               </h3>
               
               <pre><code>func (q *http2writeQueue) shift() http2FrameWriteRequest</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldClose" data-name="shouldClose">
               <h3>
                  shouldClose 
                  <span class="badge">function</span>
                  
                  <a href="#shouldClose" class="anchor" title="Link to shouldClose">#</a>
               </h3>
               
               <p>Determine whether to hang up after sending a request and body, or
receiving a response and body
'header' is the request headers.</p>
               
               <pre><code>func shouldClose(major int, minor int, header Header, removeCloseHeader bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldConfigureHTTP2ForServe" data-name="shouldConfigureHTTP2ForServe">
               <h3>
                  shouldConfigureHTTP2ForServe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldConfigureHTTP2ForServe" class="anchor" title="Link to shouldConfigureHTTP2ForServe">#</a>
               </h3>
               
               <p>shouldConfigureHTTP2ForServe reports whether Server.Serve should configure
automatic HTTP/2. (which sets up the s.TLSNextProto map)</p>
               
               <pre><code>func (s *Server) shouldConfigureHTTP2ForServe() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldCopyHeaderOnRedirect" data-name="shouldCopyHeaderOnRedirect">
               <h3>
                  shouldCopyHeaderOnRedirect 
                  <span class="badge">function</span>
                  
                  <a href="#shouldCopyHeaderOnRedirect" class="anchor" title="Link to shouldCopyHeaderOnRedirect">#</a>
               </h3>
               
               <pre><code>func shouldCopyHeaderOnRedirect(initial *url.URL, dest *url.URL) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldRedirectRLocked" data-name="shouldRedirectRLocked">
               <h3>
                  shouldRedirectRLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldRedirectRLocked" class="anchor" title="Link to shouldRedirectRLocked">#</a>
               </h3>
               
               <p>shouldRedirectRLocked reports whether the given path and host should be redirected to
path+"/". This should happen if a handler is registered for path+"/" but
not path -- see comments at ServeMux.</p>
               
               <pre><code>func (mux *serveMux121) shouldRedirectRLocked(host string, path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldRetryRequest" data-name="shouldRetryRequest">
               <h3>
                  shouldRetryRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldRetryRequest" class="anchor" title="Link to shouldRetryRequest">#</a>
               </h3>
               
               <p>shouldRetryRequest reports whether we should retry sending a failed
HTTP request on a new connection. The non-nil input error is the
error from roundTrip.</p>
               
               <pre><code>func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldReuseConnection" data-name="shouldReuseConnection">
               <h3>
                  shouldReuseConnection 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldReuseConnection" class="anchor" title="Link to shouldReuseConnection">#</a>
               </h3>
               
               <p>shouldReuseConnection reports whether the underlying TCP connection can be reused.
It must only be called after the handler is done executing.</p>
               
               <pre><code>func (w *response) shouldReuseConnection() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldSendChunkedRequestBody" data-name="shouldSendChunkedRequestBody">
               <h3>
                  shouldSendChunkedRequestBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldSendChunkedRequestBody" class="anchor" title="Link to shouldSendChunkedRequestBody">#</a>
               </h3>
               
               <p>shouldSendChunkedRequestBody reports whether we should try to send a
chunked request body to the server. In particular, the case we really
want to prevent is sending a GET or other typically-bodyless request to a
server with a chunked body when the body has zero bytes, since GETs with
bodies (while acceptable according to specs), even zero-byte chunked
bodies, are approximately never seen in the wild and confuse most
servers. See Issue 18257, as one example.
The only reason we'd send such a request is if the user set the Body to a
non-nil value (say, io.NopCloser(bytes.NewReader(nil))) and didn't
set ContentLength, or NewRequest set it to -1 (unknown), so then we assume
there's bytes to send.
This code tries to read a byte from the Request.Body in such cases to see
whether the body actually has content (super rare) or is actually just
a non-nil content-less ReadCloser (the more common case). In that more
common case, we act as if their Body were nil instead, and don't send
a body.</p>
               
               <pre><code>func (t *transferWriter) shouldSendChunkedRequestBody() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldSendContentLength" data-name="shouldSendContentLength">
               <h3>
                  shouldSendContentLength 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldSendContentLength" class="anchor" title="Link to shouldSendContentLength">#</a>
               </h3>
               
               <pre><code>func (t *transferWriter) shouldSendContentLength() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shutDownIn" data-name="shutDownIn">
               <h3>
                  shutDownIn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shutDownIn" class="anchor" title="Link to shutDownIn">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) shutDownIn(d time.Duration)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shuttingDown" data-name="shuttingDown">
               <h3>
                  shuttingDown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shuttingDown" class="anchor" title="Link to shuttingDown">#</a>
               </h3>
               
               <pre><code>func (s *Server) shuttingDown() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="socksNewDialer" data-name="socksNewDialer">
               <h3>
                  socksNewDialer 
                  <span class="badge">function</span>
                  
                  <a href="#socksNewDialer" class="anchor" title="Link to socksNewDialer">#</a>
               </h3>
               
               <p>NewDialer returns a new Dialer that dials through the provided
proxy server's network and address.</p>
               
               <pre><code>func socksNewDialer(network string, address string) *socksDialer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sockssplitHostPort" data-name="sockssplitHostPort">
               <h3>
                  sockssplitHostPort 
                  <span class="badge">function</span>
                  
                  <a href="#sockssplitHostPort" class="anchor" title="Link to sockssplitHostPort">#</a>
               </h3>
               
               <pre><code>func sockssplitHostPort(address string) (string, int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortedKeyValues" data-name="sortedKeyValues">
               <h3>
                  sortedKeyValues 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sortedKeyValues" class="anchor" title="Link to sortedKeyValues">#</a>
               </h3>
               
               <p>sortedKeyValues returns h's keys sorted in the returned kvs
slice. The headerSorter used to sort is also returned, for possible
return to headerSorterCache.</p>
               
               <pre><code>func (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startBackgroundRead" data-name="startBackgroundRead">
               <h3>
                  startBackgroundRead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startBackgroundRead" class="anchor" title="Link to startBackgroundRead">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) startBackgroundRead()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startDialConnForLocked" data-name="startDialConnForLocked">
               <h3>
                  startDialConnForLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startDialConnForLocked" class="anchor" title="Link to startDialConnForLocked">#</a>
               </h3>
               
               <p>startDialConnFor calls dialConn in a new goroutine.
t.connsPerHostMu must be held.</p>
               
               <pre><code>func (t *Transport) startDialConnForLocked(w *wantConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startFrameWrite" data-name="startFrameWrite">
               <h3>
                  startFrameWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startFrameWrite" class="anchor" title="Link to startFrameWrite">#</a>
               </h3>
               
               <p>startFrameWrite starts a goroutine to write wr (in a separate
goroutine since that might block on the network), and updates the
serve goroutine's state about the world, updated from info in wr.</p>
               
               <pre><code>func (sc *http2serverConn) startFrameWrite(wr http2FrameWriteRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startGracefulShutdown" data-name="startGracefulShutdown">
               <h3>
                  startGracefulShutdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startGracefulShutdown" class="anchor" title="Link to startGracefulShutdown">#</a>
               </h3>
               
               <pre><code>func (s *http2serverInternalState) startGracefulShutdown()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startGracefulShutdown" data-name="startGracefulShutdown">
               <h3>
                  startGracefulShutdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startGracefulShutdown" class="anchor" title="Link to startGracefulShutdown">#</a>
               </h3>
               
               <p>startGracefulShutdown gracefully shuts down a connection. This
sends GOAWAY with ErrCodeNo to tell the client we're gracefully
shutting down. The connection isn't closed until all current
streams are done.
startGracefulShutdown returns immediately; it does not wait until
the connection has shut down.</p>
               
               <pre><code>func (sc *http2serverConn) startGracefulShutdown()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startGracefulShutdownInternal" data-name="startGracefulShutdownInternal">
               <h3>
                  startGracefulShutdownInternal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startGracefulShutdownInternal" class="anchor" title="Link to startGracefulShutdownInternal">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) startGracefulShutdownInternal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startPush" data-name="startPush">
               <h3>
                  startPush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startPush" class="anchor" title="Link to startPush">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) startPush(msg *http2startPushRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startWrite" data-name="startWrite">
               <h3>
                  startWrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startWrite" class="anchor" title="Link to startWrite">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) startWrite(ftype http2FrameType, flags http2Flags, streamID uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startWriteDataPadded" data-name="startWriteDataPadded">
               <h3>
                  startWriteDataPadded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startWriteDataPadded" class="anchor" title="Link to startWriteDataPadded">#</a>
               </h3>
               
               <p>startWriteDataPadded is WriteDataPadded, but only writes the frame to the Framer's internal buffer.
The caller should call endWrite to flush the frame to the underlying writer.</p>
               
               <pre><code>func (f *http2Framer) startWriteDataPadded(streamID uint32, endStream bool, data []byte, pad []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="state" data-name="state">
               <h3>
                  state 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#state" class="anchor" title="Link to state">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) state(streamID uint32) (http2streamState, *http2stream)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (w *http2writeResHeaders) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (*http2writeGoAway) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (se http2StreamError) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (wu http2writeWindowUpdate) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (w http2writePingAck) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (w http2write100ContinueHeadersFrame) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (s http2writeSettings) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (http2flushFrameWriter) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (http2writeSettingsAck) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (w *http2writePushPromise) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (hp http2handlerPanicRST) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (w http2writePing) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staysWithinBuffer" data-name="staysWithinBuffer">
               <h3>
                  staysWithinBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staysWithinBuffer" class="anchor" title="Link to staysWithinBuffer">#</a>
               </h3>
               
               <pre><code>func (w *http2writeData) staysWithinBuffer(max int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stopShutdownTimer" data-name="stopShutdownTimer">
               <h3>
                  stopShutdownTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stopShutdownTimer" class="anchor" title="Link to stopShutdownTimer">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) stopShutdownTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="streamByID" data-name="streamByID">
               <h3>
                  streamByID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#streamByID" class="anchor" title="Link to streamByID">#</a>
               </h3>
               
               <p>streamByID returns the stream with the given id, or nil if no stream has that id.
If headerOrData is true, it clears rst.StreamPingsBlocked.</p>
               
               <pre><code>func (rl *http2clientConnReadLoop) streamByID(id uint32, headerOrData bool) *http2clientStream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringContainsCTLByte" data-name="stringContainsCTLByte">
               <h3>
                  stringContainsCTLByte 
                  <span class="badge">function</span>
                  
                  <a href="#stringContainsCTLByte" class="anchor" title="Link to stringContainsCTLByte">#</a>
               </h3>
               
               <p>stringContainsCTLByte reports whether s contains any ASCII control character.</p>
               
               <pre><code>func stringContainsCTLByte(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringToken" data-name="stringToken">
               <h3>
                  stringToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stringToken" class="anchor" title="Link to stringToken">#</a>
               </h3>
               
               <pre><code>func (e http2ErrCode) stringToken() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripHostPort" data-name="stripHostPort">
               <h3>
                  stripHostPort 
                  <span class="badge">function</span>
                  
                  <a href="#stripHostPort" class="anchor" title="Link to stripHostPort">#</a>
               </h3>
               
               <p>stripHostPort returns h without any trailing ":<port>".</p>
               
               <pre><code>func stripHostPort(h string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripPassword" data-name="stripPassword">
               <h3>
                  stripPassword 
                  <span class="badge">function</span>
                  
                  <a href="#stripPassword" class="anchor" title="Link to stripPassword">#</a>
               </h3>
               
               <pre><code>func stripPassword(u *url.URL) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sumRangesSize" data-name="sumRangesSize">
               <h3>
                  sumRangesSize 
                  <span class="badge">function</span>
                  
                  <a href="#sumRangesSize" class="anchor" title="Link to sumRangesSize">#</a>
               </h3>
               
               <pre><code>func sumRangesSize(ranges []httpRange) (size int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="suppressedHeaders" data-name="suppressedHeaders">
               <h3>
                  suppressedHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#suppressedHeaders" class="anchor" title="Link to suppressedHeaders">#</a>
               </h3>
               
               <pre><code>func suppressedHeaders(status int) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="take" data-name="take">
               <h3>
                  take 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#take" class="anchor" title="Link to take">#</a>
               </h3>
               
               <p>take attempts to take n bytes from the peer's flow control window.
It reports whether the window has available capacity.</p>
               
               <pre><code>func (f *http2inflow) take(n uint32) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="take" data-name="take">
               <h3>
                  take 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#take" class="anchor" title="Link to take">#</a>
               </h3>
               
               <pre><code>func (f *http2outflow) take(n int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="timeBeforeContextDeadline" data-name="timeBeforeContextDeadline">
               <h3>
                  timeBeforeContextDeadline 
                  <span class="badge">function</span>
                  
                  <a href="#timeBeforeContextDeadline" class="anchor" title="Link to timeBeforeContextDeadline">#</a>
               </h3>
               
               <p>timeBeforeContextDeadline reports whether the non-zero Time t is
before ctx's deadline, if any. If ctx does not have a deadline, it
always reports true (the deadline is considered infinite).</p>
               
               <pre><code>func timeBeforeContextDeadline(t time.Time, ctx context.Context) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="timeSince" data-name="timeSince">
               <h3>
                  timeSince 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#timeSince" class="anchor" title="Link to timeSince">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) timeSince(when time.Time) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tlsHandshakeTimeout" data-name="tlsHandshakeTimeout">
               <h3>
                  tlsHandshakeTimeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tlsHandshakeTimeout" class="anchor" title="Link to tlsHandshakeTimeout">#</a>
               </h3>
               
               <p>tlsHandshakeTimeout returns the time limit permitted for the TLS
handshake, or zero for unlimited.
It returns the minimum of any positive ReadHeaderTimeout,
ReadTimeout, or WriteTimeout.</p>
               
               <pre><code>func (s *Server) tlsHandshakeTimeout() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tlsHost" data-name="tlsHost">
               <h3>
                  tlsHost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tlsHost" class="anchor" title="Link to tlsHost">#</a>
               </h3>
               
               <p>tlsHost returns the host name to match against the peer's
TLS certificate.</p>
               
               <pre><code>func (cm *connectMethod) tlsHost() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tlsRecordHeaderLooksLikeHTTP" data-name="tlsRecordHeaderLooksLikeHTTP">
               <h3>
                  tlsRecordHeaderLooksLikeHTTP 
                  <span class="badge">function</span>
                  
                  <a href="#tlsRecordHeaderLooksLikeHTTP" class="anchor" title="Link to tlsRecordHeaderLooksLikeHTTP">#</a>
               </h3>
               
               <p>tlsRecordHeaderLooksLikeHTTP reports whether a TLS record header
looks like it might've been a misdirected plaintext HTTP request.</p>
               
               <pre><code>func tlsRecordHeaderLooksLikeHTTP(hdr [5]byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toHTTPError" data-name="toHTTPError">
               <h3>
                  toHTTPError 
                  <span class="badge">function</span>
                  
                  <a href="#toHTTPError" class="anchor" title="Link to toHTTPError">#</a>
               </h3>
               
               <p>toHTTPError returns a non-specific HTTP error message and status code
for a given non-nil error value. It's important that toHTTPError does not
actually return err.Error(), since msg and httpStatus are returned to users,
and historically Go's ServeContent always returned just "404 Not Found" for
all errors. We don't want to start leaking information in error messages.</p>
               
               <pre><code>func toHTTPError(err error) (msg string, httpStatus int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tooIdleLocked" data-name="tooIdleLocked">
               <h3>
                  tooIdleLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tooIdleLocked" class="anchor" title="Link to tooIdleLocked">#</a>
               </h3>
               
               <p>tooIdleLocked reports whether this connection has been been sitting idle
for too much wall time.</p>
               
               <pre><code>func (cc *http2ClientConn) tooIdleLocked() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trackConn" data-name="trackConn">
               <h3>
                  trackConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trackConn" class="anchor" title="Link to trackConn">#</a>
               </h3>
               
               <pre><code>func (s *Server) trackConn(c *conn, add bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trackListener" data-name="trackListener">
               <h3>
                  trackListener 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trackListener" class="anchor" title="Link to trackListener">#</a>
               </h3>
               
               <p>trackListener adds or removes a net.Listener to the set of tracked
listeners.
We store a pointer to interface in the map set, in case the
net.Listener is not comparable. This is safe because we only call
trackListener via Serve and can track+defer untrack the same
pointer to local variable there. We never need to compare a
Listener from another caller.
It reports whether the server is still up (not Shutdown or Closed).</p>
               
               <pre><code>func (s *Server) trackListener(ln *net.Listener, add bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="transport" data-name="transport">
               <h3>
                  transport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#transport" class="anchor" title="Link to transport">#</a>
               </h3>
               
               <pre><code>func (c *Client) transport() RoundTripper</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryDeliver" data-name="tryDeliver">
               <h3>
                  tryDeliver 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryDeliver" class="anchor" title="Link to tryDeliver">#</a>
               </h3>
               
               <p>tryDeliver attempts to deliver pc, err to w and reports whether it succeeded.</p>
               
               <pre><code>func (w *wantConn) tryDeliver(pc *persistConn, err error, idleAt time.Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryPutIdleConn" data-name="tryPutIdleConn">
               <h3>
                  tryPutIdleConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryPutIdleConn" class="anchor" title="Link to tryPutIdleConn">#</a>
               </h3>
               
               <p>tryPutIdleConn adds pconn to the list of idle persistent connections awaiting
a new request.
If pconn is no longer needed or not in a good state, tryPutIdleConn returns
an error explaining why it wasn't registered.
tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</p>
               
               <pre><code>func (t *Transport) tryPutIdleConn(pconn *persistConn) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unencryptedTLSConn" data-name="unencryptedTLSConn">
               <h3>
                  unencryptedTLSConn 
                  <span class="badge">function</span>
                  
                  <a href="#unencryptedTLSConn" class="anchor" title="Link to unencryptedTLSConn">#</a>
               </h3>
               
               <pre><code>func unencryptedTLSConn(c net.Conn) *tls.Conn</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unlock" data-name="unlock">
               <h3>
                  unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unlock" class="anchor" title="Link to unlock">#</a>
               </h3>
               
               <pre><code>func (cr *connReader) unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unreadDataSizeLocked" data-name="unreadDataSizeLocked">
               <h3>
                  unreadDataSizeLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unreadDataSizeLocked" class="anchor" title="Link to unreadDataSizeLocked">#</a>
               </h3>
               
               <p>unreadDataSizeLocked returns the number of bytes of unread input.
It returns -1 if unknown.
b.mu must be held.</p>
               
               <pre><code>func (b *body) unreadDataSizeLocked() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unregisterConn" data-name="unregisterConn">
               <h3>
                  unregisterConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unregisterConn" class="anchor" title="Link to unregisterConn">#</a>
               </h3>
               
               <pre><code>func (s *http2serverInternalState) unregisterConn(sc *http2serverConn)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unwrapBody" data-name="unwrapBody">
               <h3>
                  unwrapBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unwrapBody" class="anchor" title="Link to unwrapBody">#</a>
               </h3>
               
               <p>unwrapBody unwraps the body's inner reader if it's a
nopCloser. This is to ensure that body writes sourced from local
files (*os.File types) are properly optimized.
This function is only intended for use in writeBody.</p>
               
               <pre><code>func (t *transferWriter) unwrapBody() io.Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unwrapNopCloser" data-name="unwrapNopCloser">
               <h3>
                  unwrapNopCloser 
                  <span class="badge">function</span>
                  
                  <a href="#unwrapNopCloser" class="anchor" title="Link to unwrapNopCloser">#</a>
               </h3>
               
               <p>unwrapNopCloser return the underlying reader and true if r is a NopCloser
else it return false.</p>
               
               <pre><code>func unwrapNopCloser(r io.Reader) (underlyingReader io.Reader, isNopCloser bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="upgradeRequest" data-name="upgradeRequest">
               <h3>
                  upgradeRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#upgradeRequest" class="anchor" title="Link to upgradeRequest">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) upgradeRequest(req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="urlErrorOp" data-name="urlErrorOp">
               <h3>
                  urlErrorOp 
                  <span class="badge">function</span>
                  
                  <a href="#urlErrorOp" class="anchor" title="Link to urlErrorOp">#</a>
               </h3>
               
               <p>urlErrorOp returns the (*url.Error).Op value to use for the
provided (*Request).Method value.</p>
               
               <pre><code>func urlErrorOp(method string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useRegisteredProtocol" data-name="useRegisteredProtocol">
               <h3>
                  useRegisteredProtocol 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useRegisteredProtocol" class="anchor" title="Link to useRegisteredProtocol">#</a>
               </h3>
               
               <p>useRegisteredProtocol reports whether an alternate protocol (as registered
with Transport.RegisterProtocol) should be respected for this request.</p>
               
               <pre><code>func (t *Transport) useRegisteredProtocol(req *Request) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validCookieDomain" data-name="validCookieDomain">
               <h3>
                  validCookieDomain 
                  <span class="badge">function</span>
                  
                  <a href="#validCookieDomain" class="anchor" title="Link to validCookieDomain">#</a>
               </h3>
               
               <p>validCookieDomain reports whether v is a valid cookie domain-value.</p>
               
               <pre><code>func validCookieDomain(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validCookieExpires" data-name="validCookieExpires">
               <h3>
                  validCookieExpires 
                  <span class="badge">function</span>
                  
                  <a href="#validCookieExpires" class="anchor" title="Link to validCookieExpires">#</a>
               </h3>
               
               <p>validCookieExpires reports whether v is a valid cookie expires-value.</p>
               
               <pre><code>func validCookieExpires(t time.Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validCookiePathByte" data-name="validCookiePathByte">
               <h3>
                  validCookiePathByte 
                  <span class="badge">function</span>
                  
                  <a href="#validCookiePathByte" class="anchor" title="Link to validCookiePathByte">#</a>
               </h3>
               
               <pre><code>func validCookiePathByte(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validCookieValueByte" data-name="validCookieValueByte">
               <h3>
                  validCookieValueByte 
                  <span class="badge">function</span>
                  
                  <a href="#validCookieValueByte" class="anchor" title="Link to validCookieValueByte">#</a>
               </h3>
               
               <pre><code>func validCookieValueByte(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validMethod" data-name="validMethod">
               <h3>
                  validMethod 
                  <span class="badge">function</span>
                  
                  <a href="#validMethod" class="anchor" title="Link to validMethod">#</a>
               </h3>
               
               <pre><code>func validMethod(method string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validNextProto" data-name="validNextProto">
               <h3>
                  validNextProto 
                  <span class="badge">function</span>
                  
                  <a href="#validNextProto" class="anchor" title="Link to validNextProto">#</a>
               </h3>
               
               <p>validNextProto reports whether the proto is a valid ALPN protocol name.
Everything is valid except the empty string and built-in protocol types,
so that those can't be overridden with alternate implementations.</p>
               
               <pre><code>func validNextProto(proto string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateHeaders" data-name="validateHeaders">
               <h3>
                  validateHeaders 
                  <span class="badge">function</span>
                  
                  <a href="#validateHeaders" class="anchor" title="Link to validateHeaders">#</a>
               </h3>
               
               <pre><code>func validateHeaders(hdrs Header) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateTarget" data-name="validateTarget">
               <h3>
                  validateTarget 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validateTarget" class="anchor" title="Link to validateTarget">#</a>
               </h3>
               
               <pre><code>func (d *socksDialer) validateTarget(network string, address string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueOrDefault" data-name="valueOrDefault">
               <h3>
                  valueOrDefault 
                  <span class="badge">function</span>
                  
                  <a href="#valueOrDefault" class="anchor" title="Link to valueOrDefault">#</a>
               </h3>
               
               <p>Return value if nonempty, def otherwise.</p>
               
               <pre><code>func valueOrDefault(value string, def string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vlogf" data-name="vlogf">
               <h3>
                  vlogf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#vlogf" class="anchor" title="Link to vlogf">#</a>
               </h3>
               
               <pre><code>func (sc *http2serverConn) vlogf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vlogf" data-name="vlogf">
               <h3>
                  vlogf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#vlogf" class="anchor" title="Link to vlogf">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) vlogf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vlogf" data-name="vlogf">
               <h3>
                  vlogf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#vlogf" class="anchor" title="Link to vlogf">#</a>
               </h3>
               
               <pre><code>func (t *http2Transport) vlogf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="waitForContinue" data-name="waitForContinue">
               <h3>
                  waitForContinue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#waitForContinue" class="anchor" title="Link to waitForContinue">#</a>
               </h3>
               
               <p>waitForContinue returns the function to block until
any response, timeout or connection close. After any of them,
the function returns a bool which indicates if the body should be sent.</p>
               
               <pre><code>func (pc *persistConn) waitForContinue(continueCh <-chan struct{...}) (func() bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="waiting" data-name="waiting">
               <h3>
                  waiting 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#waiting" class="anchor" title="Link to waiting">#</a>
               </h3>
               
               <p>waiting reports whether w is still waiting for an answer (connection or error).</p>
               
               <pre><code>func (w *wantConn) waiting() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkReadyInOrder" data-name="walkReadyInOrder">
               <h3>
                  walkReadyInOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkReadyInOrder" class="anchor" title="Link to walkReadyInOrder">#</a>
               </h3>
               
               <p>walkReadyInOrder iterates over the tree in priority order, calling f for each node
with a non-empty write queue. When f returns true, this function returns true and the
walk halts. tmp is used as scratch space for sorting.
f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true
if any ancestor p of n is still open (ignoring the root node).</p>
               
               <pre><code>func (n *http2priorityNode) walkReadyInOrder(openParent bool, tmp *[]*http2priorityNode, f func(*http2priorityNode, bool) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wantsClose" data-name="wantsClose">
               <h3>
                  wantsClose 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wantsClose" class="anchor" title="Link to wantsClose">#</a>
               </h3>
               
               <pre><code>func (r *Request) wantsClose() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wantsHttp10KeepAlive" data-name="wantsHttp10KeepAlive">
               <h3>
                  wantsHttp10KeepAlive 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wantsHttp10KeepAlive" class="anchor" title="Link to wantsHttp10KeepAlive">#</a>
               </h3>
               
               <pre><code>func (r *Request) wantsHttp10KeepAlive() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <p>either dataB or dataS is non-zero.</p>
               
               <pre><code>func (w *http2responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <p>either dataB or dataS is non-zero.</p>
               
               <pre><code>func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <pre><code>func (h Header) write(w io.Writer, trace *httptrace.ClientTrace) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <p>extraHeaders may be nil
waitForContinue may be nil
always closes body</p>
               
               <pre><code>func (r *Request) write(w io.Writer, usingProxy bool, extraHeaders Header, waitForContinue func() bool) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write100ContinueHeaders" data-name="write100ContinueHeaders">
               <h3>
                  write100ContinueHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write100ContinueHeaders" class="anchor" title="Link to write100ContinueHeaders">#</a>
               </h3>
               
               <p>called from handler goroutines.</p>
               
               <pre><code>func (sc *http2serverConn) write100ContinueHeaders(st *http2stream)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeBody" data-name="writeBody">
               <h3>
                  writeBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeBody" class="anchor" title="Link to writeBody">#</a>
               </h3>
               
               <p>always closes t.BodyCloser</p>
               
               <pre><code>func (t *transferWriter) writeBody(w io.Writer) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeBufferSize" data-name="writeBufferSize">
               <h3>
                  writeBufferSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeBufferSize" class="anchor" title="Link to writeBufferSize">#</a>
               </h3>
               
               <pre><code>func (t *Transport) writeBufferSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeByte" data-name="writeByte">
               <h3>
                  writeByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeByte" class="anchor" title="Link to writeByte">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) writeByte(v byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeBytes" data-name="writeBytes">
               <h3>
                  writeBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeBytes" class="anchor" title="Link to writeBytes">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) writeBytes(v []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeChunk" data-name="writeChunk">
               <h3>
                  writeChunk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeChunk" class="anchor" title="Link to writeChunk">#</a>
               </h3>
               
               <p>writeChunk writes chunks from the bufio.Writer. But because
bufio.Writer may bypass its chunking, sometimes p may be
arbitrarily large.
writeChunk is also responsible (on the first chunk) for sending the
HEADER response.</p>
               
               <pre><code>func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDataFromHandler" data-name="writeDataFromHandler">
               <h3>
                  writeDataFromHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeDataFromHandler" class="anchor" title="Link to writeDataFromHandler">#</a>
               </h3>
               
               <p>writeDataFromHandler writes DATA response frames from a handler on
the given stream.</p>
               
               <pre><code>func (sc *http2serverConn) writeDataFromHandler(stream *http2stream, data []byte, endStream bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDebug" data-name="writeDebug">
               <h3>
                  writeDebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeDebug" class="anchor" title="Link to writeDebug">#</a>
               </h3>
               
               <pre><code>func (h http2FrameHeader) writeDebug(buf *bytes.Buffer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (w http2write100ContinueHeadersFrame) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (se http2StreamError) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (w http2writePing) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (http2writeSettingsAck) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <p>writeFrame schedules a frame to write and sends it if there's nothing
already being written.
There is no pushback here (the serve goroutine never blocks). It's
the http.Handlers that block, waiting for their previous frames to
make it onto the wire
If you're not on the serve goroutine, use writeFrameFromHandler instead.</p>
               
               <pre><code>func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (w *http2writeResHeaders) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (w *http2writeData) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (http2flushFrameWriter) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (w *http2writePushPromise) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (wu http2writeWindowUpdate) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (p *http2writeGoAway) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (hp http2handlerPanicRST) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (w http2writePingAck) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrame" data-name="writeFrame">
               <h3>
                  writeFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrame" class="anchor" title="Link to writeFrame">#</a>
               </h3>
               
               <pre><code>func (s http2writeSettings) writeFrame(ctx http2writeContext) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrameAsync" data-name="writeFrameAsync">
               <h3>
                  writeFrameAsync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrameAsync" class="anchor" title="Link to writeFrameAsync">#</a>
               </h3>
               
               <p>writeFrameAsync runs in its own goroutine and writes a single frame
and then reports when it's done.
At most one goroutine can be running writeFrameAsync at a time per
serverConn.</p>
               
               <pre><code>func (sc *http2serverConn) writeFrameAsync(wr http2FrameWriteRequest, wd *http2writeData)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFrameFromHandler" data-name="writeFrameFromHandler">
               <h3>
                  writeFrameFromHandler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFrameFromHandler" class="anchor" title="Link to writeFrameFromHandler">#</a>
               </h3>
               
               <p>writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts
if the connection has gone away.
This must not be run from the serve goroutine itself, else it might
deadlock writing to sc.wantWriteFrameCh (which is only mildly
buffered and is read by serve itself). If you're on the serve
goroutine, call writeFrame instead.</p>
               
               <pre><code>func (sc *http2serverConn) writeFrameFromHandler(wr http2FrameWriteRequest) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeader" data-name="writeHeader">
               <h3>
                  writeHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeader" class="anchor" title="Link to writeHeader">#</a>
               </h3>
               
               <p>writeHeader finalizes the header sent to the client and writes it
to cw.res.conn.bufw.
p is not written by writeHeader, but is the first chunk of the body
that will be written. It is sniffed for a Content-Type if none is
set explicitly. It's also used to set the Content-Length, if the
total body size was small and the handler has already finished
running.</p>
               
               <pre><code>func (cw *chunkWriter) writeHeader(p []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeader" data-name="writeHeader">
               <h3>
                  writeHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeader" class="anchor" title="Link to writeHeader">#</a>
               </h3>
               
               <pre><code>func (t *transferWriter) writeHeader(w io.Writer, trace *httptrace.ClientTrace) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeader" data-name="writeHeader">
               <h3>
                  writeHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeader" class="anchor" title="Link to writeHeader">#</a>
               </h3>
               
               <pre><code>func (rws *http2responseWriterState) writeHeader(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeader" data-name="writeHeader">
               <h3>
                  writeHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeader" class="anchor" title="Link to writeHeader">#</a>
               </h3>
               
               <pre><code>func (cc *http2ClientConn) writeHeader(name string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeaderBlock" data-name="writeHeaderBlock">
               <h3>
                  writeHeaderBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeaderBlock" class="anchor" title="Link to writeHeaderBlock">#</a>
               </h3>
               
               <pre><code>func (w *http2writePushPromise) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag bool, lastFrag bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeaderBlock" data-name="writeHeaderBlock">
               <h3>
                  writeHeaderBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeaderBlock" class="anchor" title="Link to writeHeaderBlock">#</a>
               </h3>
               
               <pre><code>func (w *http2writeResHeaders) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag bool, lastFrag bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeaderLocked" data-name="writeHeaderLocked">
               <h3>
                  writeHeaderLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeaderLocked" class="anchor" title="Link to writeHeaderLocked">#</a>
               </h3>
               
               <pre><code>func (tw *timeoutWriter) writeHeaderLocked(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeaders" data-name="writeHeaders">
               <h3>
                  writeHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeaders" class="anchor" title="Link to writeHeaders">#</a>
               </h3>
               
               <p>called from handler goroutines.
h may be nil.</p>
               
               <pre><code>func (sc *http2serverConn) writeHeaders(st *http2stream, headerData *http2writeResHeaders) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeHeaders" data-name="writeHeaders">
               <h3>
                  writeHeaders 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeHeaders" class="anchor" title="Link to writeHeaders">#</a>
               </h3>
               
               <p>requires cc.wmu be held</p>
               
               <pre><code>func (cc *http2ClientConn) writeHeaders(streamID uint32, endStream bool, maxFrameSize int, hdrs []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeLoop" data-name="writeLoop">
               <h3>
                  writeLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeLoop" class="anchor" title="Link to writeLoop">#</a>
               </h3>
               
               <pre><code>func (pc *persistConn) writeLoop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeMatchingPath" data-name="writeMatchingPath">
               <h3>
                  writeMatchingPath 
                  <span class="badge">function</span>
                  
                  <a href="#writeMatchingPath" class="anchor" title="Link to writeMatchingPath">#</a>
               </h3>
               
               <p>writeMatchingPath writes to b a path that matches the segments.</p>
               
               <pre><code>func writeMatchingPath(b *strings.Builder, segs []segment)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeNotModified" data-name="writeNotModified">
               <h3>
                  writeNotModified 
                  <span class="badge">function</span>
                  
                  <a href="#writeNotModified" class="anchor" title="Link to writeNotModified">#</a>
               </h3>
               
               <pre><code>func writeNotModified(w ResponseWriter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeRequest" data-name="writeRequest">
               <h3>
                  writeRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeRequest" class="anchor" title="Link to writeRequest">#</a>
               </h3>
               
               <p>writeRequest sends a request.
It returns nil after the request is written, the response read,
and the request stream is half-closed by the peer.
It returns non-nil if the request ends otherwise.
If the returned error is StreamError, the error Code may be used in resetting the stream.</p>
               
               <pre><code>func (cs *http2clientStream) writeRequest(req *Request, streamf func(*http2clientStream)) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeRequestBody" data-name="writeRequestBody">
               <h3>
                  writeRequestBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeRequestBody" class="anchor" title="Link to writeRequestBody">#</a>
               </h3>
               
               <pre><code>func (cs *http2clientStream) writeRequestBody(req *Request) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeSegment" data-name="writeSegment">
               <h3>
                  writeSegment 
                  <span class="badge">function</span>
                  
                  <a href="#writeSegment" class="anchor" title="Link to writeSegment">#</a>
               </h3>
               
               <pre><code>func writeSegment(b *strings.Builder, s segment)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeStatusLine" data-name="writeStatusLine">
               <h3>
                  writeStatusLine 
                  <span class="badge">function</span>
                  
                  <a href="#writeStatusLine" class="anchor" title="Link to writeStatusLine">#</a>
               </h3>
               
               <p>writeStatusLine writes an HTTP/1.x Status-Line (RFC 7230 Section 3.1.2)
to bw. is11 is whether the HTTP request is HTTP/1.1. false means HTTP/1.0.
code is the response status code.
scratch is an optional scratch buffer. If it has at least capacity 3, it's used.</p>
               
               <pre><code>func writeStatusLine(bw *bufio.Writer, is11 bool, code int, scratch []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeStreamReset" data-name="writeStreamReset">
               <h3>
                  writeStreamReset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeStreamReset" class="anchor" title="Link to writeStreamReset">#</a>
               </h3>
               
               <p>writeStreamReset sends a RST_STREAM frame.
When ping is true, it also sends a PING frame with a random payload.</p>
               
               <pre><code>func (cc *http2ClientConn) writeStreamReset(streamID uint32, code http2ErrCode, ping bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeSubset" data-name="writeSubset">
               <h3>
                  writeSubset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeSubset" class="anchor" title="Link to writeSubset">#</a>
               </h3>
               
               <pre><code>func (h Header) writeSubset(w io.Writer, exclude map[string]bool, trace *httptrace.ClientTrace) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeUint16" data-name="writeUint16">
               <h3>
                  writeUint16 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeUint16" class="anchor" title="Link to writeUint16">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) writeUint16(v uint16)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeUint32" data-name="writeUint32">
               <h3>
                  writeUint32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeUint32" class="anchor" title="Link to writeUint32">#</a>
               </h3>
               
               <pre><code>func (f *http2Framer) writeUint32(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wroteFrame" data-name="wroteFrame">
               <h3>
                  wroteFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wroteFrame" class="anchor" title="Link to wroteFrame">#</a>
               </h3>
               
               <p>wroteFrame is called on the serve goroutine with the result of
whatever happened on writeFrameAsync.</p>
               
               <pre><code>func (sc *http2serverConn) wroteFrame(res http2frameWriteResult)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wroteRequest" data-name="wroteRequest">
               <h3>
                  wroteRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wroteRequest" class="anchor" title="Link to wroteRequest">#</a>
               </h3>
               
               <p>wroteRequest is a check before recycling a connection that the previous write
(from writeLoop above) happened and was successful.</p>
               
               <pre><code>func (pc *persistConn) wroteRequest() bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>