<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - poly1305</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>poly1305</code>
         </h1>
         <hr />
         
         <article class="global" data-name="TagSize">
            <h2>TagSize</h2>
            <hr />
            
            <p>TagSize is the size, in bytes, of a poly1305 authenticator.</p>
            
            <pre><code>TagSize</code></pre>
         </article>
         
         <article class="global" data-name="rMask0">
            <h2>rMask0</h2>
            <hr />
            
            <p>[rMask0, rMask1] is the specified Poly1305 clamping mask in little-endian. It
clears some bits of the secret coefficient to make it possible to implement
multiplication more efficiently.</p>
            
            <pre><code>rMask0</code></pre>
         </article>
         
         <article class="global" data-name="rMask1">
            <h2>rMask1</h2>
            <hr />
            
            <p>[rMask0, rMask1] is the specified Poly1305 clamping mask in little-endian. It
clears some bits of the secret coefficient to make it possible to implement
multiplication more efficiently.</p>
            
            <pre><code>rMask1</code></pre>
         </article>
         
         <article class="global" data-name="maskLow2Bits">
            <h2>maskLow2Bits</h2>
            <hr />
            
            <pre><code>maskLow2Bits uint64</code></pre>
         </article>
         
         <article class="global" data-name="maskNotLow2Bits">
            <h2>maskNotLow2Bits</h2>
            <hr />
            
            <pre><code>maskNotLow2Bits uint64</code></pre>
         </article>
         
         <article class="global" data-name="p0">
            <h2>p0</h2>
            <hr />
            
            <p>[p0, p1, p2] is 2¹³⁰ - 5 in little endian order.</p>
            
            <pre><code>p0</code></pre>
         </article>
         
         <article class="global" data-name="p1">
            <h2>p1</h2>
            <hr />
            
            <p>[p0, p1, p2] is 2¹³⁰ - 5 in little endian order.</p>
            
            <pre><code>p1</code></pre>
         </article>
         
         <article class="global" data-name="p2">
            <h2>p2</h2>
            <hr />
            
            <p>[p0, p1, p2] is 2¹³⁰ - 5 in little endian order.</p>
            
            <pre><code>p2</code></pre>
         </article>
          
         <article class="struct" data-name="MAC">
            <h2>type MAC struct</h2>
            <hr />
            
            <p>MAC is an io.Writer computing an authentication tag
of the data written to it.

MAC cannot be used like common hash.Hash implementations,
because using a poly1305 key twice breaks its security.
Therefore writing data to a running MAC after calling
Sum or Verify causes it to panic.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mac
finalized bool</code></pre>
         </article>
         
         <article class="struct" data-name="mac">
            <h2>type mac struct</h2>
            <hr />
            
            <p>mac is a wrapper for macGeneric that redirects calls that would have gone to
updateGeneric to update.

Its Write and Sum methods are otherwise identical to the macGeneric ones, but
using function pointers would carry a major performance cost.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">macGeneric</code></pre>
         </article>
         
         <article class="struct" data-name="macState">
            <h2>type macState struct</h2>
            <hr />
            
            <p>macState holds numbers in saturated 64-bit little-endian limbs. That is,
the value of [x0, x1, x2] is x[0] + x[1] * 2⁶⁴ + x[2] * 2¹²⁸.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">h []uint64
r []uint64
s []uint64</code></pre>
         </article>
         
         <article class="struct" data-name="macGeneric">
            <h2>type macGeneric struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">macState
buffer []byte
offset int</code></pre>
         </article>
         
         <article class="struct" data-name="uint128">
            <h2>type uint128 struct</h2>
            <hr />
            
            <p>uint128 holds a 128-bit number as two 64-bit limbs, for use with the
bits.Mul64 and bits.Add64 intrinsics.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">lo uint64
hi uint64</code></pre>
         </article>
         
         <article class="struct" data-name="mac">
            <h2>type mac struct</h2>
            <hr />
            
            <p>mac is a wrapper for macGeneric that redirects calls that would have gone to
updateGeneric to update.

Its Write and Sum methods are otherwise identical to the macGeneric ones, but
using function pointers would carry a major performance cost.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">macGeneric</code></pre>
         </article>
         
         <article class="struct" data-name="mac">
            <h2>type mac struct</h2>
            <hr />
            
            <p>mac is a replacement for macGeneric that uses a larger buffer and redirects
calls that would have gone to updateGeneric to updateVX if the vector
facility is installed.

A larger buffer is required for good performance because the vector
implementation has a higher fixed cost per call than the generic
implementation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">macState
buffer []byte
offset int</code></pre>
         </article>
         
         <article class="struct" data-name="mac">
            <h2>type mac struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">macGeneric</code></pre>
         </article>
          
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum generates an authenticator for msg using a one-time key and puts the
16-byte result into out. Authenticating two different messages with the same
key allows an attacker to forge messages at will.</p>
            
            <pre><code>func Sum(out *[]byte, m []byte, key *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="Verify">
            <h2>Verify</h2>
            <hr />
            
            <p>Verify returns true if mac is a valid authenticator for m with the given key.</p>
            
            <pre><code>func Verify(mac *[]byte, m []byte, key *[]byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New returns a new MAC computing an authentication
tag of all data written to it with the given key.
This allows writing the message progressively instead
of passing it as a single slice. Common users should use
the Sum function instead.

The key must be unique for each message, as authenticating
two different messages with the same key allows an attacker
to forge messages at will.</p>
            
            <pre><code>func New(key *[]byte) *MAC</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <p>Size returns the number of bytes Sum will return.</p>
            
            <pre><code>func Size() int</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write adds more data to the running message authentication code.
It never returns an error.

It must not be called after the first call of Sum or Verify.</p>
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum computes the authenticator of all data written to the
message authentication code.</p>
            
            <pre><code>func Sum(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Verify">
            <h2>Verify</h2>
            <hr />
            
            <p>Verify returns whether the authenticator of all data written to
the message authentication code matches the expected value.</p>
            
            <pre><code>func Verify(expected []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>func update(state *macState, msg []byte)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <pre><code>func Sum(out *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="sumGeneric">
            <h2>sumGeneric</h2>
            <hr />
            
            <pre><code>func sumGeneric(out *[]byte, msg []byte, key *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="newMACGeneric">
            <h2>newMACGeneric</h2>
            <hr />
            
            <pre><code>func newMACGeneric(key *[]byte) macGeneric</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write splits the incoming message into TagSize chunks, and passes them to
update. It buffers incomplete chunks.</p>
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum flushes the last incomplete chunk from the buffer, if any, and generates
the MAC output. It does not modify its state, in order to allow for multiple
calls to Sum, even if no Write is allowed after Sum.</p>
            
            <pre><code>func Sum(out *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="initialize">
            <h2>initialize</h2>
            <hr />
            
            <p>initialize loads the 256-bit key into the two 128-bit secret values r and s.</p>
            
            <pre><code>func initialize(key *[]byte, m *macState)</code></pre>
         </article>
         
         <article class="function" data-name="mul64">
            <h2>mul64</h2>
            <hr />
            
            <pre><code>func mul64(a uint64, b uint64) uint128</code></pre>
         </article>
         
         <article class="function" data-name="add128">
            <h2>add128</h2>
            <hr />
            
            <pre><code>func add128(a uint128, b uint128) uint128</code></pre>
         </article>
         
         <article class="function" data-name="shiftRightBy2">
            <h2>shiftRightBy2</h2>
            <hr />
            
            <pre><code>func shiftRightBy2(a uint128) uint128</code></pre>
         </article>
         
         <article class="function" data-name="updateGeneric">
            <h2>updateGeneric</h2>
            <hr />
            
            <p>updateGeneric absorbs msg into the state.h accumulator. For each chunk m of
128 bits of message, it computes

	h₊ = (h + m) * r  mod  2¹³⁰ - 5

If the msg length is not a multiple of TagSize, it assumes the last
incomplete chunk is the final one.</p>
            
            <pre><code>func updateGeneric(state *macState, msg []byte)</code></pre>
         </article>
         
         <article class="function" data-name="select64">
            <h2>select64</h2>
            <hr />
            
            <p>select64 returns x if v == 1 and y if v == 0, in constant time.</p>
            
            <pre><code>func select64(v uint64, x uint64, y uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="finalize">
            <h2>finalize</h2>
            <hr />
            
            <p>finalize completes the modular reduction of h and computes

	out = h + s  mod  2¹²⁸</p>
            
            <pre><code>func finalize(out *[]byte, h *[]uint64, s *[]uint64)</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>func update(state *macState, msg []byte)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <pre><code>func Sum(out *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="updateVX">
            <h2>updateVX</h2>
            <hr />
            
            <p>updateVX is an assembly implementation of Poly1305 that uses vector
instructions. It must only be called if the vector facility (vx) is
available.</p>
            
            <pre><code>func updateVX(state *macState, msg []byte)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <pre><code>func Sum(out *[]byte)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
