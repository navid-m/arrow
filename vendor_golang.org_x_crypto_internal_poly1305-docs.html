<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - poly1305</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>poly1305</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"encoding/binary"
"math/bits"
"golang.org/x/sys/cpu"
"crypto/subtle"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="TagSize" data-name="TagSize">
               <h3>
                  TagSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TagSize" class="anchor" title="Link to TagSize">#</a>
               </h3>
               
               <p>TagSize is the size, in bytes, of a poly1305 authenticator.</p>
               
               <pre><code>const TagSize = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maskLow2Bits" data-name="maskLow2Bits">
               <h3>
                  maskLow2Bits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maskLow2Bits" class="anchor" title="Link to maskLow2Bits">#</a>
               </h3>
               
               <pre><code>const maskLow2Bits uint64 = 0x0000000000000003</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maskNotLow2Bits" data-name="maskNotLow2Bits">
               <h3>
                  maskNotLow2Bits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maskNotLow2Bits" class="anchor" title="Link to maskNotLow2Bits">#</a>
               </h3>
               
               <pre><code>const maskNotLow2Bits uint64 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p0" data-name="p0">
               <h3>
                  p0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p0" class="anchor" title="Link to p0">#</a>
               </h3>
               
               <p>[p0, p1, p2] is 2¹³⁰ - 5 in little endian order.</p>
               
               <pre><code>const p0 = 0xFFFFFFFFFFFFFFFB</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p1" data-name="p1">
               <h3>
                  p1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p1" class="anchor" title="Link to p1">#</a>
               </h3>
               
               <p>[p0, p1, p2] is 2¹³⁰ - 5 in little endian order.</p>
               
               <pre><code>const p1 = 0xFFFFFFFFFFFFFFFF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p2" data-name="p2">
               <h3>
                  p2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p2" class="anchor" title="Link to p2">#</a>
               </h3>
               
               <p>[p0, p1, p2] is 2¹³⁰ - 5 in little endian order.</p>
               
               <pre><code>const p2 = 0x0000000000000003</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rMask0" data-name="rMask0">
               <h3>
                  rMask0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#rMask0" class="anchor" title="Link to rMask0">#</a>
               </h3>
               
               <p>[rMask0, rMask1] is the specified Poly1305 clamping mask in little-endian. It
clears some bits of the secret coefficient to make it possible to implement
multiplication more efficiently.</p>
               
               <pre><code>const rMask0 = 0x0FFFFFFC0FFFFFFF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rMask1" data-name="rMask1">
               <h3>
                  rMask1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#rMask1" class="anchor" title="Link to rMask1">#</a>
               </h3>
               
               <p>[rMask0, rMask1] is the specified Poly1305 clamping mask in little-endian. It
clears some bits of the secret coefficient to make it possible to implement
multiplication more efficiently.</p>
               
               <pre><code>const rMask1 = 0x0FFFFFFC0FFFFFFC</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="MAC" data-name="MAC">
               <h3>
                  MAC
                  <span class="badge">struct</span>
                  <a href="#MAC" class="anchor" title="Link to MAC">#</a>
               </h3>
               
               <p>MAC is an io.Writer computing an authentication tag
of the data written to it.
MAC cannot be used like common hash.Hash implementations,
because using a poly1305 key twice breaks its security.
Therefore writing data to a running MAC after calling
Sum or Verify causes it to panic.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MAC struct {
mac
finalized bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mac" data-name="mac">
               <h3>
                  mac
                  <span class="badge">struct</span>
                  <a href="#mac" class="anchor" title="Link to mac">#</a>
               </h3>
               
               <p>mac is a wrapper for macGeneric that redirects calls that would have gone to
updateGeneric to update.
Its Write and Sum methods are otherwise identical to the macGeneric ones, but
using function pointers would carry a major performance cost.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mac struct {
macGeneric
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mac" data-name="mac">
               <h3>
                  mac
                  <span class="badge">struct</span>
                  <a href="#mac" class="anchor" title="Link to mac">#</a>
               </h3>
               
               <p>mac is a replacement for macGeneric that uses a larger buffer and redirects
calls that would have gone to updateGeneric to updateVX if the vector
facility is installed.
A larger buffer is required for good performance because the vector
implementation has a higher fixed cost per call than the generic
implementation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mac struct {
macState
buffer [*ast.BinaryExpr]byte
offset int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mac" data-name="mac">
               <h3>
                  mac
                  <span class="badge">struct</span>
                  <a href="#mac" class="anchor" title="Link to mac">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mac struct {
macGeneric
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mac" data-name="mac">
               <h3>
                  mac
                  <span class="badge">struct</span>
                  <a href="#mac" class="anchor" title="Link to mac">#</a>
               </h3>
               
               <p>mac is a wrapper for macGeneric that redirects calls that would have gone to
updateGeneric to update.
Its Write and Sum methods are otherwise identical to the macGeneric ones, but
using function pointers would carry a major performance cost.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mac struct {
macGeneric
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="macGeneric" data-name="macGeneric">
               <h3>
                  macGeneric
                  <span class="badge">struct</span>
                  <a href="#macGeneric" class="anchor" title="Link to macGeneric">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type macGeneric struct {
macState
buffer [TagSize]byte
offset int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="macState" data-name="macState">
               <h3>
                  macState
                  <span class="badge">struct</span>
                  <a href="#macState" class="anchor" title="Link to macState">#</a>
               </h3>
               
               <p>macState holds numbers in saturated 64-bit little-endian limbs. That is,
the value of [x0, x1, x2] is x[0] + x[1] * 2⁶⁴ + x[2] * 2¹²⁸.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type macState struct {
h [3]uint64
r [2]uint64
s [2]uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="uint128" data-name="uint128">
               <h3>
                  uint128
                  <span class="badge">struct</span>
                  <a href="#uint128" class="anchor" title="Link to uint128">#</a>
               </h3>
               
               <p>uint128 holds a 128-bit number as two 64-bit limbs, for use with the
bits.Mul64 and bits.Add64 intrinsics.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type uint128 struct {
lo uint64
hi uint64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New returns a new MAC computing an authentication
tag of all data written to it with the given key.
This allows writing the message progressively instead
of passing it as a single slice. Common users should use
the Sum function instead.
The key must be unique for each message, as authenticating
two different messages with the same key allows an attacker
to forge messages at will.</p>
               
               <pre><code>func New(key *[32]byte) *MAC</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the number of bytes Sum will return.</p>
               
               <pre><code>func (h *MAC) Size() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <pre><code>func (h *mac) Sum(out *[16]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <pre><code>func (h *mac) Sum(out *[16]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum flushes the last incomplete chunk from the buffer, if any, and generates
the MAC output. It does not modify its state, in order to allow for multiple
calls to Sum, even if no Write is allowed after Sum.</p>
               
               <pre><code>func (h *macGeneric) Sum(out *[TagSize]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum computes the authenticator of all data written to the
message authentication code.</p>
               
               <pre><code>func (h *MAC) Sum(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge">function</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum generates an authenticator for msg using a one-time key and puts the
16-byte result into out. Authenticating two different messages with the same
key allows an attacker to forge messages at will.</p>
               
               <pre><code>func Sum(out *[16]byte, m []byte, key *[32]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <pre><code>func (h *mac) Sum(out *[TagSize]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Verify" data-name="Verify">
               <h3>
                  Verify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Verify" class="anchor" title="Link to Verify">#</a>
               </h3>
               
               <p>Verify returns whether the authenticator of all data written to
the message authentication code matches the expected value.</p>
               
               <pre><code>func (h *MAC) Verify(expected []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Verify" data-name="Verify">
               <h3>
                  Verify 
                  <span class="badge">function</span>
                  
                  <a href="#Verify" class="anchor" title="Link to Verify">#</a>
               </h3>
               
               <p>Verify returns true if mac is a valid authenticator for m with the given key.</p>
               
               <pre><code>func Verify(mac *[16]byte, m []byte, key *[32]byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (h *mac) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write splits the incoming message into TagSize chunks, and passes them to
update. It buffers incomplete chunks.</p>
               
               <pre><code>func (h *macGeneric) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (h *mac) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write adds more data to the running message authentication code.
It never returns an error.
It must not be called after the first call of Sum or Verify.</p>
               
               <pre><code>func (h *MAC) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (h *mac) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add128" data-name="add128">
               <h3>
                  add128 
                  <span class="badge">function</span>
                  
                  <a href="#add128" class="anchor" title="Link to add128">#</a>
               </h3>
               
               <pre><code>func add128(a uint128, b uint128) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finalize" data-name="finalize">
               <h3>
                  finalize 
                  <span class="badge">function</span>
                  
                  <a href="#finalize" class="anchor" title="Link to finalize">#</a>
               </h3>
               
               <p>finalize completes the modular reduction of h and computes
out = h + s  mod  2¹²⁸</p>
               
               <pre><code>func finalize(out *[TagSize]byte, h *[3]uint64, s *[2]uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initialize" data-name="initialize">
               <h3>
                  initialize 
                  <span class="badge">function</span>
                  
                  <a href="#initialize" class="anchor" title="Link to initialize">#</a>
               </h3>
               
               <p>initialize loads the 256-bit key into the two 128-bit secret values r and s.</p>
               
               <pre><code>func initialize(key *[32]byte, m *macState)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mul64" data-name="mul64">
               <h3>
                  mul64 
                  <span class="badge">function</span>
                  
                  <a href="#mul64" class="anchor" title="Link to mul64">#</a>
               </h3>
               
               <pre><code>func mul64(a uint64, b uint64) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newMACGeneric" data-name="newMACGeneric">
               <h3>
                  newMACGeneric 
                  <span class="badge">function</span>
                  
                  <a href="#newMACGeneric" class="anchor" title="Link to newMACGeneric">#</a>
               </h3>
               
               <pre><code>func newMACGeneric(key *[32]byte) macGeneric</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="select64" data-name="select64">
               <h3>
                  select64 
                  <span class="badge">function</span>
                  
                  <a href="#select64" class="anchor" title="Link to select64">#</a>
               </h3>
               
               <p>select64 returns x if v == 1 and y if v == 0, in constant time.</p>
               
               <pre><code>func select64(v uint64, x uint64, y uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shiftRightBy2" data-name="shiftRightBy2">
               <h3>
                  shiftRightBy2 
                  <span class="badge">function</span>
                  
                  <a href="#shiftRightBy2" class="anchor" title="Link to shiftRightBy2">#</a>
               </h3>
               
               <pre><code>func shiftRightBy2(a uint128) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sumGeneric" data-name="sumGeneric">
               <h3>
                  sumGeneric 
                  <span class="badge">function</span>
                  
                  <a href="#sumGeneric" class="anchor" title="Link to sumGeneric">#</a>
               </h3>
               
               <pre><code>func sumGeneric(out *[TagSize]byte, msg []byte, key *[32]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge">function</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func update(state *macState, msg []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge">function</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func update(state *macState, msg []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateGeneric" data-name="updateGeneric">
               <h3>
                  updateGeneric 
                  <span class="badge">function</span>
                  
                  <a href="#updateGeneric" class="anchor" title="Link to updateGeneric">#</a>
               </h3>
               
               <p>updateGeneric absorbs msg into the state.h accumulator. For each chunk m of
128 bits of message, it computes
h₊ = (h + m) * r  mod  2¹³⁰ - 5
If the msg length is not a multiple of TagSize, it assumes the last
incomplete chunk is the final one.</p>
               
               <pre><code>func updateGeneric(state *macState, msg []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateVX" data-name="updateVX">
               <h3>
                  updateVX 
                  <span class="badge">function</span>
                  
                  <a href="#updateVX" class="anchor" title="Link to updateVX">#</a>
               </h3>
               
               <p>updateVX is an assembly implementation of Poly1305 that uses vector
instructions. It must only be called if the vector facility (vx) is
available.
go:noescape</p>
               
               <pre><code>func updateVX(state *macState, msg []byte)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>