<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>main</code>
         </h1>
         <hr />
         
         <article class="global" data-name="root">
            <h2>root</h2>
            <hr />
            
            <pre><code>root</code></pre>
         </article>
         
         <article class="global" data-name="files">
            <h2>files</h2>
            <hr />
            
            <pre><code>files</code></pre>
         </article>
         
         <article class="global" data-name="ngo">
            <h2>ngo</h2>
            <hr />
            
            <pre><code>ngo</code></pre>
         </article>
         
         <article class="global" data-name="verbose">
            <h2>verbose</h2>
            <hr />
            
            <pre><code>verbose</code></pre>
         </article>
         
         <article class="global" data-name="nfiles">
            <h2>nfiles</h2>
            <hr />
            
            <pre><code>nfiles int</code></pre>
         </article>
         
         <article class="global" data-name="objectPtrNil">
            <h2>objectPtrNil</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>objectPtrNil</code></pre>
         </article>
         
         <article class="global" data-name="scopePtrNil">
            <h2>scopePtrNil</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>scopePtrNil</code></pre>
         </article>
         
         <article class="global" data-name="identType">
            <h2>identType</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>identType</code></pre>
         </article>
         
         <article class="global" data-name="objectPtrType">
            <h2>objectPtrType</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>objectPtrType</code></pre>
         </article>
         
         <article class="global" data-name="positionType">
            <h2>positionType</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>positionType</code></pre>
         </article>
         
         <article class="global" data-name="callExprType">
            <h2>callExprType</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>callExprType</code></pre>
         </article>
         
         <article class="global" data-name="scopePtrType">
            <h2>scopePtrType</h2>
            <hr />
            
            <p>Values/types for special cases.</p>
            
            <pre><code>scopePtrType</code></pre>
         </article>
         
         <article class="global" data-name="list">
            <h2>list</h2>
            <hr />
            
            <p>main operation modes</p>
            
            <pre><code>list</code></pre>
         </article>
         
         <article class="global" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>write</code></pre>
         </article>
         
         <article class="global" data-name="rewriteRule">
            <h2>rewriteRule</h2>
            <hr />
            
            <pre><code>rewriteRule</code></pre>
         </article>
         
         <article class="global" data-name="simplifyAST">
            <h2>simplifyAST</h2>
            <hr />
            
            <pre><code>simplifyAST</code></pre>
         </article>
         
         <article class="global" data-name="doDiff">
            <h2>doDiff</h2>
            <hr />
            
            <pre><code>doDiff</code></pre>
         </article>
         
         <article class="global" data-name="allErrors">
            <h2>allErrors</h2>
            <hr />
            
            <pre><code>allErrors</code></pre>
         </article>
         
         <article class="global" data-name="cpuprofile">
            <h2>cpuprofile</h2>
            <hr />
            
            <p>debugging</p>
            
            <pre><code>cpuprofile</code></pre>
         </article>
         
         <article class="global" data-name="tabWidth">
            <h2>tabWidth</h2>
            <hr />
            
            <p>Keep these in sync with go/format/format.go.</p>
            
            <pre><code>tabWidth</code></pre>
         </article>
         
         <article class="global" data-name="printerMode">
            <h2>printerMode</h2>
            <hr />
            
            <p>Keep these in sync with go/format/format.go.</p>
            
            <pre><code>printerMode</code></pre>
         </article>
         
         <article class="global" data-name="printerNormalizeNumbers">
            <h2>printerNormalizeNumbers</h2>
            <hr />
            
            <p>printerNormalizeNumbers means to canonicalize number literal prefixes
and exponents while printing. See https://golang.org/doc/go1.13#gofmt.

This value is defined in go/printer specifically for go/format and cmd/gofmt.</p>
            
            <pre><code>printerNormalizeNumbers</code></pre>
         </article>
         
         <article class="global" data-name="fdSem">
            <h2>fdSem</h2>
            <hr />
            
            <p>fdSem guards the number of concurrently-open file descriptors.

For now, this is arbitrarily set to 200, based on the observation that many
platforms default to a kernel limit of 256. Ideally, perhaps we should derive
it from rlimit on platforms that support that system call.

File descriptors opened from outside of this package are not tracked,
so this limit may be approximate.</p>
            
            <pre><code>fdSem</code></pre>
         </article>
         
         <article class="global" data-name="rewrite">
            <h2>rewrite</h2>
            <hr />
            
            <pre><code>rewrite func</code></pre>
         </article>
         
         <article class="global" data-name="parserMode">
            <h2>parserMode</h2>
            <hr />
            
            <pre><code>parserMode parser.Mode</code></pre>
         </article>
         
         <article class="global" data-name="exclusive">
            <h2>exclusive</h2>
            <hr />
            
            <p>exclusive is a weight that can be passed to a sequencer to cause
a task to be executed without any other concurrent tasks.</p>
            
            <pre><code>exclusive</code></pre>
         </article>
         
         <article class="global" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>update</code></pre>
         </article>
          
         <article class="struct" data-name="simplifier">
            <h2>type simplifier struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="sequencer">
            <h2>type sequencer struct</h2>
            <hr />
            
            <p>A sequencer performs concurrent tasks that may write output, but emits that
output in a deterministic order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">maxWeight int64
sem *semaphore.Weighted
prev *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="reporter">
            <h2>type reporter struct</h2>
            <hr />
            
            <p>A reporter reports output, warnings, and errors.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">prev *ast.ChanType
state *reporterState</code></pre>
         </article>
         
         <article class="struct" data-name="reporterState">
            <h2>type reporterState struct</h2>
            <hr />
            
            <p>reporterState carries the state of a reporter instance.

Only one reporter at a time may have access to a reporterState.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">out io.Writer
err io.Writer
exitCode int</code></pre>
         </article>
          
         <article class="function" data-name="gofmt">
            <h2>gofmt</h2>
            <hr />
            
            <pre><code>func gofmt(fset *token.FileSet, filename string, src *bytes.Buffer) error</code></pre>
         </article>
         
         <article class="function" data-name="testFile">
            <h2>testFile</h2>
            <hr />
            
            <pre><code>func testFile(t *testing.T, b1 *bytes.Buffer, b2 *bytes.Buffer, filename string)</code></pre>
         </article>
         
         <article class="function" data-name="testFiles">
            <h2>testFiles</h2>
            <hr />
            
            <pre><code>func testFiles(t *testing.T, filenames *ast.ChanType, done *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="genFilenames">
            <h2>genFilenames</h2>
            <hr />
            
            <pre><code>func genFilenames(t *testing.T, filenames *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="TestAll">
            <h2>TestAll</h2>
            <hr />
            
            <pre><code>func TestAll(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="initRewrite">
            <h2>initRewrite</h2>
            <hr />
            
            <pre><code>func initRewrite()</code></pre>
         </article>
         
         <article class="function" data-name="parseExpr">
            <h2>parseExpr</h2>
            <hr />
            
            <p>parseExpr parses s as an expression.
It might make sense to expand this to allow statement patterns,
but there are problems with preserving formatting and also
with what a wildcard for a statement looks like.</p>
            
            <pre><code>func parseExpr(s string, what string) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="rewriteFile">
            <h2>rewriteFile</h2>
            <hr />
            
            <p>rewriteFile applies the rewrite rule 'pattern -> replace' to an entire file.</p>
            
            <pre><code>func rewriteFile(fileSet *token.FileSet, pattern ast.Expr, replace ast.Expr, p *ast.File) *ast.File</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <p>set is a wrapper for x.Set(y); it protects the caller from panics if x cannot be changed to y.</p>
            
            <pre><code>func set(x reflect.Value, y reflect.Value)</code></pre>
         </article>
         
         <article class="function" data-name="apply">
            <h2>apply</h2>
            <hr />
            
            <p>apply replaces each AST field x in val with f(x), returning val.
To avoid extra conversions, f operates on the reflect.Value form.</p>
            
            <pre><code>func apply(f func, val reflect.Value) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="isWildcard">
            <h2>isWildcard</h2>
            <hr />
            
            <pre><code>func isWildcard(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <p>match reports whether pattern matches val,
recording wildcard submatches in m.
If m == nil, match checks whether pattern == val.</p>
            
            <pre><code>func match(m *ast.MapType, pattern reflect.Value, val reflect.Value) bool</code></pre>
         </article>
         
         <article class="function" data-name="subst">
            <h2>subst</h2>
            <hr />
            
            <p>subst returns a copy of pattern with values from m substituted in place
of wildcards and pos used as the position of tokens from the pattern.
if m == nil, subst returns a copy of pattern and doesn't change the line
number information.</p>
            
            <pre><code>func subst(m *ast.MapType, pattern reflect.Value, pos reflect.Value) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="Visit">
            <h2>Visit</h2>
            <hr />
            
            <pre><code>func Visit(node ast.Node) ast.Visitor</code></pre>
         </article>
         
         <article class="function" data-name="simplifyLiteral">
            <h2>simplifyLiteral</h2>
            <hr />
            
            <pre><code>func simplifyLiteral(typ reflect.Value, astType ast.Expr, x ast.Expr, px *ast.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="isBlank">
            <h2>isBlank</h2>
            <hr />
            
            <pre><code>func isBlank(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="simplify">
            <h2>simplify</h2>
            <hr />
            
            <pre><code>func simplify(f *ast.File)</code></pre>
         </article>
         
         <article class="function" data-name="removeEmptyDeclGroups">
            <h2>removeEmptyDeclGroups</h2>
            <hr />
            
            <pre><code>func removeEmptyDeclGroups(f *ast.File)</code></pre>
         </article>
         
         <article class="function" data-name="isEmpty">
            <h2>isEmpty</h2>
            <hr />
            
            <pre><code>func isEmpty(f *ast.File, g *ast.GenDecl) bool</code></pre>
         </article>
         
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <pre><code>func usage()</code></pre>
         </article>
         
         <article class="function" data-name="initParserMode">
            <h2>initParserMode</h2>
            <hr />
            
            <pre><code>func initParserMode()</code></pre>
         </article>
         
         <article class="function" data-name="isGoFile">
            <h2>isGoFile</h2>
            <hr />
            
            <pre><code>func isGoFile(f fs.DirEntry) bool</code></pre>
         </article>
         
         <article class="function" data-name="newSequencer">
            <h2>newSequencer</h2>
            <hr />
            
            <p>newSequencer returns a sequencer that allows concurrent tasks up to maxWeight
and writes tasks' output to out and err.</p>
            
            <pre><code>func newSequencer(maxWeight int64, out io.Writer, err io.Writer) *sequencer</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add blocks until the sequencer has enough weight to spare, then adds f as a
task to be executed concurrently.

If the weight is either negative or larger than the sequencer's maximum
weight, Add blocks until all other tasks have completed, then the task
executes exclusively (blocking all other calls to Add until it completes).

f may run concurrently in a goroutine, but its output to the passed-in
reporter will be sequential relative to the other tasks in the sequencer.

If f invokes a method on the reporter, execution of that method may block
until the previous task has finished. (To maximize concurrency, f should
avoid invoking the reporter until it has finished any parallelizable work.)

If f returns a non-nil error, that error will be reported after f's output
(if any) and will cause a nonzero final exit code.</p>
            
            <pre><code>func Add(weight int64, f func)</code></pre>
         </article>
         
         <article class="function" data-name="AddReport">
            <h2>AddReport</h2>
            <hr />
            
            <p>AddReport prints an error to s after the output of any previously-added
tasks, causing the final exit code to be nonzero.</p>
            
            <pre><code>func AddReport(err error)</code></pre>
         </article>
         
         <article class="function" data-name="GetExitCode">
            <h2>GetExitCode</h2>
            <hr />
            
            <p>GetExitCode waits for all previously-added tasks to complete, then returns an
exit code for the sequence suitable for passing to os.Exit.</p>
            
            <pre><code>func GetExitCode() int</code></pre>
         </article>
         
         <article class="function" data-name="getState">
            <h2>getState</h2>
            <hr />
            
            <p>getState blocks until any prior reporters are finished with the reporter
state, then returns the state for manipulation.</p>
            
            <pre><code>func getState() *reporterState</code></pre>
         </article>
         
         <article class="function" data-name="Warnf">
            <h2>Warnf</h2>
            <hr />
            
            <p>Warnf emits a warning message to the reporter's error stream,
without changing its exit code.</p>
            
            <pre><code>func Warnf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write emits a slice to the reporter's output stream.

Any error is returned to the caller, and does not otherwise affect the
reporter's exit code.</p>
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Report">
            <h2>Report</h2>
            <hr />
            
            <p>Report emits a non-nil error to the reporter's error stream,
changing its exit code to a nonzero value.</p>
            
            <pre><code>func Report(err error)</code></pre>
         </article>
         
         <article class="function" data-name="ExitCode">
            <h2>ExitCode</h2>
            <hr />
            
            <pre><code>func ExitCode() int</code></pre>
         </article>
         
         <article class="function" data-name="processFile">
            <h2>processFile</h2>
            <hr />
            
            <p>If info == nil, we are formatting stdin instead of a file.
If in == nil, the source is the contents of the file with the given filename.</p>
            
            <pre><code>func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) error</code></pre>
         </article>
         
         <article class="function" data-name="readFile">
            <h2>readFile</h2>
            <hr />
            
            <p>readFile reads the contents of filename, described by info.
If in is non-nil, readFile reads directly from it.
Otherwise, readFile opens and reads the file itself,
with the number of concurrently-open files limited by fdSem.</p>
            
            <pre><code>func readFile(filename string, info fs.FileInfo, in io.Reader) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="main">
            <h2>main</h2>
            <hr />
            
            <pre><code>func main()</code></pre>
         </article>
         
         <article class="function" data-name="gofmtMain">
            <h2>gofmtMain</h2>
            <hr />
            
            <pre><code>func gofmtMain(s *sequencer)</code></pre>
         </article>
         
         <article class="function" data-name="fileWeight">
            <h2>fileWeight</h2>
            <hr />
            
            <pre><code>func fileWeight(path string, info fs.FileInfo) int64</code></pre>
         </article>
         
         <article class="function" data-name="writeFile">
            <h2>writeFile</h2>
            <hr />
            
            <p>writeFile updates a file with the new formatted data.</p>
            
            <pre><code>func writeFile(filename string, orig []byte, formatted []byte, perm fs.FileMode, size int64) error</code></pre>
         </article>
         
         <article class="function" data-name="backupFile">
            <h2>backupFile</h2>
            <hr />
            
            <p>backupFile writes data to a new file named filename<number> with permissions perm,
with <number> randomly chosen such that the file name is unique. backupFile returns
the chosen file name.</p>
            
            <pre><code>func backupFile(filename string, data []byte, perm fs.FileMode) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="gofmtFlags">
            <h2>gofmtFlags</h2>
            <hr />
            
            <p>gofmtFlags looks for a comment of the form

	//gofmt flags

within the first maxLines lines of the given file,
and returns the flags string, if any. Otherwise it
returns the empty string.</p>
            
            <pre><code>func gofmtFlags(filename string, maxLines int) string</code></pre>
         </article>
         
         <article class="function" data-name="runTest">
            <h2>runTest</h2>
            <hr />
            
            <pre><code>func runTest(t *testing.T, in string, out string)</code></pre>
         </article>
         
         <article class="function" data-name="TestRewrite">
            <h2>TestRewrite</h2>
            <hr />
            
            <p>TestRewrite processes testdata/*.input files and compares them to the
corresponding testdata/*.golden files. The gofmt flags used to process
a file must be provided via a comment of the form

	//gofmt flags

in the processed file within the first 20 lines, if any.</p>
            
            <pre><code>func TestRewrite(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCRLF">
            <h2>TestCRLF</h2>
            <hr />
            
            <p>Test case for issue 3961.</p>
            
            <pre><code>func TestCRLF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBackupFile">
            <h2>TestBackupFile</h2>
            <hr />
            
            <pre><code>func TestBackupFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPermissions">
            <h2>TestPermissions</h2>
            <hr />
            
            <pre><code>func TestPermissions(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <p>parse parses src, which was read from the named file,
as a Go source file, declaration, or statement list.</p>
            
            <pre><code>func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (file *ast.File, sourceAdj func, indentAdj int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="format">
            <h2>format</h2>
            <hr />
            
            <p>format formats the given package file originally obtained from src
and adjusts the result based on the original source via sourceAdj
and indentAdj.</p>
            
            <pre><code>func format(fset *token.FileSet, file *ast.File, sourceAdj func, indentAdj int, src []byte, cfg printer.Config) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="isSpace">
            <h2>isSpace</h2>
            <hr />
            
            <p>isSpace reports whether the byte is a space character.
isSpace defines a space as being among the following bytes: ' ', '\t', '\n' and '\r'.</p>
            
            <pre><code>func isSpace(b byte) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
