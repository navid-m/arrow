<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>main</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"context"
"flag"
"fmt"
"go/ast"
"go/parser"
"go/printer"
"go/scanner"
"go/token"
"internal/diff"
"io"
"io/fs"
"math/rand"
"os"
"path/filepath"
"runtime"
"runtime/pprof"
"strconv"
"strings"
"cmd/internal/telemetry/counter"
"golang.org/x/sync/semaphore"
"bytes"
"go/ast"
"go/parser"
"go/printer"
"go/token"
"strings"
"fmt"
"go/ast"
"go/parser"
"go/token"
"os"
"reflect"
"strings"
"unicode"
"unicode/utf8"
"go/ast"
"go/token"
"reflect"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="allErrors">
               <h3>
                  allErrors 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var allErrors = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="callExprType">
               <h3>
                  callExprType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var callExprType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="cpuprofile">
               <h3>
                  cpuprofile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>debugging</p>
               
               <pre><code>var cpuprofile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="doDiff">
               <h3>
                  doDiff 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var doDiff = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="exclusive">
               <h3>
                  exclusive 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>exclusive is a weight that can be passed to a sequencer to cause
a task to be executed without any other concurrent tasks.</p>
               
               <pre><code>const exclusive = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="fdSem">
               <h3>
                  fdSem 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>fdSem guards the number of concurrently-open file descriptors.
For now, this is arbitrarily set to 200, based on the observation that many
platforms default to a kernel limit of 256. Ideally, perhaps we should derive
it from rlimit on platforms that support that system call.
File descriptors opened from outside of this package are not tracked,
so this limit may be approximate.</p>
               
               <pre><code>var fdSem = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="identType">
               <h3>
                  identType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var identType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="list">
               <h3>
                  list 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>main operation modes</p>
               
               <pre><code>var list = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="objectPtrNil">
               <h3>
                  objectPtrNil 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var objectPtrNil = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="objectPtrType">
               <h3>
                  objectPtrType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var objectPtrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="parserMode">
               <h3>
                  parserMode 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var parserMode parser.Mode</code></pre>
            </article>
            
            <article class="global" data-name="positionType">
               <h3>
                  positionType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var positionType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="printerMode">
               <h3>
                  printerMode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Keep these in sync with go/format/format.go.</p>
               
               <pre><code>const printerMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="printerNormalizeNumbers">
               <h3>
                  printerNormalizeNumbers 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>printerNormalizeNumbers means to canonicalize number literal prefixes
and exponents while printing. See https://golang.org/doc/go1.13#gofmt.
This value is defined in go/printer specifically for go/format and cmd/gofmt.</p>
               
               <pre><code>const printerNormalizeNumbers = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="rewrite">
               <h3>
                  rewrite 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rewrite func(*token.FileSet, *ast.File) *ast.File</code></pre>
            </article>
            
            <article class="global" data-name="rewriteRule">
               <h3>
                  rewriteRule 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rewriteRule = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="scopePtrNil">
               <h3>
                  scopePtrNil 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var scopePtrNil = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="scopePtrType">
               <h3>
                  scopePtrType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Values/types for special cases.</p>
               
               <pre><code>var scopePtrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="simplifyAST">
               <h3>
                  simplifyAST 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var simplifyAST = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="tabWidth">
               <h3>
                  tabWidth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Keep these in sync with go/format/format.go.</p>
               
               <pre><code>const tabWidth = 8</code></pre>
            </article>
            
            <article class="global" data-name="write">
               <h3>
                  write 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var write = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="reporter">
               <h3>
                  reporter
                  <span class="badge">struct</span>
               </h3>
               
               <p>A reporter reports output, warnings, and errors.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reporter struct {
prev <-chan *reporterState
state *reporterState
}</code></pre>
            </article>
            
            <article class="struct" data-name="reporterState">
               <h3>
                  reporterState
                  <span class="badge">struct</span>
               </h3>
               
               <p>reporterState carries the state of a reporter instance.
Only one reporter at a time may have access to a reporterState.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reporterState struct {
out io.Writer
err io.Writer
exitCode int
}</code></pre>
            </article>
            
            <article class="struct" data-name="sequencer">
               <h3>
                  sequencer
                  <span class="badge">struct</span>
               </h3>
               
               <p>A sequencer performs concurrent tasks that may write output, but emits that
output in a deterministic order.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sequencer struct {
maxWeight int64
sem *semaphore.Weighted
prev <-chan *reporterState
}</code></pre>
            </article>
            
            <article class="struct" data-name="simplifier">
               <h3>
                  simplifier
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type simplifier struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add blocks until the sequencer has enough weight to spare, then adds f as a
task to be executed concurrently.
If the weight is either negative or larger than the sequencer's maximum
weight, Add blocks until all other tasks have completed, then the task
executes exclusively (blocking all other calls to Add until it completes).
f may run concurrently in a goroutine, but its output to the passed-in
reporter will be sequential relative to the other tasks in the sequencer.
If f invokes a method on the reporter, execution of that method may block
until the previous task has finished. (To maximize concurrency, f should
avoid invoking the reporter until it has finished any parallelizable work.)
If f returns a non-nil error, that error will be reported after f's output
(if any) and will cause a nonzero final exit code.</p>
               
               <pre><code>func (s *sequencer) Add(weight int64, f func(*reporter) error)</code></pre>
            </article>
            
            <article class="function" data-name="AddReport">
               <h3>
                  AddReport 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddReport prints an error to s after the output of any previously-added
tasks, causing the final exit code to be nonzero.</p>
               
               <pre><code>func (s *sequencer) AddReport(err error)</code></pre>
            </article>
            
            <article class="function" data-name="ExitCode">
               <h3>
                  ExitCode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *reporter) ExitCode() int</code></pre>
            </article>
            
            <article class="function" data-name="GetExitCode">
               <h3>
                  GetExitCode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GetExitCode waits for all previously-added tasks to complete, then returns an
exit code for the sequence suitable for passing to os.Exit.</p>
               
               <pre><code>func (s *sequencer) GetExitCode() int</code></pre>
            </article>
            
            <article class="function" data-name="Report">
               <h3>
                  Report 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Report emits a non-nil error to the reporter's error stream,
changing its exit code to a nonzero value.</p>
               
               <pre><code>func (r *reporter) Report(err error)</code></pre>
            </article>
            
            <article class="function" data-name="Visit">
               <h3>
                  Visit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s simplifier) Visit(node ast.Node) ast.Visitor</code></pre>
            </article>
            
            <article class="function" data-name="Warnf">
               <h3>
                  Warnf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Warnf emits a warning message to the reporter's error stream,
without changing its exit code.</p>
               
               <pre><code>func (r *reporter) Warnf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write emits a slice to the reporter's output stream.
Any error is returned to the caller, and does not otherwise affect the
reporter's exit code.</p>
               
               <pre><code>func (r *reporter) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="apply">
               <h3>
                  apply 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>apply replaces each AST field x in val with f(x), returning val.
To avoid extra conversions, f operates on the reflect.Value form.</p>
               
               <pre><code>func apply(f func(reflect.Value) reflect.Value, val reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="backupFile">
               <h3>
                  backupFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>backupFile writes data to a new file named filename<number> with permissions perm,
with <number> randomly chosen such that the file name is unique. backupFile returns
the chosen file name.</p>
               
               <pre><code>func backupFile(filename string, data []byte, perm fs.FileMode) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileWeight">
               <h3>
                  fileWeight 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileWeight(path string, info fs.FileInfo) int64</code></pre>
            </article>
            
            <article class="function" data-name="format">
               <h3>
                  format 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>format formats the given package file originally obtained from src
and adjusts the result based on the original source via sourceAdj
and indentAdj.</p>
               
               <pre><code>func format(fset *token.FileSet, file *ast.File, sourceAdj func(src []byte, indent int) []byte, indentAdj int, src []byte, cfg printer.Config) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="getState">
               <h3>
                  getState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getState blocks until any prior reporters are finished with the reporter
state, then returns the state for manipulation.</p>
               
               <pre><code>func (r *reporter) getState() *reporterState</code></pre>
            </article>
            
            <article class="function" data-name="gofmtMain">
               <h3>
                  gofmtMain 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gofmtMain(s *sequencer)</code></pre>
            </article>
            
            <article class="function" data-name="initParserMode">
               <h3>
                  initParserMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initParserMode()</code></pre>
            </article>
            
            <article class="function" data-name="initRewrite">
               <h3>
                  initRewrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initRewrite()</code></pre>
            </article>
            
            <article class="function" data-name="isBlank">
               <h3>
                  isBlank 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isBlank(x ast.Expr) bool</code></pre>
            </article>
            
            <article class="function" data-name="isEmpty">
               <h3>
                  isEmpty 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isEmpty(f *ast.File, g *ast.GenDecl) bool</code></pre>
            </article>
            
            <article class="function" data-name="isGoFile">
               <h3>
                  isGoFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isGoFile(f fs.DirEntry) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isSpace reports whether the byte is a space character.
isSpace defines a space as being among the following bytes: ' ', '\t', '\n' and '\r'.</p>
               
               <pre><code>func isSpace(b byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isWildcard(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="main">
               <h3>
                  main 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func main()</code></pre>
            </article>
            
            <article class="function" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>match reports whether pattern matches val,
recording wildcard submatches in m.
If m == nil, match checks whether pattern == val.</p>
               
               <pre><code>func match(m map[string]reflect.Value, pattern reflect.Value, val reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="newSequencer">
               <h3>
                  newSequencer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newSequencer returns a sequencer that allows concurrent tasks up to maxWeight
and writes tasks' output to out and err.</p>
               
               <pre><code>func newSequencer(maxWeight int64, out io.Writer, err io.Writer) *sequencer</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parse parses src, which was read from the named file,
as a Go source file, declaration, or statement list.</p>
               
               <pre><code>func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (file *ast.File, sourceAdj func(src []byte, indent int) []byte, indentAdj int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseExpr">
               <h3>
                  parseExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseExpr parses s as an expression.
It might make sense to expand this to allow statement patterns,
but there are problems with preserving formatting and also
with what a wildcard for a statement looks like.</p>
               
               <pre><code>func parseExpr(s string, what string) ast.Expr</code></pre>
            </article>
            
            <article class="function" data-name="processFile">
               <h3>
                  processFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If info == nil, we are formatting stdin instead of a file.
If in == nil, the source is the contents of the file with the given filename.</p>
               
               <pre><code>func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) error</code></pre>
            </article>
            
            <article class="function" data-name="readFile">
               <h3>
                  readFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readFile reads the contents of filename, described by info.
If in is non-nil, readFile reads directly from it.
Otherwise, readFile opens and reads the file itself,
with the number of concurrently-open files limited by fdSem.</p>
               
               <pre><code>func readFile(filename string, info fs.FileInfo, in io.Reader) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="removeEmptyDeclGroups">
               <h3>
                  removeEmptyDeclGroups 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func removeEmptyDeclGroups(f *ast.File)</code></pre>
            </article>
            
            <article class="function" data-name="rewriteFile">
               <h3>
                  rewriteFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rewriteFile applies the rewrite rule 'pattern -> replace' to an entire file.</p>
               
               <pre><code>func rewriteFile(fileSet *token.FileSet, pattern ast.Expr, replace ast.Expr, p *ast.File) *ast.File</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>set is a wrapper for x.Set(y); it protects the caller from panics if x cannot be changed to y.</p>
               
               <pre><code>func set(x reflect.Value, y reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="simplify">
               <h3>
                  simplify 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func simplify(f *ast.File)</code></pre>
            </article>
            
            <article class="function" data-name="simplifyLiteral">
               <h3>
                  simplifyLiteral 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s simplifier) simplifyLiteral(typ reflect.Value, astType ast.Expr, x ast.Expr, px *ast.Expr)</code></pre>
            </article>
            
            <article class="function" data-name="subst">
               <h3>
                  subst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>subst returns a copy of pattern with values from m substituted in place
of wildcards and pos used as the position of tokens from the pattern.
if m == nil, subst returns a copy of pattern and doesn't change the line
number information.</p>
               
               <pre><code>func subst(m map[string]reflect.Value, pattern reflect.Value, pos reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="usage">
               <h3>
                  usage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func usage()</code></pre>
            </article>
            
            <article class="function" data-name="writeFile">
               <h3>
                  writeFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeFile updates a file with the new formatted data.</p>
               
               <pre><code>func writeFile(filename string, orig []byte, formatted []byte, perm fs.FileMode, size int64) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
