<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - driver</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>driver</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"context"
"errors"
"reflect"
"fmt"
"reflect"
"strconv"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Bool" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Bool" class="anchor" title="Link to Bool">#</a>
               </h3>
               
               <p>Bool is a [ValueConverter] that converts input values to bool.
The conversion rules are:
- booleans are returned unchanged
- for integer types,
1 is true
0 is false,
other integers are an error
- for strings and []byte, same rules as [strconv.ParseBool]
- all other types are an error</p>
               
               <pre><code>var Bool boolType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultParameterConverter" data-name="DefaultParameterConverter">
               <h3>
                  DefaultParameterConverter 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DefaultParameterConverter" class="anchor" title="Link to DefaultParameterConverter">#</a>
               </h3>
               
               <p>DefaultParameterConverter is the default implementation of
[ValueConverter] that's used when a [Stmt] doesn't implement
[ColumnConverter].
DefaultParameterConverter returns its argument directly if
IsValue(arg). Otherwise, if the argument implements [Valuer], its
Value method is used to return a [Value]. As a fallback, the provided
argument's underlying type is used to convert it to a [Value]:
underlying integer types are converted to int64, floats to float64,
bool, string, and []byte to themselves. If the argument is a nil
pointer, defaultConverter.ConvertValue returns a nil [Value].
If the argument is a non-nil pointer, it is dereferenced and
defaultConverter.ConvertValue is called recursively. Other types
are an error.</p>
               
               <pre><code>var DefaultParameterConverter defaultConverter</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrBadConn" data-name="ErrBadConn">
               <h3>
                  ErrBadConn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBadConn" class="anchor" title="Link to ErrBadConn">#</a>
               </h3>
               
               <p>ErrBadConn should be returned by a driver to signal to the [database/sql]
package that a driver.[Conn] is in a bad state (such as the server
having earlier closed the connection) and the [database/sql] package should
retry on a new connection.
To prevent duplicate operations, ErrBadConn should NOT be returned
if there's a possibility that the database server might have
performed the operation. Even if the server sends back an error,
you shouldn't return ErrBadConn.
Errors will be checked using [errors.Is]. An error may
wrap ErrBadConn or implement the Is(error) bool method.</p>
               
               <pre><code>var ErrBadConn = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrRemoveArgument" data-name="ErrRemoveArgument">
               <h3>
                  ErrRemoveArgument 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrRemoveArgument" class="anchor" title="Link to ErrRemoveArgument">#</a>
               </h3>
               
               <p>ErrRemoveArgument may be returned from [NamedValueChecker] to instruct the
[database/sql] package to not pass the argument to the driver query interface.
Return when accepting query specific options or structures that aren't
SQL query arguments.</p>
               
               <pre><code>var ErrRemoveArgument = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrSkip" data-name="ErrSkip">
               <h3>
                  ErrSkip 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrSkip" class="anchor" title="Link to ErrSkip">#</a>
               </h3>
               
               <p>ErrSkip may be returned by some optional interfaces' methods to
indicate at runtime that the fast path is unavailable and the sql
package should continue as if the optional interface was not
implemented. ErrSkip is only supported where explicitly
documented.</p>
               
               <pre><code>var ErrSkip = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int32" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Int32" class="anchor" title="Link to Int32">#</a>
               </h3>
               
               <p>Int32 is a [ValueConverter] that converts input values to int64,
respecting the limits of an int32 value.</p>
               
               <pre><code>var Int32 int32Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultNoRows" data-name="ResultNoRows">
               <h3>
                  ResultNoRows 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ResultNoRows" class="anchor" title="Link to ResultNoRows">#</a>
               </h3>
               
               <p>ResultNoRows is a pre-defined [Result] for drivers to return when a DDL
command (such as a CREATE TABLE) succeeds. It returns an error for both
LastInsertId and [RowsAffected].</p>
               
               <pre><code>var ResultNoRows noRows</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String is a [ValueConverter] that converts its input to a string.
If the value is already a string or []byte, it's unchanged.
If the value is of another type, conversion to string is done
with fmt.Sprintf("%v", v).</p>
               
               <pre><code>var String stringType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ Result = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ ValueConverter = int32Type{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ ValueConverter = boolType{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ Result = noRows{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ ValueConverter = defaultConverter{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="valuerReflectType" data-name="valuerReflectType">
               <h3>
                  valuerReflectType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#valuerReflectType" class="anchor" title="Link to valuerReflectType">#</a>
               </h3>
               
               <pre><code>var valuerReflectType = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="IsolationLevel" data-name="IsolationLevel">
               <h3>
                  IsolationLevel
                  <span class="badge type-badge">type</span>
                  <a href="#IsolationLevel" class="anchor" title="Link to IsolationLevel">#</a>
               </h3>
               
               <p>IsolationLevel is the transaction isolation level stored in [TxOptions].
This type should be considered identical to [database/sql.IsolationLevel] along
with any values defined on it.</p>
               
               <pre><code>type IsolationLevel int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="RowsAffected" data-name="RowsAffected">
               <h3>
                  RowsAffected
                  <span class="badge type-badge">type</span>
                  <a href="#RowsAffected" class="anchor" title="Link to RowsAffected">#</a>
               </h3>
               
               <p>RowsAffected implements [Result] for an INSERT or UPDATE operation
which mutates a number of rows.</p>
               
               <pre><code>type RowsAffected int64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value
                  <span class="badge type-badge">type</span>
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <p>Value is a value that drivers must be able to handle.
It is either nil, a type handled by a database driver's [NamedValueChecker]
interface, or an instance of one of these types:
int64
float64
bool
[]byte
string
time.Time
If the driver supports cursors, a returned Value may also implement the [Rows] interface
in this package. This is used, for example, when a user selects a cursor
such as "select cursor(select * from my_table) from dual". If the [Rows]
from the select is closed, the cursor [Rows] will also be closed.</p>
               
               <pre><code>type Value any</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="ColumnConverter" data-name="ColumnConverter">
               <h3>
                  ColumnConverter
                  <span class="badge interface-badge">interface</span>
                  <a href="#ColumnConverter" class="anchor" title="Link to ColumnConverter">#</a>
               </h3>
               
               <p>ColumnConverter may be optionally implemented by [Stmt] if the
statement is aware of its own columns' types and can convert from
any type to a driver [Value].
Deprecated: Drivers should implement [NamedValueChecker].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ColumnConverter interface {
ColumnConverter(idx int) ValueConverter
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Conn" data-name="Conn">
               <h3>
                  Conn
                  <span class="badge interface-badge">interface</span>
                  <a href="#Conn" class="anchor" title="Link to Conn">#</a>
               </h3>
               
               <p>Conn is a connection to a database. It is not used concurrently
by multiple goroutines.
Conn is assumed to be stateful.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Conn interface {
Prepare(query string) (Stmt, error)
Close() error
Begin() (Tx, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ConnBeginTx" data-name="ConnBeginTx">
               <h3>
                  ConnBeginTx
                  <span class="badge interface-badge">interface</span>
                  <a href="#ConnBeginTx" class="anchor" title="Link to ConnBeginTx">#</a>
               </h3>
               
               <p>ConnBeginTx enhances the [Conn] interface with context and [TxOptions].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ConnBeginTx interface {
BeginTx(ctx context.Context, opts TxOptions) (Tx, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ConnPrepareContext" data-name="ConnPrepareContext">
               <h3>
                  ConnPrepareContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#ConnPrepareContext" class="anchor" title="Link to ConnPrepareContext">#</a>
               </h3>
               
               <p>ConnPrepareContext enhances the [Conn] interface with context.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ConnPrepareContext interface {
PrepareContext(ctx context.Context, query string) (Stmt, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Connector" data-name="Connector">
               <h3>
                  Connector
                  <span class="badge interface-badge">interface</span>
                  <a href="#Connector" class="anchor" title="Link to Connector">#</a>
               </h3>
               
               <p>A Connector represents a driver in a fixed configuration
and can create any number of equivalent Conns for use
by multiple goroutines.
A Connector can be passed to [database/sql.OpenDB], to allow drivers
to implement their own [database/sql.DB] constructors, or returned by
[DriverContext]'s OpenConnector method, to allow drivers
access to context and to avoid repeated parsing of driver
configuration.
If a Connector implements [io.Closer], the [database/sql.DB.Close]
method will call the Close method and return error (if any).</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Connector interface {
Connect(context.Context) (Conn, error)
Driver() Driver
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Driver" data-name="Driver">
               <h3>
                  Driver
                  <span class="badge interface-badge">interface</span>
                  <a href="#Driver" class="anchor" title="Link to Driver">#</a>
               </h3>
               
               <p>Driver is the interface that must be implemented by a database
driver.
Database drivers may implement [DriverContext] for access
to contexts and to parse the name only once for a pool of connections,
instead of once per connection.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Driver interface {
Open(name string) (Conn, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="DriverContext" data-name="DriverContext">
               <h3>
                  DriverContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#DriverContext" class="anchor" title="Link to DriverContext">#</a>
               </h3>
               
               <p>If a [Driver] implements DriverContext, then [database/sql.DB] will call
OpenConnector to obtain a [Connector] and then invoke
that [Connector]'s Connect method to obtain each needed connection,
instead of invoking the [Driver]'s Open method for each connection.
The two-step sequence allows drivers to parse the name just once
and also provides access to per-[Conn] contexts.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type DriverContext interface {
OpenConnector(name string) (Connector, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Execer" data-name="Execer">
               <h3>
                  Execer
                  <span class="badge interface-badge">interface</span>
                  <a href="#Execer" class="anchor" title="Link to Execer">#</a>
               </h3>
               
               <p>Execer is an optional interface that may be implemented by a [Conn].
If a [Conn] implements neither [ExecerContext] nor [Execer],
the [database/sql.DB.Exec] will first prepare a query, execute the statement,
and then close the statement.
Exec may return [ErrSkip].
Deprecated: Drivers should implement [ExecerContext] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Execer interface {
Exec(query string, args []Value) (Result, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ExecerContext" data-name="ExecerContext">
               <h3>
                  ExecerContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#ExecerContext" class="anchor" title="Link to ExecerContext">#</a>
               </h3>
               
               <p>ExecerContext is an optional interface that may be implemented by a [Conn].
If a [Conn] does not implement [ExecerContext], the [database/sql.DB.Exec]
will fall back to [Execer]; if the Conn does not implement Execer either,
[database/sql.DB.Exec] will first prepare a query, execute the statement, and then
close the statement.
ExecContext may return [ErrSkip].
ExecContext must honor the context timeout and return when the context is canceled.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ExecerContext interface {
ExecContext(ctx context.Context, query string, args []NamedValue) (Result, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="NamedValueChecker" data-name="NamedValueChecker">
               <h3>
                  NamedValueChecker
                  <span class="badge interface-badge">interface</span>
                  <a href="#NamedValueChecker" class="anchor" title="Link to NamedValueChecker">#</a>
               </h3>
               
               <p>NamedValueChecker may be optionally implemented by [Conn] or [Stmt]. It provides
the driver more control to handle Go and database types beyond the default
[Value] types allowed.
The [database/sql] package checks for value checkers in the following order,
stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker,
Stmt.ColumnConverter, [DefaultParameterConverter].
If CheckNamedValue returns [ErrRemoveArgument], the [NamedValue] will not be included in
the final query arguments. This may be used to pass special options to
the query itself.
If [ErrSkip] is returned the column converter error checking
path is used for the argument. Drivers may wish to return [ErrSkip] after
they have exhausted their own special cases.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type NamedValueChecker interface {
CheckNamedValue(*NamedValue) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Pinger" data-name="Pinger">
               <h3>
                  Pinger
                  <span class="badge interface-badge">interface</span>
                  <a href="#Pinger" class="anchor" title="Link to Pinger">#</a>
               </h3>
               
               <p>Pinger is an optional interface that may be implemented by a [Conn].
If a [Conn] does not implement Pinger, the [database/sql.DB.Ping] and
[database/sql.DB.PingContext] will check if there is at least one [Conn] available.
If Conn.Ping returns [ErrBadConn], [database/sql.DB.Ping] and [database/sql.DB.PingContext] will remove
the [Conn] from pool.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Pinger interface {
Ping(ctx context.Context) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Queryer" data-name="Queryer">
               <h3>
                  Queryer
                  <span class="badge interface-badge">interface</span>
                  <a href="#Queryer" class="anchor" title="Link to Queryer">#</a>
               </h3>
               
               <p>Queryer is an optional interface that may be implemented by a [Conn].
If a [Conn] implements neither [QueryerContext] nor [Queryer],
the [database/sql.DB.Query] will first prepare a query, execute the statement,
and then close the statement.
Query may return [ErrSkip].
Deprecated: Drivers should implement [QueryerContext] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Queryer interface {
Query(query string, args []Value) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="QueryerContext" data-name="QueryerContext">
               <h3>
                  QueryerContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#QueryerContext" class="anchor" title="Link to QueryerContext">#</a>
               </h3>
               
               <p>QueryerContext is an optional interface that may be implemented by a [Conn].
If a [Conn] does not implement QueryerContext, the [database/sql.DB.Query]
will fall back to [Queryer]; if the [Conn] does not implement [Queryer] either,
[database/sql.DB.Query] will first prepare a query, execute the statement, and then
close the statement.
QueryContext may return [ErrSkip].
QueryContext must honor the context timeout and return when the context is canceled.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type QueryerContext interface {
QueryContext(ctx context.Context, query string, args []NamedValue) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Result" data-name="Result">
               <h3>
                  Result
                  <span class="badge interface-badge">interface</span>
                  <a href="#Result" class="anchor" title="Link to Result">#</a>
               </h3>
               
               <p>Result is the result of a query execution.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Result interface {
LastInsertId() (int64, error)
RowsAffected() (int64, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Rows" data-name="Rows">
               <h3>
                  Rows
                  <span class="badge interface-badge">interface</span>
                  <a href="#Rows" class="anchor" title="Link to Rows">#</a>
               </h3>
               
               <p>Rows is an iterator over an executed query's results.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Rows interface {
Columns() []string
Close() error
Next(dest []Value) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RowsColumnTypeDatabaseTypeName" data-name="RowsColumnTypeDatabaseTypeName">
               <h3>
                  RowsColumnTypeDatabaseTypeName
                  <span class="badge interface-badge">interface</span>
                  <a href="#RowsColumnTypeDatabaseTypeName" class="anchor" title="Link to RowsColumnTypeDatabaseTypeName">#</a>
               </h3>
               
               <p>RowsColumnTypeDatabaseTypeName may be implemented by [Rows]. It should return the
database system type name without the length. Type names should be uppercase.
Examples of returned types: "VARCHAR", "NVARCHAR", "VARCHAR2", "CHAR", "TEXT",
"DECIMAL", "SMALLINT", "INT", "BIGINT", "BOOL", "[]BIGINT", "JSONB", "XML",
"TIMESTAMP".</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeDatabaseTypeName interface {
Rows
ColumnTypeDatabaseTypeName(index int) string
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RowsColumnTypeLength" data-name="RowsColumnTypeLength">
               <h3>
                  RowsColumnTypeLength
                  <span class="badge interface-badge">interface</span>
                  <a href="#RowsColumnTypeLength" class="anchor" title="Link to RowsColumnTypeLength">#</a>
               </h3>
               
               <p>RowsColumnTypeLength may be implemented by [Rows]. It should return the length
of the column type if the column is a variable length type. If the column is
not a variable length type ok should return false.
If length is not limited other than system limits, it should return [math.MaxInt64].
The following are examples of returned values for various types:
TEXT          (math.MaxInt64, true)
varchar(10)   (10, true)
nvarchar(10)  (10, true)
decimal       (0, false)
int           (0, false)
bytea(30)     (30, true)</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeLength interface {
Rows
ColumnTypeLength(index int) (length int64, ok bool)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RowsColumnTypeNullable" data-name="RowsColumnTypeNullable">
               <h3>
                  RowsColumnTypeNullable
                  <span class="badge interface-badge">interface</span>
                  <a href="#RowsColumnTypeNullable" class="anchor" title="Link to RowsColumnTypeNullable">#</a>
               </h3>
               
               <p>RowsColumnTypeNullable may be implemented by [Rows]. The nullable value should
be true if it is known the column may be null, or false if the column is known
to be not nullable.
If the column nullability is unknown, ok should be false.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeNullable interface {
Rows
ColumnTypeNullable(index int) (nullable bool, ok bool)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RowsColumnTypePrecisionScale" data-name="RowsColumnTypePrecisionScale">
               <h3>
                  RowsColumnTypePrecisionScale
                  <span class="badge interface-badge">interface</span>
                  <a href="#RowsColumnTypePrecisionScale" class="anchor" title="Link to RowsColumnTypePrecisionScale">#</a>
               </h3>
               
               <p>RowsColumnTypePrecisionScale may be implemented by [Rows]. It should return
the precision and scale for decimal types. If not applicable, ok should be false.
The following are examples of returned values for various types:
decimal(38, 4)    (38, 4, true)
int               (0, 0, false)
decimal           (math.MaxInt64, math.MaxInt64, true)</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypePrecisionScale interface {
Rows
ColumnTypePrecisionScale(index int) (precision int64, scale int64, ok bool)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RowsColumnTypeScanType" data-name="RowsColumnTypeScanType">
               <h3>
                  RowsColumnTypeScanType
                  <span class="badge interface-badge">interface</span>
                  <a href="#RowsColumnTypeScanType" class="anchor" title="Link to RowsColumnTypeScanType">#</a>
               </h3>
               
               <p>RowsColumnTypeScanType may be implemented by [Rows]. It should return
the value type that can be used to scan types into. For example, the database
column type "bigint" this should return "[reflect.TypeOf](int64(0))".</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeScanType interface {
Rows
ColumnTypeScanType(index int) reflect.Type
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="RowsNextResultSet" data-name="RowsNextResultSet">
               <h3>
                  RowsNextResultSet
                  <span class="badge interface-badge">interface</span>
                  <a href="#RowsNextResultSet" class="anchor" title="Link to RowsNextResultSet">#</a>
               </h3>
               
               <p>RowsNextResultSet extends the [Rows] interface by providing a way to signal
the driver to advance to the next result set.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsNextResultSet interface {
Rows
HasNextResultSet() bool
NextResultSet() error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="SessionResetter" data-name="SessionResetter">
               <h3>
                  SessionResetter
                  <span class="badge interface-badge">interface</span>
                  <a href="#SessionResetter" class="anchor" title="Link to SessionResetter">#</a>
               </h3>
               
               <p>SessionResetter may be implemented by [Conn] to allow drivers to reset the
session state associated with the connection and to signal a bad connection.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type SessionResetter interface {
ResetSession(ctx context.Context) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Stmt" data-name="Stmt">
               <h3>
                  Stmt
                  <span class="badge interface-badge">interface</span>
                  <a href="#Stmt" class="anchor" title="Link to Stmt">#</a>
               </h3>
               
               <p>Stmt is a prepared statement. It is bound to a [Conn] and not
used by multiple goroutines concurrently.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Stmt interface {
Close() error
NumInput() int
Exec(args []Value) (Result, error)
Query(args []Value) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="StmtExecContext" data-name="StmtExecContext">
               <h3>
                  StmtExecContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#StmtExecContext" class="anchor" title="Link to StmtExecContext">#</a>
               </h3>
               
               <p>StmtExecContext enhances the [Stmt] interface by providing Exec with context.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type StmtExecContext interface {
ExecContext(ctx context.Context, args []NamedValue) (Result, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="StmtQueryContext" data-name="StmtQueryContext">
               <h3>
                  StmtQueryContext
                  <span class="badge interface-badge">interface</span>
                  <a href="#StmtQueryContext" class="anchor" title="Link to StmtQueryContext">#</a>
               </h3>
               
               <p>StmtQueryContext enhances the [Stmt] interface by providing Query with context.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type StmtQueryContext interface {
QueryContext(ctx context.Context, args []NamedValue) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Tx" data-name="Tx">
               <h3>
                  Tx
                  <span class="badge interface-badge">interface</span>
                  <a href="#Tx" class="anchor" title="Link to Tx">#</a>
               </h3>
               
               <p>Tx is a transaction.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Tx interface {
Commit() error
Rollback() error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Validator" data-name="Validator">
               <h3>
                  Validator
                  <span class="badge interface-badge">interface</span>
                  <a href="#Validator" class="anchor" title="Link to Validator">#</a>
               </h3>
               
               <p>Validator may be implemented by [Conn] to allow drivers to
signal if a connection is valid or if it should be discarded.
If implemented, drivers may return the underlying error from queries,
even if the connection should be discarded by the connection pool.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Validator interface {
IsValid() bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ValueConverter" data-name="ValueConverter">
               <h3>
                  ValueConverter
                  <span class="badge interface-badge">interface</span>
                  <a href="#ValueConverter" class="anchor" title="Link to ValueConverter">#</a>
               </h3>
               
               <p>ValueConverter is the interface providing the ConvertValue method.
Various implementations of ValueConverter are provided by the
driver package to provide consistent implementations of conversions
between drivers. The ValueConverters have several uses:
- converting from the [Value] types as provided by the sql package
into a database table's specific column type and making sure it
fits, such as making sure a particular int64 fits in a
table's uint16 column.
- converting a value as given from the database into one of the
driver [Value] types.
- by the [database/sql] package, for converting from a driver's [Value] type
to a user's type in a scan.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ValueConverter interface {
ConvertValue(v any) (Value, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Valuer" data-name="Valuer">
               <h3>
                  Valuer
                  <span class="badge interface-badge">interface</span>
                  <a href="#Valuer" class="anchor" title="Link to Valuer">#</a>
               </h3>
               
               <p>Valuer is the interface providing the Value method.
Errors returned by the [Value] method are wrapped by the database/sql package.
This allows callers to use [errors.Is] for precise error handling after operations
like [database/sql.Query], [database/sql.Exec], or [database/sql.QueryRow].
Types implementing Valuer interface are able to convert
themselves to a driver [Value].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Valuer interface {
Value() (Value, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="decimalDecompose" data-name="decimalDecompose">
               <h3>
                  decimalDecompose
                  <span class="badge interface-badge">interface</span>
                  <a href="#decimalDecompose" class="anchor" title="Link to decimalDecompose">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type decimalDecompose interface {
Decompose(buf []byte) (form byte, negative bool, coefficient []byte, exponent int32)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="NamedValue" data-name="NamedValue">
               <h3>
                  NamedValue
                  <span class="badge">struct</span>
                  <a href="#NamedValue" class="anchor" title="Link to NamedValue">#</a>
               </h3>
               
               <p>NamedValue holds both the value name and value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NamedValue struct {
Name string
Ordinal int
Value Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NotNull" data-name="NotNull">
               <h3>
                  NotNull
                  <span class="badge">struct</span>
                  <a href="#NotNull" class="anchor" title="Link to NotNull">#</a>
               </h3>
               
               <p>NotNull is a type that implements [ValueConverter] by disallowing nil
values but otherwise delegating to another [ValueConverter].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NotNull struct {
Converter ValueConverter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Null" data-name="Null">
               <h3>
                  Null
                  <span class="badge">struct</span>
                  <a href="#Null" class="anchor" title="Link to Null">#</a>
               </h3>
               
               <p>Null is a type that implements [ValueConverter] by allowing nil
values but otherwise delegating to another [ValueConverter].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Null struct {
Converter ValueConverter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TxOptions" data-name="TxOptions">
               <h3>
                  TxOptions
                  <span class="badge">struct</span>
                  <a href="#TxOptions" class="anchor" title="Link to TxOptions">#</a>
               </h3>
               
               <p>TxOptions holds the transaction options.
This type should be considered identical to [database/sql.TxOptions].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TxOptions struct {
Isolation IsolationLevel
ReadOnly bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="boolType" data-name="boolType">
               <h3>
                  boolType
                  <span class="badge">struct</span>
                  <a href="#boolType" class="anchor" title="Link to boolType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type boolType struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="defaultConverter" data-name="defaultConverter">
               <h3>
                  defaultConverter
                  <span class="badge">struct</span>
                  <a href="#defaultConverter" class="anchor" title="Link to defaultConverter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type defaultConverter struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="int32Type" data-name="int32Type">
               <h3>
                  int32Type
                  <span class="badge">struct</span>
                  <a href="#int32Type" class="anchor" title="Link to int32Type">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type int32Type struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noRows" data-name="noRows">
               <h3>
                  noRows
                  <span class="badge">struct</span>
                  <a href="#noRows" class="anchor" title="Link to noRows">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noRows struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stringType" data-name="stringType">
               <h3>
                  stringType
                  <span class="badge">struct</span>
                  <a href="#stringType" class="anchor" title="Link to stringType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stringType struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ConvertValue" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertValue" class="anchor" title="Link to ConvertValue">#</a>
               </h3>
               
               <pre><code>func (n NotNull) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertValue" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertValue" class="anchor" title="Link to ConvertValue">#</a>
               </h3>
               
               <pre><code>func (stringType) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertValue" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertValue" class="anchor" title="Link to ConvertValue">#</a>
               </h3>
               
               <pre><code>func (int32Type) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertValue" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertValue" class="anchor" title="Link to ConvertValue">#</a>
               </h3>
               
               <pre><code>func (boolType) ConvertValue(src any) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertValue" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertValue" class="anchor" title="Link to ConvertValue">#</a>
               </h3>
               
               <pre><code>func (n Null) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertValue" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertValue" class="anchor" title="Link to ConvertValue">#</a>
               </h3>
               
               <pre><code>func (defaultConverter) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsScanValue" data-name="IsScanValue">
               <h3>
                  IsScanValue 
                  <span class="badge">function</span>
                  
                  <a href="#IsScanValue" class="anchor" title="Link to IsScanValue">#</a>
               </h3>
               
               <p>IsScanValue is equivalent to [IsValue].
It exists for compatibility.</p>
               
               <pre><code>func IsScanValue(v any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValue" data-name="IsValue">
               <h3>
                  IsValue 
                  <span class="badge">function</span>
                  
                  <a href="#IsValue" class="anchor" title="Link to IsValue">#</a>
               </h3>
               
               <p>IsValue reports whether v is a valid [Value] parameter type.</p>
               
               <pre><code>func IsValue(v any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LastInsertId" data-name="LastInsertId">
               <h3>
                  LastInsertId 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LastInsertId" class="anchor" title="Link to LastInsertId">#</a>
               </h3>
               
               <pre><code>func (noRows) LastInsertId() (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LastInsertId" data-name="LastInsertId">
               <h3>
                  LastInsertId 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LastInsertId" class="anchor" title="Link to LastInsertId">#</a>
               </h3>
               
               <pre><code>func (RowsAffected) LastInsertId() (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RowsAffected" data-name="RowsAffected">
               <h3>
                  RowsAffected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RowsAffected" class="anchor" title="Link to RowsAffected">#</a>
               </h3>
               
               <pre><code>func (noRows) RowsAffected() (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RowsAffected" data-name="RowsAffected">
               <h3>
                  RowsAffected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RowsAffected" class="anchor" title="Link to RowsAffected">#</a>
               </h3>
               
               <pre><code>func (v RowsAffected) RowsAffected() (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (boolType) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callValuerValue" data-name="callValuerValue">
               <h3>
                  callValuerValue 
                  <span class="badge">function</span>
                  
                  <a href="#callValuerValue" class="anchor" title="Link to callValuerValue">#</a>
               </h3>
               
               <p>callValuerValue returns vr.Value(), with one exception:
If vr.Value is an auto-generated method on a pointer type and the
pointer is nil, it would panic at runtime in the panicwrap
method. Treat it like nil instead.
Issue 8415.
This is so people can implement driver.Value on value types and
still use nil pointers to those types to mean nil/NULL, just like
string/*string.
This function is mirrored in the database/sql package.</p>
               
               <pre><code>func callValuerValue(vr Valuer) (v Value, err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>