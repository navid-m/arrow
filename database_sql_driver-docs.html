<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - driver</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>driver</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"context"
"errors"
"reflect"
"fmt"
"reflect"
"strconv"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Bool is a [ValueConverter] that converts input values to bool.
The conversion rules are:
- booleans are returned unchanged
- for integer types,
1 is true
0 is false,
other integers are an error
- for strings and []byte, same rules as [strconv.ParseBool]
- all other types are an error</p>
               
               <pre><code>var Bool boolType</code></pre>
            </article>
            
            <article class="global" data-name="DefaultParameterConverter">
               <h3>
                  DefaultParameterConverter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DefaultParameterConverter is the default implementation of
[ValueConverter] that's used when a [Stmt] doesn't implement
[ColumnConverter].
DefaultParameterConverter returns its argument directly if
IsValue(arg). Otherwise, if the argument implements [Valuer], its
Value method is used to return a [Value]. As a fallback, the provided
argument's underlying type is used to convert it to a [Value]:
underlying integer types are converted to int64, floats to float64,
bool, string, and []byte to themselves. If the argument is a nil
pointer, defaultConverter.ConvertValue returns a nil [Value].
If the argument is a non-nil pointer, it is dereferenced and
defaultConverter.ConvertValue is called recursively. Other types
are an error.</p>
               
               <pre><code>var DefaultParameterConverter defaultConverter</code></pre>
            </article>
            
            <article class="global" data-name="ErrBadConn">
               <h3>
                  ErrBadConn 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrBadConn should be returned by a driver to signal to the [database/sql]
package that a driver.[Conn] is in a bad state (such as the server
having earlier closed the connection) and the [database/sql] package should
retry on a new connection.
To prevent duplicate operations, ErrBadConn should NOT be returned
if there's a possibility that the database server might have
performed the operation. Even if the server sends back an error,
you shouldn't return ErrBadConn.
Errors will be checked using [errors.Is]. An error may
wrap ErrBadConn or implement the Is(error) bool method.</p>
               
               <pre><code>var ErrBadConn = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrRemoveArgument">
               <h3>
                  ErrRemoveArgument 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrRemoveArgument may be returned from [NamedValueChecker] to instruct the
[database/sql] package to not pass the argument to the driver query interface.
Return when accepting query specific options or structures that aren't
SQL query arguments.</p>
               
               <pre><code>var ErrRemoveArgument = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrSkip">
               <h3>
                  ErrSkip 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrSkip may be returned by some optional interfaces' methods to
indicate at runtime that the fast path is unavailable and the sql
package should continue as if the optional interface was not
implemented. ErrSkip is only supported where explicitly
documented.</p>
               
               <pre><code>var ErrSkip = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Int32 is a [ValueConverter] that converts input values to int64,
respecting the limits of an int32 value.</p>
               
               <pre><code>var Int32 int32Type</code></pre>
            </article>
            
            <article class="global" data-name="ResultNoRows">
               <h3>
                  ResultNoRows 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ResultNoRows is a pre-defined [Result] for drivers to return when a DDL
command (such as a CREATE TABLE) succeeds. It returns an error for both
LastInsertId and [RowsAffected].</p>
               
               <pre><code>var ResultNoRows noRows</code></pre>
            </article>
            
            <article class="global" data-name="String">
               <h3>
                  String 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>String is a [ValueConverter] that converts its input to a string.
If the value is already a string or []byte, it's unchanged.
If the value is of another type, conversion to string is done
with fmt.Sprintf("%v", v).</p>
               
               <pre><code>var String stringType</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ Result = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ ValueConverter = int32Type{...}</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ ValueConverter = boolType{...}</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ Result = noRows{...}</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ ValueConverter = defaultConverter{...}</code></pre>
            </article>
            
            <article class="global" data-name="valuerReflectType">
               <h3>
                  valuerReflectType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var valuerReflectType = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="IsolationLevel">
               <h3>
                  IsolationLevel
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>IsolationLevel is the transaction isolation level stored in [TxOptions].
This type should be considered identical to [database/sql.IsolationLevel] along
with any values defined on it.</p>
               
               <pre><code>type IsolationLevel int</code></pre>
            </article>
            
            <article class="type" data-name="RowsAffected">
               <h3>
                  RowsAffected
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>RowsAffected implements [Result] for an INSERT or UPDATE operation
which mutates a number of rows.</p>
               
               <pre><code>type RowsAffected int64</code></pre>
            </article>
            
            <article class="type" data-name="Value">
               <h3>
                  Value
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Value is a value that drivers must be able to handle.
It is either nil, a type handled by a database driver's [NamedValueChecker]
interface, or an instance of one of these types:
int64
float64
bool
[]byte
string
time.Time
If the driver supports cursors, a returned Value may also implement the [Rows] interface
in this package. This is used, for example, when a user selects a cursor
such as "select cursor(select * from my_table) from dual". If the [Rows]
from the select is closed, the cursor [Rows] will also be closed.</p>
               
               <pre><code>type Value any</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="ColumnConverter">
               <h3>
                  ColumnConverter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ColumnConverter may be optionally implemented by [Stmt] if the
statement is aware of its own columns' types and can convert from
any type to a driver [Value].
Deprecated: Drivers should implement [NamedValueChecker].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ColumnConverter interface {
ColumnConverter(idx int) ValueConverter
}</code></pre>
            </article>
            
            <article class="interface" data-name="Conn">
               <h3>
                  Conn
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Conn is a connection to a database. It is not used concurrently
by multiple goroutines.
Conn is assumed to be stateful.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Conn interface {
Prepare(query string) (Stmt, error)
Close() error
Begin() (Tx, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ConnBeginTx">
               <h3>
                  ConnBeginTx
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ConnBeginTx enhances the [Conn] interface with context and [TxOptions].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ConnBeginTx interface {
BeginTx(ctx context.Context, opts TxOptions) (Tx, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ConnPrepareContext">
               <h3>
                  ConnPrepareContext
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ConnPrepareContext enhances the [Conn] interface with context.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ConnPrepareContext interface {
PrepareContext(ctx context.Context, query string) (Stmt, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Connector">
               <h3>
                  Connector
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Connector represents a driver in a fixed configuration
and can create any number of equivalent Conns for use
by multiple goroutines.
A Connector can be passed to [database/sql.OpenDB], to allow drivers
to implement their own [database/sql.DB] constructors, or returned by
[DriverContext]'s OpenConnector method, to allow drivers
access to context and to avoid repeated parsing of driver
configuration.
If a Connector implements [io.Closer], the [database/sql.DB.Close]
method will call the Close method and return error (if any).</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Connector interface {
Connect(context.Context) (Conn, error)
Driver() Driver
}</code></pre>
            </article>
            
            <article class="interface" data-name="Driver">
               <h3>
                  Driver
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Driver is the interface that must be implemented by a database
driver.
Database drivers may implement [DriverContext] for access
to contexts and to parse the name only once for a pool of connections,
instead of once per connection.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Driver interface {
Open(name string) (Conn, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="DriverContext">
               <h3>
                  DriverContext
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>If a [Driver] implements DriverContext, then [database/sql.DB] will call
OpenConnector to obtain a [Connector] and then invoke
that [Connector]'s Connect method to obtain each needed connection,
instead of invoking the [Driver]'s Open method for each connection.
The two-step sequence allows drivers to parse the name just once
and also provides access to per-[Conn] contexts.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type DriverContext interface {
OpenConnector(name string) (Connector, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Execer">
               <h3>
                  Execer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Execer is an optional interface that may be implemented by a [Conn].
If a [Conn] implements neither [ExecerContext] nor [Execer],
the [database/sql.DB.Exec] will first prepare a query, execute the statement,
and then close the statement.
Exec may return [ErrSkip].
Deprecated: Drivers should implement [ExecerContext] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Execer interface {
Exec(query string, args []Value) (Result, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ExecerContext">
               <h3>
                  ExecerContext
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ExecerContext is an optional interface that may be implemented by a [Conn].
If a [Conn] does not implement [ExecerContext], the [database/sql.DB.Exec]
will fall back to [Execer]; if the Conn does not implement Execer either,
[database/sql.DB.Exec] will first prepare a query, execute the statement, and then
close the statement.
ExecContext may return [ErrSkip].
ExecContext must honor the context timeout and return when the context is canceled.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ExecerContext interface {
ExecContext(ctx context.Context, query string, args []NamedValue) (Result, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="NamedValueChecker">
               <h3>
                  NamedValueChecker
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>NamedValueChecker may be optionally implemented by [Conn] or [Stmt]. It provides
the driver more control to handle Go and database types beyond the default
[Value] types allowed.
The [database/sql] package checks for value checkers in the following order,
stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker,
Stmt.ColumnConverter, [DefaultParameterConverter].
If CheckNamedValue returns [ErrRemoveArgument], the [NamedValue] will not be included in
the final query arguments. This may be used to pass special options to
the query itself.
If [ErrSkip] is returned the column converter error checking
path is used for the argument. Drivers may wish to return [ErrSkip] after
they have exhausted their own special cases.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type NamedValueChecker interface {
CheckNamedValue(*NamedValue) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Pinger">
               <h3>
                  Pinger
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Pinger is an optional interface that may be implemented by a [Conn].
If a [Conn] does not implement Pinger, the [database/sql.DB.Ping] and
[database/sql.DB.PingContext] will check if there is at least one [Conn] available.
If Conn.Ping returns [ErrBadConn], [database/sql.DB.Ping] and [database/sql.DB.PingContext] will remove
the [Conn] from pool.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Pinger interface {
Ping(ctx context.Context) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Queryer">
               <h3>
                  Queryer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Queryer is an optional interface that may be implemented by a [Conn].
If a [Conn] implements neither [QueryerContext] nor [Queryer],
the [database/sql.DB.Query] will first prepare a query, execute the statement,
and then close the statement.
Query may return [ErrSkip].
Deprecated: Drivers should implement [QueryerContext] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Queryer interface {
Query(query string, args []Value) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="QueryerContext">
               <h3>
                  QueryerContext
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>QueryerContext is an optional interface that may be implemented by a [Conn].
If a [Conn] does not implement QueryerContext, the [database/sql.DB.Query]
will fall back to [Queryer]; if the [Conn] does not implement [Queryer] either,
[database/sql.DB.Query] will first prepare a query, execute the statement, and then
close the statement.
QueryContext may return [ErrSkip].
QueryContext must honor the context timeout and return when the context is canceled.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type QueryerContext interface {
QueryContext(ctx context.Context, query string, args []NamedValue) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Result">
               <h3>
                  Result
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Result is the result of a query execution.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Result interface {
LastInsertId() (int64, error)
RowsAffected() (int64, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Rows">
               <h3>
                  Rows
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Rows is an iterator over an executed query's results.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Rows interface {
Columns() []string
Close() error
Next(dest []Value) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="RowsColumnTypeDatabaseTypeName">
               <h3>
                  RowsColumnTypeDatabaseTypeName
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RowsColumnTypeDatabaseTypeName may be implemented by [Rows]. It should return the
database system type name without the length. Type names should be uppercase.
Examples of returned types: "VARCHAR", "NVARCHAR", "VARCHAR2", "CHAR", "TEXT",
"DECIMAL", "SMALLINT", "INT", "BIGINT", "BOOL", "[]BIGINT", "JSONB", "XML",
"TIMESTAMP".</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeDatabaseTypeName interface {
Rows
ColumnTypeDatabaseTypeName(index int) string
}</code></pre>
            </article>
            
            <article class="interface" data-name="RowsColumnTypeLength">
               <h3>
                  RowsColumnTypeLength
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RowsColumnTypeLength may be implemented by [Rows]. It should return the length
of the column type if the column is a variable length type. If the column is
not a variable length type ok should return false.
If length is not limited other than system limits, it should return [math.MaxInt64].
The following are examples of returned values for various types:
TEXT          (math.MaxInt64, true)
varchar(10)   (10, true)
nvarchar(10)  (10, true)
decimal       (0, false)
int           (0, false)
bytea(30)     (30, true)</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeLength interface {
Rows
ColumnTypeLength(index int) (length int64, ok bool)
}</code></pre>
            </article>
            
            <article class="interface" data-name="RowsColumnTypeNullable">
               <h3>
                  RowsColumnTypeNullable
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RowsColumnTypeNullable may be implemented by [Rows]. The nullable value should
be true if it is known the column may be null, or false if the column is known
to be not nullable.
If the column nullability is unknown, ok should be false.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeNullable interface {
Rows
ColumnTypeNullable(index int) (nullable bool, ok bool)
}</code></pre>
            </article>
            
            <article class="interface" data-name="RowsColumnTypePrecisionScale">
               <h3>
                  RowsColumnTypePrecisionScale
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RowsColumnTypePrecisionScale may be implemented by [Rows]. It should return
the precision and scale for decimal types. If not applicable, ok should be false.
The following are examples of returned values for various types:
decimal(38, 4)    (38, 4, true)
int               (0, 0, false)
decimal           (math.MaxInt64, math.MaxInt64, true)</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypePrecisionScale interface {
Rows
ColumnTypePrecisionScale(index int) (precision int64, scale int64, ok bool)
}</code></pre>
            </article>
            
            <article class="interface" data-name="RowsColumnTypeScanType">
               <h3>
                  RowsColumnTypeScanType
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RowsColumnTypeScanType may be implemented by [Rows]. It should return
the value type that can be used to scan types into. For example, the database
column type "bigint" this should return "[reflect.TypeOf](int64(0))".</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsColumnTypeScanType interface {
Rows
ColumnTypeScanType(index int) reflect.Type
}</code></pre>
            </article>
            
            <article class="interface" data-name="RowsNextResultSet">
               <h3>
                  RowsNextResultSet
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RowsNextResultSet extends the [Rows] interface by providing a way to signal
the driver to advance to the next result set.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RowsNextResultSet interface {
Rows
HasNextResultSet() bool
NextResultSet() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="SessionResetter">
               <h3>
                  SessionResetter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>SessionResetter may be implemented by [Conn] to allow drivers to reset the
session state associated with the connection and to signal a bad connection.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type SessionResetter interface {
ResetSession(ctx context.Context) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Stmt">
               <h3>
                  Stmt
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Stmt is a prepared statement. It is bound to a [Conn] and not
used by multiple goroutines concurrently.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Stmt interface {
Close() error
NumInput() int
Exec(args []Value) (Result, error)
Query(args []Value) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="StmtExecContext">
               <h3>
                  StmtExecContext
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>StmtExecContext enhances the [Stmt] interface by providing Exec with context.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type StmtExecContext interface {
ExecContext(ctx context.Context, args []NamedValue) (Result, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="StmtQueryContext">
               <h3>
                  StmtQueryContext
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>StmtQueryContext enhances the [Stmt] interface by providing Query with context.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type StmtQueryContext interface {
QueryContext(ctx context.Context, args []NamedValue) (Rows, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Tx">
               <h3>
                  Tx
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Tx is a transaction.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Tx interface {
Commit() error
Rollback() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Validator">
               <h3>
                  Validator
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Validator may be implemented by [Conn] to allow drivers to
signal if a connection is valid or if it should be discarded.
If implemented, drivers may return the underlying error from queries,
even if the connection should be discarded by the connection pool.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Validator interface {
IsValid() bool
}</code></pre>
            </article>
            
            <article class="interface" data-name="ValueConverter">
               <h3>
                  ValueConverter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ValueConverter is the interface providing the ConvertValue method.
Various implementations of ValueConverter are provided by the
driver package to provide consistent implementations of conversions
between drivers. The ValueConverters have several uses:
- converting from the [Value] types as provided by the sql package
into a database table's specific column type and making sure it
fits, such as making sure a particular int64 fits in a
table's uint16 column.
- converting a value as given from the database into one of the
driver [Value] types.
- by the [database/sql] package, for converting from a driver's [Value] type
to a user's type in a scan.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ValueConverter interface {
ConvertValue(v any) (Value, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Valuer">
               <h3>
                  Valuer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Valuer is the interface providing the Value method.
Errors returned by the [Value] method are wrapped by the database/sql package.
This allows callers to use [errors.Is] for precise error handling after operations
like [database/sql.Query], [database/sql.Exec], or [database/sql.QueryRow].
Types implementing Valuer interface are able to convert
themselves to a driver [Value].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Valuer interface {
Value() (Value, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="decimalDecompose">
               <h3>
                  decimalDecompose
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type decimalDecompose interface {
Decompose(buf []byte) (form byte, negative bool, coefficient []byte, exponent int32)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="NamedValue">
               <h3>
                  NamedValue
                  <span class="badge">struct</span>
               </h3>
               
               <p>NamedValue holds both the value name and value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NamedValue struct {
Name string
Ordinal int
Value Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="NotNull">
               <h3>
                  NotNull
                  <span class="badge">struct</span>
               </h3>
               
               <p>NotNull is a type that implements [ValueConverter] by disallowing nil
values but otherwise delegating to another [ValueConverter].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NotNull struct {
Converter ValueConverter
}</code></pre>
            </article>
            
            <article class="struct" data-name="Null">
               <h3>
                  Null
                  <span class="badge">struct</span>
               </h3>
               
               <p>Null is a type that implements [ValueConverter] by allowing nil
values but otherwise delegating to another [ValueConverter].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Null struct {
Converter ValueConverter
}</code></pre>
            </article>
            
            <article class="struct" data-name="TxOptions">
               <h3>
                  TxOptions
                  <span class="badge">struct</span>
               </h3>
               
               <p>TxOptions holds the transaction options.
This type should be considered identical to [database/sql.TxOptions].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TxOptions struct {
Isolation IsolationLevel
ReadOnly bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="boolType">
               <h3>
                  boolType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type boolType struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="defaultConverter">
               <h3>
                  defaultConverter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type defaultConverter struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="int32Type">
               <h3>
                  int32Type
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type int32Type struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="noRows">
               <h3>
                  noRows
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noRows struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="stringType">
               <h3>
                  stringType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stringType struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n NotNull) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (stringType) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (int32Type) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (boolType) ConvertValue(src any) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n Null) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="ConvertValue">
               <h3>
                  ConvertValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (defaultConverter) ConvertValue(v any) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="IsScanValue">
               <h3>
                  IsScanValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsScanValue is equivalent to [IsValue].
It exists for compatibility.</p>
               
               <pre><code>func IsScanValue(v any) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValue">
               <h3>
                  IsValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsValue reports whether v is a valid [Value] parameter type.</p>
               
               <pre><code>func IsValue(v any) bool</code></pre>
            </article>
            
            <article class="function" data-name="LastInsertId">
               <h3>
                  LastInsertId 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noRows) LastInsertId() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="LastInsertId">
               <h3>
                  LastInsertId 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (RowsAffected) LastInsertId() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="RowsAffected">
               <h3>
                  RowsAffected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noRows) RowsAffected() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="RowsAffected">
               <h3>
                  RowsAffected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v RowsAffected) RowsAffected() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (boolType) String() string</code></pre>
            </article>
            
            <article class="function" data-name="callValuerValue">
               <h3>
                  callValuerValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>callValuerValue returns vr.Value(), with one exception:
If vr.Value is an auto-generated method on a pointer type and the
pointer is nil, it would panic at runtime in the panicwrap
method. Treat it like nil instead.
Issue 8415.
This is so people can implement driver.Value on value types and
still use nil pointers to those types to mean nil/NULL, just like
string/*string.
This function is mirrored in the database/sql package.</p>
               
               <pre><code>func callValuerValue(vr Valuer) (v Value, err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
