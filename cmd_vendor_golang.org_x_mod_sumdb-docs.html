<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>sumdb - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_vendor_golang.org_x_mod_sumdb_dirhash-docs.html">dirhash</a></li>
               
               <li><a href="cmd_vendor_golang.org_x_mod_sumdb_note-docs.html">note</a></li>
               
               <li><a href="cmd_vendor_golang.org_x_mod_sumdb_tlog-docs.html">tlog</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>sumdb</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"sync"
"sync/atomic"
"bytes"
"errors"
"fmt"
"strings"
"sync"
"sync/atomic"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb/note"
"golang.org/x/mod/sumdb/tlog"
"bytes"
"context"
"net/http"
"os"
"strings"
"golang.org/x/mod/internal/lazyregexp"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb/tlog"
"context"
"fmt"
"sync"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb/note"
"golang.org/x/mod/sumdb/tlog"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrGONOSUMDB" data-name="ErrGONOSUMDB">
               <h3>
                  ErrGONOSUMDB 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrGONOSUMDB" class="anchor" title="Link to ErrGONOSUMDB">#</a>
               </h3>
               
                  <p class="doc-comment">ErrGONOSUMDB is returned by [Client.Lookup] for paths that match
a pattern listed in the GONOSUMDB list (set by [Client.SetGONOSUMDB],
usually from the environment variable).</p>
               
               <pre><code class="language-go">var ErrGONOSUMDB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrSecurity" data-name="ErrSecurity">
               <h3>
                  ErrSecurity 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrSecurity" class="anchor" title="Link to ErrSecurity">#</a>
               </h3>
               
                  <p class="doc-comment">ErrSecurity is returned by [Client] operations that invoke Client.SecurityError.</p>
               
               <pre><code class="language-go">var ErrSecurity = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrWriteConflict" data-name="ErrWriteConflict">
               <h3>
                  ErrWriteConflict 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrWriteConflict" class="anchor" title="Link to ErrWriteConflict">#</a>
               </h3>
               
                  <p class="doc-comment">ErrWriteConflict signals a write conflict during Client.WriteConfig.</p>
               
               <pre><code class="language-go">var ErrWriteConflict = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ServerPaths" data-name="ServerPaths">
               <h3>
                  ServerPaths 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ServerPaths" class="anchor" title="Link to ServerPaths">#</a>
               </h3>
               
                  <p class="doc-comment">ServerPaths are the URL paths the Server can (and should) serve.
Typically a server will do:
srv := sumdb.NewServer(ops)
for _, path := range sumdb.ServerPaths {
http.Handle(path, srv)
}</p>
               
               <pre><code class="language-go">var ServerPaths = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modVerRE" data-name="modVerRE">
               <h3>
                  modVerRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#modVerRE" class="anchor" title="Link to modVerRE">#</a>
               </h3>
               
               <pre><code class="language-go">var modVerRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="msgFuture" data-name="msgFuture">
               <h3>
                  msgFuture 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#msgFuture" class="anchor" title="Link to msgFuture">#</a>
               </h3>
               
               <pre><code class="language-go">const msgFuture</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="msgNow" data-name="msgNow">
               <h3>
                  msgNow 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#msgNow" class="anchor" title="Link to msgNow">#</a>
               </h3>
               
               <pre><code class="language-go">const msgNow</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="msgPast" data-name="msgPast">
               <h3>
                  msgPast 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#msgPast" class="anchor" title="Link to msgPast">#</a>
               </h3>
               
               <pre><code class="language-go">const msgPast = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="testHashes" data-name="testHashes">
               <h3>
                  testHashes
                  <span class="badge type-badge">type</span>
                  <a href="#testHashes" class="anchor" title="Link to testHashes">#</a>
               </h3>
               
               <p>testHashes implements tlog.HashReader, reading from a slice.</p>
               
               <pre><code class="language-go">type testHashes []tlog.Hash</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="ClientOps" data-name="ClientOps">
               <h3>
                  ClientOps
                  <span class="badge interface-badge">interface</span>
                  <a href="#ClientOps" class="anchor" title="Link to ClientOps">#</a>
               </h3>
               
               <p>A ClientOps provides the external operations
(file caching, HTTP fetches, and so on) needed by the [Client].
The methods must be safe for concurrent use by multiple goroutines.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ClientOps interface {
ReadRemote(path string) ([]byte, error)
ReadConfig(file string) ([]byte, error)
WriteConfig(file string, old []byte, new []byte) error
ReadCache(file string) ([]byte, error)
WriteCache(file string, data []byte)
Log(msg string)
SecurityError(msg string)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ServerOps" data-name="ServerOps">
               <h3>
                  ServerOps
                  <span class="badge interface-badge">interface</span>
                  <a href="#ServerOps" class="anchor" title="Link to ServerOps">#</a>
               </h3>
               
               <p>A ServerOps provides the external operations
(underlying database access and so on) needed by the [Server].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ServerOps interface {
Signed(ctx context.Context) ([]byte, error)
ReadRecords(ctx context.Context, id int64, n int64) ([][]byte, error)
Lookup(ctx context.Context, m module.Version) (int64, error)
ReadTileData(ctx context.Context, t tlog.Tile) ([]byte, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Client" data-name="Client">
               <h3>
                  Client
                  <span class="badge">struct</span>
                  <a href="#Client" class="anchor" title="Link to Client">#</a>
               </h3>
               
               <p>A Client is a client connection to a checksum database.
All the methods are safe for simultaneous use by multiple goroutines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Client struct {
ops ClientOps
didLookup uint32
initOnce sync.Once
initErr error
name string
verifiers note.Verifiers
tileReader tileReader
tileHeight int
nosumdb string
record parCache
tileCache parCache
latestMu sync.Mutex
latest tlog.Tree
latestMsg []byte
tileSavedMu sync.Mutex
tileSaved map[tlog.Tile]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Server" data-name="Server">
               <h3>
                  Server
                  <span class="badge">struct</span>
                  <a href="#Server" class="anchor" title="Link to Server">#</a>
               </h3>
               
               <p>A Server is the checksum database HTTP server,
which implements http.Handler and should be invoked
to serve the paths listed in [ServerPaths].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Server struct {
ops ServerOps
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TestServer" data-name="TestServer">
               <h3>
                  TestServer
                  <span class="badge">struct</span>
                  <a href="#TestServer" class="anchor" title="Link to TestServer">#</a>
               </h3>
               
               <p>A TestServer is an in-memory implementation of [ServerOps] for testing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TestServer struct {
signer string
gosum func(path string, vers string) ([]byte, error)
mu sync.Mutex
hashes testHashes
records [][]byte
lookup map[string]int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cacheEntry" data-name="cacheEntry">
               <h3>
                  cacheEntry
                  <span class="badge">struct</span>
                  <a href="#cacheEntry" class="anchor" title="Link to cacheEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cacheEntry struct {
done uint32
mu sync.Mutex
result interface{}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parCache" data-name="parCache">
               <h3>
                  parCache
                  <span class="badge">struct</span>
                  <a href="#parCache" class="anchor" title="Link to parCache">#</a>
               </h3>
               
               <p>parCache runs an action once per key and caches the result.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parCache struct {
m sync.Map
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tileReader" data-name="tileReader">
               <h3>
                  tileReader
                  <span class="badge">struct</span>
                  <a href="#tileReader" class="anchor" title="Link to tileReader">#</a>
               </h3>
               
               <p>tileReader is a *Client wrapper that implements tlog.TileReader.
The separate type avoids exposing the ReadTiles and SaveTiles
methods on Client itself.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type tileReader struct {
c *Client
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Do" data-name="Do">
               <h3>
                  Do 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Do" class="anchor" title="Link to Do">#</a>
               </h3>
               
               <p>Do calls the function f if and only if Do is being called for the first time with this key.
No call to Do with a given key returns until the one call to f returns.
Do returns the value returned by the one call to f.</p>
               
               <pre><code class="language-go">func (c *parCache) Do(key interface{}, f func() interface{}) interface{}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get returns the cached result associated with key.
It returns nil if there is no such result.
If the result for key is being computed, Get does not wait for the computation to finish.</p>
               
               <pre><code class="language-go">func (c *parCache) Get(key interface{}) interface{}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Height" data-name="Height">
               <h3>
                  Height 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Height" class="anchor" title="Link to Height">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *tileReader) Height() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup returns the go.sum lines for the given module path and version.
The version may end in a /go.mod suffix, in which case Lookup returns
the go.sum lines for the module's go.mod-only hash.</p>
               
               <pre><code class="language-go">func (c *Client) Lookup(path string, vers string) (lines []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *TestServer) Lookup(ctx context.Context, m module.Version) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewClient" data-name="NewClient">
               <h3>
                  NewClient 
                  <span class="badge">function</span>
                  
                  <a href="#NewClient" class="anchor" title="Link to NewClient">#</a>
               </h3>
               
               <p>NewClient returns a new [Client] using the given [ClientOps].</p>
               
               <pre><code class="language-go">func NewClient(ops ClientOps) *Client</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewServer" data-name="NewServer">
               <h3>
                  NewServer 
                  <span class="badge">function</span>
                  
                  <a href="#NewServer" class="anchor" title="Link to NewServer">#</a>
               </h3>
               
               <p>NewServer returns a new Server using the given operations.</p>
               
               <pre><code class="language-go">func NewServer(ops ServerOps) *Server</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTestServer" data-name="NewTestServer">
               <h3>
                  NewTestServer 
                  <span class="badge">function</span>
                  
                  <a href="#NewTestServer" class="anchor" title="Link to NewTestServer">#</a>
               </h3>
               
               <p>NewTestServer constructs a new [TestServer]
that will sign its tree with the given signer key
(see [golang.org/x/mod/sumdb/note])
and fetch new records as needed by calling gosum.</p>
               
               <pre><code class="language-go">func NewTestServer(signer string, gosum func(path string, vers string) ([]byte, error)) *TestServer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadHashes" data-name="ReadHashes">
               <h3>
                  ReadHashes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadHashes" class="anchor" title="Link to ReadHashes">#</a>
               </h3>
               
               <pre><code class="language-go">func (h testHashes) ReadHashes(indexes []int64) ([]tlog.Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRecords" data-name="ReadRecords">
               <h3>
                  ReadRecords 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRecords" class="anchor" title="Link to ReadRecords">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *TestServer) ReadRecords(ctx context.Context, id int64, n int64) ([][]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadTileData" data-name="ReadTileData">
               <h3>
                  ReadTileData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadTileData" class="anchor" title="Link to ReadTileData">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *TestServer) ReadTileData(ctx context.Context, t tlog.Tile) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadTiles" data-name="ReadTiles">
               <h3>
                  ReadTiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadTiles" class="anchor" title="Link to ReadTiles">#</a>
               </h3>
               
               <p>ReadTiles reads and returns the requested tiles,
either from the on-disk cache or the server.</p>
               
               <pre><code class="language-go">func (r *tileReader) ReadTiles(tiles []tlog.Tile) ([][]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SaveTiles" data-name="SaveTiles">
               <h3>
                  SaveTiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SaveTiles" class="anchor" title="Link to SaveTiles">#</a>
               </h3>
               
               <p>SaveTiles saves the now validated tiles.</p>
               
               <pre><code class="language-go">func (r *tileReader) SaveTiles(tiles []tlog.Tile, data [][]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetGONOSUMDB" data-name="SetGONOSUMDB">
               <h3>
                  SetGONOSUMDB 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetGONOSUMDB" class="anchor" title="Link to SetGONOSUMDB">#</a>
               </h3>
               
               <p>SetGONOSUMDB sets the list of comma-separated GONOSUMDB patterns for the Client.
For any module path matching one of the patterns,
[Client.Lookup] will return ErrGONOSUMDB.
SetGONOSUMDB can be called at most once,
and if so it must be called before the first call to Lookup.</p>
               
               <pre><code class="language-go">func (c *Client) SetGONOSUMDB(list string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetTileHeight" data-name="SetTileHeight">
               <h3>
                  SetTileHeight 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetTileHeight" class="anchor" title="Link to SetTileHeight">#</a>
               </h3>
               
               <p>SetTileHeight sets the tile height for the Client.
Any call to SetTileHeight must happen before the first call to [Client.Lookup].
If SetTileHeight is not called, the Client defaults to tile height 8.
SetTileHeight can be called at most once,
and if so it must be called before the first call to Lookup.</p>
               
               <pre><code class="language-go">func (c *Client) SetTileHeight(height int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Signed" data-name="Signed">
               <h3>
                  Signed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Signed" class="anchor" title="Link to Signed">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *TestServer) Signed(ctx context.Context) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkRecord" data-name="checkRecord">
               <h3>
                  checkRecord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkRecord" class="anchor" title="Link to checkRecord">#</a>
               </h3>
               
               <p>checkRecord checks that record #id's hash matches data.</p>
               
               <pre><code class="language-go">func (c *Client) checkRecord(id int64, data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkTrees" data-name="checkTrees">
               <h3>
                  checkTrees 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkTrees" class="anchor" title="Link to checkTrees">#</a>
               </h3>
               
               <p>checkTrees checks that older (from olderNote) is contained in newer (from newerNote).
If an error occurs, such as malformed data or a network problem, checkTrees returns that error.
If on the other hand checkTrees finds evidence of misbehavior, it prepares a detailed
message and calls log.Fatal.</p>
               
               <pre><code class="language-go">func (c *Client) checkTrees(older tlog.Tree, olderNote []byte, newer tlog.Tree, newerNote []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>init initializes the client (if not already initialized)
and returns any initialization error.</p>
               
               <pre><code class="language-go">func (c *Client) init() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initWork" data-name="initWork">
               <h3>
                  initWork 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initWork" class="anchor" title="Link to initWork">#</a>
               </h3>
               
               <p>initWork does the actual initialization work.</p>
               
               <pre><code class="language-go">func (c *Client) initWork()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markTileSaved" data-name="markTileSaved">
               <h3>
                  markTileSaved 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markTileSaved" class="anchor" title="Link to markTileSaved">#</a>
               </h3>
               
               <p>markTileSaved records that tile is already present in the on-disk cache,
so that a future SaveTiles for that tile can be ignored.</p>
               
               <pre><code class="language-go">func (c *Client) markTileSaved(tile tlog.Tile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeLatest" data-name="mergeLatest">
               <h3>
                  mergeLatest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mergeLatest" class="anchor" title="Link to mergeLatest">#</a>
               </h3>
               
               <p>mergeLatest merges the tree head in msg
with the Client's current latest tree head,
ensuring the result is a consistent timeline.
If the result is inconsistent, mergeLatest calls c.ops.SecurityError
with a detailed security error message and then
(only if c.ops.SecurityError does not exit the program) returns ErrSecurity.
If the Client's current latest tree head moves forward,
mergeLatest updates the underlying configuration file as well,
taking care to merge any independent updates to that configuration.</p>
               
               <pre><code class="language-go">func (c *Client) mergeLatest(msg []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeLatestMem" data-name="mergeLatestMem">
               <h3>
                  mergeLatestMem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mergeLatestMem" class="anchor" title="Link to mergeLatestMem">#</a>
               </h3>
               
               <p>mergeLatestMem is like mergeLatest but is only concerned with
updating the in-memory copy of the latest tree head (c.latest)
not the configuration file.
The when result explains when msg happened relative to our
previous idea of c.latest:
msgPast means msg was from before c.latest,
msgNow means msg was exactly c.latest, and
msgFuture means msg was from after c.latest, which has now been updated.</p>
               
               <pre><code class="language-go">func (c *Client) mergeLatestMem(msg []byte) (when int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readTile" data-name="readTile">
               <h3>
                  readTile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readTile" class="anchor" title="Link to readTile">#</a>
               </h3>
               
               <p>readTile reads a single tile, either from the on-disk cache or the server.</p>
               
               <pre><code class="language-go">func (c *Client) readTile(tile tlog.Tile) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportError" data-name="reportError">
               <h3>
                  reportError 
                  <span class="badge">function</span>
                  
                  <a href="#reportError" class="anchor" title="Link to reportError">#</a>
               </h3>
               
               <p>reportError reports err to w.
If it's a not-found, the reported error is 404.
Otherwise it is an internal server error.
The caller must only call reportError in contexts where
a not-found err should be reported as 404.</p>
               
               <pre><code class="language-go">func reportError(w http.ResponseWriter, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skip" data-name="skip">
               <h3>
                  skip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#skip" class="anchor" title="Link to skip">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Client) skip(target string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tileCacheKey" data-name="tileCacheKey">
               <h3>
                  tileCacheKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tileCacheKey" class="anchor" title="Link to tileCacheKey">#</a>
               </h3>
               
               <p>tileCacheKey returns the cache key for the tile.</p>
               
               <pre><code class="language-go">func (c *Client) tileCacheKey(tile tlog.Tile) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tileRemotePath" data-name="tileRemotePath">
               <h3>
                  tileRemotePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tileRemotePath" class="anchor" title="Link to tileRemotePath">#</a>
               </h3>
               
               <p>tileRemotePath returns the remote path for the tile.</p>
               
               <pre><code class="language-go">func (c *Client) tileRemotePath(tile tlog.Tile) string</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>