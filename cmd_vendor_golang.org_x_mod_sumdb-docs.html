<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - sumdb</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_vendor_golang.org_x_mod_sumdb_dirhash-docs.html">dirhash</a>
         <br />
         
         <a href="cmd_vendor_golang.org_x_mod_sumdb_note-docs.html">note</a>
         <br />
         
         <a href="cmd_vendor_golang.org_x_mod_sumdb_tlog-docs.html">tlog</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>sumdb</code>
         </h1>
         <hr />
         
         <article class="global" data-name="ServerPaths">
            <h2>ServerPaths</h2>
            <hr />
            
            <p>ServerPaths are the URL paths the Server can (and should) serve.

Typically a server will do:

	srv := sumdb.NewServer(ops)
	for _, path := range sumdb.ServerPaths {
		http.Handle(path, srv)
	}</p>
            
            <pre><code>ServerPaths</code></pre>
         </article>
         
         <article class="global" data-name="modVerRE">
            <h2>modVerRE</h2>
            <hr />
            
            <pre><code>modVerRE</code></pre>
         </article>
         
         <article class="global" data-name="ErrWriteConflict">
            <h2>ErrWriteConflict</h2>
            <hr />
            
            <p>ErrWriteConflict signals a write conflict during Client.WriteConfig.</p>
            
            <pre><code>ErrWriteConflict</code></pre>
         </article>
         
         <article class="global" data-name="ErrSecurity">
            <h2>ErrSecurity</h2>
            <hr />
            
            <p>ErrSecurity is returned by [Client] operations that invoke Client.SecurityError.</p>
            
            <pre><code>ErrSecurity</code></pre>
         </article>
         
         <article class="global" data-name="ErrGONOSUMDB">
            <h2>ErrGONOSUMDB</h2>
            <hr />
            
            <p>ErrGONOSUMDB is returned by [Client.Lookup] for paths that match
a pattern listed in the GONOSUMDB list (set by [Client.SetGONOSUMDB],
usually from the environment variable).</p>
            
            <pre><code>ErrGONOSUMDB</code></pre>
         </article>
         
         <article class="global" data-name="msgPast">
            <h2>msgPast</h2>
            <hr />
            
            <pre><code>msgPast</code></pre>
         </article>
         
         <article class="global" data-name="msgNow">
            <h2>msgNow</h2>
            <hr />
            
            <pre><code>msgNow</code></pre>
         </article>
         
         <article class="global" data-name="msgFuture">
            <h2>msgFuture</h2>
            <hr />
            
            <pre><code>msgFuture</code></pre>
         </article>
          
         <article class="struct" data-name="Server">
            <h2>type Server struct</h2>
            <hr />
            
            <p>A Server is the checksum database HTTP server,
which implements http.Handler and should be invoked
to serve the paths listed in [ServerPaths].</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ops ServerOps</code></pre>
         </article>
         
         <article class="struct" data-name="TestServer">
            <h2>type TestServer struct</h2>
            <hr />
            
            <p>A TestServer is an in-memory implementation of [ServerOps] for testing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">signer string
gosum func
mu sync.Mutex
hashes testHashes
records [][]byte
lookup *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="parCache">
            <h2>type parCache struct</h2>
            <hr />
            
            <p>parCache runs an action once per key and caches the result.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">m sync.Map</code></pre>
         </article>
         
         <article class="struct" data-name="cacheEntry">
            <h2>type cacheEntry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">done uint32
mu sync.Mutex
result *ast.InterfaceType</code></pre>
         </article>
         
         <article class="struct" data-name="Client">
            <h2>type Client struct</h2>
            <hr />
            
            <p>A Client is a client connection to a checksum database.
All the methods are safe for simultaneous use by multiple goroutines.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ops ClientOps
didLookup uint32
initOnce sync.Once
initErr error
name string
verifiers note.Verifiers
tileReader tileReader
tileHeight int
nosumdb string
record parCache
tileCache parCache
latestMu sync.Mutex
latest tlog.Tree
latestMsg []byte
tileSavedMu sync.Mutex
tileSaved *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="tileReader">
            <h2>type tileReader struct</h2>
            <hr />
            
            <p>tileReader is a *Client wrapper that implements tlog.TileReader.
The separate type avoids exposing the ReadTiles and SaveTiles
methods on Client itself.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">c *Client</code></pre>
         </article>
          
         <article class="function" data-name="NewServer">
            <h2>NewServer</h2>
            <hr />
            
            <p>NewServer returns a new Server using the given operations.</p>
            
            <pre><code>func NewServer(ops ServerOps) *Server</code></pre>
         </article>
         
         <article class="function" data-name="ServeHTTP">
            <h2>ServeHTTP</h2>
            <hr />
            
            <pre><code>func ServeHTTP(w http.ResponseWriter, r *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="reportError">
            <h2>reportError</h2>
            <hr />
            
            <p>reportError reports err to w.
If it's a not-found, the reported error is 404.
Otherwise it is an internal server error.
The caller must only call reportError in contexts where
a not-found err should be reported as 404.</p>
            
            <pre><code>func reportError(w http.ResponseWriter, err error)</code></pre>
         </article>
         
         <article class="function" data-name="NewTestServer">
            <h2>NewTestServer</h2>
            <hr />
            
            <p>NewTestServer constructs a new [TestServer]
that will sign its tree with the given signer key
(see [golang.org/x/mod/sumdb/note])
and fetch new records as needed by calling gosum.</p>
            
            <pre><code>func NewTestServer(signer string, gosum func) *TestServer</code></pre>
         </article>
         
         <article class="function" data-name="ReadHashes">
            <h2>ReadHashes</h2>
            <hr />
            
            <pre><code>func ReadHashes(indexes []int64) ([]tlog.Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="Signed">
            <h2>Signed</h2>
            <hr />
            
            <pre><code>func Signed(ctx context.Context) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadRecords">
            <h2>ReadRecords</h2>
            <hr />
            
            <pre><code>func ReadRecords(ctx context.Context, id int64, n int64) ([][]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <pre><code>func Lookup(ctx context.Context, m module.Version) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadTileData">
            <h2>ReadTileData</h2>
            <hr />
            
            <pre><code>func ReadTileData(ctx context.Context, t tlog.Tile) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Do">
            <h2>Do</h2>
            <hr />
            
            <p>Do calls the function f if and only if Do is being called for the first time with this key.
No call to Do with a given key returns until the one call to f returns.
Do returns the value returned by the one call to f.</p>
            
            <pre><code>func Do(key *ast.InterfaceType, f func) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <p>Get returns the cached result associated with key.
It returns nil if there is no such result.
If the result for key is being computed, Get does not wait for the computation to finish.</p>
            
            <pre><code>func Get(key *ast.InterfaceType) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="NewClient">
            <h2>NewClient</h2>
            <hr />
            
            <p>NewClient returns a new [Client] using the given [ClientOps].</p>
            
            <pre><code>func NewClient(ops ClientOps) *Client</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <p>init initializes the client (if not already initialized)
and returns any initialization error.</p>
            
            <pre><code>func init() error</code></pre>
         </article>
         
         <article class="function" data-name="initWork">
            <h2>initWork</h2>
            <hr />
            
            <p>initWork does the actual initialization work.</p>
            
            <pre><code>func initWork()</code></pre>
         </article>
         
         <article class="function" data-name="SetTileHeight">
            <h2>SetTileHeight</h2>
            <hr />
            
            <p>SetTileHeight sets the tile height for the Client.
Any call to SetTileHeight must happen before the first call to [Client.Lookup].
If SetTileHeight is not called, the Client defaults to tile height 8.
SetTileHeight can be called at most once,
and if so it must be called before the first call to Lookup.</p>
            
            <pre><code>func SetTileHeight(height int)</code></pre>
         </article>
         
         <article class="function" data-name="SetGONOSUMDB">
            <h2>SetGONOSUMDB</h2>
            <hr />
            
            <p>SetGONOSUMDB sets the list of comma-separated GONOSUMDB patterns for the Client.
For any module path matching one of the patterns,
[Client.Lookup] will return ErrGONOSUMDB.
SetGONOSUMDB can be called at most once,
and if so it must be called before the first call to Lookup.</p>
            
            <pre><code>func SetGONOSUMDB(list string)</code></pre>
         </article>
         
         <article class="function" data-name="skip">
            <h2>skip</h2>
            <hr />
            
            <pre><code>func skip(target string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Lookup returns the go.sum lines for the given module path and version.
The version may end in a /go.mod suffix, in which case Lookup returns
the go.sum lines for the module's go.mod-only hash.</p>
            
            <pre><code>func Lookup(path string, vers string) (lines []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="mergeLatest">
            <h2>mergeLatest</h2>
            <hr />
            
            <p>mergeLatest merges the tree head in msg
with the Client's current latest tree head,
ensuring the result is a consistent timeline.
If the result is inconsistent, mergeLatest calls c.ops.SecurityError
with a detailed security error message and then
(only if c.ops.SecurityError does not exit the program) returns ErrSecurity.
If the Client's current latest tree head moves forward,
mergeLatest updates the underlying configuration file as well,
taking care to merge any independent updates to that configuration.</p>
            
            <pre><code>func mergeLatest(msg []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="mergeLatestMem">
            <h2>mergeLatestMem</h2>
            <hr />
            
            <p>mergeLatestMem is like mergeLatest but is only concerned with
updating the in-memory copy of the latest tree head (c.latest)
not the configuration file.
The when result explains when msg happened relative to our
previous idea of c.latest:
msgPast means msg was from before c.latest,
msgNow means msg was exactly c.latest, and
msgFuture means msg was from after c.latest, which has now been updated.</p>
            
            <pre><code>func mergeLatestMem(msg []byte) (when int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="checkTrees">
            <h2>checkTrees</h2>
            <hr />
            
            <p>checkTrees checks that older (from olderNote) is contained in newer (from newerNote).
If an error occurs, such as malformed data or a network problem, checkTrees returns that error.
If on the other hand checkTrees finds evidence of misbehavior, it prepares a detailed
message and calls log.Fatal.</p>
            
            <pre><code>func checkTrees(older tlog.Tree, olderNote []byte, newer tlog.Tree, newerNote []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="checkRecord">
            <h2>checkRecord</h2>
            <hr />
            
            <p>checkRecord checks that record #id's hash matches data.</p>
            
            <pre><code>func checkRecord(id int64, data []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="Height">
            <h2>Height</h2>
            <hr />
            
            <pre><code>func Height() int</code></pre>
         </article>
         
         <article class="function" data-name="ReadTiles">
            <h2>ReadTiles</h2>
            <hr />
            
            <p>ReadTiles reads and returns the requested tiles,
either from the on-disk cache or the server.</p>
            
            <pre><code>func ReadTiles(tiles []tlog.Tile) ([][]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="tileCacheKey">
            <h2>tileCacheKey</h2>
            <hr />
            
            <p>tileCacheKey returns the cache key for the tile.</p>
            
            <pre><code>func tileCacheKey(tile tlog.Tile) string</code></pre>
         </article>
         
         <article class="function" data-name="tileRemotePath">
            <h2>tileRemotePath</h2>
            <hr />
            
            <p>tileRemotePath returns the remote path for the tile.</p>
            
            <pre><code>func tileRemotePath(tile tlog.Tile) string</code></pre>
         </article>
         
         <article class="function" data-name="readTile">
            <h2>readTile</h2>
            <hr />
            
            <p>readTile reads a single tile, either from the on-disk cache or the server.</p>
            
            <pre><code>func readTile(tile tlog.Tile) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="markTileSaved">
            <h2>markTileSaved</h2>
            <hr />
            
            <p>markTileSaved records that tile is already present in the on-disk cache,
so that a future SaveTiles for that tile can be ignored.</p>
            
            <pre><code>func markTileSaved(tile tlog.Tile)</code></pre>
         </article>
         
         <article class="function" data-name="SaveTiles">
            <h2>SaveTiles</h2>
            <hr />
            
            <p>SaveTiles saves the now validated tiles.</p>
            
            <pre><code>func SaveTiles(tiles []tlog.Tile, data [][]byte)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
