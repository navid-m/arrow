<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - template</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="text_template_parse-docs.html">parse</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>template</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"fmt"
"io"
"net/url"
"reflect"
"strings"
"sync"
"unicode"
"unicode/utf8"
"fmt"
"io/fs"
"os"
"path"
"path/filepath"
"strings"
"maps"
"reflect"
"sync"
"text/template/parse"
"errors"
"fmt"
"internal/fmtsort"
"io"
"reflect"
"runtime"
"strings"
"text/template/parse"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="boolKind">
               <h3>
                  boolKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const boolKind</code></pre>
            </article>
            
            <article class="global" data-name="builtinFuncsOnce">
               <h3>
                  builtinFuncsOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var builtinFuncsOnce struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="complexKind">
               <h3>
                  complexKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const complexKind</code></pre>
            </article>
            
            <article class="global" data-name="errBadComparison">
               <h3>
                  errBadComparison 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errBadComparison = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errBadComparisonType">
               <h3>
                  errBadComparisonType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errBadComparisonType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoComparison">
               <h3>
                  errNoComparison 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoComparison = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errorType">
               <h3>
                  errorType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errorType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="floatKind">
               <h3>
                  floatKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const floatKind</code></pre>
            </article>
            
            <article class="global" data-name="fmtStringerType">
               <h3>
                  fmtStringerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fmtStringerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="hex">
               <h3>
                  hex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlAmp">
               <h3>
                  htmlAmp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlAmp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlApos">
               <h3>
                  htmlApos 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlApos = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlGt">
               <h3>
                  htmlGt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlGt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlLt">
               <h3>
                  htmlLt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlLt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlNull">
               <h3>
                  htmlNull 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlNull = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlQuot">
               <h3>
                  htmlQuot 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlQuot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="intKind">
               <h3>
                  intKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const intKind</code></pre>
            </article>
            
            <article class="global" data-name="invalidKind">
               <h3>
                  invalidKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const invalidKind kind = iota</code></pre>
            </article>
            
            <article class="global" data-name="jsAmp">
               <h3>
                  jsAmp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsAmp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsApos">
               <h3>
                  jsApos 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsApos = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsBackslash">
               <h3>
                  jsBackslash 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsBackslash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsEq">
               <h3>
                  jsEq 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsEq = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsGt">
               <h3>
                  jsGt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsGt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsLowUni">
               <h3>
                  jsLowUni 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsLowUni = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsLt">
               <h3>
                  jsLt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsLt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="jsQuot">
               <h3>
                  jsQuot 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var jsQuot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="mapError">
               <h3>
                  mapError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mapError</code></pre>
            </article>
            
            <article class="global" data-name="mapInvalid">
               <h3>
                  mapInvalid 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mapInvalid missingKeyAction = iota</code></pre>
            </article>
            
            <article class="global" data-name="mapZeroValue">
               <h3>
                  mapZeroValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mapZeroValue</code></pre>
            </article>
            
            <article class="global" data-name="maxExecDepth">
               <h3>
                  maxExecDepth 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>maxExecDepth specifies the maximum stack depth of templates within
templates. This limit is only practically reached by accidentally
recursive template invocations. This limit allows us to return
an error instead of triggering a stack overflow.</p>
               
               <pre><code>var maxExecDepth = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="missingVal">
               <h3>
                  missingVal 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var missingVal = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="missingValReflectType">
               <h3>
                  missingValReflectType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var missingValReflectType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="reflectValueType">
               <h3>
                  reflectValueType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var reflectValueType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="stringKind">
               <h3>
                  stringKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stringKind</code></pre>
            </article>
            
            <article class="global" data-name="uintKind">
               <h3>
                  uintKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const uintKind</code></pre>
            </article>
            
            <article class="global" data-name="walkBreak">
               <h3>
                  walkBreak 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Sentinel errors for use with panic to signal early exits from range loops.</p>
               
               <pre><code>var walkBreak = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="walkContinue">
               <h3>
                  walkContinue 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Sentinel errors for use with panic to signal early exits from range loops.</p>
               
               <pre><code>var walkContinue = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="zero">
               <h3>
                  zero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var zero reflect.Value</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="FuncMap">
               <h3>
                  FuncMap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>FuncMap is the type of the map defining the mapping from names to functions.
Each function must have either a single return value, or two return values of
which the second has type error. In that case, if the second (error)
return value evaluates to non-nil during execution, execution terminates and
Execute returns that error.
Errors returned by Execute wrap the underlying error; call [errors.As] to
unwrap them.
When template execution invokes a function with an argument list, that list
must be assignable to the function's parameter types. Functions meant to
apply to arguments of arbitrary type can use parameters of type interface{} or
of type [reflect.Value]. Similarly, functions meant to return a result of arbitrary
type can return interface{} or [reflect.Value].</p>
               
               <pre><code>type FuncMap map[string]any</code></pre>
            </article>
            
            <article class="type" data-name="kind">
               <h3>
                  kind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type kind int</code></pre>
            </article>
            
            <article class="type" data-name="missingKeyAction">
               <h3>
                  missingKeyAction
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>missingKeyAction defines how to respond to indexing a map with a key that is not present.</p>
               
               <pre><code>type missingKeyAction int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ExecError">
               <h3>
                  ExecError
                  <span class="badge">struct</span>
               </h3>
               
               <p>ExecError is the custom error type returned when Execute has an
error evaluating its template. (If a write error occurs, the actual
error is returned; it will not be of type ExecError.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ExecError struct {
Name string
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="Template">
               <h3>
                  Template
                  <span class="badge">struct</span>
               </h3>
               
               <p>Template is the representation of a parsed template. The *parse.Tree
field is exported only for use by [html/template] and should be treated
as unexported by all other clients.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Template struct {
name string
*parse.Tree
*common
leftDelim string
rightDelim string
}</code></pre>
            </article>
            
            <article class="struct" data-name="common">
               <h3>
                  common
                  <span class="badge">struct</span>
               </h3>
               
               <p>common holds the information shared by related templates.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type common struct {
tmpl map[string]*Template
muTmpl sync.RWMutex
option option
muFuncs sync.RWMutex
parseFuncs FuncMap
execFuncs map[string]reflect.Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="missingValType">
               <h3>
                  missingValType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type missingValType struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="option">
               <h3>
                  option
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type option struct {
missingKey missingKeyAction
}</code></pre>
            </article>
            
            <article class="struct" data-name="state">
               <h3>
                  state
                  <span class="badge">struct</span>
               </h3>
               
               <p>state represents the state of an execution. It's not part of the
template so that multiple executions of the same template
can execute in parallel.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type state struct {
tmpl *Template
wr io.Writer
node parse.Node
vars []variable
depth int
}</code></pre>
            </article>
            
            <article class="struct" data-name="variable">
               <h3>
                  variable
                  <span class="badge">struct</span>
               </h3>
               
               <p>variable holds the dynamic value of a variable such as $, $x etc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type variable struct {
name string
value reflect.Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="writeError">
               <h3>
                  writeError
                  <span class="badge">struct</span>
               </h3>
               
               <p>writeError is the wrapper type used internally when Execute has an
error writing to its output. We strip the wrapper in errRecover.
Note that this is not an implementation of error, so it cannot escape
from the package as an error value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writeError struct {
Err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddParseTree">
               <h3>
                  AddParseTree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddParseTree associates the argument parse tree with the template t, giving
it the specified name. If the template has not been defined, this tree becomes
its definition. If it has been defined and already has that name, the existing
definition is replaced; otherwise a new template is created, defined, and returned.</p>
               
               <pre><code>func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Clone returns a duplicate of the template, including all associated
templates. The actual representation is not copied, but the name space of
associated templates is, so further calls to [Template.Parse] in the copy will add
templates to the copy but not to the original. Clone can be used to prepare
common templates and use them with variant definitions for other templates
by adding the variants after the clone is made.</p>
               
               <pre><code>func (t *Template) Clone() (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="DefinedTemplates">
               <h3>
                  DefinedTemplates 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DefinedTemplates returns a string listing the defined templates,
prefixed by the string "; defined templates are: ". If there are none,
it returns the empty string. For generating an error message here
and in [html/template].</p>
               
               <pre><code>func (t *Template) DefinedTemplates() string</code></pre>
            </article>
            
            <article class="function" data-name="Delims">
               <h3>
                  Delims 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Delims sets the action delimiters to the specified strings, to be used in
subsequent calls to [Template.Parse], [Template.ParseFiles], or [Template.ParseGlob]. Nested template
definitions will inherit the settings. An empty delimiter stands for the
corresponding default: {{ or }}.
The return value is the template, so calls can be chained.</p>
               
               <pre><code>func (t *Template) Delims(left string, right string) *Template</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e ExecError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Execute">
               <h3>
                  Execute 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Execute applies a parsed template to the specified data object,
and writes the output to wr.
If an error occurs executing the template or writing its output,
execution stops, but partial results may already have been written to
the output writer.
A template may be executed safely in parallel, although if parallel
executions share a Writer the output may be interleaved.
If data is a [reflect.Value], the template applies to the concrete
value that the reflect.Value holds, as in [fmt.Print].</p>
               
               <pre><code>func (t *Template) Execute(wr io.Writer, data any) error</code></pre>
            </article>
            
            <article class="function" data-name="ExecuteTemplate">
               <h3>
                  ExecuteTemplate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExecuteTemplate applies the template associated with t that has the given name
to the specified data object and writes the output to wr.
If an error occurs executing the template or writing its output,
execution stops, but partial results may already have been written to
the output writer.
A template may be executed safely in parallel, although if parallel
executions share a Writer the output may be interleaved.</p>
               
               <pre><code>func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error</code></pre>
            </article>
            
            <article class="function" data-name="Funcs">
               <h3>
                  Funcs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Funcs adds the elements of the argument map to the template's function map.
It must be called before the template is parsed.
It panics if a value in the map is not a function with appropriate return
type or if the name cannot be used syntactically as a function in a template.
It is legal to overwrite elements of the map. The return value is the template,
so calls can be chained.</p>
               
               <pre><code>func (t *Template) Funcs(funcMap FuncMap) *Template</code></pre>
            </article>
            
            <article class="function" data-name="HTMLEscape">
               <h3>
                  HTMLEscape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</p>
               
               <pre><code>func HTMLEscape(w io.Writer, b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="HTMLEscapeString">
               <h3>
                  HTMLEscapeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</p>
               
               <pre><code>func HTMLEscapeString(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="HTMLEscaper">
               <h3>
                  HTMLEscaper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HTMLEscaper returns the escaped HTML equivalent of the textual
representation of its arguments.</p>
               
               <pre><code>func HTMLEscaper(args ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="IsTrue">
               <h3>
                  IsTrue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsTrue reports whether the value is 'true', in the sense of not the zero of its type,
and whether the value has a meaningful truth value. This is the definition of
truth used by if and other such actions.</p>
               
               <pre><code>func IsTrue(val any) (truth bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="JSEscape">
               <h3>
                  JSEscape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</p>
               
               <pre><code>func JSEscape(w io.Writer, b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="JSEscapeString">
               <h3>
                  JSEscapeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</p>
               
               <pre><code>func JSEscapeString(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="JSEscaper">
               <h3>
                  JSEscaper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>JSEscaper returns the escaped JavaScript equivalent of the textual
representation of its arguments.</p>
               
               <pre><code>func JSEscaper(args ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Lookup returns the template with the given name that is associated with t.
It returns nil if there is no such template or the template has no definition.</p>
               
               <pre><code>func (t *Template) Lookup(name string) *Template</code></pre>
            </article>
            
            <article class="function" data-name="Must">
               <h3>
                  Must 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Must is a helper that wraps a call to a function returning ([*Template], error)
and panics if the error is non-nil. It is intended for use in variable
initializations such as
var t = template.Must(template.New("name").Parse("text"))</p>
               
               <pre><code>func Must(t *Template, err error) *Template</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name returns the name of the template.</p>
               
               <pre><code>func (t *Template) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="New">
               <h3>
                  New 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>New allocates a new, undefined template associated with the given one and with the same
delimiters. The association, which is transitive, allows one template to
invoke another with a {{template}} action.
Because associated templates share underlying data, template construction
cannot be done safely in parallel. Once the templates are constructed, they
can be executed in parallel.</p>
               
               <pre><code>func (t *Template) New(name string) *Template</code></pre>
            </article>
            
            <article class="function" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>New allocates a new, undefined template with the given name.</p>
               
               <pre><code>func New(name string) *Template</code></pre>
            </article>
            
            <article class="function" data-name="Option">
               <h3>
                  Option 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Option sets options for the template. Options are described by
strings, either a simple string or "key=value". There can be at
most one equals sign in an option string. If the option string
is unrecognized or otherwise invalid, Option panics.
Known options:
missingkey: Control the behavior during execution if a map is
indexed with a key that is not present in the map.
"missingkey=default" or "missingkey=invalid"
The default behavior: Do nothing and continue execution.
If printed, the result of the index operation is the string
"<no value>".
"missingkey=zero"
The operation returns the zero value for the map type's element.
"missingkey=error"
Execution stops immediately with an error.</p>
               
               <pre><code>func (t *Template) Option(opt ...string) *Template</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Parse parses text as a template body for t.
Named template definitions ({{define ...}} or {{block ...}} statements) in text
define additional templates associated with t and are removed from the
definition of t itself.
Templates can be redefined in successive calls to Parse.
A template definition with a body containing only white space and comments
is considered empty and will not replace an existing template's body.
This allows using Parse to add new named template definitions without
overwriting the main template body.</p>
               
               <pre><code>func (t *Template) Parse(text string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseFS">
               <h3>
                  ParseFS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys
instead of the host operating system's file system.
It accepts a list of glob patterns (see [path.Match]).
(Note that most file names serve as glob patterns matching only themselves.)</p>
               
               <pre><code>func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseFS">
               <h3>
                  ParseFS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys
instead of the host operating system's file system.
It accepts a list of glob patterns (see [path.Match]).
(Note that most file names serve as glob patterns matching only themselves.)</p>
               
               <pre><code>func ParseFS(fsys fs.FS, patterns ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseFiles">
               <h3>
                  ParseFiles 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ParseFiles parses the named files and associates the resulting templates with
t. If an error occurs, parsing stops and the returned template is nil;
otherwise it is t. There must be at least one file.
Since the templates created by ParseFiles are named by the base
(see [filepath.Base]) names of the argument files, t should usually have the
name of one of the (base) names of the files. If it does not, depending on
t's contents before calling ParseFiles, t.Execute may fail. In that
case use t.ExecuteTemplate to execute a valid template.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.</p>
               
               <pre><code>func (t *Template) ParseFiles(filenames ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseFiles">
               <h3>
                  ParseFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseFiles creates a new [Template] and parses the template definitions from
the named files. The returned template's name will have the base name and
parsed contents of the first file. There must be at least one file.
If an error occurs, parsing stops and the returned *Template is nil.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.
For instance, ParseFiles("a/foo", "b/foo") stores "b/foo" as the template
named "foo", while "a/foo" is unavailable.</p>
               
               <pre><code>func ParseFiles(filenames ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseGlob">
               <h3>
                  ParseGlob 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ParseGlob parses the template definitions in the files identified by the
pattern and associates the resulting templates with t. The files are matched
according to the semantics of [filepath.Match], and the pattern must match at
least one file. ParseGlob is equivalent to calling [Template.ParseFiles] with
the list of files matched by the pattern.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.</p>
               
               <pre><code>func (t *Template) ParseGlob(pattern string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseGlob">
               <h3>
                  ParseGlob 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseGlob creates a new [Template] and parses the template definitions from
the files identified by the pattern. The files are matched according to the
semantics of [filepath.Match], and the pattern must match at least one file.
The returned template will have the [filepath.Base] name and (parsed)
contents of the first file matched by the pattern. ParseGlob is equivalent to
calling [ParseFiles] with the list of files matched by the pattern.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.</p>
               
               <pre><code>func ParseGlob(pattern string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="Templates">
               <h3>
                  Templates 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Templates returns a slice of defined templates associated with t.</p>
               
               <pre><code>func (t *Template) Templates() []*Template</code></pre>
            </article>
            
            <article class="function" data-name="URLQueryEscaper">
               <h3>
                  URLQueryEscaper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>URLQueryEscaper returns the escaped value of the textual representation of
its arguments in a form suitable for embedding in a URL query.</p>
               
               <pre><code>func URLQueryEscaper(args ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e ExecError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="addFuncs">
               <h3>
                  addFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addFuncs adds to values the functions in funcs. It does no checking of the input -
call addValueFuncs first.</p>
               
               <pre><code>func addFuncs(out FuncMap, in FuncMap)</code></pre>
            </article>
            
            <article class="function" data-name="addValueFuncs">
               <h3>
                  addValueFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.</p>
               
               <pre><code>func addValueFuncs(out map[string]reflect.Value, in FuncMap)</code></pre>
            </article>
            
            <article class="function" data-name="and">
               <h3>
                  and 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>and computes the Boolean AND of its arguments, returning
the first false argument it encounters, or the last argument.</p>
               
               <pre><code>func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="associate">
               <h3>
                  associate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>associate installs the new template into the group of templates associated
with t. The two are already known to share the common structure.
The boolean return value reports whether to store this tree as t.Tree.</p>
               
               <pre><code>func (t *Template) associate(new *Template, tree *parse.Tree) bool</code></pre>
            </article>
            
            <article class="function" data-name="at">
               <h3>
                  at 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>at marks the state to be on node n, for error reporting.</p>
               
               <pre><code>func (s *state) at(node parse.Node)</code></pre>
            </article>
            
            <article class="function" data-name="basicKind">
               <h3>
                  basicKind 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func basicKind(v reflect.Value) (kind, error)</code></pre>
            </article>
            
            <article class="function" data-name="builtinFuncs">
               <h3>
                  builtinFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>builtinFuncsOnce lazily computes & caches the builtinFuncs map.
TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</p>
               
               <pre><code>func builtinFuncs() map[string]reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="builtins">
               <h3>
                  builtins 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>builtins returns the FuncMap.
It is not a global variable so the linker can dead code eliminate
more when this isn't called. See golang.org/issue/36021.
TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</p>
               
               <pre><code>func builtins() FuncMap</code></pre>
            </article>
            
            <article class="function" data-name="call">
               <h3>
                  call 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>call returns the result of evaluating the first argument as a function.
The function must return 1 result, or 2 results, the second of which is an error.</p>
               
               <pre><code>func call(name string, fn reflect.Value, args ...reflect.Value) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="canBeNil">
               <h3>
                  canBeNil 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.</p>
               
               <pre><code>func canBeNil(typ reflect.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="canCompare">
               <h3>
                  canCompare 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canCompare reports whether v1 and v2 are both the same kind, or one is nil.
Called only when dealing with nillable types, or there's about to be an error.</p>
               
               <pre><code>func canCompare(v1 reflect.Value, v2 reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copy returns a shallow copy of t, with common set to the argument.</p>
               
               <pre><code>func (t *Template) copy(c *common) *Template</code></pre>
            </article>
            
            <article class="function" data-name="createValueFuncs">
               <h3>
                  createValueFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>createValueFuncs turns a FuncMap into a map[string]reflect.Value</p>
               
               <pre><code>func createValueFuncs(funcMap FuncMap) map[string]reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="doublePercent">
               <h3>
                  doublePercent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>doublePercent returns the string with %'s replaced by %%, if necessary,
so it can be used safely inside a Printf format string.</p>
               
               <pre><code>func doublePercent(str string) string</code></pre>
            </article>
            
            <article class="function" data-name="emptyCall">
               <h3>
                  emptyCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func emptyCall(fn reflect.Value, args ...reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="eq">
               <h3>
                  eq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>eq evaluates the comparison a == b || a == c || ...</p>
               
               <pre><code>func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="errRecover">
               <h3>
                  errRecover 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>errRecover is the handler that turns panics into returns from the top
level of Parse.</p>
               
               <pre><code>func errRecover(errp *error)</code></pre>
            </article>
            
            <article class="function" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>errorf records an ExecError and terminates processing.</p>
               
               <pre><code>func (s *state) errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="evalArg">
               <h3>
                  evalArg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalArgs">
               <h3>
                  evalArgs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>evalArgs formats the list of arguments into a string. It is therefore equivalent to
fmt.Sprint(args...)
except that each argument is indirected (if a pointer), as required,
using the same rules as the default string evaluation during template
execution.</p>
               
               <pre><code>func evalArgs(args []any) string</code></pre>
            </article>
            
            <article class="function" data-name="evalBool">
               <h3>
                  evalBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalCall">
               <h3>
                  evalCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>evalCall executes a function or method call. If it's a method, fun already has the receiver bound, so
it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0]
as the function itself.</p>
               
               <pre><code>func (s *state) evalCall(dot reflect.Value, fun reflect.Value, isBuiltin bool, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalChainNode">
               <h3>
                  evalChainNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalCommand">
               <h3>
                  evalCommand 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalComplex">
               <h3>
                  evalComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalEmptyInterface">
               <h3>
                  evalEmptyInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalField">
               <h3>
                  evalField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>evalField evaluates an expression like (.Field) or (.Field arg1 arg2).
The 'final' argument represents the return value from the preceding
value of the pipeline, if any.</p>
               
               <pre><code>func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final reflect.Value, receiver reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalFieldChain">
               <h3>
                  evalFieldChain 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>evalFieldChain evaluates .X.Y.Z possibly followed by arguments.
dot is the environment in which to evaluate arguments, while
receiver is the value being walked along the chain.</p>
               
               <pre><code>func (s *state) evalFieldChain(dot reflect.Value, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalFieldNode">
               <h3>
                  evalFieldNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalFloat">
               <h3>
                  evalFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalFunction">
               <h3>
                  evalFunction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalInteger">
               <h3>
                  evalInteger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalPipeline">
               <h3>
                  evalPipeline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>evalPipeline returns the value acquired by evaluating a pipeline. If the
pipeline has a variable declaration, the variable will be pushed on the
stack. Callers should therefore pop the stack after they are finished
executing commands depending on the pipeline value.</p>
               
               <pre><code>func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="evalString">
               <h3>
                  evalString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalUnsignedInteger">
               <h3>
                  evalUnsignedInteger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="evalVariableNode">
               <h3>
                  evalVariableNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="execute">
               <h3>
                  execute 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Template) execute(wr io.Writer, data any) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="findFunction">
               <h3>
                  findFunction 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>findFunction looks for a function in the template, and global map.</p>
               
               <pre><code>func findFunction(name string, tmpl *Template) (v reflect.Value, isBuiltin bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="ge">
               <h3>
                  ge 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ge evaluates the comparison a >= b.</p>
               
               <pre><code>func ge(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="goodFunc">
               <h3>
                  goodFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goodFunc reports whether the function or method has the right result signature.</p>
               
               <pre><code>func goodFunc(name string, typ reflect.Type) error</code></pre>
            </article>
            
            <article class="function" data-name="goodName">
               <h3>
                  goodName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goodName reports whether the function name is a valid identifier.</p>
               
               <pre><code>func goodName(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="gt">
               <h3>
                  gt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gt evaluates the comparison a > b.</p>
               
               <pre><code>func gt(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="idealConstant">
               <h3>
                  idealConstant 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>idealConstant is called to return the value of a number in a context where
we don't know the type. In that case, the syntax of the number tells us
its type, and we use Go rules to resolve. Note there is no such thing as
a uint ideal constant in this situation - the value must be of int type.</p>
               
               <pre><code>func (s *state) idealConstant(constant *parse.NumberNode) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="index">
               <h3>
                  index 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>index returns the result of indexing its first argument by the following
arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each
indexed item must be a map, slice, or array.</p>
               
               <pre><code>func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="indexArg">
               <h3>
                  indexArg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indexArg checks if a reflect.Value can be used as an index, and converts it to int if possible.</p>
               
               <pre><code>func indexArg(index reflect.Value, cap int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="indirect">
               <h3>
                  indirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indirect returns the item at the end of indirection, and a bool to indicate
if it's nil. If the returned bool is true, the returned value's kind will be
either a pointer or interface.</p>
               
               <pre><code>func indirect(v reflect.Value) (rv reflect.Value, isNil bool)</code></pre>
            </article>
            
            <article class="function" data-name="indirectInterface">
               <h3>
                  indirectInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indirectInterface returns the concrete value in an interface value,
or else the zero reflect.Value.
That is, if v represents the interface value x, the result is the same as reflect.ValueOf(x):
the fact that x was an interface value is forgotten.</p>
               
               <pre><code>func indirectInterface(v reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>init guarantees that t has a valid common structure.</p>
               
               <pre><code>func (t *Template) init()</code></pre>
            </article>
            
            <article class="function" data-name="initMaxExecDepth">
               <h3>
                  initMaxExecDepth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initMaxExecDepth() int</code></pre>
            </article>
            
            <article class="function" data-name="intLike">
               <h3>
                  intLike 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func intLike(typ reflect.Kind) bool</code></pre>
            </article>
            
            <article class="function" data-name="isHexInt">
               <h3>
                  isHexInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isHexInt(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isMissing">
               <h3>
                  isMissing 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isMissing(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isNil returns true if v is the zero reflect.Value, or nil of its type.</p>
               
               <pre><code>func isNil(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="isRuneInt">
               <h3>
                  isRuneInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isRuneInt(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isTrue">
               <h3>
                  isTrue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isTrue(val reflect.Value) (truth bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="jsIsSpecial">
               <h3>
                  jsIsSpecial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func jsIsSpecial(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="le">
               <h3>
                  le 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>le evaluates the comparison <= b.</p>
               
               <pre><code>func le(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="length">
               <h3>
                  length 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>length returns the length of the item, with an error if it has no defined length.</p>
               
               <pre><code>func length(item reflect.Value) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="lt">
               <h3>
                  lt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lt evaluates the comparison a < b.</p>
               
               <pre><code>func lt(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="mark">
               <h3>
                  mark 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mark returns the length of the variable stack.</p>
               
               <pre><code>func (s *state) mark() int</code></pre>
            </article>
            
            <article class="function" data-name="ne">
               <h3>
                  ne 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ne evaluates the comparison a != b.</p>
               
               <pre><code>func ne(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="not">
               <h3>
                  not 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>not returns the Boolean negation of its argument.</p>
               
               <pre><code>func not(arg reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="notAFunction">
               <h3>
                  notAFunction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) notAFunction(args []parse.Node, final reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="or">
               <h3>
                  or 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>or computes the Boolean OR of its arguments, returning
the first true argument it encounters, or the last argument.</p>
               
               <pre><code>func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="parseFS">
               <h3>
                  parseFS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseFiles">
               <h3>
                  parseFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseFiles is the helper for the method and function. If the argument
template is nil, it is created from the first file.</p>
               
               <pre><code>func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseGlob">
               <h3>
                  parseGlob 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseGlob is the implementation of the function and method ParseGlob.</p>
               
               <pre><code>func parseGlob(t *Template, pattern string) (*Template, error)</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pop pops the variable stack up to the mark.</p>
               
               <pre><code>func (s *state) pop(mark int)</code></pre>
            </article>
            
            <article class="function" data-name="prepareArg">
               <h3>
                  prepareArg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>prepareArg checks if value can be used as an argument of type argType, and
converts an invalid value to appropriate zero if possible.</p>
               
               <pre><code>func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="printValue">
               <h3>
                  printValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printValue writes the textual representation of the value to the output of
the template.</p>
               
               <pre><code>func (s *state) printValue(n parse.Node, v reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="printableValue">
               <h3>
                  printableValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>printableValue returns the, possibly indirected, interface value inside v that
is best for a call to formatted printer.</p>
               
               <pre><code>func printableValue(v reflect.Value) (any, bool)</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>push pushes a new variable on the stack.</p>
               
               <pre><code>func (s *state) push(name string, value reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="readFileFS">
               <h3>
                  readFileFS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readFileFS(fsys fs.FS) (func(string) (string, []byte, error))</code></pre>
            </article>
            
            <article class="function" data-name="readFileOS">
               <h3>
                  readFileOS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readFileOS(file string) (name string, b []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="safeCall">
               <h3>
                  safeCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>safeCall runs fun.Call(args), and returns the resulting value and error, if
any. If the call panics, the panic value is returned as an error.</p>
               
               <pre><code>func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error)</code></pre>
            </article>
            
            <article class="function" data-name="setOption">
               <h3>
                  setOption 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Template) setOption(opt string)</code></pre>
            </article>
            
            <article class="function" data-name="setTopVar">
               <h3>
                  setTopVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setTopVar overwrites the top-nth variable on the stack. Used by range iterations.</p>
               
               <pre><code>func (s *state) setTopVar(n int, value reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="setVar">
               <h3>
                  setVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setVar overwrites the last declared variable with the given name.
Used by variable assignments.</p>
               
               <pre><code>func (s *state) setVar(name string, value reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="slice">
               <h3>
                  slice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>slice returns the result of slicing its first argument by the remaining
arguments. Thus "slice x 1 2" is, in Go syntax, x[1:2], while "slice x"
is x[:], "slice x 1" is x[1:], and "slice x 1 2 3" is x[1:2:3]. The first
argument must be a string, slice, or array.</p>
               
               <pre><code>func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="truth">
               <h3>
                  truth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func truth(arg reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="validateType">
               <h3>
                  validateType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>validateType guarantees that the value is valid and assignable to the type.</p>
               
               <pre><code>func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="varValue">
               <h3>
                  varValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>varValue returns the value of the named variable.</p>
               
               <pre><code>func (s *state) varValue(name string) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Walk functions step through the major pieces of the template structure,
generating output as they go.</p>
               
               <pre><code>func (s *state) walk(dot reflect.Value, node parse.Node)</code></pre>
            </article>
            
            <article class="function" data-name="walkIfOrWith">
               <h3>
                  walkIfOrWith 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>walkIfOrWith walks an 'if' or 'with' node. The two control structures
are identical in behavior except that 'with' sets dot.</p>
               
               <pre><code>func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list *parse.ListNode, elseList *parse.ListNode)</code></pre>
            </article>
            
            <article class="function" data-name="walkRange">
               <h3>
                  walkRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode)</code></pre>
            </article>
            
            <article class="function" data-name="walkTemplate">
               <h3>
                  walkTemplate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode)</code></pre>
            </article>
            
            <article class="function" data-name="writeError">
               <h3>
                  writeError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *state) writeError(err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
