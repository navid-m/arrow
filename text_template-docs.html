<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - template</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="text_template_parse-docs.html">parse</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>template</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"io/fs"
"os"
"path"
"path/filepath"
"strings"
"maps"
"reflect"
"sync"
"text/template/parse"
"errors"
"fmt"
"internal/fmtsort"
"io"
"reflect"
"runtime"
"strings"
"text/template/parse"
"errors"
"fmt"
"io"
"net/url"
"reflect"
"strings"
"sync"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="boolKind" data-name="boolKind">
               <h3>
                  boolKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#boolKind" class="anchor" title="Link to boolKind">#</a>
               </h3>
               
               <pre><code>const boolKind</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builtinFuncsOnce" data-name="builtinFuncsOnce">
               <h3>
                  builtinFuncsOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#builtinFuncsOnce" class="anchor" title="Link to builtinFuncsOnce">#</a>
               </h3>
               
               <pre><code>var builtinFuncsOnce struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="complexKind" data-name="complexKind">
               <h3>
                  complexKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#complexKind" class="anchor" title="Link to complexKind">#</a>
               </h3>
               
               <pre><code>const complexKind</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errBadComparison" data-name="errBadComparison">
               <h3>
                  errBadComparison 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errBadComparison" class="anchor" title="Link to errBadComparison">#</a>
               </h3>
               
               <pre><code>var errBadComparison = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errBadComparisonType" data-name="errBadComparisonType">
               <h3>
                  errBadComparisonType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errBadComparisonType" class="anchor" title="Link to errBadComparisonType">#</a>
               </h3>
               
               <pre><code>var errBadComparisonType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoComparison" data-name="errNoComparison">
               <h3>
                  errNoComparison 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoComparison" class="anchor" title="Link to errNoComparison">#</a>
               </h3>
               
               <pre><code>var errNoComparison = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errorType" data-name="errorType">
               <h3>
                  errorType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errorType" class="anchor" title="Link to errorType">#</a>
               </h3>
               
               <pre><code>var errorType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="floatKind" data-name="floatKind">
               <h3>
                  floatKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#floatKind" class="anchor" title="Link to floatKind">#</a>
               </h3>
               
               <pre><code>const floatKind</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fmtStringerType" data-name="fmtStringerType">
               <h3>
                  fmtStringerType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fmtStringerType" class="anchor" title="Link to fmtStringerType">#</a>
               </h3>
               
               <pre><code>var fmtStringerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hex" data-name="hex">
               <h3>
                  hex 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hex" class="anchor" title="Link to hex">#</a>
               </h3>
               
               <pre><code>var hex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlAmp" data-name="htmlAmp">
               <h3>
                  htmlAmp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlAmp" class="anchor" title="Link to htmlAmp">#</a>
               </h3>
               
               <pre><code>var htmlAmp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlApos" data-name="htmlApos">
               <h3>
                  htmlApos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlApos" class="anchor" title="Link to htmlApos">#</a>
               </h3>
               
               <pre><code>var htmlApos = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlGt" data-name="htmlGt">
               <h3>
                  htmlGt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlGt" class="anchor" title="Link to htmlGt">#</a>
               </h3>
               
               <pre><code>var htmlGt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlLt" data-name="htmlLt">
               <h3>
                  htmlLt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlLt" class="anchor" title="Link to htmlLt">#</a>
               </h3>
               
               <pre><code>var htmlLt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlNull" data-name="htmlNull">
               <h3>
                  htmlNull 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlNull" class="anchor" title="Link to htmlNull">#</a>
               </h3>
               
               <pre><code>var htmlNull = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlQuot" data-name="htmlQuot">
               <h3>
                  htmlQuot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlQuot" class="anchor" title="Link to htmlQuot">#</a>
               </h3>
               
               <pre><code>var htmlQuot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intKind" data-name="intKind">
               <h3>
                  intKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#intKind" class="anchor" title="Link to intKind">#</a>
               </h3>
               
               <pre><code>const intKind</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidKind" data-name="invalidKind">
               <h3>
                  invalidKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidKind" class="anchor" title="Link to invalidKind">#</a>
               </h3>
               
               <pre><code>const invalidKind kind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsAmp" data-name="jsAmp">
               <h3>
                  jsAmp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsAmp" class="anchor" title="Link to jsAmp">#</a>
               </h3>
               
               <pre><code>var jsAmp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsApos" data-name="jsApos">
               <h3>
                  jsApos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsApos" class="anchor" title="Link to jsApos">#</a>
               </h3>
               
               <pre><code>var jsApos = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsBackslash" data-name="jsBackslash">
               <h3>
                  jsBackslash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsBackslash" class="anchor" title="Link to jsBackslash">#</a>
               </h3>
               
               <pre><code>var jsBackslash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsEq" data-name="jsEq">
               <h3>
                  jsEq 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsEq" class="anchor" title="Link to jsEq">#</a>
               </h3>
               
               <pre><code>var jsEq = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsGt" data-name="jsGt">
               <h3>
                  jsGt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsGt" class="anchor" title="Link to jsGt">#</a>
               </h3>
               
               <pre><code>var jsGt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsLowUni" data-name="jsLowUni">
               <h3>
                  jsLowUni 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsLowUni" class="anchor" title="Link to jsLowUni">#</a>
               </h3>
               
               <pre><code>var jsLowUni = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsLt" data-name="jsLt">
               <h3>
                  jsLt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsLt" class="anchor" title="Link to jsLt">#</a>
               </h3>
               
               <pre><code>var jsLt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jsQuot" data-name="jsQuot">
               <h3>
                  jsQuot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jsQuot" class="anchor" title="Link to jsQuot">#</a>
               </h3>
               
               <pre><code>var jsQuot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapError" data-name="mapError">
               <h3>
                  mapError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapError" class="anchor" title="Link to mapError">#</a>
               </h3>
               
               <pre><code>const mapError</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapInvalid" data-name="mapInvalid">
               <h3>
                  mapInvalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapInvalid" class="anchor" title="Link to mapInvalid">#</a>
               </h3>
               
               <pre><code>const mapInvalid missingKeyAction = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapZeroValue" data-name="mapZeroValue">
               <h3>
                  mapZeroValue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapZeroValue" class="anchor" title="Link to mapZeroValue">#</a>
               </h3>
               
               <pre><code>const mapZeroValue</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxExecDepth" data-name="maxExecDepth">
               <h3>
                  maxExecDepth 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#maxExecDepth" class="anchor" title="Link to maxExecDepth">#</a>
               </h3>
               
               <p>maxExecDepth specifies the maximum stack depth of templates within
templates. This limit is only practically reached by accidentally
recursive template invocations. This limit allows us to return
an error instead of triggering a stack overflow.</p>
               
               <pre><code>var maxExecDepth = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="missingVal" data-name="missingVal">
               <h3>
                  missingVal 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#missingVal" class="anchor" title="Link to missingVal">#</a>
               </h3>
               
               <pre><code>var missingVal = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="missingValReflectType" data-name="missingValReflectType">
               <h3>
                  missingValReflectType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#missingValReflectType" class="anchor" title="Link to missingValReflectType">#</a>
               </h3>
               
               <pre><code>var missingValReflectType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="reflectValueType" data-name="reflectValueType">
               <h3>
                  reflectValueType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#reflectValueType" class="anchor" title="Link to reflectValueType">#</a>
               </h3>
               
               <pre><code>var reflectValueType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stringKind" data-name="stringKind">
               <h3>
                  stringKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stringKind" class="anchor" title="Link to stringKind">#</a>
               </h3>
               
               <pre><code>const stringKind</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uintKind" data-name="uintKind">
               <h3>
                  uintKind 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#uintKind" class="anchor" title="Link to uintKind">#</a>
               </h3>
               
               <pre><code>const uintKind</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="walkBreak" data-name="walkBreak">
               <h3>
                  walkBreak 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#walkBreak" class="anchor" title="Link to walkBreak">#</a>
               </h3>
               
               <p>Sentinel errors for use with panic to signal early exits from range loops.</p>
               
               <pre><code>var walkBreak = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="walkContinue" data-name="walkContinue">
               <h3>
                  walkContinue 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#walkContinue" class="anchor" title="Link to walkContinue">#</a>
               </h3>
               
               <p>Sentinel errors for use with panic to signal early exits from range loops.</p>
               
               <pre><code>var walkContinue = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zero" data-name="zero">
               <h3>
                  zero 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zero" class="anchor" title="Link to zero">#</a>
               </h3>
               
               <pre><code>var zero reflect.Value</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="FuncMap" data-name="FuncMap">
               <h3>
                  FuncMap
                  <span class="badge type-badge">type</span>
                  <a href="#FuncMap" class="anchor" title="Link to FuncMap">#</a>
               </h3>
               
               <p>FuncMap is the type of the map defining the mapping from names to functions.
Each function must have either a single return value, or two return values of
which the second has type error. In that case, if the second (error)
return value evaluates to non-nil during execution, execution terminates and
Execute returns that error.
Errors returned by Execute wrap the underlying error; call [errors.As] to
unwrap them.
When template execution invokes a function with an argument list, that list
must be assignable to the function's parameter types. Functions meant to
apply to arguments of arbitrary type can use parameters of type interface{} or
of type [reflect.Value]. Similarly, functions meant to return a result of arbitrary
type can return interface{} or [reflect.Value].</p>
               
               <pre><code>type FuncMap map[string]any</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="kind" data-name="kind">
               <h3>
                  kind
                  <span class="badge type-badge">type</span>
                  <a href="#kind" class="anchor" title="Link to kind">#</a>
               </h3>
               
               <pre><code>type kind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="missingKeyAction" data-name="missingKeyAction">
               <h3>
                  missingKeyAction
                  <span class="badge type-badge">type</span>
                  <a href="#missingKeyAction" class="anchor" title="Link to missingKeyAction">#</a>
               </h3>
               
               <p>missingKeyAction defines how to respond to indexing a map with a key that is not present.</p>
               
               <pre><code>type missingKeyAction int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ExecError" data-name="ExecError">
               <h3>
                  ExecError
                  <span class="badge">struct</span>
                  <a href="#ExecError" class="anchor" title="Link to ExecError">#</a>
               </h3>
               
               <p>ExecError is the custom error type returned when Execute has an
error evaluating its template. (If a write error occurs, the actual
error is returned; it will not be of type ExecError.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ExecError struct {
Name string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Template" data-name="Template">
               <h3>
                  Template
                  <span class="badge">struct</span>
                  <a href="#Template" class="anchor" title="Link to Template">#</a>
               </h3>
               
               <p>Template is the representation of a parsed template. The *parse.Tree
field is exported only for use by [html/template] and should be treated
as unexported by all other clients.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Template struct {
name string
*parse.Tree
*common
leftDelim string
rightDelim string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="common" data-name="common">
               <h3>
                  common
                  <span class="badge">struct</span>
                  <a href="#common" class="anchor" title="Link to common">#</a>
               </h3>
               
               <p>common holds the information shared by related templates.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type common struct {
tmpl map[string]*Template
muTmpl sync.RWMutex
option option
muFuncs sync.RWMutex
parseFuncs FuncMap
execFuncs map[string]reflect.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="missingValType" data-name="missingValType">
               <h3>
                  missingValType
                  <span class="badge">struct</span>
                  <a href="#missingValType" class="anchor" title="Link to missingValType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type missingValType struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="option" data-name="option">
               <h3>
                  option
                  <span class="badge">struct</span>
                  <a href="#option" class="anchor" title="Link to option">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type option struct {
missingKey missingKeyAction
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="state" data-name="state">
               <h3>
                  state
                  <span class="badge">struct</span>
                  <a href="#state" class="anchor" title="Link to state">#</a>
               </h3>
               
               <p>state represents the state of an execution. It's not part of the
template so that multiple executions of the same template
can execute in parallel.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type state struct {
tmpl *Template
wr io.Writer
node parse.Node
vars []variable
depth int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="variable" data-name="variable">
               <h3>
                  variable
                  <span class="badge">struct</span>
                  <a href="#variable" class="anchor" title="Link to variable">#</a>
               </h3>
               
               <p>variable holds the dynamic value of a variable such as $, $x etc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type variable struct {
name string
value reflect.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writeError" data-name="writeError">
               <h3>
                  writeError
                  <span class="badge">struct</span>
                  <a href="#writeError" class="anchor" title="Link to writeError">#</a>
               </h3>
               
               <p>writeError is the wrapper type used internally when Execute has an
error writing to its output. We strip the wrapper in errRecover.
Note that this is not an implementation of error, so it cannot escape
from the package as an error value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writeError struct {
Err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddParseTree" data-name="AddParseTree">
               <h3>
                  AddParseTree 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddParseTree" class="anchor" title="Link to AddParseTree">#</a>
               </h3>
               
               <p>AddParseTree associates the argument parse tree with the template t, giving
it the specified name. If the template has not been defined, this tree becomes
its definition. If it has been defined and already has that name, the existing
definition is replaced; otherwise a new template is created, defined, and returned.</p>
               
               <pre><code>func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clone" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clone" class="anchor" title="Link to Clone">#</a>
               </h3>
               
               <p>Clone returns a duplicate of the template, including all associated
templates. The actual representation is not copied, but the name space of
associated templates is, so further calls to [Template.Parse] in the copy will add
templates to the copy but not to the original. Clone can be used to prepare
common templates and use them with variant definitions for other templates
by adding the variants after the clone is made.</p>
               
               <pre><code>func (t *Template) Clone() (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefinedTemplates" data-name="DefinedTemplates">
               <h3>
                  DefinedTemplates 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DefinedTemplates" class="anchor" title="Link to DefinedTemplates">#</a>
               </h3>
               
               <p>DefinedTemplates returns a string listing the defined templates,
prefixed by the string "; defined templates are: ". If there are none,
it returns the empty string. For generating an error message here
and in [html/template].</p>
               
               <pre><code>func (t *Template) DefinedTemplates() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delims" data-name="Delims">
               <h3>
                  Delims 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delims" class="anchor" title="Link to Delims">#</a>
               </h3>
               
               <p>Delims sets the action delimiters to the specified strings, to be used in
subsequent calls to [Template.Parse], [Template.ParseFiles], or [Template.ParseGlob]. Nested template
definitions will inherit the settings. An empty delimiter stands for the
corresponding default: {{ or }}.
The return value is the template, so calls can be chained.</p>
               
               <pre><code>func (t *Template) Delims(left string, right string) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e ExecError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Execute" data-name="Execute">
               <h3>
                  Execute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Execute" class="anchor" title="Link to Execute">#</a>
               </h3>
               
               <p>Execute applies a parsed template to the specified data object,
and writes the output to wr.
If an error occurs executing the template or writing its output,
execution stops, but partial results may already have been written to
the output writer.
A template may be executed safely in parallel, although if parallel
executions share a Writer the output may be interleaved.
If data is a [reflect.Value], the template applies to the concrete
value that the reflect.Value holds, as in [fmt.Print].</p>
               
               <pre><code>func (t *Template) Execute(wr io.Writer, data any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExecuteTemplate" data-name="ExecuteTemplate">
               <h3>
                  ExecuteTemplate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExecuteTemplate" class="anchor" title="Link to ExecuteTemplate">#</a>
               </h3>
               
               <p>ExecuteTemplate applies the template associated with t that has the given name
to the specified data object and writes the output to wr.
If an error occurs executing the template or writing its output,
execution stops, but partial results may already have been written to
the output writer.
A template may be executed safely in parallel, although if parallel
executions share a Writer the output may be interleaved.</p>
               
               <pre><code>func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Funcs" data-name="Funcs">
               <h3>
                  Funcs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Funcs" class="anchor" title="Link to Funcs">#</a>
               </h3>
               
               <p>Funcs adds the elements of the argument map to the template's function map.
It must be called before the template is parsed.
It panics if a value in the map is not a function with appropriate return
type or if the name cannot be used syntactically as a function in a template.
It is legal to overwrite elements of the map. The return value is the template,
so calls can be chained.</p>
               
               <pre><code>func (t *Template) Funcs(funcMap FuncMap) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTMLEscape" data-name="HTMLEscape">
               <h3>
                  HTMLEscape 
                  <span class="badge">function</span>
                  
                  <a href="#HTMLEscape" class="anchor" title="Link to HTMLEscape">#</a>
               </h3>
               
               <p>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</p>
               
               <pre><code>func HTMLEscape(w io.Writer, b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTMLEscapeString" data-name="HTMLEscapeString">
               <h3>
                  HTMLEscapeString 
                  <span class="badge">function</span>
                  
                  <a href="#HTMLEscapeString" class="anchor" title="Link to HTMLEscapeString">#</a>
               </h3>
               
               <p>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</p>
               
               <pre><code>func HTMLEscapeString(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTMLEscaper" data-name="HTMLEscaper">
               <h3>
                  HTMLEscaper 
                  <span class="badge">function</span>
                  
                  <a href="#HTMLEscaper" class="anchor" title="Link to HTMLEscaper">#</a>
               </h3>
               
               <p>HTMLEscaper returns the escaped HTML equivalent of the textual
representation of its arguments.</p>
               
               <pre><code>func HTMLEscaper(args ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsTrue" data-name="IsTrue">
               <h3>
                  IsTrue 
                  <span class="badge">function</span>
                  
                  <a href="#IsTrue" class="anchor" title="Link to IsTrue">#</a>
               </h3>
               
               <p>IsTrue reports whether the value is 'true', in the sense of not the zero of its type,
and whether the value has a meaningful truth value. This is the definition of
truth used by if and other such actions.</p>
               
               <pre><code>func IsTrue(val any) (truth bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="JSEscape" data-name="JSEscape">
               <h3>
                  JSEscape 
                  <span class="badge">function</span>
                  
                  <a href="#JSEscape" class="anchor" title="Link to JSEscape">#</a>
               </h3>
               
               <p>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</p>
               
               <pre><code>func JSEscape(w io.Writer, b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="JSEscapeString" data-name="JSEscapeString">
               <h3>
                  JSEscapeString 
                  <span class="badge">function</span>
                  
                  <a href="#JSEscapeString" class="anchor" title="Link to JSEscapeString">#</a>
               </h3>
               
               <p>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</p>
               
               <pre><code>func JSEscapeString(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="JSEscaper" data-name="JSEscaper">
               <h3>
                  JSEscaper 
                  <span class="badge">function</span>
                  
                  <a href="#JSEscaper" class="anchor" title="Link to JSEscaper">#</a>
               </h3>
               
               <p>JSEscaper returns the escaped JavaScript equivalent of the textual
representation of its arguments.</p>
               
               <pre><code>func JSEscaper(args ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup returns the template with the given name that is associated with t.
It returns nil if there is no such template or the template has no definition.</p>
               
               <pre><code>func (t *Template) Lookup(name string) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Must" data-name="Must">
               <h3>
                  Must 
                  <span class="badge">function</span>
                  
                  <a href="#Must" class="anchor" title="Link to Must">#</a>
               </h3>
               
               <p>Must is a helper that wraps a call to a function returning ([*Template], error)
and panics if the error is non-nil. It is intended for use in variable
initializations such as
var t = template.Must(template.New("name").Parse("text"))</p>
               
               <pre><code>func Must(t *Template, err error) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the name of the template.</p>
               
               <pre><code>func (t *Template) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New allocates a new, undefined template associated with the given one and with the same
delimiters. The association, which is transitive, allows one template to
invoke another with a {{template}} action.
Because associated templates share underlying data, template construction
cannot be done safely in parallel. Once the templates are constructed, they
can be executed in parallel.</p>
               
               <pre><code>func (t *Template) New(name string) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New allocates a new, undefined template with the given name.</p>
               
               <pre><code>func New(name string) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Option" data-name="Option">
               <h3>
                  Option 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Option" class="anchor" title="Link to Option">#</a>
               </h3>
               
               <p>Option sets options for the template. Options are described by
strings, either a simple string or "key=value". There can be at
most one equals sign in an option string. If the option string
is unrecognized or otherwise invalid, Option panics.
Known options:
missingkey: Control the behavior during execution if a map is
indexed with a key that is not present in the map.
"missingkey=default" or "missingkey=invalid"
The default behavior: Do nothing and continue execution.
If printed, the result of the index operation is the string
"<no value>".
"missingkey=zero"
The operation returns the zero value for the map type's element.
"missingkey=error"
Execution stops immediately with an error.</p>
               
               <pre><code>func (t *Template) Option(opt ...string) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses text as a template body for t.
Named template definitions ({{define ...}} or {{block ...}} statements) in text
define additional templates associated with t and are removed from the
definition of t itself.
Templates can be redefined in successive calls to Parse.
A template definition with a body containing only white space and comments
is considered empty and will not replace an existing template's body.
This allows using Parse to add new named template definitions without
overwriting the main template body.</p>
               
               <pre><code>func (t *Template) Parse(text string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseFS" data-name="ParseFS">
               <h3>
                  ParseFS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ParseFS" class="anchor" title="Link to ParseFS">#</a>
               </h3>
               
               <p>ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys
instead of the host operating system's file system.
It accepts a list of glob patterns (see [path.Match]).
(Note that most file names serve as glob patterns matching only themselves.)</p>
               
               <pre><code>func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseFS" data-name="ParseFS">
               <h3>
                  ParseFS 
                  <span class="badge">function</span>
                  
                  <a href="#ParseFS" class="anchor" title="Link to ParseFS">#</a>
               </h3>
               
               <p>ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys
instead of the host operating system's file system.
It accepts a list of glob patterns (see [path.Match]).
(Note that most file names serve as glob patterns matching only themselves.)</p>
               
               <pre><code>func ParseFS(fsys fs.FS, patterns ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseFiles" data-name="ParseFiles">
               <h3>
                  ParseFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ParseFiles" class="anchor" title="Link to ParseFiles">#</a>
               </h3>
               
               <p>ParseFiles parses the named files and associates the resulting templates with
t. If an error occurs, parsing stops and the returned template is nil;
otherwise it is t. There must be at least one file.
Since the templates created by ParseFiles are named by the base
(see [filepath.Base]) names of the argument files, t should usually have the
name of one of the (base) names of the files. If it does not, depending on
t's contents before calling ParseFiles, t.Execute may fail. In that
case use t.ExecuteTemplate to execute a valid template.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.</p>
               
               <pre><code>func (t *Template) ParseFiles(filenames ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseFiles" data-name="ParseFiles">
               <h3>
                  ParseFiles 
                  <span class="badge">function</span>
                  
                  <a href="#ParseFiles" class="anchor" title="Link to ParseFiles">#</a>
               </h3>
               
               <p>ParseFiles creates a new [Template] and parses the template definitions from
the named files. The returned template's name will have the base name and
parsed contents of the first file. There must be at least one file.
If an error occurs, parsing stops and the returned *Template is nil.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.
For instance, ParseFiles("a/foo", "b/foo") stores "b/foo" as the template
named "foo", while "a/foo" is unavailable.</p>
               
               <pre><code>func ParseFiles(filenames ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseGlob" data-name="ParseGlob">
               <h3>
                  ParseGlob 
                  <span class="badge">function</span>
                  
                  <a href="#ParseGlob" class="anchor" title="Link to ParseGlob">#</a>
               </h3>
               
               <p>ParseGlob creates a new [Template] and parses the template definitions from
the files identified by the pattern. The files are matched according to the
semantics of [filepath.Match], and the pattern must match at least one file.
The returned template will have the [filepath.Base] name and (parsed)
contents of the first file matched by the pattern. ParseGlob is equivalent to
calling [ParseFiles] with the list of files matched by the pattern.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.</p>
               
               <pre><code>func ParseGlob(pattern string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseGlob" data-name="ParseGlob">
               <h3>
                  ParseGlob 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ParseGlob" class="anchor" title="Link to ParseGlob">#</a>
               </h3>
               
               <p>ParseGlob parses the template definitions in the files identified by the
pattern and associates the resulting templates with t. The files are matched
according to the semantics of [filepath.Match], and the pattern must match at
least one file. ParseGlob is equivalent to calling [Template.ParseFiles] with
the list of files matched by the pattern.
When parsing multiple files with the same name in different directories,
the last one mentioned will be the one that results.</p>
               
               <pre><code>func (t *Template) ParseGlob(pattern string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Templates" data-name="Templates">
               <h3>
                  Templates 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Templates" class="anchor" title="Link to Templates">#</a>
               </h3>
               
               <p>Templates returns a slice of defined templates associated with t.</p>
               
               <pre><code>func (t *Template) Templates() []*Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="URLQueryEscaper" data-name="URLQueryEscaper">
               <h3>
                  URLQueryEscaper 
                  <span class="badge">function</span>
                  
                  <a href="#URLQueryEscaper" class="anchor" title="Link to URLQueryEscaper">#</a>
               </h3>
               
               <p>URLQueryEscaper returns the escaped value of the textual representation of
its arguments in a form suitable for embedding in a URL query.</p>
               
               <pre><code>func URLQueryEscaper(args ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e ExecError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addFuncs" data-name="addFuncs">
               <h3>
                  addFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#addFuncs" class="anchor" title="Link to addFuncs">#</a>
               </h3>
               
               <p>addFuncs adds to values the functions in funcs. It does no checking of the input -
call addValueFuncs first.</p>
               
               <pre><code>func addFuncs(out FuncMap, in FuncMap)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addValueFuncs" data-name="addValueFuncs">
               <h3>
                  addValueFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#addValueFuncs" class="anchor" title="Link to addValueFuncs">#</a>
               </h3>
               
               <p>addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.</p>
               
               <pre><code>func addValueFuncs(out map[string]reflect.Value, in FuncMap)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="and" data-name="and">
               <h3>
                  and 
                  <span class="badge">function</span>
                  
                  <a href="#and" class="anchor" title="Link to and">#</a>
               </h3>
               
               <p>and computes the Boolean AND of its arguments, returning
the first false argument it encounters, or the last argument.</p>
               
               <pre><code>func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="associate" data-name="associate">
               <h3>
                  associate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#associate" class="anchor" title="Link to associate">#</a>
               </h3>
               
               <p>associate installs the new template into the group of templates associated
with t. The two are already known to share the common structure.
The boolean return value reports whether to store this tree as t.Tree.</p>
               
               <pre><code>func (t *Template) associate(new *Template, tree *parse.Tree) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="at" data-name="at">
               <h3>
                  at 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#at" class="anchor" title="Link to at">#</a>
               </h3>
               
               <p>at marks the state to be on node n, for error reporting.</p>
               
               <pre><code>func (s *state) at(node parse.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="basicKind" data-name="basicKind">
               <h3>
                  basicKind 
                  <span class="badge">function</span>
                  
                  <a href="#basicKind" class="anchor" title="Link to basicKind">#</a>
               </h3>
               
               <pre><code>func basicKind(v reflect.Value) (kind, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="builtinFuncs" data-name="builtinFuncs">
               <h3>
                  builtinFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#builtinFuncs" class="anchor" title="Link to builtinFuncs">#</a>
               </h3>
               
               <p>builtinFuncsOnce lazily computes & caches the builtinFuncs map.
TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</p>
               
               <pre><code>func builtinFuncs() map[string]reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="builtins" data-name="builtins">
               <h3>
                  builtins 
                  <span class="badge">function</span>
                  
                  <a href="#builtins" class="anchor" title="Link to builtins">#</a>
               </h3>
               
               <p>builtins returns the FuncMap.
It is not a global variable so the linker can dead code eliminate
more when this isn't called. See golang.org/issue/36021.
TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</p>
               
               <pre><code>func builtins() FuncMap</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge">function</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <p>call returns the result of evaluating the first argument as a function.
The function must return 1 result, or 2 results, the second of which is an error.</p>
               
               <pre><code>func call(name string, fn reflect.Value, args ...reflect.Value) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canBeNil" data-name="canBeNil">
               <h3>
                  canBeNil 
                  <span class="badge">function</span>
                  
                  <a href="#canBeNil" class="anchor" title="Link to canBeNil">#</a>
               </h3>
               
               <p>canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.</p>
               
               <pre><code>func canBeNil(typ reflect.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canCompare" data-name="canCompare">
               <h3>
                  canCompare 
                  <span class="badge">function</span>
                  
                  <a href="#canCompare" class="anchor" title="Link to canCompare">#</a>
               </h3>
               
               <p>canCompare reports whether v1 and v2 are both the same kind, or one is nil.
Called only when dealing with nillable types, or there's about to be an error.</p>
               
               <pre><code>func canCompare(v1 reflect.Value, v2 reflect.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copy" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copy" class="anchor" title="Link to copy">#</a>
               </h3>
               
               <p>copy returns a shallow copy of t, with common set to the argument.</p>
               
               <pre><code>func (t *Template) copy(c *common) *Template</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="createValueFuncs" data-name="createValueFuncs">
               <h3>
                  createValueFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#createValueFuncs" class="anchor" title="Link to createValueFuncs">#</a>
               </h3>
               
               <p>createValueFuncs turns a FuncMap into a map[string]reflect.Value</p>
               
               <pre><code>func createValueFuncs(funcMap FuncMap) map[string]reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doublePercent" data-name="doublePercent">
               <h3>
                  doublePercent 
                  <span class="badge">function</span>
                  
                  <a href="#doublePercent" class="anchor" title="Link to doublePercent">#</a>
               </h3>
               
               <p>doublePercent returns the string with %'s replaced by %%, if necessary,
so it can be used safely inside a Printf format string.</p>
               
               <pre><code>func doublePercent(str string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emptyCall" data-name="emptyCall">
               <h3>
                  emptyCall 
                  <span class="badge">function</span>
                  
                  <a href="#emptyCall" class="anchor" title="Link to emptyCall">#</a>
               </h3>
               
               <pre><code>func emptyCall(fn reflect.Value, args ...reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eq" data-name="eq">
               <h3>
                  eq 
                  <span class="badge">function</span>
                  
                  <a href="#eq" class="anchor" title="Link to eq">#</a>
               </h3>
               
               <p>eq evaluates the comparison a == b || a == c || ...</p>
               
               <pre><code>func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errRecover" data-name="errRecover">
               <h3>
                  errRecover 
                  <span class="badge">function</span>
                  
                  <a href="#errRecover" class="anchor" title="Link to errRecover">#</a>
               </h3>
               
               <p>errRecover is the handler that turns panics into returns from the top
level of Parse.</p>
               
               <pre><code>func errRecover(errp *error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorf" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorf" class="anchor" title="Link to errorf">#</a>
               </h3>
               
               <p>errorf records an ExecError and terminates processing.</p>
               
               <pre><code>func (s *state) errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalArg" data-name="evalArg">
               <h3>
                  evalArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalArg" class="anchor" title="Link to evalArg">#</a>
               </h3>
               
               <pre><code>func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalArgs" data-name="evalArgs">
               <h3>
                  evalArgs 
                  <span class="badge">function</span>
                  
                  <a href="#evalArgs" class="anchor" title="Link to evalArgs">#</a>
               </h3>
               
               <p>evalArgs formats the list of arguments into a string. It is therefore equivalent to
fmt.Sprint(args...)
except that each argument is indirected (if a pointer), as required,
using the same rules as the default string evaluation during template
execution.</p>
               
               <pre><code>func evalArgs(args []any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalBool" data-name="evalBool">
               <h3>
                  evalBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalBool" class="anchor" title="Link to evalBool">#</a>
               </h3>
               
               <pre><code>func (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalCall" data-name="evalCall">
               <h3>
                  evalCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalCall" class="anchor" title="Link to evalCall">#</a>
               </h3>
               
               <p>evalCall executes a function or method call. If it's a method, fun already has the receiver bound, so
it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0]
as the function itself.</p>
               
               <pre><code>func (s *state) evalCall(dot reflect.Value, fun reflect.Value, isBuiltin bool, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalChainNode" data-name="evalChainNode">
               <h3>
                  evalChainNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalChainNode" class="anchor" title="Link to evalChainNode">#</a>
               </h3>
               
               <pre><code>func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalCommand" data-name="evalCommand">
               <h3>
                  evalCommand 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalCommand" class="anchor" title="Link to evalCommand">#</a>
               </h3>
               
               <pre><code>func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalComplex" data-name="evalComplex">
               <h3>
                  evalComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalComplex" class="anchor" title="Link to evalComplex">#</a>
               </h3>
               
               <pre><code>func (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalEmptyInterface" data-name="evalEmptyInterface">
               <h3>
                  evalEmptyInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalEmptyInterface" class="anchor" title="Link to evalEmptyInterface">#</a>
               </h3>
               
               <pre><code>func (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalField" data-name="evalField">
               <h3>
                  evalField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalField" class="anchor" title="Link to evalField">#</a>
               </h3>
               
               <p>evalField evaluates an expression like (.Field) or (.Field arg1 arg2).
The 'final' argument represents the return value from the preceding
value of the pipeline, if any.</p>
               
               <pre><code>func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final reflect.Value, receiver reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalFieldChain" data-name="evalFieldChain">
               <h3>
                  evalFieldChain 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalFieldChain" class="anchor" title="Link to evalFieldChain">#</a>
               </h3>
               
               <p>evalFieldChain evaluates .X.Y.Z possibly followed by arguments.
dot is the environment in which to evaluate arguments, while
receiver is the value being walked along the chain.</p>
               
               <pre><code>func (s *state) evalFieldChain(dot reflect.Value, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalFieldNode" data-name="evalFieldNode">
               <h3>
                  evalFieldNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalFieldNode" class="anchor" title="Link to evalFieldNode">#</a>
               </h3>
               
               <pre><code>func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalFloat" data-name="evalFloat">
               <h3>
                  evalFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalFloat" class="anchor" title="Link to evalFloat">#</a>
               </h3>
               
               <pre><code>func (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalFunction" data-name="evalFunction">
               <h3>
                  evalFunction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalFunction" class="anchor" title="Link to evalFunction">#</a>
               </h3>
               
               <pre><code>func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalInteger" data-name="evalInteger">
               <h3>
                  evalInteger 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalInteger" class="anchor" title="Link to evalInteger">#</a>
               </h3>
               
               <pre><code>func (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalPipeline" data-name="evalPipeline">
               <h3>
                  evalPipeline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalPipeline" class="anchor" title="Link to evalPipeline">#</a>
               </h3>
               
               <p>evalPipeline returns the value acquired by evaluating a pipeline. If the
pipeline has a variable declaration, the variable will be pushed on the
stack. Callers should therefore pop the stack after they are finished
executing commands depending on the pipeline value.</p>
               
               <pre><code>func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalString" data-name="evalString">
               <h3>
                  evalString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalString" class="anchor" title="Link to evalString">#</a>
               </h3>
               
               <pre><code>func (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalUnsignedInteger" data-name="evalUnsignedInteger">
               <h3>
                  evalUnsignedInteger 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalUnsignedInteger" class="anchor" title="Link to evalUnsignedInteger">#</a>
               </h3>
               
               <pre><code>func (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalVariableNode" data-name="evalVariableNode">
               <h3>
                  evalVariableNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evalVariableNode" class="anchor" title="Link to evalVariableNode">#</a>
               </h3>
               
               <pre><code>func (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="execute" data-name="execute">
               <h3>
                  execute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#execute" class="anchor" title="Link to execute">#</a>
               </h3>
               
               <pre><code>func (t *Template) execute(wr io.Writer, data any) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findFunction" data-name="findFunction">
               <h3>
                  findFunction 
                  <span class="badge">function</span>
                  
                  <a href="#findFunction" class="anchor" title="Link to findFunction">#</a>
               </h3>
               
               <p>findFunction looks for a function in the template, and global map.</p>
               
               <pre><code>func findFunction(name string, tmpl *Template) (v reflect.Value, isBuiltin bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ge" data-name="ge">
               <h3>
                  ge 
                  <span class="badge">function</span>
                  
                  <a href="#ge" class="anchor" title="Link to ge">#</a>
               </h3>
               
               <p>ge evaluates the comparison a >= b.</p>
               
               <pre><code>func ge(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goodFunc" data-name="goodFunc">
               <h3>
                  goodFunc 
                  <span class="badge">function</span>
                  
                  <a href="#goodFunc" class="anchor" title="Link to goodFunc">#</a>
               </h3>
               
               <p>goodFunc reports whether the function or method has the right result signature.</p>
               
               <pre><code>func goodFunc(name string, typ reflect.Type) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goodName" data-name="goodName">
               <h3>
                  goodName 
                  <span class="badge">function</span>
                  
                  <a href="#goodName" class="anchor" title="Link to goodName">#</a>
               </h3>
               
               <p>goodName reports whether the function name is a valid identifier.</p>
               
               <pre><code>func goodName(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gt" data-name="gt">
               <h3>
                  gt 
                  <span class="badge">function</span>
                  
                  <a href="#gt" class="anchor" title="Link to gt">#</a>
               </h3>
               
               <p>gt evaluates the comparison a > b.</p>
               
               <pre><code>func gt(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idealConstant" data-name="idealConstant">
               <h3>
                  idealConstant 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idealConstant" class="anchor" title="Link to idealConstant">#</a>
               </h3>
               
               <p>idealConstant is called to return the value of a number in a context where
we don't know the type. In that case, the syntax of the number tells us
its type, and we use Go rules to resolve. Note there is no such thing as
a uint ideal constant in this situation - the value must be of int type.</p>
               
               <pre><code>func (s *state) idealConstant(constant *parse.NumberNode) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="index" data-name="index">
               <h3>
                  index 
                  <span class="badge">function</span>
                  
                  <a href="#index" class="anchor" title="Link to index">#</a>
               </h3>
               
               <p>index returns the result of indexing its first argument by the following
arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each
indexed item must be a map, slice, or array.</p>
               
               <pre><code>func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexArg" data-name="indexArg">
               <h3>
                  indexArg 
                  <span class="badge">function</span>
                  
                  <a href="#indexArg" class="anchor" title="Link to indexArg">#</a>
               </h3>
               
               <p>indexArg checks if a reflect.Value can be used as an index, and converts it to int if possible.</p>
               
               <pre><code>func indexArg(index reflect.Value, cap int) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indirect" data-name="indirect">
               <h3>
                  indirect 
                  <span class="badge">function</span>
                  
                  <a href="#indirect" class="anchor" title="Link to indirect">#</a>
               </h3>
               
               <p>indirect returns the item at the end of indirection, and a bool to indicate
if it's nil. If the returned bool is true, the returned value's kind will be
either a pointer or interface.</p>
               
               <pre><code>func indirect(v reflect.Value) (rv reflect.Value, isNil bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indirectInterface" data-name="indirectInterface">
               <h3>
                  indirectInterface 
                  <span class="badge">function</span>
                  
                  <a href="#indirectInterface" class="anchor" title="Link to indirectInterface">#</a>
               </h3>
               
               <p>indirectInterface returns the concrete value in an interface value,
or else the zero reflect.Value.
That is, if v represents the interface value x, the result is the same as reflect.ValueOf(x):
the fact that x was an interface value is forgotten.</p>
               
               <pre><code>func indirectInterface(v reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>init guarantees that t has a valid common structure.</p>
               
               <pre><code>func (t *Template) init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initMaxExecDepth" data-name="initMaxExecDepth">
               <h3>
                  initMaxExecDepth 
                  <span class="badge">function</span>
                  
                  <a href="#initMaxExecDepth" class="anchor" title="Link to initMaxExecDepth">#</a>
               </h3>
               
               <pre><code>func initMaxExecDepth() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intLike" data-name="intLike">
               <h3>
                  intLike 
                  <span class="badge">function</span>
                  
                  <a href="#intLike" class="anchor" title="Link to intLike">#</a>
               </h3>
               
               <pre><code>func intLike(typ reflect.Kind) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isHexInt" data-name="isHexInt">
               <h3>
                  isHexInt 
                  <span class="badge">function</span>
                  
                  <a href="#isHexInt" class="anchor" title="Link to isHexInt">#</a>
               </h3>
               
               <pre><code>func isHexInt(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMissing" data-name="isMissing">
               <h3>
                  isMissing 
                  <span class="badge">function</span>
                  
                  <a href="#isMissing" class="anchor" title="Link to isMissing">#</a>
               </h3>
               
               <pre><code>func isMissing(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNil" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge">function</span>
                  
                  <a href="#isNil" class="anchor" title="Link to isNil">#</a>
               </h3>
               
               <p>isNil returns true if v is the zero reflect.Value, or nil of its type.</p>
               
               <pre><code>func isNil(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isRuneInt" data-name="isRuneInt">
               <h3>
                  isRuneInt 
                  <span class="badge">function</span>
                  
                  <a href="#isRuneInt" class="anchor" title="Link to isRuneInt">#</a>
               </h3>
               
               <pre><code>func isRuneInt(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTrue" data-name="isTrue">
               <h3>
                  isTrue 
                  <span class="badge">function</span>
                  
                  <a href="#isTrue" class="anchor" title="Link to isTrue">#</a>
               </h3>
               
               <pre><code>func isTrue(val reflect.Value) (truth bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="jsIsSpecial" data-name="jsIsSpecial">
               <h3>
                  jsIsSpecial 
                  <span class="badge">function</span>
                  
                  <a href="#jsIsSpecial" class="anchor" title="Link to jsIsSpecial">#</a>
               </h3>
               
               <pre><code>func jsIsSpecial(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="le" data-name="le">
               <h3>
                  le 
                  <span class="badge">function</span>
                  
                  <a href="#le" class="anchor" title="Link to le">#</a>
               </h3>
               
               <p>le evaluates the comparison <= b.</p>
               
               <pre><code>func le(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="length" data-name="length">
               <h3>
                  length 
                  <span class="badge">function</span>
                  
                  <a href="#length" class="anchor" title="Link to length">#</a>
               </h3>
               
               <p>length returns the length of the item, with an error if it has no defined length.</p>
               
               <pre><code>func length(item reflect.Value) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lt" data-name="lt">
               <h3>
                  lt 
                  <span class="badge">function</span>
                  
                  <a href="#lt" class="anchor" title="Link to lt">#</a>
               </h3>
               
               <p>lt evaluates the comparison a < b.</p>
               
               <pre><code>func lt(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mark" data-name="mark">
               <h3>
                  mark 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mark" class="anchor" title="Link to mark">#</a>
               </h3>
               
               <p>mark returns the length of the variable stack.</p>
               
               <pre><code>func (s *state) mark() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ne" data-name="ne">
               <h3>
                  ne 
                  <span class="badge">function</span>
                  
                  <a href="#ne" class="anchor" title="Link to ne">#</a>
               </h3>
               
               <p>ne evaluates the comparison a != b.</p>
               
               <pre><code>func ne(arg1 reflect.Value, arg2 reflect.Value) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="not" data-name="not">
               <h3>
                  not 
                  <span class="badge">function</span>
                  
                  <a href="#not" class="anchor" title="Link to not">#</a>
               </h3>
               
               <p>not returns the Boolean negation of its argument.</p>
               
               <pre><code>func not(arg reflect.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="notAFunction" data-name="notAFunction">
               <h3>
                  notAFunction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#notAFunction" class="anchor" title="Link to notAFunction">#</a>
               </h3>
               
               <pre><code>func (s *state) notAFunction(args []parse.Node, final reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="or" data-name="or">
               <h3>
                  or 
                  <span class="badge">function</span>
                  
                  <a href="#or" class="anchor" title="Link to or">#</a>
               </h3>
               
               <p>or computes the Boolean OR of its arguments, returning
the first true argument it encounters, or the last argument.</p>
               
               <pre><code>func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFS" data-name="parseFS">
               <h3>
                  parseFS 
                  <span class="badge">function</span>
                  
                  <a href="#parseFS" class="anchor" title="Link to parseFS">#</a>
               </h3>
               
               <pre><code>func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFiles" data-name="parseFiles">
               <h3>
                  parseFiles 
                  <span class="badge">function</span>
                  
                  <a href="#parseFiles" class="anchor" title="Link to parseFiles">#</a>
               </h3>
               
               <p>parseFiles is the helper for the method and function. If the argument
template is nil, it is created from the first file.</p>
               
               <pre><code>func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGlob" data-name="parseGlob">
               <h3>
                  parseGlob 
                  <span class="badge">function</span>
                  
                  <a href="#parseGlob" class="anchor" title="Link to parseGlob">#</a>
               </h3>
               
               <p>parseGlob is the implementation of the function and method ParseGlob.</p>
               
               <pre><code>func parseGlob(t *Template, pattern string) (*Template, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pop" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pop" class="anchor" title="Link to pop">#</a>
               </h3>
               
               <p>pop pops the variable stack up to the mark.</p>
               
               <pre><code>func (s *state) pop(mark int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prepareArg" data-name="prepareArg">
               <h3>
                  prepareArg 
                  <span class="badge">function</span>
                  
                  <a href="#prepareArg" class="anchor" title="Link to prepareArg">#</a>
               </h3>
               
               <p>prepareArg checks if value can be used as an argument of type argType, and
converts an invalid value to appropriate zero if possible.</p>
               
               <pre><code>func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printValue" data-name="printValue">
               <h3>
                  printValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printValue" class="anchor" title="Link to printValue">#</a>
               </h3>
               
               <p>printValue writes the textual representation of the value to the output of
the template.</p>
               
               <pre><code>func (s *state) printValue(n parse.Node, v reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printableValue" data-name="printableValue">
               <h3>
                  printableValue 
                  <span class="badge">function</span>
                  
                  <a href="#printableValue" class="anchor" title="Link to printableValue">#</a>
               </h3>
               
               <p>printableValue returns the, possibly indirected, interface value inside v that
is best for a call to formatted printer.</p>
               
               <pre><code>func printableValue(v reflect.Value) (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <p>push pushes a new variable on the stack.</p>
               
               <pre><code>func (s *state) push(name string, value reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFileFS" data-name="readFileFS">
               <h3>
                  readFileFS 
                  <span class="badge">function</span>
                  
                  <a href="#readFileFS" class="anchor" title="Link to readFileFS">#</a>
               </h3>
               
               <pre><code>func readFileFS(fsys fs.FS) (func(string) (string, []byte, error))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFileOS" data-name="readFileOS">
               <h3>
                  readFileOS 
                  <span class="badge">function</span>
                  
                  <a href="#readFileOS" class="anchor" title="Link to readFileOS">#</a>
               </h3>
               
               <pre><code>func readFileOS(file string) (name string, b []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeCall" data-name="safeCall">
               <h3>
                  safeCall 
                  <span class="badge">function</span>
                  
                  <a href="#safeCall" class="anchor" title="Link to safeCall">#</a>
               </h3>
               
               <p>safeCall runs fun.Call(args), and returns the resulting value and error, if
any. If the call panics, the panic value is returned as an error.</p>
               
               <pre><code>func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setOption" data-name="setOption">
               <h3>
                  setOption 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setOption" class="anchor" title="Link to setOption">#</a>
               </h3>
               
               <pre><code>func (t *Template) setOption(opt string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setTopVar" data-name="setTopVar">
               <h3>
                  setTopVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setTopVar" class="anchor" title="Link to setTopVar">#</a>
               </h3>
               
               <p>setTopVar overwrites the top-nth variable on the stack. Used by range iterations.</p>
               
               <pre><code>func (s *state) setTopVar(n int, value reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setVar" data-name="setVar">
               <h3>
                  setVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setVar" class="anchor" title="Link to setVar">#</a>
               </h3>
               
               <p>setVar overwrites the last declared variable with the given name.
Used by variable assignments.</p>
               
               <pre><code>func (s *state) setVar(name string, value reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="slice" data-name="slice">
               <h3>
                  slice 
                  <span class="badge">function</span>
                  
                  <a href="#slice" class="anchor" title="Link to slice">#</a>
               </h3>
               
               <p>slice returns the result of slicing its first argument by the remaining
arguments. Thus "slice x 1 2" is, in Go syntax, x[1:2], while "slice x"
is x[:], "slice x 1" is x[1:], and "slice x 1 2 3" is x[1:2:3]. The first
argument must be a string, slice, or array.</p>
               
               <pre><code>func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="truth" data-name="truth">
               <h3>
                  truth 
                  <span class="badge">function</span>
                  
                  <a href="#truth" class="anchor" title="Link to truth">#</a>
               </h3>
               
               <pre><code>func truth(arg reflect.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateType" data-name="validateType">
               <h3>
                  validateType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validateType" class="anchor" title="Link to validateType">#</a>
               </h3>
               
               <p>validateType guarantees that the value is valid and assignable to the type.</p>
               
               <pre><code>func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varValue" data-name="varValue">
               <h3>
                  varValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varValue" class="anchor" title="Link to varValue">#</a>
               </h3>
               
               <p>varValue returns the value of the named variable.</p>
               
               <pre><code>func (s *state) varValue(name string) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walk" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walk" class="anchor" title="Link to walk">#</a>
               </h3>
               
               <p>Walk functions step through the major pieces of the template structure,
generating output as they go.</p>
               
               <pre><code>func (s *state) walk(dot reflect.Value, node parse.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkIfOrWith" data-name="walkIfOrWith">
               <h3>
                  walkIfOrWith 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkIfOrWith" class="anchor" title="Link to walkIfOrWith">#</a>
               </h3>
               
               <p>walkIfOrWith walks an 'if' or 'with' node. The two control structures
are identical in behavior except that 'with' sets dot.</p>
               
               <pre><code>func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list *parse.ListNode, elseList *parse.ListNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkRange" data-name="walkRange">
               <h3>
                  walkRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkRange" class="anchor" title="Link to walkRange">#</a>
               </h3>
               
               <pre><code>func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkTemplate" data-name="walkTemplate">
               <h3>
                  walkTemplate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkTemplate" class="anchor" title="Link to walkTemplate">#</a>
               </h3>
               
               <pre><code>func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeError" data-name="writeError">
               <h3>
                  writeError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeError" class="anchor" title="Link to writeError">#</a>
               </h3>
               
               <pre><code>func (s *state) writeError(err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>