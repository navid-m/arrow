<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - loader</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>loader</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"cmd/internal/bio"
"cmd/internal/goobj"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/sym"
"debug/elf"
"fmt"
"internal/abi"
"io"
"log"
"math/bits"
"os"
"sort"
"strings"
"cmd/internal/goobj"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/sym"
"cmp"
"slices"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="FlagCheckLinkname">
               <h3>
                  FlagCheckLinkname 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagCheckLinkname</code></pre>
            </article>
            
            <article class="global" data-name="FlagStrictDups">
               <h3>
                  FlagStrictDups 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Loader.flags</p>
               
               <pre><code>const FlagStrictDups = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ = fmt.Print</code></pre>
            </article>
            
            <article class="global" data-name="blockedLinknames">
               <h3>
                  blockedLinknames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>A list of blocked linknames. Some linknames are allowed only
in specific packages. This maps symbol names to allowed packages.
If a name is not in this map, it is allowed iff the definition
has a linkname (push).
If a name is in this map, it is allowed only in listed packages,
even if it has a linknamed definition.</p>
               
               <pre><code>var blockedLinknames = map[string][]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="extObj">
               <h3>
                  extObj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>objidx</p>
               
               <pre><code>const extObj</code></pre>
            </article>
            
            <article class="global" data-name="goObjStart">
               <h3>
                  goObjStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>objidx</p>
               
               <pre><code>const goObjStart</code></pre>
            </article>
            
            <article class="global" data-name="hashed64Def">
               <h3>
                  hashed64Def 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashed64Def</code></pre>
            </article>
            
            <article class="global" data-name="hashedDef">
               <h3>
                  hashedDef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashedDef</code></pre>
            </article>
            
            <article class="global" data-name="nilObj">
               <h3>
                  nilObj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>objidx</p>
               
               <pre><code>const nilObj = iota</code></pre>
            </article>
            
            <article class="global" data-name="nonPkgDef">
               <h3>
                  nonPkgDef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nonPkgDef</code></pre>
            </article>
            
            <article class="global" data-name="nonPkgRef">
               <h3>
                  nonPkgRef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nonPkgRef</code></pre>
            </article>
            
            <article class="global" data-name="pkgDef">
               <h3>
                  pkgDef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const pkgDef = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Bitmap">
               <h3>
                  Bitmap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type Bitmap []uint32</code></pre>
            </article>
            
            <article class="type" data-name="Sym">
               <h3>
                  Sym
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Sym encapsulates a global symbol index, used to identify a specific
Go symbol. The 0-valued Sym is corresponds to an invalid symbol.</p>
               
               <pre><code>type Sym sym.LoaderSym</code></pre>
            </article>
            
            <article class="type" data-name="bySymValue">
               <h3>
                  bySymValue
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bySymValue []symWithVal</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Aux">
               <h3>
                  Aux
                  <span class="badge">struct</span>
               </h3>
               
               <p>Aux holds a "handle" to access an aux symbol record from an
object file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Aux struct {
*goobj.Aux
r *oReader
l *Loader
}</code></pre>
            </article>
            
            <article class="struct" data-name="ErrorReporter">
               <h3>
                  ErrorReporter
                  <span class="badge">struct</span>
               </h3>
               
               <p>ErrorReporter is a helper class for reporting errors.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ErrorReporter struct {
ldr *Loader
AfterErrorAction func()
}</code></pre>
            </article>
            
            <article class="struct" data-name="ExtReloc">
               <h3>
                  ExtReloc
                  <span class="badge">struct</span>
               </h3>
               
               <p>ExtReloc contains the payload for an external relocation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ExtReloc struct {
Xsym Sym
Xadd int64
Type objabi.RelocType
Size uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="FuncInfo">
               <h3>
                  FuncInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>FuncInfo provides hooks to access goobj.FuncInfo in the objects.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FuncInfo struct {
l *Loader
r *oReader
data []byte
lengths goobj.FuncInfoLengths
}</code></pre>
            </article>
            
            <article class="struct" data-name="InlTreeNode">
               <h3>
                  InlTreeNode
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InlTreeNode struct {
Parent int32
File goobj.CUFileIndex
Line int32
Func Sym
ParentPC int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="Loader">
               <h3>
                  Loader
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Loader loads new object files and resolves indexed symbol references.
Notes on the layout of global symbol index space:
- Go object files are read before host object files; each Go object
read adds its defined package symbols to the global index space.
Nonpackage symbols are not yet added.
- In loader.LoadNonpkgSyms, add non-package defined symbols and
references in all object files to the global index space.
- Host object file loading happens; the host object loader does a
name/version lookup for each symbol it finds; this can wind up
extending the external symbol index space range. The host object
loader stores symbol payloads in loader.payloads using SymbolBuilder.
- Each symbol gets a unique global index. For duplicated and
overwriting/overwritten symbols, the second (or later) appearance
of the symbol gets the same global index as the first appearance.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Loader struct {
objs []*oReader
extStart Sym
builtinSyms []Sym
objSyms []objSym
symsByName [2]map[string]Sym
extStaticSyms map[nameVer]Sym
extReader *oReader
payloadBatch []extSymPayload
payloads []*extSymPayload
values []int64
sects []*sym.Section
symSects []uint16
align []uint8
deferReturnTramp map[Sym]bool
objByPkg map[string]uint32
anonVersion int
attrReachable Bitmap
attrOnList Bitmap
attrLocal Bitmap
attrNotInSymbolTable Bitmap
attrUsedInIface Bitmap
attrSpecial Bitmap
attrVisibilityHidden Bitmap
attrDuplicateOK Bitmap
attrShared Bitmap
attrExternal Bitmap
generatedSyms Bitmap
attrReadOnly map[Sym]bool
attrCgoExportDynamic map[Sym]struct{...}
attrCgoExportStatic map[Sym]struct{...}
outer []Sym
sub map[Sym]Sym
dynimplib map[Sym]string
dynimpvers map[Sym]string
localentry map[Sym]uint8
extname map[Sym]string
elfType map[Sym]elf.SymType
elfSym map[Sym]int32
localElfSym map[Sym]int32
symPkg map[Sym]string
plt map[Sym]int32
got map[Sym]int32
dynid map[Sym]int32
relocVariant map[relocId]sym.RelocVariant
Reachparent []Sym
CgoExports map[string]Sym
WasmExports []Sym
sizeFixups []symAndSize
flags uint32
strictDupMsgs int
errorReporter *ErrorReporter
npkgsyms int
nhashedsyms int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Reloc">
               <h3>
                  Reloc
                  <span class="badge">struct</span>
               </h3>
               
               <p>Reloc holds a "handle" to access a relocation record from an
object file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reloc struct {
*goobj.Reloc
r *oReader
l *Loader
}</code></pre>
            </article>
            
            <article class="struct" data-name="Relocs">
               <h3>
                  Relocs
                  <span class="badge">struct</span>
               </h3>
               
               <p>Relocs encapsulates the set of relocations on a given symbol; an
instance of this type is returned by the Loader Relocs() method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Relocs struct {
rs []goobj.Reloc
li uint32
r *oReader
l *Loader
}</code></pre>
            </article>
            
            <article class="struct" data-name="SymbolBuilder">
               <h3>
                  SymbolBuilder
                  <span class="badge">struct</span>
               </h3>
               
               <p>SymbolBuilder is a helper designed to help with the construction
of new symbol contents.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SymbolBuilder struct {
*extSymPayload
symIdx Sym
l *Loader
}</code></pre>
            </article>
            
            <article class="struct" data-name="extSymPayload">
               <h3>
                  extSymPayload
                  <span class="badge">struct</span>
               </h3>
               
               <p>extSymPayload holds the payload (data + relocations) for linker-synthesized
external symbols (note that symbol value is stored in a separate slice).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type extSymPayload struct {
name string
size int64
ver int
kind sym.SymKind
objidx uint32
relocs []goobj.Reloc
data []byte
auxs []goobj.Aux
}</code></pre>
            </article>
            
            <article class="struct" data-name="linknameVarRef">
               <h3>
                  linknameVarRef
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type linknameVarRef struct {
pkg string
name string
sym Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="loadState">
               <h3>
                  loadState
                  <span class="badge">struct</span>
               </h3>
               
               <p>Holds the loader along with temporary states for loading symbols.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type loadState struct {
l *Loader
hashed64Syms map[uint64]symAndSize
hashedSyms map[goobj.HashType]symAndSize
linknameVarRefs []linknameVarRef
}</code></pre>
            </article>
            
            <article class="struct" data-name="nameVer">
               <h3>
                  nameVer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nameVer struct {
name string
v int
}</code></pre>
            </article>
            
            <article class="struct" data-name="oReader">
               <h3>
                  oReader
                  <span class="badge">struct</span>
               </h3>
               
               <p>oReader is a wrapper type of obj.Reader, along with some
extra information.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type oReader struct {
*goobj.Reader
unit *sym.CompilationUnit
version int
pkgprefix string
syms []Sym
pkg []uint32
ndef int
nhashed64def int
nhasheddef int
objidx uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="objSym">
               <h3>
                  objSym
                  <span class="badge">struct</span>
               </h3>
               
               <p>objSym represents a symbol in an object file. It is a tuple of
the object and the symbol's local index.
For external symbols, objidx is the index of l.extReader (extObj),
s is its index into the payload array.
{0, 0} represents the nil symbol.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type objSym struct {
objidx uint32
s uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="relocId">
               <h3>
                  relocId
                  <span class="badge">struct</span>
               </h3>
               
               <p>relocId is essentially a <S,R> tuple identifying the Rth
relocation of symbol S.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type relocId struct {
sym Sym
ridx int
}</code></pre>
            </article>
            
            <article class="struct" data-name="symAndSize">
               <h3>
                  symAndSize
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type symAndSize struct {
sym Sym
size uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="symWithVal">
               <h3>
                  symWithVal
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type symWithVal struct {
s Sym
v int64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddAddr">
               <h3>
                  AddAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddAddr(arch *sys.Arch, tgt Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddAddrPlus">
               <h3>
                  AddAddrPlus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddAddrPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddAddrPlus4">
               <h3>
                  AddAddrPlus4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddAddrPlus4(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddBytes">
               <h3>
                  AddBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddBytes(data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="AddCStringAt">
               <h3>
                  AddCStringAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddCStringAt adds str plus a null terminating byte.</p>
               
               <pre><code>func (sb *SymbolBuilder) AddCStringAt(off int64, str string) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddCURelativeAddrPlus">
               <h3>
                  AddCURelativeAddrPlus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddCURelativeAddrPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddCgoExport">
               <h3>
                  AddCgoExport 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddCgoExport records a cgo-exported symbol in l.CgoExports.
This table is used to identify the correct Go symbol ABI to use
to resolve references from host objects (which don't have ABIs).</p>
               
               <pre><code>func (l *Loader) AddCgoExport(s Sym)</code></pre>
            </article>
            
            <article class="function" data-name="AddInteriorSym">
               <h3>
                  AddInteriorSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddInteriorSym sets up 'interior' as an interior symbol of
container/payload symbol 'container'. An interior symbol does not
itself have data, but gives a name to a subrange of the data in its
container symbol. The container itself may or may not have a name.
This method is intended primarily for use in the host object
loaders, to capture the semantics of symbols and sections in an
object file. When reading a host object file, we'll typically
encounter a static section symbol (ex: ".text") containing content
for a collection of functions, then a series of ELF (or macho, etc)
symbol table entries each of which points into a sub-section
(offset and length) of its corresponding container symbol. Within
the go linker we create a loader.Sym for the container (which is
expected to have the actual content/payload) and then a set of
interior loader.Sym's that point into a portion of the container.</p>
               
               <pre><code>func (l *Loader) AddInteriorSym(container Sym, interior Sym)</code></pre>
            </article>
            
            <article class="function" data-name="AddInteriorSym">
               <h3>
                  AddInteriorSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddInteriorSym(sub Sym)</code></pre>
            </article>
            
            <article class="function" data-name="AddPCRelPlus">
               <h3>
                  AddPCRelPlus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddPCRelPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddPEImageRelativeAddrPlus">
               <h3>
                  AddPEImageRelativeAddrPlus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddPEImageRelativeAddrPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddRel">
               <h3>
                  AddRel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add a relocation with given type, return its handle and index
(to set other fields).</p>
               
               <pre><code>func (sb *SymbolBuilder) AddRel(typ objabi.RelocType) (Reloc, int)</code></pre>
            </article>
            
            <article class="function" data-name="AddRelocs">
               <h3>
                  AddRelocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add n relocations, return a handle to the relocations.</p>
               
               <pre><code>func (sb *SymbolBuilder) AddRelocs(n int) Relocs</code></pre>
            </article>
            
            <article class="function" data-name="AddSize">
               <h3>
                  AddSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddSize(arch *sys.Arch, tgt Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddStringAt">
               <h3>
                  AddStringAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddStringAt(off int64, str string) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddSymRef">
               <h3>
                  AddSymRef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add a symbol reference (relocation) with given type, addend, and size
(the most generic form).</p>
               
               <pre><code>func (sb *SymbolBuilder) AddSymRef(arch *sys.Arch, tgt Sym, add int64, typ objabi.RelocType, rsize int) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddToSymValue">
               <h3>
                  AddToSymValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddToSymValue adds to the value of the i-th symbol. i is the global index.</p>
               
               <pre><code>func (l *Loader) AddToSymValue(i Sym, val int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddUint">
               <h3>
                  AddUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUint(arch *sys.Arch, v uint64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddUint16">
               <h3>
                  AddUint16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUint16(arch *sys.Arch, v uint16) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddUint32">
               <h3>
                  AddUint32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUint32(arch *sys.Arch, v uint32) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddUint64">
               <h3>
                  AddUint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUint64(arch *sys.Arch, v uint64) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddUint8">
               <h3>
                  AddUint8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUint8(v uint8) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddUintXX">
               <h3>
                  AddUintXX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUintXX(arch *sys.Arch, v uint64, wid int) int64</code></pre>
            </article>
            
            <article class="function" data-name="AddUleb">
               <h3>
                  AddUleb 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) AddUleb(v uint64)</code></pre>
            </article>
            
            <article class="function" data-name="Addstring">
               <h3>
                  Addstring 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Addstring(str string) int64</code></pre>
            </article>
            
            <article class="function" data-name="Align">
               <h3>
                  Align 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Align() int32</code></pre>
            </article>
            
            <article class="function" data-name="Args">
               <h3>
                  Args 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) Args() int</code></pre>
            </article>
            
            <article class="function" data-name="AssignTextSymbolOrder">
               <h3>
                  AssignTextSymbolOrder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AssignTextSymbolOrder populates the Textp slices within each
library and compilation unit, insuring that packages are laid down
in dependency order (internal first, then everything else). Return value
is a slice of all text syms.</p>
               
               <pre><code>func (l *Loader) AssignTextSymbolOrder(libs []*sym.Library, intlibs []bool, extsyms []Sym) []Sym</code></pre>
            </article>
            
            <article class="function" data-name="At">
               <h3>
                  At 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>At returns the j-th reloc for a global symbol.</p>
               
               <pre><code>func (relocs *Relocs) At(j int) Reloc</code></pre>
            </article>
            
            <article class="function" data-name="AttrCgoExport">
               <h3>
                  AttrCgoExport 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) AttrCgoExport(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrCgoExportDynamic">
               <h3>
                  AttrCgoExportDynamic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrCgoExportDynamic returns true for a symbol that has been
specially marked via the "cgo_export_dynamic" compiler directive
written by cgo (in response to //export directives in the source).</p>
               
               <pre><code>func (l *Loader) AttrCgoExportDynamic(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrCgoExportStatic">
               <h3>
                  AttrCgoExportStatic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrCgoExportStatic returns true for a symbol that has been
specially marked via the "cgo_export_static" directive
written by cgo.</p>
               
               <pre><code>func (l *Loader) AttrCgoExportStatic(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrDuplicateOK">
               <h3>
                  AttrDuplicateOK 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrDuplicateOK returns true for a symbol that can be present in
multiple object files.</p>
               
               <pre><code>func (l *Loader) AttrDuplicateOK(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrExternal">
               <h3>
                  AttrExternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrExternal returns true for function symbols loaded from host
object files.</p>
               
               <pre><code>func (l *Loader) AttrExternal(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrLocal">
               <h3>
                  AttrLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrLocal returns true for symbols that are only visible within the
module (executable or shared library) being linked. This attribute
is applied to thunks and certain other linker-generated symbols.</p>
               
               <pre><code>func (l *Loader) AttrLocal(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrNotInSymbolTable">
               <h3>
                  AttrNotInSymbolTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrNotInSymbolTable returns true for symbols that should not be
added to the symbol table of the final generated load module.</p>
               
               <pre><code>func (l *Loader) AttrNotInSymbolTable(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrOnList">
               <h3>
                  AttrOnList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrOnList returns true for symbols that are on some list (such as
the list of all text symbols, or one of the lists of data symbols)
and is consulted to avoid bugs where a symbol is put on a list
twice.</p>
               
               <pre><code>func (l *Loader) AttrOnList(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrReachable">
               <h3>
                  AttrReachable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrReachable returns true for symbols that are transitively
referenced from the entry points. Unreachable symbols are not
written to the output.</p>
               
               <pre><code>func (l *Loader) AttrReachable(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrReadOnly">
               <h3>
                  AttrReadOnly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrReadOnly returns true for a symbol whose underlying data
is stored via a read-only mmap.</p>
               
               <pre><code>func (l *Loader) AttrReadOnly(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrShared">
               <h3>
                  AttrShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrShared returns true for symbols compiled with the -shared option.</p>
               
               <pre><code>func (l *Loader) AttrShared(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrSpecial">
               <h3>
                  AttrSpecial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrSpecial returns true for a symbols that do not have their
address (i.e. Value) computed by the usual mechanism of
data.go:dodata() & data.go:address().</p>
               
               <pre><code>func (l *Loader) AttrSpecial(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrSubSymbol">
               <h3>
                  AttrSubSymbol 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) AttrSubSymbol(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrUsedInIface">
               <h3>
                  AttrUsedInIface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrUsedInIface returns true for a type symbol that is used in
an interface.</p>
               
               <pre><code>func (l *Loader) AttrUsedInIface(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="AttrVisibilityHidden">
               <h3>
                  AttrVisibilityHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AttrVisibilityHidden symbols returns true for ELF symbols with
visibility set to STV_HIDDEN. They become local symbols in
the final executable. Only relevant when internally linking
on an ELF platform.</p>
               
               <pre><code>func (l *Loader) AttrVisibilityHidden(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="Aux">
               <h3>
                  Aux 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the "handle" to the j-th aux symbol of the i-th symbol.</p>
               
               <pre><code>func (l *Loader) Aux(i Sym, j int) Aux</code></pre>
            </article>
            
            <article class="function" data-name="CgoExportDynamic">
               <h3>
                  CgoExportDynamic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) CgoExportDynamic() bool</code></pre>
            </article>
            
            <article class="function" data-name="CopySym">
               <h3>
                  CopySym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy the payload of symbol src to dst. Both src and dst must be external
symbols.
The intended use case is that when building/linking against a shared library,
where we do symbol name mangling, the Go object file may have reference to
the original symbol name whereas the shared library provides a symbol with
the mangled name. When we do mangling, we copy payload of mangled to original.</p>
               
               <pre><code>func (l *Loader) CopySym(src Sym, dst Sym)</code></pre>
            </article>
            
            <article class="function" data-name="Count">
               <h3>
                  Count 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (relocs *Relocs) Count() int</code></pre>
            </article>
            
            <article class="function" data-name="Count">
               <h3>
                  Count 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>return the number of bits set.</p>
               
               <pre><code>func (bm Bitmap) Count() int</code></pre>
            </article>
            
            <article class="function" data-name="CreateExtSym">
               <h3>
                  CreateExtSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CreateExtSym creates a new external symbol with the specified name
without adding it to any lookup tables, returning a Sym index for it.</p>
               
               <pre><code>func (l *Loader) CreateExtSym(name string, ver int) Sym</code></pre>
            </article>
            
            <article class="function" data-name="CreateStaticSym">
               <h3>
                  CreateStaticSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CreateStaticSym creates a new static symbol with the specified name
without adding it to any lookup tables, returning a Sym index for it.</p>
               
               <pre><code>func (l *Loader) CreateStaticSym(name string) Sym</code></pre>
            </article>
            
            <article class="function" data-name="CreateSymForUpdate">
               <h3>
                  CreateSymForUpdate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CreateSymForUpdate creates a symbol with given name and version,
returns a CreateSymForUpdate for update. If the symbol already
exists, it will update in-place.</p>
               
               <pre><code>func (l *Loader) CreateSymForUpdate(name string, version int) *SymbolBuilder</code></pre>
            </article>
            
            <article class="function" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Data() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the symbol content of the i-th symbol. i is global index.</p>
               
               <pre><code>func (l *Loader) Data(i Sym) []byte</code></pre>
            </article>
            
            <article class="function" data-name="DataString">
               <h3>
                  DataString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the symbol content of the i-th symbol as a string. i is global index.</p>
               
               <pre><code>func (l *Loader) DataString(i Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="Dump">
               <h3>
                  Dump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>For debugging.</p>
               
               <pre><code>func (l *Loader) Dump()</code></pre>
            </article>
            
            <article class="function" data-name="DuplicateOK">
               <h3>
                  DuplicateOK 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) DuplicateOK() bool</code></pre>
            </article>
            
            <article class="function" data-name="DynidSyms">
               <h3>
                  DynidSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DynidSyms returns the set of symbols for which dynID is set to an
interesting (non-default) value. This is expected to be a fairly
small set.</p>
               
               <pre><code>func (l *Loader) DynidSyms() []Sym</code></pre>
            </article>
            
            <article class="function" data-name="Dynimplib">
               <h3>
                  Dynimplib 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Dynimplib() string</code></pre>
            </article>
            
            <article class="function" data-name="Dynimpvers">
               <h3>
                  Dynimpvers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Dynimpvers() string</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Errorf method logs an error message. See ErrorReporter.Errorf for details.</p>
               
               <pre><code>func (l *Loader) Errorf(s Sym, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Errorf method logs an error message.
After each error, the error actions function will be invoked; this
will either terminate the link immediately (if -h option given)
or it will keep a count and exit if more than 20 errors have been printed.
Logging an error means that on exit cmd/link will delete any
output file and return a non-zero error code.</p>
               
               <pre><code>func (reporter *ErrorReporter) Errorf(s Sym, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="External">
               <h3>
                  External 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) External() bool</code></pre>
            </article>
            
            <article class="function" data-name="Extname">
               <h3>
                  Extname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Extname() string</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) File(k int) goobj.CUFileIndex</code></pre>
            </article>
            
            <article class="function" data-name="ForAllCgoExportDynamic">
               <h3>
                  ForAllCgoExportDynamic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ForAllCgoExportDynamic calls f for every symbol that has been
marked with the "cgo_export_dynamic" compiler directive.</p>
               
               <pre><code>func (l *Loader) ForAllCgoExportDynamic(f func(Sym))</code></pre>
            </article>
            
            <article class="function" data-name="FreeData">
               <h3>
                  FreeData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FreeData clears the symbol data of an external symbol, allowing the memory
to be freed earlier. No-op for non-external symbols.
i is global index.</p>
               
               <pre><code>func (l *Loader) FreeData(i Sym)</code></pre>
            </article>
            
            <article class="function" data-name="FreeSym">
               <h3>
                  FreeSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) FreeSym(i Sym)</code></pre>
            </article>
            
            <article class="function" data-name="FuncFlag">
               <h3>
                  FuncFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) FuncFlag() abi.FuncFlag</code></pre>
            </article>
            
            <article class="function" data-name="FuncID">
               <h3>
                  FuncID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) FuncID() abi.FuncID</code></pre>
            </article>
            
            <article class="function" data-name="FuncInfo">
               <h3>
                  FuncInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) FuncInfo(i Sym) FuncInfo</code></pre>
            </article>
            
            <article class="function" data-name="Funcdata">
               <h3>
                  Funcdata 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns all funcdata symbols of symbol i.
tmp is a scratch space.</p>
               
               <pre><code>func (l *Loader) Funcdata(i Sym, tmp []Sym) []Sym</code></pre>
            </article>
            
            <article class="function" data-name="GenAddAddrPlusFunc">
               <h3>
                  GenAddAddrPlusFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GenAddAddrPlusFunc returns a function to be called when capturing
a function symbol's address. In later stages of the link (when
address assignment is done) when doing internal linking and
targeting an executable, we can just emit the address of a function
directly instead of generating a relocation. Clients can call
this function (setting 'internalExec' based on build mode and target)
and then invoke the returned function in roughly the same way that
loader.*SymbolBuilder.AddAddrPlus would be used.</p>
               
               <pre><code>func GenAddAddrPlusFunc(internalExec bool) (func(s *SymbolBuilder, arch *sys.Arch, tgt Sym, add int64) int64)</code></pre>
            </article>
            
            <article class="function" data-name="GetErrorReporter">
               <h3>
                  GetErrorReporter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GetErrorReporter returns the loader's associated error reporter.</p>
               
               <pre><code>func (l *Loader) GetErrorReporter() *ErrorReporter</code></pre>
            </article>
            
            <article class="function" data-name="GetFuncDwarfAuxSyms">
               <h3>
                  GetFuncDwarfAuxSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GetFuncDwarfAuxSyms collects and returns the auxiliary DWARF
symbols associated with a given function symbol.  Prior to the
introduction of the loader, this was done purely using name
lookups, e.f. for function with name XYZ we would then look up
go.info.XYZ, etc.</p>
               
               <pre><code>func (l *Loader) GetFuncDwarfAuxSyms(fnSymIdx Sym) (auxDwarfInfo Sym, auxDwarfLoc Sym, auxDwarfRanges Sym, auxDwarfLines Sym)</code></pre>
            </article>
            
            <article class="function" data-name="GetVarDwarfAuxSym">
               <h3>
                  GetVarDwarfAuxSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) GetVarDwarfAuxSym(i Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="GoType">
               <h3>
                  GoType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) GoType() Sym</code></pre>
            </article>
            
            <article class="function" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ms *extSymPayload) Grow(siz int64)</code></pre>
            </article>
            
            <article class="function" data-name="Has">
               <h3>
                  Has 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>whether the i-th bit is set.</p>
               
               <pre><code>func (bm Bitmap) Has(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="InitReachable">
               <h3>
                  InitReachable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Initialize Reachable bitmap and its siblings for running deadcode pass.</p>
               
               <pre><code>func (l *Loader) InitReachable()</code></pre>
            </article>
            
            <article class="function" data-name="InlTree">
               <h3>
                  InlTree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) InlTree(k int) InlTreeNode</code></pre>
            </article>
            
            <article class="function" data-name="IsDeferReturnTramp">
               <h3>
                  IsDeferReturnTramp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Return whether this is a trampoline of a deferreturn call.</p>
               
               <pre><code>func (l *Loader) IsDeferReturnTramp(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDict">
               <h3>
                  IsDict 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether this symbol is a dictionary symbol.</p>
               
               <pre><code>func (l *Loader) IsDict(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsExternal">
               <h3>
                  IsExternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) IsExternal(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFileLocal">
               <h3>
                  IsFileLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) IsFileLocal(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFromAssembly">
               <h3>
                  IsFromAssembly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsFromAssembly returns true if this symbol is derived from an
object file generated by the Go assembler.</p>
               
               <pre><code>func (l *Loader) IsFromAssembly(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsGeneratedSym">
               <h3>
                  IsGeneratedSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsGeneratedSym returns true if a symbol's been previously marked as a
generator symbol through the SetIsGeneratedSym. The functions for generator
symbols are kept in the Link context.</p>
               
               <pre><code>func (l *Loader) IsGeneratedSym(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsGoType">
               <h3>
                  IsGoType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether this is a Go type symbol.</p>
               
               <pre><code>func (l *Loader) IsGoType(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsItab">
               <h3>
                  IsItab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether this symbol is an itab symbol.</p>
               
               <pre><code>func (l *Loader) IsItab(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMarker">
               <h3>
                  IsMarker 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rel Reloc) IsMarker() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNoSplit">
               <h3>
                  IsNoSplit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether the i-th symbol is nosplit.</p>
               
               <pre><code>func (l *Loader) IsNoSplit(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPkgInit">
               <h3>
                  IsPkgInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether this symbol is a compiler-generated package init func.</p>
               
               <pre><code>func (l *Loader) IsPkgInit(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsReflectMethod">
               <h3>
                  IsReflectMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether the i-th symbol has ReflectMethod attribute set.</p>
               
               <pre><code>func (l *Loader) IsReflectMethod(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsTypelink">
               <h3>
                  IsTypelink 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns whether this symbol should be included in typelink.</p>
               
               <pre><code>func (l *Loader) IsTypelink(i Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s bySymValue) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>return current length of bitmap in bits.</p>
               
               <pre><code>func (bm Bitmap) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s bySymValue) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="LoadSyms">
               <h3>
                  LoadSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add syms, hashed (content-addressable) symbols, non-package symbols, and
references to external symbols (which are always named).</p>
               
               <pre><code>func (l *Loader) LoadSyms(arch *sys.Arch)</code></pre>
            </article>
            
            <article class="function" data-name="Localentry">
               <h3>
                  Localentry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Localentry() uint8</code></pre>
            </article>
            
            <article class="function" data-name="Locals">
               <h3>
                  Locals 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) Locals() int</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Look up a symbol by name, return global index, or 0 if not found.
This is more like Syms.ROLookup than Lookup -- it doesn't create
new symbol.</p>
               
               <pre><code>func (l *Loader) Lookup(name string, ver int) Sym</code></pre>
            </article>
            
            <article class="function" data-name="LookupOrCreateCgoExport">
               <h3>
                  LookupOrCreateCgoExport 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupOrCreateCgoExport is like LookupOrCreateSym, but if ver
indicates a global symbol, it uses the CgoExport table to determine
the appropriate symbol version (ABI) to use. ver must be either 0
or a static symbol version.</p>
               
               <pre><code>func (l *Loader) LookupOrCreateCgoExport(name string, ver int) Sym</code></pre>
            </article>
            
            <article class="function" data-name="LookupOrCreateSym">
               <h3>
                  LookupOrCreateSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupOrCreateSym looks up the symbol with the specified name/version,
returning its Sym index if found. If the lookup fails, a new external
Sym will be created, entered into the lookup tables, and returned.</p>
               
               <pre><code>func (l *Loader) LookupOrCreateSym(name string, ver int) Sym</code></pre>
            </article>
            
            <article class="function" data-name="MakeBitmap">
               <h3>
                  MakeBitmap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func MakeBitmap(n int) Bitmap</code></pre>
            </article>
            
            <article class="function" data-name="MakeSymbolBuilder">
               <h3>
                  MakeSymbolBuilder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MakeSymbolBuilder creates a symbol builder for use in constructing
an entirely new symbol.</p>
               
               <pre><code>func (l *Loader) MakeSymbolBuilder(name string) *SymbolBuilder</code></pre>
            </article>
            
            <article class="function" data-name="MakeSymbolUpdater">
               <h3>
                  MakeSymbolUpdater 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MakeSymbolUpdater creates a symbol builder helper for an existing
symbol 'symIdx'. If 'symIdx' is not an external symbol, then create
a clone of it (copy name, properties, etc) fix things up so that
the lookup tables and caches point to the new version, not the old
version.</p>
               
               <pre><code>func (l *Loader) MakeSymbolUpdater(symIdx Sym) *SymbolBuilder</code></pre>
            </article>
            
            <article class="function" data-name="MakeWritable">
               <h3>
                  MakeWritable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) MakeWritable()</code></pre>
            </article>
            
            <article class="function" data-name="NAlldef">
               <h3>
                  NAlldef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Total number of defined symbols (package symbols, hashed symbols, and
non-package symbols).</p>
               
               <pre><code>func (r *oReader) NAlldef() int</code></pre>
            </article>
            
            <article class="function" data-name="NAux">
               <h3>
                  NAux 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the number of aux symbols given a global index.</p>
               
               <pre><code>func (l *Loader) NAux(i Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="NDef">
               <h3>
                  NDef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Number of defined Go symbols.</p>
               
               <pre><code>func (l *Loader) NDef() int</code></pre>
            </article>
            
            <article class="function" data-name="NReachableSym">
               <h3>
                  NReachableSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Number of reachable symbols.</p>
               
               <pre><code>func (l *Loader) NReachableSym() int</code></pre>
            </article>
            
            <article class="function" data-name="NStrictDupMsgs">
               <h3>
                  NStrictDupMsgs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) NStrictDupMsgs() int</code></pre>
            </article>
            
            <article class="function" data-name="NSym">
               <h3>
                  NSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Number of total symbols.</p>
               
               <pre><code>func (l *Loader) NSym() int</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="NewLoader">
               <h3>
                  NewLoader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewLoader(flags uint32, reporter *ErrorReporter) *Loader</code></pre>
            </article>
            
            <article class="function" data-name="NewSection">
               <h3>
                  NewSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NewSection creates a new (output) section.</p>
               
               <pre><code>func (l *Loader) NewSection() *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="NumFile">
               <h3>
                  NumFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) NumFile() uint32</code></pre>
            </article>
            
            <article class="function" data-name="NumFuncdata">
               <h3>
                  NumFuncdata 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the number of funcdata for symbol i.</p>
               
               <pre><code>func (l *Loader) NumFuncdata(i Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="NumInlTree">
               <h3>
                  NumInlTree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) NumInlTree() uint32</code></pre>
            </article>
            
            <article class="function" data-name="NumPcdata">
               <h3>
                  NumPcdata 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the number of pcdata for symbol i.</p>
               
               <pre><code>func (l *Loader) NumPcdata(i Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="OnList">
               <h3>
                  OnList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) OnList() bool</code></pre>
            </article>
            
            <article class="function" data-name="Outer">
               <h3>
                  Outer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Outer() Sym</code></pre>
            </article>
            
            <article class="function" data-name="OuterSym">
               <h3>
                  OuterSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OuterSym gets the outer/container symbol.</p>
               
               <pre><code>func (l *Loader) OuterSym(i Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="PcdataAuxs">
               <h3>
                  PcdataAuxs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns all aux symbols of per-PC data for symbol i.
tmp is a scratch space for the pcdata slice.</p>
               
               <pre><code>func (l *Loader) PcdataAuxs(i Sym, tmp []Sym) (pcsp Sym, pcfile Sym, pcline Sym, pcinline Sym, pcdata []Sym)</code></pre>
            </article>
            
            <article class="function" data-name="Pcsp">
               <h3>
                  Pcsp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) Pcsp(i Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="Preload">
               <h3>
                  Preload 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Preload has to be called prior to invoking the various methods
below related to pcdata, funcdataoff, files, and inltree nodes.</p>
               
               <pre><code>func (fi *FuncInfo) Preload()</code></pre>
            </article>
            
            <article class="function" data-name="Preload">
               <h3>
                  Preload 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Preload a package: adds autolib.
Does not add defined package or non-packaged symbols to the symbol table.
These are done in LoadSyms.
Does not read symbol data.
Returns the fingerprint of the object.</p>
               
               <pre><code>func (l *Loader) Preload(localSymVersion int, f *bio.Reader, lib *sym.Library, unit *sym.CompilationUnit, length int64) goobj.FingerprintType</code></pre>
            </article>
            
            <article class="function" data-name="Reachable">
               <h3>
                  Reachable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Reachable() bool</code></pre>
            </article>
            
            <article class="function" data-name="ReadOnly">
               <h3>
                  ReadOnly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) ReadOnly() bool</code></pre>
            </article>
            
            <article class="function" data-name="RelocVariant">
               <h3>
                  RelocVariant 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RelocVariant returns the 'variant' property of a relocation on
some specific symbol.</p>
               
               <pre><code>func (l *Loader) RelocVariant(s Sym, ri int) sym.RelocVariant</code></pre>
            </article>
            
            <article class="function" data-name="Relocs">
               <h3>
                  Relocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Relocs returns a Relocs object for the given global sym.</p>
               
               <pre><code>func (l *Loader) Relocs(i Sym) Relocs</code></pre>
            </article>
            
            <article class="function" data-name="Relocs">
               <h3>
                  Relocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Relocs() Relocs</code></pre>
            </article>
            
            <article class="function" data-name="ResetRelocs">
               <h3>
                  ResetRelocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ResetRelocs removes all relocations on this symbol.</p>
               
               <pre><code>func (sb *SymbolBuilder) ResetRelocs()</code></pre>
            </article>
            
            <article class="function" data-name="SEHUnwindSym">
               <h3>
                  SEHUnwindSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SEHUnwindSym returns the auxiliary SEH unwind symbol associated with
a given function symbol.</p>
               
               <pre><code>func (l *Loader) SEHUnwindSym(fnSymIdx Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sect">
               <h3>
                  Sect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Sect() *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>set the i-th bit.</p>
               
               <pre><code>func (bm Bitmap) Set(i Sym)</code></pre>
            </article>
            
            <article class="function" data-name="SetAddr">
               <h3>
                  SetAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetAddr(arch *sys.Arch, off int64, tgt Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetAddrPlus">
               <h3>
                  SetAddrPlus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetAddrPlus(arch *sys.Arch, off int64, tgt Sym, add int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetAlign">
               <h3>
                  SetAlign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetAlign(align int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrCgoExportDynamic">
               <h3>
                  SetAttrCgoExportDynamic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrCgoExportDynamic sets the "cgo_export_dynamic" for a symbol
(see AttrCgoExportDynamic).</p>
               
               <pre><code>func (l *Loader) SetAttrCgoExportDynamic(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrCgoExportStatic">
               <h3>
                  SetAttrCgoExportStatic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrCgoExportStatic sets the "cgo_export_static" for a symbol
(see AttrCgoExportStatic).</p>
               
               <pre><code>func (l *Loader) SetAttrCgoExportStatic(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrDuplicateOK">
               <h3>
                  SetAttrDuplicateOK 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrDuplicateOK sets the "duplicate OK" property for an external
symbol (see AttrDuplicateOK).</p>
               
               <pre><code>func (l *Loader) SetAttrDuplicateOK(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrExternal">
               <h3>
                  SetAttrExternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrExternal sets the "external" property for a host object
symbol (see AttrExternal).</p>
               
               <pre><code>func (l *Loader) SetAttrExternal(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrLocal">
               <h3>
                  SetAttrLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrLocal the "local" property for a symbol (see AttrLocal above).</p>
               
               <pre><code>func (l *Loader) SetAttrLocal(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrNotInSymbolTable">
               <h3>
                  SetAttrNotInSymbolTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrNotInSymbolTable the "not in symtab" property for a symbol
(see AttrNotInSymbolTable above).</p>
               
               <pre><code>func (l *Loader) SetAttrNotInSymbolTable(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrOnList">
               <h3>
                  SetAttrOnList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrOnList sets the "on list" property for a symbol (see
AttrOnList).</p>
               
               <pre><code>func (l *Loader) SetAttrOnList(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrReachable">
               <h3>
                  SetAttrReachable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrReachable sets the reachability property for a symbol (see
AttrReachable).</p>
               
               <pre><code>func (l *Loader) SetAttrReachable(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrReadOnly">
               <h3>
                  SetAttrReadOnly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrReadOnly sets the "data is read only" property for a symbol
(see AttrReadOnly).</p>
               
               <pre><code>func (l *Loader) SetAttrReadOnly(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrShared">
               <h3>
                  SetAttrShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrShared sets the "shared" property for an external
symbol (see AttrShared).</p>
               
               <pre><code>func (l *Loader) SetAttrShared(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrSpecial">
               <h3>
                  SetAttrSpecial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrSpecial sets the "special" property for a symbol (see
AttrSpecial).</p>
               
               <pre><code>func (l *Loader) SetAttrSpecial(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrUsedInIface">
               <h3>
                  SetAttrUsedInIface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) SetAttrUsedInIface(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAttrVisibilityHidden">
               <h3>
                  SetAttrVisibilityHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAttrVisibilityHidden sets the "hidden visibility" property for a
symbol (see AttrVisibilityHidden).</p>
               
               <pre><code>func (l *Loader) SetAttrVisibilityHidden(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytesAt">
               <h3>
                  SetBytesAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetBytesAt(off int64, b []byte) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetCarrierSym">
               <h3>
                  SetCarrierSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetCarrierSym declares that 'c' is the carrier or container symbol
for 's'. Carrier symbols are used in the linker to as a container
for a collection of sub-symbols where the content of the
sub-symbols is effectively concatenated to form the content of the
carrier. The carrier is given a name in the output symbol table
while the sub-symbol names are not. For example, the Go compiler
emits named string symbols (type SGOSTRING) when compiling a
package; after being deduplicated, these symbols are collected into
a single unit by assigning them a new carrier symbol named
"go:string.*" (which appears in the final symbol table for the
output load module).</p>
               
               <pre><code>func (l *Loader) SetCarrierSym(s Sym, c Sym)</code></pre>
            </article>
            
            <article class="function" data-name="SetData">
               <h3>
                  SetData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetData(data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="SetDuplicateOK">
               <h3>
                  SetDuplicateOK 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetDuplicateOK(v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetDynimplib">
               <h3>
                  SetDynimplib 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetDynimplib(value string)</code></pre>
            </article>
            
            <article class="function" data-name="SetDynimpvers">
               <h3>
                  SetDynimpvers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetDynimpvers(value string)</code></pre>
            </article>
            
            <article class="function" data-name="SetExternal">
               <h3>
                  SetExternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetExternal(v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetExtname">
               <h3>
                  SetExtname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetExtname(value string)</code></pre>
            </article>
            
            <article class="function" data-name="SetGot">
               <h3>
                  SetGot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetGot(value int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetGot">
               <h3>
                  SetGot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetGot sets the GOT offset of symbol i.</p>
               
               <pre><code>func (l *Loader) SetGot(i Sym, v int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsDeferReturnTramp">
               <h3>
                  SetIsDeferReturnTramp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set that i is a trampoline of a deferreturn call.</p>
               
               <pre><code>func (l *Loader) SetIsDeferReturnTramp(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsGeneratedSym">
               <h3>
                  SetIsGeneratedSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetIsGeneratedSym marks symbols as generated symbols. Data shouldn't be
stored in generated symbols, and a function is registered and called for
each of these symbols.</p>
               
               <pre><code>func (l *Loader) SetIsGeneratedSym(i Sym, v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetLocal">
               <h3>
                  SetLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetLocal(value bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetLocalentry">
               <h3>
                  SetLocalentry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetLocalentry(value uint8)</code></pre>
            </article>
            
            <article class="function" data-name="SetNotInSymbolTable">
               <h3>
                  SetNotInSymbolTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetNotInSymbolTable(value bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetOnList">
               <h3>
                  SetOnList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetOnList(v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetPlt">
               <h3>
                  SetPlt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetPlt(value int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetPlt">
               <h3>
                  SetPlt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetPlt sets the PLT offset of symbol i.</p>
               
               <pre><code>func (l *Loader) SetPlt(i Sym, v int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetReachable">
               <h3>
                  SetReachable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetReachable(v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetReadOnly">
               <h3>
                  SetReadOnly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetReadOnly(v bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetRelocAdd">
               <h3>
                  SetRelocAdd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetRelocAdd sets the addend of the 'i'-th relocation on this sym to 'a'</p>
               
               <pre><code>func (sb *SymbolBuilder) SetRelocAdd(i int, a int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetRelocSym">
               <h3>
                  SetRelocSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetRelocSym sets the target sym of the 'i'-th relocation on this sym to 's'</p>
               
               <pre><code>func (sb *SymbolBuilder) SetRelocSym(i int, tgt Sym)</code></pre>
            </article>
            
            <article class="function" data-name="SetRelocType">
               <h3>
                  SetRelocType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetRelocType sets the type of the 'i'-th relocation on this sym to 't'</p>
               
               <pre><code>func (sb *SymbolBuilder) SetRelocType(i int, t objabi.RelocType)</code></pre>
            </article>
            
            <article class="function" data-name="SetRelocVariant">
               <h3>
                  SetRelocVariant 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetRelocVariant sets the 'variant' property of a relocation on
some specific symbol.</p>
               
               <pre><code>func (l *Loader) SetRelocVariant(s Sym, ri int, v sym.RelocVariant)</code></pre>
            </article>
            
            <article class="function" data-name="SetSect">
               <h3>
                  SetSect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetSect(sect *sym.Section)</code></pre>
            </article>
            
            <article class="function" data-name="SetSize">
               <h3>
                  SetSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetSize(size int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetSpecial">
               <h3>
                  SetSpecial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetSpecial(value bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetSym">
               <h3>
                  SetSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rel Reloc) SetSym(s Sym)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymAlign">
               <h3>
                  SetSymAlign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymAlign sets the alignment for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymAlign(i Sym, align int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymDynid">
               <h3>
                  SetSymDynid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymDynid sets the "dynid" property for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymDynid(i Sym, val int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymDynimplib">
               <h3>
                  SetSymDynimplib 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymDynimplib sets the "dynimplib" attribute for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymDynimplib(i Sym, value string)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymDynimpvers">
               <h3>
                  SetSymDynimpvers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymDynimpvers sets the "dynimpvers" attribute for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymDynimpvers(i Sym, value string)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymElfSym">
               <h3>
                  SetSymElfSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymElfSym sets the elf symbol index for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymElfSym(i Sym, es int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymElfType">
               <h3>
                  SetSymElfType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymElfType sets the elf type attribute for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymElfType(i Sym, et elf.SymType)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymExtname">
               <h3>
                  SetSymExtname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymExtname sets the  "extname" attribute for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymExtname(i Sym, value string)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymLocalElfSym">
               <h3>
                  SetSymLocalElfSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymLocalElfSym sets the "local" elf symbol index for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymLocalElfSym(i Sym, es int32)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymLocalentry">
               <h3>
                  SetSymLocalentry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymLocalentry sets the "local entry" offset attribute for a symbol.</p>
               
               <pre><code>func (l *Loader) SetSymLocalentry(i Sym, value uint8)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymPkg">
               <h3>
                  SetSymPkg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymPkg sets the package/library for a symbol. This is
needed mainly for external symbols, specifically those imported
from shared libraries.</p>
               
               <pre><code>func (l *Loader) SetSymPkg(i Sym, pkg string)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymSect">
               <h3>
                  SetSymSect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymSect sets the section of the i-th symbol. i is global index.</p>
               
               <pre><code>func (l *Loader) SetSymSect(i Sym, sect *sym.Section)</code></pre>
            </article>
            
            <article class="function" data-name="SetSymValue">
               <h3>
                  SetSymValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetSymValue sets the value of the i-th symbol. i is global index.</p>
               
               <pre><code>func (l *Loader) SetSymValue(i Sym, val int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetType">
               <h3>
                  SetType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetType(kind sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="SetType">
               <h3>
                  SetType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rel Reloc) SetType(t objabi.RelocType)</code></pre>
            </article>
            
            <article class="function" data-name="SetUint">
               <h3>
                  SetUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetUint(arch *sys.Arch, r int64, v uint64) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetUint16">
               <h3>
                  SetUint16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetUint16(arch *sys.Arch, r int64, v uint16) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetUint32">
               <h3>
                  SetUint32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetUint32(arch *sys.Arch, r int64, v uint32) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetUint8">
               <h3>
                  SetUint8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetUint8(arch *sys.Arch, r int64, v uint8) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetUintptr">
               <h3>
                  SetUintptr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetUintptr(arch *sys.Arch, r int64, v uintptr) int64</code></pre>
            </article>
            
            <article class="function" data-name="SetValue">
               <h3>
                  SetValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetValue(v int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetVisibilityHidden">
               <h3>
                  SetVisibilityHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SetVisibilityHidden(value bool)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="SortRelocs">
               <h3>
                  SortRelocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SortRelocs Sort relocations by offset.</p>
               
               <pre><code>func (sb *SymbolBuilder) SortRelocs()</code></pre>
            </article>
            
            <article class="function" data-name="SortSub">
               <h3>
                  SortSub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SortSub walks through the sub-symbols for 's' and sorts them
in place by increasing value. Return value is the new
sub symbol for the specified outer symbol.</p>
               
               <pre><code>func (l *Loader) SortSub(s Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="SortSub">
               <h3>
                  SortSub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SortSub()</code></pre>
            </article>
            
            <article class="function" data-name="SortSyms">
               <h3>
                  SortSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SortSyms sorts a list of symbols by their value.</p>
               
               <pre><code>func (l *Loader) SortSyms(ss []Sym)</code></pre>
            </article>
            
            <article class="function" data-name="StartLine">
               <h3>
                  StartLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) StartLine() int32</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Symbol statistics.</p>
               
               <pre><code>func (l *Loader) Stat() string</code></pre>
            </article>
            
            <article class="function" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Sub() Sym</code></pre>
            </article>
            
            <article class="function" data-name="SubSym">
               <h3>
                  SubSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SubSym gets the subsymbol for host object loaded symbols.</p>
               
               <pre><code>func (l *Loader) SubSym(i Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="SubSym">
               <h3>
                  SubSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) SubSym() Sym</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s bySymValue) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rel Reloc) Sym() Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a Aux) Sym() Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Sym() Sym</code></pre>
            </article>
            
            <article class="function" data-name="SymAddr">
               <h3>
                  SymAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymAddr checks that a symbol is reachable, and returns its value.</p>
               
               <pre><code>func (l *Loader) SymAddr(i Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="SymAlign">
               <h3>
                  SymAlign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymAlign returns the alignment for a symbol.</p>
               
               <pre><code>func (l *Loader) SymAlign(i Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="SymAttr">
               <h3>
                  SymAttr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the attributes of the i-th symbol.</p>
               
               <pre><code>func (l *Loader) SymAttr(i Sym) uint8</code></pre>
            </article>
            
            <article class="function" data-name="SymDynid">
               <h3>
                  SymDynid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymDynid returns the "dynid" property for the specified symbol.</p>
               
               <pre><code>func (l *Loader) SymDynid(i Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="SymDynimplib">
               <h3>
                  SymDynimplib 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymDynimplib returns the "dynimplib" attribute for the specified
symbol, making up a portion of the info for a symbol specified
on a "cgo_import_dynamic" compiler directive.</p>
               
               <pre><code>func (l *Loader) SymDynimplib(i Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="SymDynimpvers">
               <h3>
                  SymDynimpvers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymDynimpvers returns the "dynimpvers" attribute for the specified
symbol, making up a portion of the info for a symbol specified
on a "cgo_import_dynamic" compiler directive.</p>
               
               <pre><code>func (l *Loader) SymDynimpvers(i Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="SymElfSym">
               <h3>
                  SymElfSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymElfSym returns the ELF symbol index for a given loader
symbol, assigned during ELF symtab generation.</p>
               
               <pre><code>func (l *Loader) SymElfSym(i Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="SymElfType">
               <h3>
                  SymElfType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymElfType returns the previously recorded ELF type for a symbol
(used only for symbols read from shared libraries by ldshlibsyms).
It is not set for symbols defined by the packages being linked or
by symbols read by ldelf (and so is left as elf.STT_NOTYPE).</p>
               
               <pre><code>func (l *Loader) SymElfType(i Sym) elf.SymType</code></pre>
            </article>
            
            <article class="function" data-name="SymExtname">
               <h3>
                  SymExtname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymExtname returns the "extname" value for the specified
symbol.</p>
               
               <pre><code>func (l *Loader) SymExtname(i Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="SymGoType">
               <h3>
                  SymGoType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymGoType returns the 'Gotype' property for a given symbol (set by
the Go compiler for variable symbols). This version relies on
reading aux symbols for the target sym -- it could be that a faster
approach would be to check for gotype during preload and copy the
results in to a map (might want to try this at some point and see
if it helps speed things up).</p>
               
               <pre><code>func (l *Loader) SymGoType(i Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="SymGot">
               <h3>
                  SymGot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymGot returns the GOT offset of symbol s.</p>
               
               <pre><code>func (l *Loader) SymGot(s Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="SymLocalElfSym">
               <h3>
                  SymLocalElfSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymLocalElfSym returns the "local" ELF symbol index for a given loader
symbol, assigned during ELF symtab generation.</p>
               
               <pre><code>func (l *Loader) SymLocalElfSym(i Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="SymLocalentry">
               <h3>
                  SymLocalentry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymLocalentry returns an offset in bytes of the "local entry" of a symbol.
On PPC64, a value of 1 indicates the symbol does not use or preserve a TOC
pointer in R2, nor does it have a distinct local entry.</p>
               
               <pre><code>func (l *Loader) SymLocalentry(i Sym) uint8</code></pre>
            </article>
            
            <article class="function" data-name="SymName">
               <h3>
                  SymName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the name of the i-th symbol.</p>
               
               <pre><code>func (l *Loader) SymName(i Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="SymPkg">
               <h3>
                  SymPkg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymPkg returns the package where the symbol came from (for
regular compiler-generated Go symbols), but in the case of
building with "-linkshared" (when a symbol is read from a
shared library), will hold the library name.
NOTE: this corresponds to sym.Symbol.File field.</p>
               
               <pre><code>func (l *Loader) SymPkg(i Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="SymPlt">
               <h3>
                  SymPlt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymPlt returns the PLT offset of symbol s.</p>
               
               <pre><code>func (l *Loader) SymPlt(s Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="SymSect">
               <h3>
                  SymSect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymSect returns the section of the i-th symbol. i is global index.</p>
               
               <pre><code>func (l *Loader) SymSect(i Sym) *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="SymSize">
               <h3>
                  SymSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the size of the i-th symbol.</p>
               
               <pre><code>func (l *Loader) SymSize(i Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="SymType">
               <h3>
                  SymType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the type of the i-th symbol.</p>
               
               <pre><code>func (l *Loader) SymType(i Sym) sym.SymKind</code></pre>
            </article>
            
            <article class="function" data-name="SymUnit">
               <h3>
                  SymUnit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymUnit returns the compilation unit for a given symbol (which will
typically be nil for external or linker-manufactured symbols).</p>
               
               <pre><code>func (l *Loader) SymUnit(i Sym) *sym.CompilationUnit</code></pre>
            </article>
            
            <article class="function" data-name="SymValue">
               <h3>
                  SymValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymValue returns the value of the i-th symbol. i is global index.</p>
               
               <pre><code>func (l *Loader) SymValue(i Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="SymVersion">
               <h3>
                  SymVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the version of the i-th symbol.</p>
               
               <pre><code>func (l *Loader) SymVersion(i Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="TopFrame">
               <h3>
                  TopFrame 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TopFrame returns true if the function associated with this FuncInfo
is an entry point, meaning that unwinders should stop when they hit
this function.</p>
               
               <pre><code>func (fi *FuncInfo) TopFrame() bool</code></pre>
            </article>
            
            <article class="function" data-name="TopLevelSym">
               <h3>
                  TopLevelSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TopLevelSym tests a symbol (by name and kind) to determine whether
the symbol first class sym (participating in the link) or is an
anonymous aux or sub-symbol containing some sub-part or payload of
another symbol.</p>
               
               <pre><code>func (l *Loader) TopLevelSym(s Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rel Reloc) Type() objabi.RelocType</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Type() sym.SymKind</code></pre>
            </article>
            
            <article class="function" data-name="UndefinedRelocTargets">
               <h3>
                  UndefinedRelocTargets 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UndefinedRelocTargets iterates through the global symbol index
space, looking for symbols with relocations targeting undefined
references. The linker's loadlib method uses this to determine if
there are unresolved references to functions in system libraries
(for example, libgcc.a), presumably due to CGO code. Return value
is a pair of lists of loader.Sym's. First list corresponds to the
corresponding to the undefined symbols themselves, the second list
is the symbol that is making a reference to the undef. The "limit"
param controls the maximum number of results returned; if "limit"
is -1, then all undefs are returned.</p>
               
               <pre><code>func (l *Loader) UndefinedRelocTargets(limit int) ([]Sym, []Sym)</code></pre>
            </article>
            
            <article class="function" data-name="Unset">
               <h3>
                  Unset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unset the i-th bit.</p>
               
               <pre><code>func (bm Bitmap) Unset(i Sym)</code></pre>
            </article>
            
            <article class="function" data-name="Valid">
               <h3>
                  Valid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi *FuncInfo) Valid() bool</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Value() int64</code></pre>
            </article>
            
            <article class="function" data-name="Version">
               <h3>
                  Version 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) Version() int</code></pre>
            </article>
            
            <article class="function" data-name="VisibilityHidden">
               <h3>
                  VisibilityHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) VisibilityHidden() bool</code></pre>
            </article>
            
            <article class="function" data-name="WasmImportSym">
               <h3>
                  WasmImportSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WasmImportSym returns the auxiliary WebAssembly import symbol associated with
a given function symbol. The aux sym only exists for Go function stubs that
have been annotated with the //go:wasmimport directive.  The aux sym
contains the information necessary for the linker to add a WebAssembly
import statement.
(https://webassembly.github.io/spec/core/syntax/modules.html#imports)</p>
               
               <pre><code>func (l *Loader) WasmImportSym(fnSymIdx Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="WasmTypeSym">
               <h3>
                  WasmTypeSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) WasmTypeSym(s Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="Weak">
               <h3>
                  Weak 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rel Reloc) Weak() bool</code></pre>
            </article>
            
            <article class="function" data-name="abiToVer">
               <h3>
                  abiToVer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func abiToVer(abi uint16, localSymVersion int) int</code></pre>
            </article>
            
            <article class="function" data-name="addObj">
               <h3>
                  addObj 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add object file r</p>
               
               <pre><code>func (l *Loader) addObj(pkg string, r *oReader)</code></pre>
            </article>
            
            <article class="function" data-name="addSym">
               <h3>
                  addSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add a symbol from an object file, return the global index.
If the symbol already exist, it returns the index of that symbol.</p>
               
               <pre><code>func (st *loadState) addSym(name string, ver int, r *oReader, li uint32, kind int, osym *goobj.Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="addSymRef">
               <h3>
                  addSymRef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) addSymRef(tgt Sym, add int64, typ objabi.RelocType, rsize int) int64</code></pre>
            </article>
            
            <article class="function" data-name="allocPayload">
               <h3>
                  allocPayload 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocPayload allocates a new payload.</p>
               
               <pre><code>func (l *Loader) allocPayload() *extSymPayload</code></pre>
            </article>
            
            <article class="function" data-name="aux1">
               <h3>
                  aux1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns a specific aux symbol of type t for symbol i.</p>
               
               <pre><code>func (l *Loader) aux1(i Sym, t uint8) Sym</code></pre>
            </article>
            
            <article class="function" data-name="auxs">
               <h3>
                  auxs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) auxs(i Sym) (*oReader, []goobj.Aux)</code></pre>
            </article>
            
            <article class="function" data-name="checkLinkname">
               <h3>
                  checkLinkname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>check if a linkname reference to symbol s from pkg is allowed</p>
               
               <pre><code>func (l *Loader) checkLinkname(pkg string, name string, s Sym)</code></pre>
            </article>
            
            <article class="function" data-name="checkdup">
               <h3>
                  checkdup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Check that duplicate symbols have same contents.</p>
               
               <pre><code>func (l *Loader) checkdup(name string, r *oReader, li uint32, dup Sym)</code></pre>
            </article>
            
            <article class="function" data-name="cloneToExternal">
               <h3>
                  cloneToExternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cloneToExternal takes the existing object file symbol (symIdx)
and creates a new external symbol payload that is a clone with
respect to name, version, type, relocations, etc. The idea here
is that if the linker decides it wants to update the contents of
a symbol originally discovered as part of an object file, it's
easier to do this if we make the updates to an external symbol
payload.</p>
               
               <pre><code>func (l *Loader) cloneToExternal(symIdx Sym) *extSymPayload</code></pre>
            </article>
            
            <article class="function" data-name="extIndex">
               <h3>
                  extIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>For external symbol, return its index in the payloads array.
XXX result is actually not a global index. We (ab)use the Sym type
so we don't need conversion for accessing bitmaps.</p>
               
               <pre><code>func (l *Loader) extIndex(i Sym) Sym</code></pre>
            </article>
            
            <article class="function" data-name="getPayload">
               <h3>
                  getPayload 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getPayload returns a pointer to the extSymPayload struct for an
external symbol if the symbol has a payload. Will panic if the
symbol in question is bogus (zero or not an external sym).</p>
               
               <pre><code>func (l *Loader) getPayload(i Sym) *extSymPayload</code></pre>
            </article>
            
            <article class="function" data-name="growAttrBitmaps">
               <h3>
                  growAttrBitmaps 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Insure that reachable bitmap and its siblings have enough size.</p>
               
               <pre><code>func (l *Loader) growAttrBitmaps(reqLen int)</code></pre>
            </article>
            
            <article class="function" data-name="growBitmap">
               <h3>
                  growBitmap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>growBitmap insures that the specified bitmap has enough capacity,
reallocating (doubling the size) if needed.</p>
               
               <pre><code>func growBitmap(reqLen int, b Bitmap) Bitmap</code></pre>
            </article>
            
            <article class="function" data-name="growExtAttrBitmaps">
               <h3>
                  growExtAttrBitmaps 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) growExtAttrBitmaps()</code></pre>
            </article>
            
            <article class="function" data-name="growOuter">
               <h3>
                  growOuter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>growOuter grows the slice used to store outer symbol.</p>
               
               <pre><code>func (l *Loader) growOuter(reqLen int)</code></pre>
            </article>
            
            <article class="function" data-name="growValues">
               <h3>
                  growValues 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>growValues grows the slice used to store symbol values.</p>
               
               <pre><code>func (l *Loader) growValues(reqLen int)</code></pre>
            </article>
            
            <article class="function" data-name="isExtReader">
               <h3>
                  isExtReader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Loader) isExtReader(r *oReader) bool</code></pre>
            </article>
            
            <article class="function" data-name="loadObjRefs">
               <h3>
                  loadObjRefs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadObjRefs(l *Loader, r *oReader, arch *sys.Arch)</code></pre>
            </article>
            
            <article class="function" data-name="newExtSym">
               <h3>
                  newExtSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newExtSym creates a new external sym with the specified
name/version.</p>
               
               <pre><code>func (l *Loader) newExtSym(name string, ver int) Sym</code></pre>
            </article>
            
            <article class="function" data-name="newPayload">
               <h3>
                  newPayload 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Get a new payload for external symbol, return its index in
the payloads array.</p>
               
               <pre><code>func (l *Loader) newPayload(name string, ver int) int</code></pre>
            </article>
            
            <article class="function" data-name="preloadSyms">
               <h3>
                  preloadSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Preload symbols of given kind from an object.</p>
               
               <pre><code>func (st *loadState) preloadSyms(r *oReader, kind int)</code></pre>
            </article>
            
            <article class="function" data-name="relocs">
               <h3>
                  relocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>relocs returns a Relocs object given a local sym index and reader.</p>
               
               <pre><code>func (l *Loader) relocs(r *oReader, li uint32) Relocs</code></pre>
            </article>
            
            <article class="function" data-name="reportMissingBuiltin">
               <h3>
                  reportMissingBuiltin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reportMissingBuiltin issues an error in the case where we have a
relocation against a runtime builtin whose definition is not found
when the runtime package is built. The canonical example is
"runtime.racefuncenter" -- currently if you do something like
go build -gcflags=-race myprogram.go
the compiler will insert calls to the builtin runtime.racefuncenter,
but the version of the runtime used for linkage won't actually contain
definitions of that symbol. See issue #42396 for details.
As currently implemented, this is a fatal error. This has drawbacks
in that if there are multiple missing builtins, the error will only
cite the first one. On the plus side, terminating the link here has
advantages in that we won't run the risk of panics or crashes later
on in the linker due to R_CALL relocations with 0-valued target
symbols.</p>
               
               <pre><code>func (l *Loader) reportMissingBuiltin(bsym int, reflib string)</code></pre>
            </article>
            
            <article class="function" data-name="resolve">
               <h3>
                  resolve 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Resolve a local symbol reference. Return global index.</p>
               
               <pre><code>func (l *Loader) resolve(r *oReader, s goobj.SymRef) Sym</code></pre>
            </article>
            
            <article class="function" data-name="setUintXX">
               <h3>
                  setUintXX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sb *SymbolBuilder) setUintXX(arch *sys.Arch, off int64, v uint64, wid int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="toGlobal">
               <h3>
                  toGlobal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Convert a local index to a global index.</p>
               
               <pre><code>func (l *Loader) toGlobal(r *oReader, i uint32) Sym</code></pre>
            </article>
            
            <article class="function" data-name="toLocal">
               <h3>
                  toLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Convert a global index to a local index.</p>
               
               <pre><code>func (l *Loader) toLocal(i Sym) (*oReader, uint32)</code></pre>
            </article>
            
            <article class="function" data-name="topLevelSym">
               <h3>
                  topLevelSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>topLevelSym tests a symbol name and kind to determine whether
the symbol first class sym (participating in the link) or is an
anonymous aux or sub-symbol containing some sub-part or payload of
another symbol.</p>
               
               <pre><code>func topLevelSym(sname string, skind sym.SymKind) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
