<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - loader</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>loader</code>
         </h1>
         <hr />
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="pkgDef">
            <h2>pkgDef</h2>
            <hr />
            
            <pre><code>pkgDef</code></pre>
         </article>
         
         <article class="global" data-name="hashed64Def">
            <h2>hashed64Def</h2>
            <hr />
            
            <pre><code>hashed64Def</code></pre>
         </article>
         
         <article class="global" data-name="hashedDef">
            <h2>hashedDef</h2>
            <hr />
            
            <pre><code>hashedDef</code></pre>
         </article>
         
         <article class="global" data-name="nonPkgDef">
            <h2>nonPkgDef</h2>
            <hr />
            
            <pre><code>nonPkgDef</code></pre>
         </article>
         
         <article class="global" data-name="nonPkgRef">
            <h2>nonPkgRef</h2>
            <hr />
            
            <pre><code>nonPkgRef</code></pre>
         </article>
         
         <article class="global" data-name="nilObj">
            <h2>nilObj</h2>
            <hr />
            
            <p>objidx</p>
            
            <pre><code>nilObj</code></pre>
         </article>
         
         <article class="global" data-name="extObj">
            <h2>extObj</h2>
            <hr />
            
            <p>objidx</p>
            
            <pre><code>extObj</code></pre>
         </article>
         
         <article class="global" data-name="goObjStart">
            <h2>goObjStart</h2>
            <hr />
            
            <p>objidx</p>
            
            <pre><code>goObjStart</code></pre>
         </article>
         
         <article class="global" data-name="FlagStrictDups">
            <h2>FlagStrictDups</h2>
            <hr />
            
            <p>Loader.flags</p>
            
            <pre><code>FlagStrictDups</code></pre>
         </article>
         
         <article class="global" data-name="FlagCheckLinkname">
            <h2>FlagCheckLinkname</h2>
            <hr />
            
            <pre><code>FlagCheckLinkname</code></pre>
         </article>
         
         <article class="global" data-name="blockedLinknames">
            <h2>blockedLinknames</h2>
            <hr />
            
            <p>A list of blocked linknames. Some linknames are allowed only
in specific packages. This maps symbol names to allowed packages.
If a name is not in this map, it is allowed iff the definition
has a linkname (push).
If a name is in this map, it is allowed only in listed packages,
even if it has a linknamed definition.</p>
            
            <pre><code>blockedLinknames</code></pre>
         </article>
          
         <article class="struct" data-name="Relocs">
            <h2>type Relocs struct</h2>
            <hr />
            
            <p>Relocs encapsulates the set of relocations on a given symbol; an
instance of this type is returned by the Loader Relocs() method.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">rs []goobj.Reloc
li uint32
r *oReader
l *Loader</code></pre>
         </article>
         
         <article class="struct" data-name="ExtReloc">
            <h2>type ExtReloc struct</h2>
            <hr />
            
            <p>ExtReloc contains the payload for an external relocation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Xsym Sym
Xadd int64
Type objabi.RelocType
Size uint8</code></pre>
         </article>
         
         <article class="struct" data-name="Reloc">
            <h2>type Reloc struct</h2>
            <hr />
            
            <p>Reloc holds a "handle" to access a relocation record from an
object file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*goobj.Reloc
r *oReader
l *Loader</code></pre>
         </article>
         
         <article class="struct" data-name="Aux">
            <h2>type Aux struct</h2>
            <hr />
            
            <p>Aux holds a "handle" to access an aux symbol record from an
object file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*goobj.Aux
r *oReader
l *Loader</code></pre>
         </article>
         
         <article class="struct" data-name="oReader">
            <h2>type oReader struct</h2>
            <hr />
            
            <p>oReader is a wrapper type of obj.Reader, along with some
extra information.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*goobj.Reader
unit *sym.CompilationUnit
version int
pkgprefix string
syms []Sym
pkg []uint32
ndef int
nhashed64def int
nhasheddef int
objidx uint32</code></pre>
         </article>
         
         <article class="struct" data-name="objSym">
            <h2>type objSym struct</h2>
            <hr />
            
            <p>objSym represents a symbol in an object file. It is a tuple of
the object and the symbol's local index.
For external symbols, objidx is the index of l.extReader (extObj),
s is its index into the payload array.
{0, 0} represents the nil symbol.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">objidx uint32
s uint32</code></pre>
         </article>
         
         <article class="struct" data-name="nameVer">
            <h2>type nameVer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
v int</code></pre>
         </article>
         
         <article class="struct" data-name="symAndSize">
            <h2>type symAndSize struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">sym Sym
size uint32</code></pre>
         </article>
         
         <article class="struct" data-name="Loader">
            <h2>type Loader struct</h2>
            <hr />
            
            <p>A Loader loads new object files and resolves indexed symbol references.

Notes on the layout of global symbol index space:

  - Go object files are read before host object files; each Go object
    read adds its defined package symbols to the global index space.
    Nonpackage symbols are not yet added.

  - In loader.LoadNonpkgSyms, add non-package defined symbols and
    references in all object files to the global index space.

  - Host object file loading happens; the host object loader does a
    name/version lookup for each symbol it finds; this can wind up
    extending the external symbol index space range. The host object
    loader stores symbol payloads in loader.payloads using SymbolBuilder.

  - Each symbol gets a unique global index. For duplicated and
    overwriting/overwritten symbols, the second (or later) appearance
    of the symbol gets the same global index as the first appearance.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">objs []*oReader
extStart Sym
builtinSyms []Sym
objSyms []objSym
symsByName []*ast.MapType
extStaticSyms *ast.MapType
extReader *oReader
payloadBatch []extSymPayload
payloads []*extSymPayload
values []int64
sects []*sym.Section
symSects []uint16
align []uint8
deferReturnTramp *ast.MapType
objByPkg *ast.MapType
anonVersion int
attrReachable Bitmap
attrOnList Bitmap
attrLocal Bitmap
attrNotInSymbolTable Bitmap
attrUsedInIface Bitmap
attrSpecial Bitmap
attrVisibilityHidden Bitmap
attrDuplicateOK Bitmap
attrShared Bitmap
attrExternal Bitmap
generatedSyms Bitmap
attrReadOnly *ast.MapType
attrCgoExportDynamic *ast.MapType
attrCgoExportStatic *ast.MapType
outer []Sym
sub *ast.MapType
dynimplib *ast.MapType
dynimpvers *ast.MapType
localentry *ast.MapType
extname *ast.MapType
elfType *ast.MapType
elfSym *ast.MapType
localElfSym *ast.MapType
symPkg *ast.MapType
plt *ast.MapType
got *ast.MapType
dynid *ast.MapType
relocVariant *ast.MapType
Reachparent []Sym
CgoExports *ast.MapType
WasmExports []Sym
sizeFixups []symAndSize
flags uint32
strictDupMsgs int
errorReporter *ErrorReporter
npkgsyms int
nhashedsyms int</code></pre>
         </article>
         
         <article class="struct" data-name="extSymPayload">
            <h2>type extSymPayload struct</h2>
            <hr />
            
            <p>extSymPayload holds the payload (data + relocations) for linker-synthesized
external symbols (note that symbol value is stored in a separate slice).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
size int64
ver int
kind sym.SymKind
objidx uint32
relocs []goobj.Reloc
data []byte
auxs []goobj.Aux</code></pre>
         </article>
         
         <article class="struct" data-name="symWithVal">
            <h2>type symWithVal struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s Sym
v int64</code></pre>
         </article>
         
         <article class="struct" data-name="FuncInfo">
            <h2>type FuncInfo struct</h2>
            <hr />
            
            <p>FuncInfo provides hooks to access goobj.FuncInfo in the objects.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">l *Loader
r *oReader
data []byte
lengths goobj.FuncInfoLengths</code></pre>
         </article>
         
         <article class="struct" data-name="InlTreeNode">
            <h2>type InlTreeNode struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Parent int32
File goobj.CUFileIndex
Line int32
Func Sym
ParentPC int32</code></pre>
         </article>
         
         <article class="struct" data-name="loadState">
            <h2>type loadState struct</h2>
            <hr />
            
            <p>Holds the loader along with temporary states for loading symbols.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">l *Loader
hashed64Syms *ast.MapType
hashedSyms *ast.MapType
linknameVarRefs []linknameVarRef</code></pre>
         </article>
         
         <article class="struct" data-name="linknameVarRef">
            <h2>type linknameVarRef struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg string
name string
sym Sym</code></pre>
         </article>
         
         <article class="struct" data-name="relocId">
            <h2>type relocId struct</h2>
            <hr />
            
            <p>relocId is essentially a <S,R> tuple identifying the Rth
relocation of symbol S.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sym Sym
ridx int</code></pre>
         </article>
         
         <article class="struct" data-name="ErrorReporter">
            <h2>type ErrorReporter struct</h2>
            <hr />
            
            <p>ErrorReporter is a helper class for reporting errors.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ldr *Loader
AfterErrorAction func</code></pre>
         </article>
         
         <article class="struct" data-name="SymbolBuilder">
            <h2>type SymbolBuilder struct</h2>
            <hr />
            
            <p>SymbolBuilder is a helper designed to help with the construction
of new symbol contents.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*extSymPayload
symIdx Sym
l *Loader</code></pre>
         </article>
          
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() objabi.RelocType</code></pre>
         </article>
         
         <article class="function" data-name="Weak">
            <h2>Weak</h2>
            <hr />
            
            <pre><code>func Weak() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetType">
            <h2>SetType</h2>
            <hr />
            
            <pre><code>func SetType(t objabi.RelocType)</code></pre>
         </article>
         
         <article class="function" data-name="Sym">
            <h2>Sym</h2>
            <hr />
            
            <pre><code>func Sym() Sym</code></pre>
         </article>
         
         <article class="function" data-name="SetSym">
            <h2>SetSym</h2>
            <hr />
            
            <pre><code>func SetSym(s Sym)</code></pre>
         </article>
         
         <article class="function" data-name="IsMarker">
            <h2>IsMarker</h2>
            <hr />
            
            <pre><code>func IsMarker() bool</code></pre>
         </article>
         
         <article class="function" data-name="Sym">
            <h2>Sym</h2>
            <hr />
            
            <pre><code>func Sym() Sym</code></pre>
         </article>
         
         <article class="function" data-name="NAlldef">
            <h2>NAlldef</h2>
            <hr />
            
            <p>Total number of defined symbols (package symbols, hashed symbols, and
non-package symbols).</p>
            
            <pre><code>func NAlldef() int</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>set the i-th bit.</p>
            
            <pre><code>func Set(i Sym)</code></pre>
         </article>
         
         <article class="function" data-name="Unset">
            <h2>Unset</h2>
            <hr />
            
            <p>unset the i-th bit.</p>
            
            <pre><code>func Unset(i Sym)</code></pre>
         </article>
         
         <article class="function" data-name="Has">
            <h2>Has</h2>
            <hr />
            
            <p>whether the i-th bit is set.</p>
            
            <pre><code>func Has(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <p>return current length of bitmap in bits.</p>
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Count">
            <h2>Count</h2>
            <hr />
            
            <p>return the number of bits set.</p>
            
            <pre><code>func Count() int</code></pre>
         </article>
         
         <article class="function" data-name="MakeBitmap">
            <h2>MakeBitmap</h2>
            <hr />
            
            <pre><code>func MakeBitmap(n int) Bitmap</code></pre>
         </article>
         
         <article class="function" data-name="growBitmap">
            <h2>growBitmap</h2>
            <hr />
            
            <p>growBitmap insures that the specified bitmap has enough capacity,
reallocating (doubling the size) if needed.</p>
            
            <pre><code>func growBitmap(reqLen int, b Bitmap) Bitmap</code></pre>
         </article>
         
         <article class="function" data-name="NewLoader">
            <h2>NewLoader</h2>
            <hr />
            
            <pre><code>func NewLoader(flags uint32, reporter *ErrorReporter) *Loader</code></pre>
         </article>
         
         <article class="function" data-name="addObj">
            <h2>addObj</h2>
            <hr />
            
            <p>Add object file r</p>
            
            <pre><code>func addObj(pkg string, r *oReader)</code></pre>
         </article>
         
         <article class="function" data-name="addSym">
            <h2>addSym</h2>
            <hr />
            
            <p>Add a symbol from an object file, return the global index.
If the symbol already exist, it returns the index of that symbol.</p>
            
            <pre><code>func addSym(name string, ver int, r *oReader, li uint32, kind int, osym *goobj.Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="newExtSym">
            <h2>newExtSym</h2>
            <hr />
            
            <p>newExtSym creates a new external sym with the specified
name/version.</p>
            
            <pre><code>func newExtSym(name string, ver int) Sym</code></pre>
         </article>
         
         <article class="function" data-name="LookupOrCreateSym">
            <h2>LookupOrCreateSym</h2>
            <hr />
            
            <p>LookupOrCreateSym looks up the symbol with the specified name/version,
returning its Sym index if found. If the lookup fails, a new external
Sym will be created, entered into the lookup tables, and returned.</p>
            
            <pre><code>func LookupOrCreateSym(name string, ver int) Sym</code></pre>
         </article>
         
         <article class="function" data-name="AddCgoExport">
            <h2>AddCgoExport</h2>
            <hr />
            
            <p>AddCgoExport records a cgo-exported symbol in l.CgoExports.
This table is used to identify the correct Go symbol ABI to use
to resolve references from host objects (which don't have ABIs).</p>
            
            <pre><code>func AddCgoExport(s Sym)</code></pre>
         </article>
         
         <article class="function" data-name="LookupOrCreateCgoExport">
            <h2>LookupOrCreateCgoExport</h2>
            <hr />
            
            <p>LookupOrCreateCgoExport is like LookupOrCreateSym, but if ver
indicates a global symbol, it uses the CgoExport table to determine
the appropriate symbol version (ABI) to use. ver must be either 0
or a static symbol version.</p>
            
            <pre><code>func LookupOrCreateCgoExport(name string, ver int) Sym</code></pre>
         </article>
         
         <article class="function" data-name="IsExternal">
            <h2>IsExternal</h2>
            <hr />
            
            <pre><code>func IsExternal(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="isExtReader">
            <h2>isExtReader</h2>
            <hr />
            
            <pre><code>func isExtReader(r *oReader) bool</code></pre>
         </article>
         
         <article class="function" data-name="extIndex">
            <h2>extIndex</h2>
            <hr />
            
            <p>For external symbol, return its index in the payloads array.
XXX result is actually not a global index. We (ab)use the Sym type
so we don't need conversion for accessing bitmaps.</p>
            
            <pre><code>func extIndex(i Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="newPayload">
            <h2>newPayload</h2>
            <hr />
            
            <p>Get a new payload for external symbol, return its index in
the payloads array.</p>
            
            <pre><code>func newPayload(name string, ver int) int</code></pre>
         </article>
         
         <article class="function" data-name="getPayload">
            <h2>getPayload</h2>
            <hr />
            
            <p>getPayload returns a pointer to the extSymPayload struct for an
external symbol if the symbol has a payload. Will panic if the
symbol in question is bogus (zero or not an external sym).</p>
            
            <pre><code>func getPayload(i Sym) *extSymPayload</code></pre>
         </article>
         
         <article class="function" data-name="allocPayload">
            <h2>allocPayload</h2>
            <hr />
            
            <p>allocPayload allocates a new payload.</p>
            
            <pre><code>func allocPayload() *extSymPayload</code></pre>
         </article>
         
         <article class="function" data-name="Grow">
            <h2>Grow</h2>
            <hr />
            
            <pre><code>func Grow(siz int64)</code></pre>
         </article>
         
         <article class="function" data-name="toGlobal">
            <h2>toGlobal</h2>
            <hr />
            
            <p>Convert a local index to a global index.</p>
            
            <pre><code>func toGlobal(r *oReader, i uint32) Sym</code></pre>
         </article>
         
         <article class="function" data-name="toLocal">
            <h2>toLocal</h2>
            <hr />
            
            <p>Convert a global index to a local index.</p>
            
            <pre><code>func toLocal(i Sym) (*oReader, uint32)</code></pre>
         </article>
         
         <article class="function" data-name="resolve">
            <h2>resolve</h2>
            <hr />
            
            <p>Resolve a local symbol reference. Return global index.</p>
            
            <pre><code>func resolve(r *oReader, s goobj.SymRef) Sym</code></pre>
         </article>
         
         <article class="function" data-name="reportMissingBuiltin">
            <h2>reportMissingBuiltin</h2>
            <hr />
            
            <p>reportMissingBuiltin issues an error in the case where we have a
relocation against a runtime builtin whose definition is not found
when the runtime package is built. The canonical example is
"runtime.racefuncenter" -- currently if you do something like

	go build -gcflags=-race myprogram.go

the compiler will insert calls to the builtin runtime.racefuncenter,
but the version of the runtime used for linkage won't actually contain
definitions of that symbol. See issue #42396 for details.

As currently implemented, this is a fatal error. This has drawbacks
in that if there are multiple missing builtins, the error will only
cite the first one. On the plus side, terminating the link here has
advantages in that we won't run the risk of panics or crashes later
on in the linker due to R_CALL relocations with 0-valued target
symbols.</p>
            
            <pre><code>func reportMissingBuiltin(bsym int, reflib string)</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Look up a symbol by name, return global index, or 0 if not found.
This is more like Syms.ROLookup than Lookup -- it doesn't create
new symbol.</p>
            
            <pre><code>func Lookup(name string, ver int) Sym</code></pre>
         </article>
         
         <article class="function" data-name="checkdup">
            <h2>checkdup</h2>
            <hr />
            
            <p>Check that duplicate symbols have same contents.</p>
            
            <pre><code>func checkdup(name string, r *oReader, li uint32, dup Sym)</code></pre>
         </article>
         
         <article class="function" data-name="NStrictDupMsgs">
            <h2>NStrictDupMsgs</h2>
            <hr />
            
            <pre><code>func NStrictDupMsgs() int</code></pre>
         </article>
         
         <article class="function" data-name="NSym">
            <h2>NSym</h2>
            <hr />
            
            <p>Number of total symbols.</p>
            
            <pre><code>func NSym() int</code></pre>
         </article>
         
         <article class="function" data-name="NDef">
            <h2>NDef</h2>
            <hr />
            
            <p>Number of defined Go symbols.</p>
            
            <pre><code>func NDef() int</code></pre>
         </article>
         
         <article class="function" data-name="NReachableSym">
            <h2>NReachableSym</h2>
            <hr />
            
            <p>Number of reachable symbols.</p>
            
            <pre><code>func NReachableSym() int</code></pre>
         </article>
         
         <article class="function" data-name="SymName">
            <h2>SymName</h2>
            <hr />
            
            <p>Returns the name of the i-th symbol.</p>
            
            <pre><code>func SymName(i Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="SymVersion">
            <h2>SymVersion</h2>
            <hr />
            
            <p>Returns the version of the i-th symbol.</p>
            
            <pre><code>func SymVersion(i Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="IsFileLocal">
            <h2>IsFileLocal</h2>
            <hr />
            
            <pre><code>func IsFileLocal(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsFromAssembly">
            <h2>IsFromAssembly</h2>
            <hr />
            
            <p>IsFromAssembly returns true if this symbol is derived from an
object file generated by the Go assembler.</p>
            
            <pre><code>func IsFromAssembly(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SymType">
            <h2>SymType</h2>
            <hr />
            
            <p>Returns the type of the i-th symbol.</p>
            
            <pre><code>func SymType(i Sym) sym.SymKind</code></pre>
         </article>
         
         <article class="function" data-name="SymAttr">
            <h2>SymAttr</h2>
            <hr />
            
            <p>Returns the attributes of the i-th symbol.</p>
            
            <pre><code>func SymAttr(i Sym) uint8</code></pre>
         </article>
         
         <article class="function" data-name="SymSize">
            <h2>SymSize</h2>
            <hr />
            
            <p>Returns the size of the i-th symbol.</p>
            
            <pre><code>func SymSize(i Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="AttrReachable">
            <h2>AttrReachable</h2>
            <hr />
            
            <p>AttrReachable returns true for symbols that are transitively
referenced from the entry points. Unreachable symbols are not
written to the output.</p>
            
            <pre><code>func AttrReachable(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrReachable">
            <h2>SetAttrReachable</h2>
            <hr />
            
            <p>SetAttrReachable sets the reachability property for a symbol (see
AttrReachable).</p>
            
            <pre><code>func SetAttrReachable(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrOnList">
            <h2>AttrOnList</h2>
            <hr />
            
            <p>AttrOnList returns true for symbols that are on some list (such as
the list of all text symbols, or one of the lists of data symbols)
and is consulted to avoid bugs where a symbol is put on a list
twice.</p>
            
            <pre><code>func AttrOnList(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrOnList">
            <h2>SetAttrOnList</h2>
            <hr />
            
            <p>SetAttrOnList sets the "on list" property for a symbol (see
AttrOnList).</p>
            
            <pre><code>func SetAttrOnList(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrLocal">
            <h2>AttrLocal</h2>
            <hr />
            
            <p>AttrLocal returns true for symbols that are only visible within the
module (executable or shared library) being linked. This attribute
is applied to thunks and certain other linker-generated symbols.</p>
            
            <pre><code>func AttrLocal(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrLocal">
            <h2>SetAttrLocal</h2>
            <hr />
            
            <p>SetAttrLocal the "local" property for a symbol (see AttrLocal above).</p>
            
            <pre><code>func SetAttrLocal(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrUsedInIface">
            <h2>AttrUsedInIface</h2>
            <hr />
            
            <p>AttrUsedInIface returns true for a type symbol that is used in
an interface.</p>
            
            <pre><code>func AttrUsedInIface(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrUsedInIface">
            <h2>SetAttrUsedInIface</h2>
            <hr />
            
            <pre><code>func SetAttrUsedInIface(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="SymAddr">
            <h2>SymAddr</h2>
            <hr />
            
            <p>SymAddr checks that a symbol is reachable, and returns its value.</p>
            
            <pre><code>func SymAddr(i Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="AttrNotInSymbolTable">
            <h2>AttrNotInSymbolTable</h2>
            <hr />
            
            <p>AttrNotInSymbolTable returns true for symbols that should not be
added to the symbol table of the final generated load module.</p>
            
            <pre><code>func AttrNotInSymbolTable(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrNotInSymbolTable">
            <h2>SetAttrNotInSymbolTable</h2>
            <hr />
            
            <p>SetAttrNotInSymbolTable the "not in symtab" property for a symbol
(see AttrNotInSymbolTable above).</p>
            
            <pre><code>func SetAttrNotInSymbolTable(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrVisibilityHidden">
            <h2>AttrVisibilityHidden</h2>
            <hr />
            
            <p>AttrVisibilityHidden symbols returns true for ELF symbols with
visibility set to STV_HIDDEN. They become local symbols in
the final executable. Only relevant when internally linking
on an ELF platform.</p>
            
            <pre><code>func AttrVisibilityHidden(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrVisibilityHidden">
            <h2>SetAttrVisibilityHidden</h2>
            <hr />
            
            <p>SetAttrVisibilityHidden sets the "hidden visibility" property for a
symbol (see AttrVisibilityHidden).</p>
            
            <pre><code>func SetAttrVisibilityHidden(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrDuplicateOK">
            <h2>AttrDuplicateOK</h2>
            <hr />
            
            <p>AttrDuplicateOK returns true for a symbol that can be present in
multiple object files.</p>
            
            <pre><code>func AttrDuplicateOK(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrDuplicateOK">
            <h2>SetAttrDuplicateOK</h2>
            <hr />
            
            <p>SetAttrDuplicateOK sets the "duplicate OK" property for an external
symbol (see AttrDuplicateOK).</p>
            
            <pre><code>func SetAttrDuplicateOK(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrShared">
            <h2>AttrShared</h2>
            <hr />
            
            <p>AttrShared returns true for symbols compiled with the -shared option.</p>
            
            <pre><code>func AttrShared(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrShared">
            <h2>SetAttrShared</h2>
            <hr />
            
            <p>SetAttrShared sets the "shared" property for an external
symbol (see AttrShared).</p>
            
            <pre><code>func SetAttrShared(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrExternal">
            <h2>AttrExternal</h2>
            <hr />
            
            <p>AttrExternal returns true for function symbols loaded from host
object files.</p>
            
            <pre><code>func AttrExternal(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrExternal">
            <h2>SetAttrExternal</h2>
            <hr />
            
            <p>SetAttrExternal sets the "external" property for a host object
symbol (see AttrExternal).</p>
            
            <pre><code>func SetAttrExternal(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrSpecial">
            <h2>AttrSpecial</h2>
            <hr />
            
            <p>AttrSpecial returns true for a symbols that do not have their
address (i.e. Value) computed by the usual mechanism of
data.go:dodata() & data.go:address().</p>
            
            <pre><code>func AttrSpecial(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrSpecial">
            <h2>SetAttrSpecial</h2>
            <hr />
            
            <p>SetAttrSpecial sets the "special" property for a symbol (see
AttrSpecial).</p>
            
            <pre><code>func SetAttrSpecial(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrCgoExportDynamic">
            <h2>AttrCgoExportDynamic</h2>
            <hr />
            
            <p>AttrCgoExportDynamic returns true for a symbol that has been
specially marked via the "cgo_export_dynamic" compiler directive
written by cgo (in response to //export directives in the source).</p>
            
            <pre><code>func AttrCgoExportDynamic(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrCgoExportDynamic">
            <h2>SetAttrCgoExportDynamic</h2>
            <hr />
            
            <p>SetAttrCgoExportDynamic sets the "cgo_export_dynamic" for a symbol
(see AttrCgoExportDynamic).</p>
            
            <pre><code>func SetAttrCgoExportDynamic(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="ForAllCgoExportDynamic">
            <h2>ForAllCgoExportDynamic</h2>
            <hr />
            
            <p>ForAllCgoExportDynamic calls f for every symbol that has been
marked with the "cgo_export_dynamic" compiler directive.</p>
            
            <pre><code>func ForAllCgoExportDynamic(f func)</code></pre>
         </article>
         
         <article class="function" data-name="AttrCgoExportStatic">
            <h2>AttrCgoExportStatic</h2>
            <hr />
            
            <p>AttrCgoExportStatic returns true for a symbol that has been
specially marked via the "cgo_export_static" directive
written by cgo.</p>
            
            <pre><code>func AttrCgoExportStatic(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrCgoExportStatic">
            <h2>SetAttrCgoExportStatic</h2>
            <hr />
            
            <p>SetAttrCgoExportStatic sets the "cgo_export_static" for a symbol
(see AttrCgoExportStatic).</p>
            
            <pre><code>func SetAttrCgoExportStatic(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="IsGeneratedSym">
            <h2>IsGeneratedSym</h2>
            <hr />
            
            <p>IsGeneratedSym returns true if a symbol's been previously marked as a
generator symbol through the SetIsGeneratedSym. The functions for generator
symbols are kept in the Link context.</p>
            
            <pre><code>func IsGeneratedSym(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetIsGeneratedSym">
            <h2>SetIsGeneratedSym</h2>
            <hr />
            
            <p>SetIsGeneratedSym marks symbols as generated symbols. Data shouldn't be
stored in generated symbols, and a function is registered and called for
each of these symbols.</p>
            
            <pre><code>func SetIsGeneratedSym(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrCgoExport">
            <h2>AttrCgoExport</h2>
            <hr />
            
            <pre><code>func AttrCgoExport(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="AttrReadOnly">
            <h2>AttrReadOnly</h2>
            <hr />
            
            <p>AttrReadOnly returns true for a symbol whose underlying data
is stored via a read-only mmap.</p>
            
            <pre><code>func AttrReadOnly(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAttrReadOnly">
            <h2>SetAttrReadOnly</h2>
            <hr />
            
            <p>SetAttrReadOnly sets the "data is read only" property for a symbol
(see AttrReadOnly).</p>
            
            <pre><code>func SetAttrReadOnly(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="AttrSubSymbol">
            <h2>AttrSubSymbol</h2>
            <hr />
            
            <pre><code>func AttrSubSymbol(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsReflectMethod">
            <h2>IsReflectMethod</h2>
            <hr />
            
            <p>Returns whether the i-th symbol has ReflectMethod attribute set.</p>
            
            <pre><code>func IsReflectMethod(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsNoSplit">
            <h2>IsNoSplit</h2>
            <hr />
            
            <p>Returns whether the i-th symbol is nosplit.</p>
            
            <pre><code>func IsNoSplit(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsGoType">
            <h2>IsGoType</h2>
            <hr />
            
            <p>Returns whether this is a Go type symbol.</p>
            
            <pre><code>func IsGoType(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsTypelink">
            <h2>IsTypelink</h2>
            <hr />
            
            <p>Returns whether this symbol should be included in typelink.</p>
            
            <pre><code>func IsTypelink(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsItab">
            <h2>IsItab</h2>
            <hr />
            
            <p>Returns whether this symbol is an itab symbol.</p>
            
            <pre><code>func IsItab(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsDict">
            <h2>IsDict</h2>
            <hr />
            
            <p>Returns whether this symbol is a dictionary symbol.</p>
            
            <pre><code>func IsDict(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPkgInit">
            <h2>IsPkgInit</h2>
            <hr />
            
            <p>Returns whether this symbol is a compiler-generated package init func.</p>
            
            <pre><code>func IsPkgInit(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsDeferReturnTramp">
            <h2>IsDeferReturnTramp</h2>
            <hr />
            
            <p>Return whether this is a trampoline of a deferreturn call.</p>
            
            <pre><code>func IsDeferReturnTramp(i Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetIsDeferReturnTramp">
            <h2>SetIsDeferReturnTramp</h2>
            <hr />
            
            <p>Set that i is a trampoline of a deferreturn call.</p>
            
            <pre><code>func SetIsDeferReturnTramp(i Sym, v bool)</code></pre>
         </article>
         
         <article class="function" data-name="growValues">
            <h2>growValues</h2>
            <hr />
            
            <p>growValues grows the slice used to store symbol values.</p>
            
            <pre><code>func growValues(reqLen int)</code></pre>
         </article>
         
         <article class="function" data-name="SymValue">
            <h2>SymValue</h2>
            <hr />
            
            <p>SymValue returns the value of the i-th symbol. i is global index.</p>
            
            <pre><code>func SymValue(i Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetSymValue">
            <h2>SetSymValue</h2>
            <hr />
            
            <p>SetSymValue sets the value of the i-th symbol. i is global index.</p>
            
            <pre><code>func SetSymValue(i Sym, val int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddToSymValue">
            <h2>AddToSymValue</h2>
            <hr />
            
            <p>AddToSymValue adds to the value of the i-th symbol. i is the global index.</p>
            
            <pre><code>func AddToSymValue(i Sym, val int64)</code></pre>
         </article>
         
         <article class="function" data-name="Data">
            <h2>Data</h2>
            <hr />
            
            <p>Returns the symbol content of the i-th symbol. i is global index.</p>
            
            <pre><code>func Data(i Sym) []byte</code></pre>
         </article>
         
         <article class="function" data-name="DataString">
            <h2>DataString</h2>
            <hr />
            
            <p>Returns the symbol content of the i-th symbol as a string. i is global index.</p>
            
            <pre><code>func DataString(i Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="FreeData">
            <h2>FreeData</h2>
            <hr />
            
            <p>FreeData clears the symbol data of an external symbol, allowing the memory
to be freed earlier. No-op for non-external symbols.
i is global index.</p>
            
            <pre><code>func FreeData(i Sym)</code></pre>
         </article>
         
         <article class="function" data-name="SymAlign">
            <h2>SymAlign</h2>
            <hr />
            
            <p>SymAlign returns the alignment for a symbol.</p>
            
            <pre><code>func SymAlign(i Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="SetSymAlign">
            <h2>SetSymAlign</h2>
            <hr />
            
            <p>SetSymAlign sets the alignment for a symbol.</p>
            
            <pre><code>func SetSymAlign(i Sym, align int32)</code></pre>
         </article>
         
         <article class="function" data-name="SymSect">
            <h2>SymSect</h2>
            <hr />
            
            <p>SymSect returns the section of the i-th symbol. i is global index.</p>
            
            <pre><code>func SymSect(i Sym) *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="SetSymSect">
            <h2>SetSymSect</h2>
            <hr />
            
            <p>SetSymSect sets the section of the i-th symbol. i is global index.</p>
            
            <pre><code>func SetSymSect(i Sym, sect *sym.Section)</code></pre>
         </article>
         
         <article class="function" data-name="NewSection">
            <h2>NewSection</h2>
            <hr />
            
            <p>NewSection creates a new (output) section.</p>
            
            <pre><code>func NewSection() *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="SymDynimplib">
            <h2>SymDynimplib</h2>
            <hr />
            
            <p>SymDynimplib returns the "dynimplib" attribute for the specified
symbol, making up a portion of the info for a symbol specified
on a "cgo_import_dynamic" compiler directive.</p>
            
            <pre><code>func SymDynimplib(i Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="SetSymDynimplib">
            <h2>SetSymDynimplib</h2>
            <hr />
            
            <p>SetSymDynimplib sets the "dynimplib" attribute for a symbol.</p>
            
            <pre><code>func SetSymDynimplib(i Sym, value string)</code></pre>
         </article>
         
         <article class="function" data-name="SymDynimpvers">
            <h2>SymDynimpvers</h2>
            <hr />
            
            <p>SymDynimpvers returns the "dynimpvers" attribute for the specified
symbol, making up a portion of the info for a symbol specified
on a "cgo_import_dynamic" compiler directive.</p>
            
            <pre><code>func SymDynimpvers(i Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="SetSymDynimpvers">
            <h2>SetSymDynimpvers</h2>
            <hr />
            
            <p>SetSymDynimpvers sets the "dynimpvers" attribute for a symbol.</p>
            
            <pre><code>func SetSymDynimpvers(i Sym, value string)</code></pre>
         </article>
         
         <article class="function" data-name="SymExtname">
            <h2>SymExtname</h2>
            <hr />
            
            <p>SymExtname returns the "extname" value for the specified
symbol.</p>
            
            <pre><code>func SymExtname(i Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="SetSymExtname">
            <h2>SetSymExtname</h2>
            <hr />
            
            <p>SetSymExtname sets the  "extname" attribute for a symbol.</p>
            
            <pre><code>func SetSymExtname(i Sym, value string)</code></pre>
         </article>
         
         <article class="function" data-name="SymElfType">
            <h2>SymElfType</h2>
            <hr />
            
            <p>SymElfType returns the previously recorded ELF type for a symbol
(used only for symbols read from shared libraries by ldshlibsyms).
It is not set for symbols defined by the packages being linked or
by symbols read by ldelf (and so is left as elf.STT_NOTYPE).</p>
            
            <pre><code>func SymElfType(i Sym) elf.SymType</code></pre>
         </article>
         
         <article class="function" data-name="SetSymElfType">
            <h2>SetSymElfType</h2>
            <hr />
            
            <p>SetSymElfType sets the elf type attribute for a symbol.</p>
            
            <pre><code>func SetSymElfType(i Sym, et elf.SymType)</code></pre>
         </article>
         
         <article class="function" data-name="SymElfSym">
            <h2>SymElfSym</h2>
            <hr />
            
            <p>SymElfSym returns the ELF symbol index for a given loader
symbol, assigned during ELF symtab generation.</p>
            
            <pre><code>func SymElfSym(i Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="SetSymElfSym">
            <h2>SetSymElfSym</h2>
            <hr />
            
            <p>SetSymElfSym sets the elf symbol index for a symbol.</p>
            
            <pre><code>func SetSymElfSym(i Sym, es int32)</code></pre>
         </article>
         
         <article class="function" data-name="SymLocalElfSym">
            <h2>SymLocalElfSym</h2>
            <hr />
            
            <p>SymLocalElfSym returns the "local" ELF symbol index for a given loader
symbol, assigned during ELF symtab generation.</p>
            
            <pre><code>func SymLocalElfSym(i Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="SetSymLocalElfSym">
            <h2>SetSymLocalElfSym</h2>
            <hr />
            
            <p>SetSymLocalElfSym sets the "local" elf symbol index for a symbol.</p>
            
            <pre><code>func SetSymLocalElfSym(i Sym, es int32)</code></pre>
         </article>
         
         <article class="function" data-name="SymPlt">
            <h2>SymPlt</h2>
            <hr />
            
            <p>SymPlt returns the PLT offset of symbol s.</p>
            
            <pre><code>func SymPlt(s Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="SetPlt">
            <h2>SetPlt</h2>
            <hr />
            
            <p>SetPlt sets the PLT offset of symbol i.</p>
            
            <pre><code>func SetPlt(i Sym, v int32)</code></pre>
         </article>
         
         <article class="function" data-name="SymGot">
            <h2>SymGot</h2>
            <hr />
            
            <p>SymGot returns the GOT offset of symbol s.</p>
            
            <pre><code>func SymGot(s Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="SetGot">
            <h2>SetGot</h2>
            <hr />
            
            <p>SetGot sets the GOT offset of symbol i.</p>
            
            <pre><code>func SetGot(i Sym, v int32)</code></pre>
         </article>
         
         <article class="function" data-name="SymDynid">
            <h2>SymDynid</h2>
            <hr />
            
            <p>SymDynid returns the "dynid" property for the specified symbol.</p>
            
            <pre><code>func SymDynid(i Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="SetSymDynid">
            <h2>SetSymDynid</h2>
            <hr />
            
            <p>SetSymDynid sets the "dynid" property for a symbol.</p>
            
            <pre><code>func SetSymDynid(i Sym, val int32)</code></pre>
         </article>
         
         <article class="function" data-name="DynidSyms">
            <h2>DynidSyms</h2>
            <hr />
            
            <p>DynidSyms returns the set of symbols for which dynID is set to an
interesting (non-default) value. This is expected to be a fairly
small set.</p>
            
            <pre><code>func DynidSyms() []Sym</code></pre>
         </article>
         
         <article class="function" data-name="SymGoType">
            <h2>SymGoType</h2>
            <hr />
            
            <p>SymGoType returns the 'Gotype' property for a given symbol (set by
the Go compiler for variable symbols). This version relies on
reading aux symbols for the target sym -- it could be that a faster
approach would be to check for gotype during preload and copy the
results in to a map (might want to try this at some point and see
if it helps speed things up).</p>
            
            <pre><code>func SymGoType(i Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="SymUnit">
            <h2>SymUnit</h2>
            <hr />
            
            <p>SymUnit returns the compilation unit for a given symbol (which will
typically be nil for external or linker-manufactured symbols).</p>
            
            <pre><code>func SymUnit(i Sym) *sym.CompilationUnit</code></pre>
         </article>
         
         <article class="function" data-name="SymPkg">
            <h2>SymPkg</h2>
            <hr />
            
            <p>SymPkg returns the package where the symbol came from (for
regular compiler-generated Go symbols), but in the case of
building with "-linkshared" (when a symbol is read from a
shared library), will hold the library name.
NOTE: this corresponds to sym.Symbol.File field.</p>
            
            <pre><code>func SymPkg(i Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="SetSymPkg">
            <h2>SetSymPkg</h2>
            <hr />
            
            <p>SetSymPkg sets the package/library for a symbol. This is
needed mainly for external symbols, specifically those imported
from shared libraries.</p>
            
            <pre><code>func SetSymPkg(i Sym, pkg string)</code></pre>
         </article>
         
         <article class="function" data-name="SymLocalentry">
            <h2>SymLocalentry</h2>
            <hr />
            
            <p>SymLocalentry returns an offset in bytes of the "local entry" of a symbol.

On PPC64, a value of 1 indicates the symbol does not use or preserve a TOC
pointer in R2, nor does it have a distinct local entry.</p>
            
            <pre><code>func SymLocalentry(i Sym) uint8</code></pre>
         </article>
         
         <article class="function" data-name="SetSymLocalentry">
            <h2>SetSymLocalentry</h2>
            <hr />
            
            <p>SetSymLocalentry sets the "local entry" offset attribute for a symbol.</p>
            
            <pre><code>func SetSymLocalentry(i Sym, value uint8)</code></pre>
         </article>
         
         <article class="function" data-name="NAux">
            <h2>NAux</h2>
            <hr />
            
            <p>Returns the number of aux symbols given a global index.</p>
            
            <pre><code>func NAux(i Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="Aux">
            <h2>Aux</h2>
            <hr />
            
            <p>Returns the "handle" to the j-th aux symbol of the i-th symbol.</p>
            
            <pre><code>func Aux(i Sym, j int) Aux</code></pre>
         </article>
         
         <article class="function" data-name="WasmImportSym">
            <h2>WasmImportSym</h2>
            <hr />
            
            <p>WasmImportSym returns the auxiliary WebAssembly import symbol associated with
a given function symbol. The aux sym only exists for Go function stubs that
have been annotated with the //go:wasmimport directive.  The aux sym
contains the information necessary for the linker to add a WebAssembly
import statement.
(https://webassembly.github.io/spec/core/syntax/modules.html#imports)</p>
            
            <pre><code>func WasmImportSym(fnSymIdx Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="WasmTypeSym">
            <h2>WasmTypeSym</h2>
            <hr />
            
            <pre><code>func WasmTypeSym(s Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="SEHUnwindSym">
            <h2>SEHUnwindSym</h2>
            <hr />
            
            <p>SEHUnwindSym returns the auxiliary SEH unwind symbol associated with
a given function symbol.</p>
            
            <pre><code>func SEHUnwindSym(fnSymIdx Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="GetFuncDwarfAuxSyms">
            <h2>GetFuncDwarfAuxSyms</h2>
            <hr />
            
            <p>GetFuncDwarfAuxSyms collects and returns the auxiliary DWARF
symbols associated with a given function symbol.  Prior to the
introduction of the loader, this was done purely using name
lookups, e.f. for function with name XYZ we would then look up
go.info.XYZ, etc.</p>
            
            <pre><code>func GetFuncDwarfAuxSyms(fnSymIdx Sym) (auxDwarfInfo Sym, auxDwarfLoc Sym, auxDwarfRanges Sym, auxDwarfLines Sym)</code></pre>
         </article>
         
         <article class="function" data-name="GetVarDwarfAuxSym">
            <h2>GetVarDwarfAuxSym</h2>
            <hr />
            
            <pre><code>func GetVarDwarfAuxSym(i Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="AddInteriorSym">
            <h2>AddInteriorSym</h2>
            <hr />
            
            <p>AddInteriorSym sets up 'interior' as an interior symbol of
container/payload symbol 'container'. An interior symbol does not
itself have data, but gives a name to a subrange of the data in its
container symbol. The container itself may or may not have a name.
This method is intended primarily for use in the host object
loaders, to capture the semantics of symbols and sections in an
object file. When reading a host object file, we'll typically
encounter a static section symbol (ex: ".text") containing content
for a collection of functions, then a series of ELF (or macho, etc)
symbol table entries each of which points into a sub-section
(offset and length) of its corresponding container symbol. Within
the go linker we create a loader.Sym for the container (which is
expected to have the actual content/payload) and then a set of
interior loader.Sym's that point into a portion of the container.</p>
            
            <pre><code>func AddInteriorSym(container Sym, interior Sym)</code></pre>
         </article>
         
         <article class="function" data-name="OuterSym">
            <h2>OuterSym</h2>
            <hr />
            
            <p>OuterSym gets the outer/container symbol.</p>
            
            <pre><code>func OuterSym(i Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="SubSym">
            <h2>SubSym</h2>
            <hr />
            
            <p>SubSym gets the subsymbol for host object loaded symbols.</p>
            
            <pre><code>func SubSym(i Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="growOuter">
            <h2>growOuter</h2>
            <hr />
            
            <p>growOuter grows the slice used to store outer symbol.</p>
            
            <pre><code>func growOuter(reqLen int)</code></pre>
         </article>
         
         <article class="function" data-name="SetCarrierSym">
            <h2>SetCarrierSym</h2>
            <hr />
            
            <p>SetCarrierSym declares that 'c' is the carrier or container symbol
for 's'. Carrier symbols are used in the linker to as a container
for a collection of sub-symbols where the content of the
sub-symbols is effectively concatenated to form the content of the
carrier. The carrier is given a name in the output symbol table
while the sub-symbol names are not. For example, the Go compiler
emits named string symbols (type SGOSTRING) when compiling a
package; after being deduplicated, these symbols are collected into
a single unit by assigning them a new carrier symbol named
"go:string.*" (which appears in the final symbol table for the
output load module).</p>
            
            <pre><code>func SetCarrierSym(s Sym, c Sym)</code></pre>
         </article>
         
         <article class="function" data-name="InitReachable">
            <h2>InitReachable</h2>
            <hr />
            
            <p>Initialize Reachable bitmap and its siblings for running deadcode pass.</p>
            
            <pre><code>func InitReachable()</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="SortSub">
            <h2>SortSub</h2>
            <hr />
            
            <p>SortSub walks through the sub-symbols for 's' and sorts them
in place by increasing value. Return value is the new
sub symbol for the specified outer symbol.</p>
            
            <pre><code>func SortSub(s Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="SortSyms">
            <h2>SortSyms</h2>
            <hr />
            
            <p>SortSyms sorts a list of symbols by their value.</p>
            
            <pre><code>func SortSyms(ss []Sym)</code></pre>
         </article>
         
         <article class="function" data-name="growAttrBitmaps">
            <h2>growAttrBitmaps</h2>
            <hr />
            
            <p>Insure that reachable bitmap and its siblings have enough size.</p>
            
            <pre><code>func growAttrBitmaps(reqLen int)</code></pre>
         </article>
         
         <article class="function" data-name="growExtAttrBitmaps">
            <h2>growExtAttrBitmaps</h2>
            <hr />
            
            <pre><code>func growExtAttrBitmaps()</code></pre>
         </article>
         
         <article class="function" data-name="Count">
            <h2>Count</h2>
            <hr />
            
            <pre><code>func Count() int</code></pre>
         </article>
         
         <article class="function" data-name="At">
            <h2>At</h2>
            <hr />
            
            <p>At returns the j-th reloc for a global symbol.</p>
            
            <pre><code>func At(j int) Reloc</code></pre>
         </article>
         
         <article class="function" data-name="Relocs">
            <h2>Relocs</h2>
            <hr />
            
            <p>Relocs returns a Relocs object for the given global sym.</p>
            
            <pre><code>func Relocs(i Sym) Relocs</code></pre>
         </article>
         
         <article class="function" data-name="relocs">
            <h2>relocs</h2>
            <hr />
            
            <p>relocs returns a Relocs object given a local sym index and reader.</p>
            
            <pre><code>func relocs(r *oReader, li uint32) Relocs</code></pre>
         </article>
         
         <article class="function" data-name="auxs">
            <h2>auxs</h2>
            <hr />
            
            <pre><code>func auxs(i Sym) (*oReader, []goobj.Aux)</code></pre>
         </article>
         
         <article class="function" data-name="aux1">
            <h2>aux1</h2>
            <hr />
            
            <p>Returns a specific aux symbol of type t for symbol i.</p>
            
            <pre><code>func aux1(i Sym, t uint8) Sym</code></pre>
         </article>
         
         <article class="function" data-name="Pcsp">
            <h2>Pcsp</h2>
            <hr />
            
            <pre><code>func Pcsp(i Sym) Sym</code></pre>
         </article>
         
         <article class="function" data-name="PcdataAuxs">
            <h2>PcdataAuxs</h2>
            <hr />
            
            <p>Returns all aux symbols of per-PC data for symbol i.
tmp is a scratch space for the pcdata slice.</p>
            
            <pre><code>func PcdataAuxs(i Sym, tmp []Sym) (pcsp Sym, pcfile Sym, pcline Sym, pcinline Sym, pcdata []Sym)</code></pre>
         </article>
         
         <article class="function" data-name="NumPcdata">
            <h2>NumPcdata</h2>
            <hr />
            
            <p>Returns the number of pcdata for symbol i.</p>
            
            <pre><code>func NumPcdata(i Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="Funcdata">
            <h2>Funcdata</h2>
            <hr />
            
            <p>Returns all funcdata symbols of symbol i.
tmp is a scratch space.</p>
            
            <pre><code>func Funcdata(i Sym, tmp []Sym) []Sym</code></pre>
         </article>
         
         <article class="function" data-name="NumFuncdata">
            <h2>NumFuncdata</h2>
            <hr />
            
            <p>Returns the number of funcdata for symbol i.</p>
            
            <pre><code>func NumFuncdata(i Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="Valid">
            <h2>Valid</h2>
            <hr />
            
            <pre><code>func Valid() bool</code></pre>
         </article>
         
         <article class="function" data-name="Args">
            <h2>Args</h2>
            <hr />
            
            <pre><code>func Args() int</code></pre>
         </article>
         
         <article class="function" data-name="Locals">
            <h2>Locals</h2>
            <hr />
            
            <pre><code>func Locals() int</code></pre>
         </article>
         
         <article class="function" data-name="FuncID">
            <h2>FuncID</h2>
            <hr />
            
            <pre><code>func FuncID() abi.FuncID</code></pre>
         </article>
         
         <article class="function" data-name="FuncFlag">
            <h2>FuncFlag</h2>
            <hr />
            
            <pre><code>func FuncFlag() abi.FuncFlag</code></pre>
         </article>
         
         <article class="function" data-name="StartLine">
            <h2>StartLine</h2>
            <hr />
            
            <pre><code>func StartLine() int32</code></pre>
         </article>
         
         <article class="function" data-name="Preload">
            <h2>Preload</h2>
            <hr />
            
            <p>Preload has to be called prior to invoking the various methods
below related to pcdata, funcdataoff, files, and inltree nodes.</p>
            
            <pre><code>func Preload()</code></pre>
         </article>
         
         <article class="function" data-name="NumFile">
            <h2>NumFile</h2>
            <hr />
            
            <pre><code>func NumFile() uint32</code></pre>
         </article>
         
         <article class="function" data-name="File">
            <h2>File</h2>
            <hr />
            
            <pre><code>func File(k int) goobj.CUFileIndex</code></pre>
         </article>
         
         <article class="function" data-name="TopFrame">
            <h2>TopFrame</h2>
            <hr />
            
            <p>TopFrame returns true if the function associated with this FuncInfo
is an entry point, meaning that unwinders should stop when they hit
this function.</p>
            
            <pre><code>func TopFrame() bool</code></pre>
         </article>
         
         <article class="function" data-name="NumInlTree">
            <h2>NumInlTree</h2>
            <hr />
            
            <pre><code>func NumInlTree() uint32</code></pre>
         </article>
         
         <article class="function" data-name="InlTree">
            <h2>InlTree</h2>
            <hr />
            
            <pre><code>func InlTree(k int) InlTreeNode</code></pre>
         </article>
         
         <article class="function" data-name="FuncInfo">
            <h2>FuncInfo</h2>
            <hr />
            
            <pre><code>func FuncInfo(i Sym) FuncInfo</code></pre>
         </article>
         
         <article class="function" data-name="Preload">
            <h2>Preload</h2>
            <hr />
            
            <p>Preload a package: adds autolib.
Does not add defined package or non-packaged symbols to the symbol table.
These are done in LoadSyms.
Does not read symbol data.
Returns the fingerprint of the object.</p>
            
            <pre><code>func Preload(localSymVersion int, f *bio.Reader, lib *sym.Library, unit *sym.CompilationUnit, length int64) goobj.FingerprintType</code></pre>
         </article>
         
         <article class="function" data-name="preloadSyms">
            <h2>preloadSyms</h2>
            <hr />
            
            <p>Preload symbols of given kind from an object.</p>
            
            <pre><code>func preloadSyms(r *oReader, kind int)</code></pre>
         </article>
         
         <article class="function" data-name="LoadSyms">
            <h2>LoadSyms</h2>
            <hr />
            
            <p>Add syms, hashed (content-addressable) symbols, non-package symbols, and
references to external symbols (which are always named).</p>
            
            <pre><code>func LoadSyms(arch *sys.Arch)</code></pre>
         </article>
         
         <article class="function" data-name="loadObjRefs">
            <h2>loadObjRefs</h2>
            <hr />
            
            <pre><code>func loadObjRefs(l *Loader, r *oReader, arch *sys.Arch)</code></pre>
         </article>
         
         <article class="function" data-name="abiToVer">
            <h2>abiToVer</h2>
            <hr />
            
            <pre><code>func abiToVer(abi uint16, localSymVersion int) int</code></pre>
         </article>
         
         <article class="function" data-name="checkLinkname">
            <h2>checkLinkname</h2>
            <hr />
            
            <p>check if a linkname reference to symbol s from pkg is allowed</p>
            
            <pre><code>func checkLinkname(pkg string, name string, s Sym)</code></pre>
         </article>
         
         <article class="function" data-name="TopLevelSym">
            <h2>TopLevelSym</h2>
            <hr />
            
            <p>TopLevelSym tests a symbol (by name and kind) to determine whether
the symbol first class sym (participating in the link) or is an
anonymous aux or sub-symbol containing some sub-part or payload of
another symbol.</p>
            
            <pre><code>func TopLevelSym(s Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="topLevelSym">
            <h2>topLevelSym</h2>
            <hr />
            
            <p>topLevelSym tests a symbol name and kind to determine whether
the symbol first class sym (participating in the link) or is an
anonymous aux or sub-symbol containing some sub-part or payload of
another symbol.</p>
            
            <pre><code>func topLevelSym(sname string, skind sym.SymKind) bool</code></pre>
         </article>
         
         <article class="function" data-name="cloneToExternal">
            <h2>cloneToExternal</h2>
            <hr />
            
            <p>cloneToExternal takes the existing object file symbol (symIdx)
and creates a new external symbol payload that is a clone with
respect to name, version, type, relocations, etc. The idea here
is that if the linker decides it wants to update the contents of
a symbol originally discovered as part of an object file, it's
easier to do this if we make the updates to an external symbol
payload.</p>
            
            <pre><code>func cloneToExternal(symIdx Sym) *extSymPayload</code></pre>
         </article>
         
         <article class="function" data-name="CopySym">
            <h2>CopySym</h2>
            <hr />
            
            <p>Copy the payload of symbol src to dst. Both src and dst must be external
symbols.
The intended use case is that when building/linking against a shared library,
where we do symbol name mangling, the Go object file may have reference to
the original symbol name whereas the shared library provides a symbol with
the mangled name. When we do mangling, we copy payload of mangled to original.</p>
            
            <pre><code>func CopySym(src Sym, dst Sym)</code></pre>
         </article>
         
         <article class="function" data-name="CreateExtSym">
            <h2>CreateExtSym</h2>
            <hr />
            
            <p>CreateExtSym creates a new external symbol with the specified name
without adding it to any lookup tables, returning a Sym index for it.</p>
            
            <pre><code>func CreateExtSym(name string, ver int) Sym</code></pre>
         </article>
         
         <article class="function" data-name="CreateStaticSym">
            <h2>CreateStaticSym</h2>
            <hr />
            
            <p>CreateStaticSym creates a new static symbol with the specified name
without adding it to any lookup tables, returning a Sym index for it.</p>
            
            <pre><code>func CreateStaticSym(name string) Sym</code></pre>
         </article>
         
         <article class="function" data-name="FreeSym">
            <h2>FreeSym</h2>
            <hr />
            
            <pre><code>func FreeSym(i Sym)</code></pre>
         </article>
         
         <article class="function" data-name="SetRelocVariant">
            <h2>SetRelocVariant</h2>
            <hr />
            
            <p>SetRelocVariant sets the 'variant' property of a relocation on
some specific symbol.</p>
            
            <pre><code>func SetRelocVariant(s Sym, ri int, v sym.RelocVariant)</code></pre>
         </article>
         
         <article class="function" data-name="RelocVariant">
            <h2>RelocVariant</h2>
            <hr />
            
            <p>RelocVariant returns the 'variant' property of a relocation on
some specific symbol.</p>
            
            <pre><code>func RelocVariant(s Sym, ri int) sym.RelocVariant</code></pre>
         </article>
         
         <article class="function" data-name="UndefinedRelocTargets">
            <h2>UndefinedRelocTargets</h2>
            <hr />
            
            <p>UndefinedRelocTargets iterates through the global symbol index
space, looking for symbols with relocations targeting undefined
references. The linker's loadlib method uses this to determine if
there are unresolved references to functions in system libraries
(for example, libgcc.a), presumably due to CGO code. Return value
is a pair of lists of loader.Sym's. First list corresponds to the
corresponding to the undefined symbols themselves, the second list
is the symbol that is making a reference to the undef. The "limit"
param controls the maximum number of results returned; if "limit"
is -1, then all undefs are returned.</p>
            
            <pre><code>func UndefinedRelocTargets(limit int) ([]Sym, []Sym)</code></pre>
         </article>
         
         <article class="function" data-name="AssignTextSymbolOrder">
            <h2>AssignTextSymbolOrder</h2>
            <hr />
            
            <p>AssignTextSymbolOrder populates the Textp slices within each
library and compilation unit, insuring that packages are laid down
in dependency order (internal first, then everything else). Return value
is a slice of all text syms.</p>
            
            <pre><code>func AssignTextSymbolOrder(libs []*sym.Library, intlibs []bool, extsyms []Sym) []Sym</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <p>Errorf method logs an error message.

After each error, the error actions function will be invoked; this
will either terminate the link immediately (if -h option given)
or it will keep a count and exit if more than 20 errors have been printed.

Logging an error means that on exit cmd/link will delete any
output file and return a non-zero error code.</p>
            
            <pre><code>func Errorf(s Sym, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="GetErrorReporter">
            <h2>GetErrorReporter</h2>
            <hr />
            
            <p>GetErrorReporter returns the loader's associated error reporter.</p>
            
            <pre><code>func GetErrorReporter() *ErrorReporter</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <p>Errorf method logs an error message. See ErrorReporter.Errorf for details.</p>
            
            <pre><code>func Errorf(s Sym, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Symbol statistics.</p>
            
            <pre><code>func Stat() string</code></pre>
         </article>
         
         <article class="function" data-name="Dump">
            <h2>Dump</h2>
            <hr />
            
            <p>For debugging.</p>
            
            <pre><code>func Dump()</code></pre>
         </article>
         
         <article class="function" data-name="addDummyObjSym">
            <h2>addDummyObjSym</h2>
            <hr />
            
            <p>dummyAddSym adds the named symbol to the loader as if it had been
read from a Go object file. Note that it allocates a global
index without creating an associated object reader, so one can't
do anything interesting with this symbol (such as look at its
data or relocations).</p>
            
            <pre><code>func addDummyObjSym(t *testing.T, ldr *Loader, or *oReader, name string) Sym</code></pre>
         </article>
         
         <article class="function" data-name="mkLoader">
            <h2>mkLoader</h2>
            <hr />
            
            <pre><code>func mkLoader() *Loader</code></pre>
         </article>
         
         <article class="function" data-name="TestAddMaterializedSymbol">
            <h2>TestAddMaterializedSymbol</h2>
            <hr />
            
            <pre><code>func TestAddMaterializedSymbol(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="sameRelocSlice">
            <h2>sameRelocSlice</h2>
            <hr />
            
            <pre><code>func sameRelocSlice(s1 *Relocs, s2 []Reloc) bool</code></pre>
         </article>
         
         <article class="function" data-name="mkReloc">
            <h2>mkReloc</h2>
            <hr />
            
            <pre><code>func mkReloc(l *Loader, typ objabi.RelocType, off int32, siz uint8, add int64, sym Sym) Reloc</code></pre>
         </article>
         
         <article class="function" data-name="TestAddDataMethods">
            <h2>TestAddDataMethods</h2>
            <hr />
            
            <pre><code>func TestAddDataMethods(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestOuterSub">
            <h2>TestOuterSub</h2>
            <hr />
            
            <pre><code>func TestOuterSub(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="MakeSymbolBuilder">
            <h2>MakeSymbolBuilder</h2>
            <hr />
            
            <p>MakeSymbolBuilder creates a symbol builder for use in constructing
an entirely new symbol.</p>
            
            <pre><code>func MakeSymbolBuilder(name string) *SymbolBuilder</code></pre>
         </article>
         
         <article class="function" data-name="MakeSymbolUpdater">
            <h2>MakeSymbolUpdater</h2>
            <hr />
            
            <p>MakeSymbolUpdater creates a symbol builder helper for an existing
symbol 'symIdx'. If 'symIdx' is not an external symbol, then create
a clone of it (copy name, properties, etc) fix things up so that
the lookup tables and caches point to the new version, not the old
version.</p>
            
            <pre><code>func MakeSymbolUpdater(symIdx Sym) *SymbolBuilder</code></pre>
         </article>
         
         <article class="function" data-name="CreateSymForUpdate">
            <h2>CreateSymForUpdate</h2>
            <hr />
            
            <p>CreateSymForUpdate creates a symbol with given name and version,
returns a CreateSymForUpdate for update. If the symbol already
exists, it will update in-place.</p>
            
            <pre><code>func CreateSymForUpdate(name string, version int) *SymbolBuilder</code></pre>
         </article>
         
         <article class="function" data-name="Sym">
            <h2>Sym</h2>
            <hr />
            
            <pre><code>func Sym() Sym</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="Version">
            <h2>Version</h2>
            <hr />
            
            <pre><code>func Version() int</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() sym.SymKind</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Data">
            <h2>Data</h2>
            <hr />
            
            <pre><code>func Data() []byte</code></pre>
         </article>
         
         <article class="function" data-name="Value">
            <h2>Value</h2>
            <hr />
            
            <pre><code>func Value() int64</code></pre>
         </article>
         
         <article class="function" data-name="Align">
            <h2>Align</h2>
            <hr />
            
            <pre><code>func Align() int32</code></pre>
         </article>
         
         <article class="function" data-name="Localentry">
            <h2>Localentry</h2>
            <hr />
            
            <pre><code>func Localentry() uint8</code></pre>
         </article>
         
         <article class="function" data-name="OnList">
            <h2>OnList</h2>
            <hr />
            
            <pre><code>func OnList() bool</code></pre>
         </article>
         
         <article class="function" data-name="External">
            <h2>External</h2>
            <hr />
            
            <pre><code>func External() bool</code></pre>
         </article>
         
         <article class="function" data-name="Extname">
            <h2>Extname</h2>
            <hr />
            
            <pre><code>func Extname() string</code></pre>
         </article>
         
         <article class="function" data-name="CgoExportDynamic">
            <h2>CgoExportDynamic</h2>
            <hr />
            
            <pre><code>func CgoExportDynamic() bool</code></pre>
         </article>
         
         <article class="function" data-name="Dynimplib">
            <h2>Dynimplib</h2>
            <hr />
            
            <pre><code>func Dynimplib() string</code></pre>
         </article>
         
         <article class="function" data-name="Dynimpvers">
            <h2>Dynimpvers</h2>
            <hr />
            
            <pre><code>func Dynimpvers() string</code></pre>
         </article>
         
         <article class="function" data-name="SubSym">
            <h2>SubSym</h2>
            <hr />
            
            <pre><code>func SubSym() Sym</code></pre>
         </article>
         
         <article class="function" data-name="GoType">
            <h2>GoType</h2>
            <hr />
            
            <pre><code>func GoType() Sym</code></pre>
         </article>
         
         <article class="function" data-name="VisibilityHidden">
            <h2>VisibilityHidden</h2>
            <hr />
            
            <pre><code>func VisibilityHidden() bool</code></pre>
         </article>
         
         <article class="function" data-name="Sect">
            <h2>Sect</h2>
            <hr />
            
            <pre><code>func Sect() *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="SetType">
            <h2>SetType</h2>
            <hr />
            
            <pre><code>func SetType(kind sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="SetSize">
            <h2>SetSize</h2>
            <hr />
            
            <pre><code>func SetSize(size int64)</code></pre>
         </article>
         
         <article class="function" data-name="SetData">
            <h2>SetData</h2>
            <hr />
            
            <pre><code>func SetData(data []byte)</code></pre>
         </article>
         
         <article class="function" data-name="SetOnList">
            <h2>SetOnList</h2>
            <hr />
            
            <pre><code>func SetOnList(v bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetExternal">
            <h2>SetExternal</h2>
            <hr />
            
            <pre><code>func SetExternal(v bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetValue">
            <h2>SetValue</h2>
            <hr />
            
            <pre><code>func SetValue(v int64)</code></pre>
         </article>
         
         <article class="function" data-name="SetAlign">
            <h2>SetAlign</h2>
            <hr />
            
            <pre><code>func SetAlign(align int32)</code></pre>
         </article>
         
         <article class="function" data-name="SetLocalentry">
            <h2>SetLocalentry</h2>
            <hr />
            
            <pre><code>func SetLocalentry(value uint8)</code></pre>
         </article>
         
         <article class="function" data-name="SetExtname">
            <h2>SetExtname</h2>
            <hr />
            
            <pre><code>func SetExtname(value string)</code></pre>
         </article>
         
         <article class="function" data-name="SetDynimplib">
            <h2>SetDynimplib</h2>
            <hr />
            
            <pre><code>func SetDynimplib(value string)</code></pre>
         </article>
         
         <article class="function" data-name="SetDynimpvers">
            <h2>SetDynimpvers</h2>
            <hr />
            
            <pre><code>func SetDynimpvers(value string)</code></pre>
         </article>
         
         <article class="function" data-name="SetPlt">
            <h2>SetPlt</h2>
            <hr />
            
            <pre><code>func SetPlt(value int32)</code></pre>
         </article>
         
         <article class="function" data-name="SetGot">
            <h2>SetGot</h2>
            <hr />
            
            <pre><code>func SetGot(value int32)</code></pre>
         </article>
         
         <article class="function" data-name="SetSpecial">
            <h2>SetSpecial</h2>
            <hr />
            
            <pre><code>func SetSpecial(value bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetLocal">
            <h2>SetLocal</h2>
            <hr />
            
            <pre><code>func SetLocal(value bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetVisibilityHidden">
            <h2>SetVisibilityHidden</h2>
            <hr />
            
            <pre><code>func SetVisibilityHidden(value bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetNotInSymbolTable">
            <h2>SetNotInSymbolTable</h2>
            <hr />
            
            <pre><code>func SetNotInSymbolTable(value bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetSect">
            <h2>SetSect</h2>
            <hr />
            
            <pre><code>func SetSect(sect *sym.Section)</code></pre>
         </article>
         
         <article class="function" data-name="AddBytes">
            <h2>AddBytes</h2>
            <hr />
            
            <pre><code>func AddBytes(data []byte)</code></pre>
         </article>
         
         <article class="function" data-name="Relocs">
            <h2>Relocs</h2>
            <hr />
            
            <pre><code>func Relocs() Relocs</code></pre>
         </article>
         
         <article class="function" data-name="ResetRelocs">
            <h2>ResetRelocs</h2>
            <hr />
            
            <p>ResetRelocs removes all relocations on this symbol.</p>
            
            <pre><code>func ResetRelocs()</code></pre>
         </article>
         
         <article class="function" data-name="SetRelocType">
            <h2>SetRelocType</h2>
            <hr />
            
            <p>SetRelocType sets the type of the 'i'-th relocation on this sym to 't'</p>
            
            <pre><code>func SetRelocType(i int, t objabi.RelocType)</code></pre>
         </article>
         
         <article class="function" data-name="SetRelocSym">
            <h2>SetRelocSym</h2>
            <hr />
            
            <p>SetRelocSym sets the target sym of the 'i'-th relocation on this sym to 's'</p>
            
            <pre><code>func SetRelocSym(i int, tgt Sym)</code></pre>
         </article>
         
         <article class="function" data-name="SetRelocAdd">
            <h2>SetRelocAdd</h2>
            <hr />
            
            <p>SetRelocAdd sets the addend of the 'i'-th relocation on this sym to 'a'</p>
            
            <pre><code>func SetRelocAdd(i int, a int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddRelocs">
            <h2>AddRelocs</h2>
            <hr />
            
            <p>Add n relocations, return a handle to the relocations.</p>
            
            <pre><code>func AddRelocs(n int) Relocs</code></pre>
         </article>
         
         <article class="function" data-name="AddRel">
            <h2>AddRel</h2>
            <hr />
            
            <p>Add a relocation with given type, return its handle and index
(to set other fields).</p>
            
            <pre><code>func AddRel(typ objabi.RelocType) (Reloc, int)</code></pre>
         </article>
         
         <article class="function" data-name="SortRelocs">
            <h2>SortRelocs</h2>
            <hr />
            
            <p>SortRelocs Sort relocations by offset.</p>
            
            <pre><code>func SortRelocs()</code></pre>
         </article>
         
         <article class="function" data-name="Reachable">
            <h2>Reachable</h2>
            <hr />
            
            <pre><code>func Reachable() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetReachable">
            <h2>SetReachable</h2>
            <hr />
            
            <pre><code>func SetReachable(v bool)</code></pre>
         </article>
         
         <article class="function" data-name="ReadOnly">
            <h2>ReadOnly</h2>
            <hr />
            
            <pre><code>func ReadOnly() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetReadOnly">
            <h2>SetReadOnly</h2>
            <hr />
            
            <pre><code>func SetReadOnly(v bool)</code></pre>
         </article>
         
         <article class="function" data-name="DuplicateOK">
            <h2>DuplicateOK</h2>
            <hr />
            
            <pre><code>func DuplicateOK() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetDuplicateOK">
            <h2>SetDuplicateOK</h2>
            <hr />
            
            <pre><code>func SetDuplicateOK(v bool)</code></pre>
         </article>
         
         <article class="function" data-name="Outer">
            <h2>Outer</h2>
            <hr />
            
            <pre><code>func Outer() Sym</code></pre>
         </article>
         
         <article class="function" data-name="Sub">
            <h2>Sub</h2>
            <hr />
            
            <pre><code>func Sub() Sym</code></pre>
         </article>
         
         <article class="function" data-name="SortSub">
            <h2>SortSub</h2>
            <hr />
            
            <pre><code>func SortSub()</code></pre>
         </article>
         
         <article class="function" data-name="AddInteriorSym">
            <h2>AddInteriorSym</h2>
            <hr />
            
            <pre><code>func AddInteriorSym(sub Sym)</code></pre>
         </article>
         
         <article class="function" data-name="AddUint8">
            <h2>AddUint8</h2>
            <hr />
            
            <pre><code>func AddUint8(v uint8) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddUintXX">
            <h2>AddUintXX</h2>
            <hr />
            
            <pre><code>func AddUintXX(arch *sys.Arch, v uint64, wid int) int64</code></pre>
         </article>
         
         <article class="function" data-name="setUintXX">
            <h2>setUintXX</h2>
            <hr />
            
            <pre><code>func setUintXX(arch *sys.Arch, off int64, v uint64, wid int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddUint16">
            <h2>AddUint16</h2>
            <hr />
            
            <pre><code>func AddUint16(arch *sys.Arch, v uint16) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddUint32">
            <h2>AddUint32</h2>
            <hr />
            
            <pre><code>func AddUint32(arch *sys.Arch, v uint32) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddUint64">
            <h2>AddUint64</h2>
            <hr />
            
            <pre><code>func AddUint64(arch *sys.Arch, v uint64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddUint">
            <h2>AddUint</h2>
            <hr />
            
            <pre><code>func AddUint(arch *sys.Arch, v uint64) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetUint8">
            <h2>SetUint8</h2>
            <hr />
            
            <pre><code>func SetUint8(arch *sys.Arch, r int64, v uint8) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetUint16">
            <h2>SetUint16</h2>
            <hr />
            
            <pre><code>func SetUint16(arch *sys.Arch, r int64, v uint16) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetUint32">
            <h2>SetUint32</h2>
            <hr />
            
            <pre><code>func SetUint32(arch *sys.Arch, r int64, v uint32) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetUint">
            <h2>SetUint</h2>
            <hr />
            
            <pre><code>func SetUint(arch *sys.Arch, r int64, v uint64) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetUintptr">
            <h2>SetUintptr</h2>
            <hr />
            
            <pre><code>func SetUintptr(arch *sys.Arch, r int64, v uintptr) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetAddrPlus">
            <h2>SetAddrPlus</h2>
            <hr />
            
            <pre><code>func SetAddrPlus(arch *sys.Arch, off int64, tgt Sym, add int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetAddr">
            <h2>SetAddr</h2>
            <hr />
            
            <pre><code>func SetAddr(arch *sys.Arch, off int64, tgt Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddStringAt">
            <h2>AddStringAt</h2>
            <hr />
            
            <pre><code>func AddStringAt(off int64, str string) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddCStringAt">
            <h2>AddCStringAt</h2>
            <hr />
            
            <p>AddCStringAt adds str plus a null terminating byte.</p>
            
            <pre><code>func AddCStringAt(off int64, str string) int64</code></pre>
         </article>
         
         <article class="function" data-name="Addstring">
            <h2>Addstring</h2>
            <hr />
            
            <pre><code>func Addstring(str string) int64</code></pre>
         </article>
         
         <article class="function" data-name="SetBytesAt">
            <h2>SetBytesAt</h2>
            <hr />
            
            <pre><code>func SetBytesAt(off int64, b []byte) int64</code></pre>
         </article>
         
         <article class="function" data-name="addSymRef">
            <h2>addSymRef</h2>
            <hr />
            
            <pre><code>func addSymRef(tgt Sym, add int64, typ objabi.RelocType, rsize int) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddSymRef">
            <h2>AddSymRef</h2>
            <hr />
            
            <p>Add a symbol reference (relocation) with given type, addend, and size
(the most generic form).</p>
            
            <pre><code>func AddSymRef(arch *sys.Arch, tgt Sym, add int64, typ objabi.RelocType, rsize int) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddAddrPlus">
            <h2>AddAddrPlus</h2>
            <hr />
            
            <pre><code>func AddAddrPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddAddrPlus4">
            <h2>AddAddrPlus4</h2>
            <hr />
            
            <pre><code>func AddAddrPlus4(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddAddr">
            <h2>AddAddr</h2>
            <hr />
            
            <pre><code>func AddAddr(arch *sys.Arch, tgt Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddPEImageRelativeAddrPlus">
            <h2>AddPEImageRelativeAddrPlus</h2>
            <hr />
            
            <pre><code>func AddPEImageRelativeAddrPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddPCRelPlus">
            <h2>AddPCRelPlus</h2>
            <hr />
            
            <pre><code>func AddPCRelPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddCURelativeAddrPlus">
            <h2>AddCURelativeAddrPlus</h2>
            <hr />
            
            <pre><code>func AddCURelativeAddrPlus(arch *sys.Arch, tgt Sym, add int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddSize">
            <h2>AddSize</h2>
            <hr />
            
            <pre><code>func AddSize(arch *sys.Arch, tgt Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="GenAddAddrPlusFunc">
            <h2>GenAddAddrPlusFunc</h2>
            <hr />
            
            <p>GenAddAddrPlusFunc returns a function to be called when capturing
a function symbol's address. In later stages of the link (when
address assignment is done) when doing internal linking and
targeting an executable, we can just emit the address of a function
directly instead of generating a relocation. Clients can call
this function (setting 'internalExec' based on build mode and target)
and then invoke the returned function in roughly the same way that
loader.*SymbolBuilder.AddAddrPlus would be used.</p>
            
            <pre><code>func GenAddAddrPlusFunc(internalExec bool) func</code></pre>
         </article>
         
         <article class="function" data-name="MakeWritable">
            <h2>MakeWritable</h2>
            <hr />
            
            <pre><code>func MakeWritable()</code></pre>
         </article>
         
         <article class="function" data-name="AddUleb">
            <h2>AddUleb</h2>
            <hr />
            
            <pre><code>func AddUleb(v uint64)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
