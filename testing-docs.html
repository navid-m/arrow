<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - testing</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="testing_fstest-docs.html">fstest</a></li>
               
               <li><a href="testing_iotest-docs.html">iotest</a></li>
               
               <li><a href="testing_quick-docs.html">quick</a></li>
               
               <li><a href="testing_slogtest-docs.html">slogtest</a></li>
               
               <li><a href="testing_synctest-docs.html">synctest</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>testing</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"runtime"
"context"
"flag"
"fmt"
"internal/sysinfo"
"io"
"math"
"os"
"runtime"
"slices"
"strconv"
"strings"
"sync"
"sync/atomic"
"time"
"unicode"
"fmt"
"runtime"
"slices"
"strings"
"time"
"fmt"
"os"
"strconv"
"strings"
"sync"
"fmt"
"internal/goexperiment"
"os"
_ "unsafe"
"bytes"
"context"
"errors"
"flag"
"fmt"
"internal/goexperiment"
"internal/race"
"io"
"math/rand"
"os"
"path/filepath"
"reflect"
"runtime"
"runtime/debug"
"runtime/trace"
"slices"
"strconv"
"strings"
"sync"
"sync/atomic"
"time"
"unicode"
"unicode/utf8"
"errors"
"internal/syscall/windows"
"math/bits"
"syscall"
"time"
"fmt"
"internal/goexperiment"
"os"
"sync/atomic"
"context"
"errors"
"flag"
"fmt"
"io"
"os"
"path/filepath"
"reflect"
"runtime"
"strings"
"time"
"fmt"
"io"
"os"
"strings"
"time"
"fmt"
"io"
"os"
"strings"
"time"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ TB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ TB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ TB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="benchTime" data-name="benchTime">
               <h3>
                  benchTime 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#benchTime" class="anchor" title="Link to benchTime">#</a>
               </h3>
               
               <pre><code class="language-go">var benchTime = durationOrCountFlag{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="benchmarkLock" data-name="benchmarkLock">
               <h3>
                  benchmarkLock 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#benchmarkLock" class="anchor" title="Link to benchmarkLock">#</a>
               </h3>
               
                  <p class="doc-comment">Global lock to ensure only one benchmark runs at a time.</p>
               
               <pre><code class="language-go">var benchmarkLock sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="benchmarkMemory" data-name="benchmarkMemory">
               <h3>
                  benchmarkMemory 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#benchmarkMemory" class="anchor" title="Link to benchmarkMemory">#</a>
               </h3>
               
               <pre><code class="language-go">var benchmarkMemory *bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blockProfile" data-name="blockProfile">
               <h3>
                  blockProfile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#blockProfile" class="anchor" title="Link to blockProfile">#</a>
               </h3>
               
               <pre><code class="language-go">var blockProfile *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blockProfileRate" data-name="blockProfileRate">
               <h3>
                  blockProfileRate 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#blockProfileRate" class="anchor" title="Link to blockProfileRate">#</a>
               </h3>
               
               <pre><code class="language-go">var blockProfileRate *int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="chatty" data-name="chatty">
               <h3>
                  chatty 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#chatty" class="anchor" title="Link to chatty">#</a>
               </h3>
               
               <pre><code class="language-go">var chatty chattyFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="corpusDir" data-name="corpusDir">
               <h3>
                  corpusDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#corpusDir" class="anchor" title="Link to corpusDir">#</a>
               </h3>
               
                  <p class="doc-comment">corpusDir is the parent directory of the fuzz test's seed corpus within
the package.</p>
               
               <pre><code class="language-go">var corpusDir = "testdata/fuzz"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="count" data-name="count">
               <h3>
                  count 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#count" class="anchor" title="Link to count">#</a>
               </h3>
               
               <pre><code class="language-go">var count *uint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cover" data-name="cover">
               <h3>
                  cover 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cover" class="anchor" title="Link to cover">#</a>
               </h3>
               
               <pre><code class="language-go">var cover Cover</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cover2" data-name="cover2">
               <h3>
                  cover2 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cover2" class="anchor" title="Link to cover2">#</a>
               </h3>
               
                  <p class="doc-comment">cover2 variable stores the current coverage mode and a
tear-down function to be called at the end of the testing run.</p>
               
               <pre><code class="language-go">var cover2 struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="coverProfile" data-name="coverProfile">
               <h3>
                  coverProfile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#coverProfile" class="anchor" title="Link to coverProfile">#</a>
               </h3>
               
               <pre><code class="language-go">var coverProfile *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cpuList" data-name="cpuList">
               <h3>
                  cpuList 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cpuList" class="anchor" title="Link to cpuList">#</a>
               </h3>
               
               <pre><code class="language-go">var cpuList []int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cpuListStr" data-name="cpuListStr">
               <h3>
                  cpuListStr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cpuListStr" class="anchor" title="Link to cpuListStr">#</a>
               </h3>
               
               <pre><code class="language-go">var cpuListStr *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cpuProfile" data-name="cpuProfile">
               <h3>
                  cpuProfile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cpuProfile" class="anchor" title="Link to cpuProfile">#</a>
               </h3>
               
               <pre><code class="language-go">var cpuProfile *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMain" data-name="errMain">
               <h3>
                  errMain 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMain" class="anchor" title="Link to errMain">#</a>
               </h3>
               
                  <p class="doc-comment">No one should be using func Main anymore.
See the doc comment on func Main and use MainStart instead.</p>
               
               <pre><code class="language-go">var errMain = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNilPanicOrGoexit" data-name="errNilPanicOrGoexit">
               <h3>
                  errNilPanicOrGoexit 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNilPanicOrGoexit" class="anchor" title="Link to errNilPanicOrGoexit">#</a>
               </h3>
               
               <pre><code class="language-go">var errNilPanicOrGoexit = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="failFast" data-name="failFast">
               <h3>
                  failFast 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#failFast" class="anchor" title="Link to failFast">#</a>
               </h3>
               
               <pre><code class="language-go">var failFast *bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fullPath" data-name="fullPath">
               <h3>
                  fullPath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fullPath" class="anchor" title="Link to fullPath">#</a>
               </h3>
               
               <pre><code class="language-go">var fullPath *bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fuzzCacheDir" data-name="fuzzCacheDir">
               <h3>
                  fuzzCacheDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fuzzCacheDir" class="anchor" title="Link to fuzzCacheDir">#</a>
               </h3>
               
               <pre><code class="language-go">var fuzzCacheDir *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fuzzCoordinator" data-name="fuzzCoordinator">
               <h3>
                  fuzzCoordinator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fuzzCoordinator" class="anchor" title="Link to fuzzCoordinator">#</a>
               </h3>
               
               <pre><code class="language-go">const fuzzCoordinator</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fuzzDuration" data-name="fuzzDuration">
               <h3>
                  fuzzDuration 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fuzzDuration" class="anchor" title="Link to fuzzDuration">#</a>
               </h3>
               
               <pre><code class="language-go">var fuzzDuration durationOrCountFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fuzzWorker" data-name="fuzzWorker">
               <h3>
                  fuzzWorker 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fuzzWorker" class="anchor" title="Link to fuzzWorker">#</a>
               </h3>
               
               <pre><code class="language-go">const fuzzWorker</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fuzzWorkerExitCode" data-name="fuzzWorkerExitCode">
               <h3>
                  fuzzWorkerExitCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fuzzWorkerExitCode" class="anchor" title="Link to fuzzWorkerExitCode">#</a>
               </h3>
               
                  <p class="doc-comment">fuzzWorkerExitCode is used as an exit code by fuzz worker processes after an
internal error. This distinguishes internal errors from uncontrolled panics
and other failures. Keep in sync with internal/fuzz.workerExitCode.</p>
               
               <pre><code class="language-go">const fuzzWorkerExitCode = 70</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gocoverdir" data-name="gocoverdir">
               <h3>
                  gocoverdir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gocoverdir" class="anchor" title="Link to gocoverdir">#</a>
               </h3>
               
               <pre><code class="language-go">var gocoverdir *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="haveExamples" data-name="haveExamples">
               <h3>
                  haveExamples 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#haveExamples" class="anchor" title="Link to haveExamples">#</a>
               </h3>
               
               <pre><code class="language-go">var haveExamples bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hideStdoutForTesting" data-name="hideStdoutForTesting">
               <h3>
                  hideStdoutForTesting 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hideStdoutForTesting" class="anchor" title="Link to hideStdoutForTesting">#</a>
               </h3>
               
                  <p class="doc-comment">If hideStdoutForTesting is true, Run does not print the benchName.
This avoids a spurious print during 'go test' on package testing itself,
which invokes b.Run in its own tests (see sub_test.go).</p>
               
               <pre><code class="language-go">var hideStdoutForTesting = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initRan" data-name="initRan">
               <h3>
                  initRan 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initRan" class="anchor" title="Link to initRan">#</a>
               </h3>
               
               <pre><code class="language-go">var initRan bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isFuzzWorker" data-name="isFuzzWorker">
               <h3>
                  isFuzzWorker 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#isFuzzWorker" class="anchor" title="Link to isFuzzWorker">#</a>
               </h3>
               
               <pre><code class="language-go">var isFuzzWorker *bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="labelsOnce" data-name="labelsOnce">
               <h3>
                  labelsOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#labelsOnce" class="anchor" title="Link to labelsOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var labelsOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="loopPoisonMask" data-name="loopPoisonMask">
               <h3>
                  loopPoisonMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#loopPoisonMask" class="anchor" title="Link to loopPoisonMask">#</a>
               </h3>
               
                  <p class="doc-comment">loopPoisonMask is the set of all loop poison bits. (iota-1) is the index
of the bit we just set, from which we recreate that bit mask. We subtract
1 to set all of the bits below that bit, then complement the result to
get the mask. Sorry, not sorry.</p>
               
               <pre><code class="language-go">const loopPoisonMask = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="loopPoisonTimer" data-name="loopPoisonTimer">
               <h3>
                  loopPoisonTimer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#loopPoisonTimer" class="anchor" title="Link to loopPoisonTimer">#</a>
               </h3>
               
                  <p class="doc-comment">The loopPoison constants can be OR'd into B.loop.i to cause it to fall back
to the slow path.</p>
               
               <pre><code class="language-go">const loopPoisonTimer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="marker" data-name="marker">
               <h3>
                  marker 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#marker" class="anchor" title="Link to marker">#</a>
               </h3>
               
               <pre><code class="language-go">const marker = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code class="language-go">var match *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchBenchmarks" data-name="matchBenchmarks">
               <h3>
                  matchBenchmarks 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#matchBenchmarks" class="anchor" title="Link to matchBenchmarks">#</a>
               </h3>
               
               <pre><code class="language-go">var matchBenchmarks *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchFuzz" data-name="matchFuzz">
               <h3>
                  matchFuzz 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#matchFuzz" class="anchor" title="Link to matchFuzz">#</a>
               </h3>
               
               <pre><code class="language-go">var matchFuzz *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchList" data-name="matchList">
               <h3>
                  matchList 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#matchList" class="anchor" title="Link to matchList">#</a>
               </h3>
               
               <pre><code class="language-go">var matchList *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchMutex" data-name="matchMutex">
               <h3>
                  matchMutex 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#matchMutex" class="anchor" title="Link to matchMutex">#</a>
               </h3>
               
                  <p class="doc-comment">TODO: fix test_main to avoid race and improve caching, also allowing to
eliminate this Mutex.</p>
               
               <pre><code class="language-go">var matchMutex sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxStackLen" data-name="maxStackLen">
               <h3>
                  maxStackLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxStackLen" class="anchor" title="Link to maxStackLen">#</a>
               </h3>
               
                  <p class="doc-comment">The maximum number of stack frames to go through when skipping helper functions for
the purpose of decorating log messages.</p>
               
               <pre><code class="language-go">const maxStackLen = 50</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memProfile" data-name="memProfile">
               <h3>
                  memProfile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memProfile" class="anchor" title="Link to memProfile">#</a>
               </h3>
               
               <pre><code class="language-go">var memProfile *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memProfileRate" data-name="memProfileRate">
               <h3>
                  memProfileRate 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memProfileRate" class="anchor" title="Link to memProfileRate">#</a>
               </h3>
               
               <pre><code class="language-go">var memProfileRate *int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memStats" data-name="memStats">
               <h3>
                  memStats 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memStats" class="anchor" title="Link to memStats">#</a>
               </h3>
               
                  <p class="doc-comment">Used for every benchmark for measuring memory.</p>
               
               <pre><code class="language-go">var memStats runtime.MemStats</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="minimizeDuration" data-name="minimizeDuration">
               <h3>
                  minimizeDuration 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#minimizeDuration" class="anchor" title="Link to minimizeDuration">#</a>
               </h3>
               
               <pre><code class="language-go">var minimizeDuration = durationOrCountFlag{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mutexProfile" data-name="mutexProfile">
               <h3>
                  mutexProfile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mutexProfile" class="anchor" title="Link to mutexProfile">#</a>
               </h3>
               
               <pre><code class="language-go">var mutexProfile *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mutexProfileFraction" data-name="mutexProfileFraction">
               <h3>
                  mutexProfileFraction 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mutexProfileFraction" class="anchor" title="Link to mutexProfileFraction">#</a>
               </h3>
               
               <pre><code class="language-go">var mutexProfileFraction *int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="normalPanic" data-name="normalPanic">
               <h3>
                  normalPanic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#normalPanic" class="anchor" title="Link to normalPanic">#</a>
               </h3>
               
               <pre><code class="language-go">const normalPanic panicHandling = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numFailed" data-name="numFailed">
               <h3>
                  numFailed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#numFailed" class="anchor" title="Link to numFailed">#</a>
               </h3>
               
               <pre><code class="language-go">var numFailed atomic.Uint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="outputDir" data-name="outputDir">
               <h3>
                  outputDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#outputDir" class="anchor" title="Link to outputDir">#</a>
               </h3>
               
               <pre><code class="language-go">var outputDir *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="panicOnExit0" data-name="panicOnExit0">
               <h3>
                  panicOnExit0 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#panicOnExit0" class="anchor" title="Link to panicOnExit0">#</a>
               </h3>
               
               <pre><code class="language-go">var panicOnExit0 *bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="parallel" data-name="parallel">
               <h3>
                  parallel 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#parallel" class="anchor" title="Link to parallel">#</a>
               </h3>
               
               <pre><code class="language-go">var parallel *int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="parallelConflict" data-name="parallelConflict">
               <h3>
                  parallelConflict 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#parallelConflict" class="anchor" title="Link to parallelConflict">#</a>
               </h3>
               
               <pre><code class="language-go">const parallelConflict = `testing: test using t.Setenv or t.Chdir can not use t.Parallel`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="queryPerformanceFrequency" data-name="queryPerformanceFrequency">
               <h3>
                  queryPerformanceFrequency 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#queryPerformanceFrequency" class="anchor" title="Link to queryPerformanceFrequency">#</a>
               </h3>
               
               <pre><code class="language-go">var queryPerformanceFrequency int64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="realStderr" data-name="realStderr">
               <h3>
                  realStderr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#realStderr" class="anchor" title="Link to realStderr">#</a>
               </h3>
               
               <pre><code class="language-go">var realStderr *os.File</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="recoverAndReturnPanic" data-name="recoverAndReturnPanic">
               <h3>
                  recoverAndReturnPanic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#recoverAndReturnPanic" class="anchor" title="Link to recoverAndReturnPanic">#</a>
               </h3>
               
               <pre><code class="language-go">const recoverAndReturnPanic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="running" data-name="running">
               <h3>
                  running 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#running" class="anchor" title="Link to running">#</a>
               </h3>
               
               <pre><code class="language-go">var running sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seedCorpusOnly" data-name="seedCorpusOnly">
               <h3>
                  seedCorpusOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seedCorpusOnly" class="anchor" title="Link to seedCorpusOnly">#</a>
               </h3>
               
               <pre><code class="language-go">const seedCorpusOnly fuzzMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="short" data-name="short">
               <h3>
                  short 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#short" class="anchor" title="Link to short">#</a>
               </h3>
               
                  <p class="doc-comment">Flags, registered during Init.</p>
               
               <pre><code class="language-go">var short *bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="shuffle" data-name="shuffle">
               <h3>
                  shuffle 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#shuffle" class="anchor" title="Link to shuffle">#</a>
               </h3>
               
               <pre><code class="language-go">var shuffle *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skip" data-name="skip">
               <h3>
                  skip 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#skip" class="anchor" title="Link to skip">#</a>
               </h3>
               
               <pre><code class="language-go">var skip *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportedTypes" data-name="supportedTypes">
               <h3>
                  supportedTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#supportedTypes" class="anchor" title="Link to supportedTypes">#</a>
               </h3>
               
                  <p class="doc-comment">supportedTypes represents all of the supported types which can be fuzzed.</p>
               
               <pre><code class="language-go">var supportedTypes = map[reflect.Type]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testBinary" data-name="testBinary">
               <h3>
                  testBinary 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testBinary" class="anchor" title="Link to testBinary">#</a>
               </h3>
               
                  <p class="doc-comment">testBinary is set by cmd/go to "1" if this is a binary built by "go test".
The value is set to "1" by a -X option to cmd/link. We assume that
because this is possible, the compiler will not optimize testBinary
into a constant on the basis that it is an unexported package-scope
variable that is never changed. If the compiler ever starts implementing
such an optimization, we will need some technique to mark this variable
as "changed by a cmd/link -X option".</p>
               
               <pre><code class="language-go">var testBinary = "0"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testingTesting" data-name="testingTesting">
               <h3>
                  testingTesting 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testingTesting" class="anchor" title="Link to testingTesting">#</a>
               </h3>
               
               <pre><code class="language-go">var testingTesting bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testlog" data-name="testlog">
               <h3>
                  testlog 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testlog" class="anchor" title="Link to testlog">#</a>
               </h3>
               
               <pre><code class="language-go">var testlog *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testlogFile" data-name="testlogFile">
               <h3>
                  testlogFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testlogFile" class="anchor" title="Link to testlogFile">#</a>
               </h3>
               
               <pre><code class="language-go">var testlogFile *os.File</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="timeout" data-name="timeout">
               <h3>
                  timeout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#timeout" class="anchor" title="Link to timeout">#</a>
               </h3>
               
               <pre><code class="language-go">var timeout *time.Duration</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traceFile" data-name="traceFile">
               <h3>
                  traceFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#traceFile" class="anchor" title="Link to traceFile">#</a>
               </h3>
               
               <pre><code class="language-go">var traceFile *string</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="alternationMatch" data-name="alternationMatch">
               <h3>
                  alternationMatch
                  <span class="badge type-badge">type</span>
                  <a href="#alternationMatch" class="anchor" title="Link to alternationMatch">#</a>
               </h3>
               
               <p>alternationMatch matches a test name if one of the alternations match.</p>
               
               <pre><code class="language-go">type alternationMatch []filterMatch</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="fuzzMode" data-name="fuzzMode">
               <h3>
                  fuzzMode
                  <span class="badge type-badge">type</span>
                  <a href="#fuzzMode" class="anchor" title="Link to fuzzMode">#</a>
               </h3>
               
               <pre><code class="language-go">type fuzzMode uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="matchStringOnly" data-name="matchStringOnly">
               <h3>
                  matchStringOnly
                  <span class="badge type-badge">type</span>
                  <a href="#matchStringOnly" class="anchor" title="Link to matchStringOnly">#</a>
               </h3>
               
               <pre><code class="language-go">type matchStringOnly func(pat string, str string) (bool, error)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="panicHandling" data-name="panicHandling">
               <h3>
                  panicHandling
                  <span class="badge type-badge">type</span>
                  <a href="#panicHandling" class="anchor" title="Link to panicHandling">#</a>
               </h3>
               
               <p>panicHandling controls the panic handling used by runCleanup.</p>
               
               <pre><code class="language-go">type panicHandling int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="simpleMatch" data-name="simpleMatch">
               <h3>
                  simpleMatch
                  <span class="badge type-badge">type</span>
                  <a href="#simpleMatch" class="anchor" title="Link to simpleMatch">#</a>
               </h3>
               
               <p>simpleMatch matches a test name if all of the pattern strings match in
sequence.</p>
               
               <pre><code class="language-go">type simpleMatch []string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="TB" data-name="TB">
               <h3>
                  TB
                  <span class="badge interface-badge">interface</span>
                  <a href="#TB" class="anchor" title="Link to TB">#</a>
               </h3>
               
               <p>TB is the interface common to T, B, and F.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type TB interface {
Cleanup(func())
Error(args ...any)
Errorf(format string, args ...any)
Fail()
FailNow()
Failed() bool
Fatal(args ...any)
Fatalf(format string, args ...any)
Helper()
Log(args ...any)
Logf(format string, args ...any)
Name() string
Setenv(key string, value string)
Chdir(dir string)
Skip(args ...any)
SkipNow()
Skipf(format string, args ...any)
Skipped() bool
TempDir() string
Context() context.Context
private()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="filterMatch" data-name="filterMatch">
               <h3>
                  filterMatch
                  <span class="badge interface-badge">interface</span>
                  <a href="#filterMatch" class="anchor" title="Link to filterMatch">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type filterMatch interface {
matches(name []string, matchString func(pat string, str string) (bool, error)) (ok bool, partial bool)
verify(name string, matchString func(pat string, str string) (bool, error)) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="fuzzCrashError" data-name="fuzzCrashError">
               <h3>
                  fuzzCrashError
                  <span class="badge interface-badge">interface</span>
                  <a href="#fuzzCrashError" class="anchor" title="Link to fuzzCrashError">#</a>
               </h3>
               
               <p>fuzzCrashError is satisfied by a failing input detected while fuzzing.
These errors are written to the seed corpus and can be re-run with 'go test'.
Errors within the fuzzing framework (like I/O errors between coordinator
and worker processes) don't satisfy this interface.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type fuzzCrashError interface {
error
Unwrap() error
CrashPath() string
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="testDeps" data-name="testDeps">
               <h3>
                  testDeps
                  <span class="badge interface-badge">interface</span>
                  <a href="#testDeps" class="anchor" title="Link to testDeps">#</a>
               </h3>
               
               <p>testDeps is an internal interface of functionality that is
passed into this package by a test's generated main package.
The canonical implementation of this interface is
testing/internal/testdeps's TestDeps.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type testDeps interface {
ImportPath() string
MatchString(pat string, str string) (bool, error)
SetPanicOnExit0(bool)
StartCPUProfile(io.Writer) error
StopCPUProfile()
StartTestLog(io.Writer)
StopTestLog() error
WriteProfileTo(string, io.Writer, int) error
CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error
RunFuzzWorker(func(corpusEntry) error) error
ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)
CheckCorpus([]any, []reflect.Type) error
ResetCoverage()
SnapshotCoverage()
InitRuntimeCoverage() (mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="B" data-name="B">
               <h3>
                  B
                  <span class="badge">struct</span>
                  <a href="#B" class="anchor" title="Link to B">#</a>
               </h3>
               
               <p>B is a type passed to [Benchmark] functions to manage benchmark
timing and control the number of iterations.
A benchmark ends when its Benchmark function returns or calls any of the methods
FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called
only from the goroutine running the Benchmark function.
The other reporting methods, such as the variations of Log and Error,
may be called simultaneously from multiple goroutines.
Like in tests, benchmark logs are accumulated during execution
and dumped to standard output when done. Unlike in tests, benchmark logs
are always printed, so as not to hide output whose existence may be
affecting benchmark results.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type B struct {
common
importPath string
bstate *benchState
N int
previousN int
previousDuration time.Duration
benchFunc func(b *B)
benchTime durationOrCountFlag
bytes int64
missingBytes bool
timerOn bool
showAllocResult bool
result BenchmarkResult
parallelism int
startAllocs uint64
startBytes uint64
netAllocs uint64
netBytes uint64
extra map[string]float64
loop struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="BenchmarkResult" data-name="BenchmarkResult">
               <h3>
                  BenchmarkResult
                  <span class="badge">struct</span>
                  <a href="#BenchmarkResult" class="anchor" title="Link to BenchmarkResult">#</a>
               </h3>
               
               <p>BenchmarkResult contains the results of a benchmark run.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type BenchmarkResult struct {
N int
T time.Duration
Bytes int64
MemAllocs uint64
MemBytes uint64
Extra map[string]float64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Cover" data-name="Cover">
               <h3>
                  Cover
                  <span class="badge">struct</span>
                  <a href="#Cover" class="anchor" title="Link to Cover">#</a>
               </h3>
               
               <p>Cover records information about test coverage checking.
NOTE: This struct is internal to the testing infrastructure and may change.
It is not covered (yet) by the Go 1 compatibility guidelines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Cover struct {
Mode string
Counters map[string][]uint32
Blocks map[string][]CoverBlock
CoveredPackages string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="CoverBlock" data-name="CoverBlock">
               <h3>
                  CoverBlock
                  <span class="badge">struct</span>
                  <a href="#CoverBlock" class="anchor" title="Link to CoverBlock">#</a>
               </h3>
               
               <p>CoverBlock records the coverage data for a single basic block.
The fields are 1-indexed, as in an editor: The opening line of
the file is number 1, for example. Columns are measured
in bytes.
NOTE: This struct is internal to the testing infrastructure and may change.
It is not covered (yet) by the Go 1 compatibility guidelines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CoverBlock struct {
Line0 uint32
Col0 uint16
Line1 uint32
Col1 uint16
Stmts uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="F" data-name="F">
               <h3>
                  F
                  <span class="badge">struct</span>
                  <a href="#F" class="anchor" title="Link to F">#</a>
               </h3>
               
               <p>F is a type passed to fuzz tests.
Fuzz tests run generated inputs against a provided fuzz target, which can
find and report potential bugs in the code being tested.
A fuzz test runs the seed corpus by default, which includes entries provided
by (*F).Add and entries in the testdata/fuzz/<FuzzTestName> directory. After
any necessary setup and calls to (*F).Add, the fuzz test must then call
(*F).Fuzz to provide the fuzz target. See the testing package documentation
for an example, and see the [F.Fuzz] and [F.Add] method documentation for
details.
*F methods can only be called before (*F).Fuzz. Once the test is
executing the fuzz target, only (*T) methods can be used. The only *F methods
that are allowed in the (*F).Fuzz function are (*F).Failed and (*F).Name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type F struct {
common
fstate *fuzzState
tstate *testState
inFuzzFn bool
corpus []corpusEntry
result fuzzResult
fuzzCalled bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InternalBenchmark" data-name="InternalBenchmark">
               <h3>
                  InternalBenchmark
                  <span class="badge">struct</span>
                  <a href="#InternalBenchmark" class="anchor" title="Link to InternalBenchmark">#</a>
               </h3>
               
               <p>InternalBenchmark is an internal type but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InternalBenchmark struct {
Name string
F func(b *B)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InternalExample" data-name="InternalExample">
               <h3>
                  InternalExample
                  <span class="badge">struct</span>
                  <a href="#InternalExample" class="anchor" title="Link to InternalExample">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InternalExample struct {
Name string
F func()
Output string
Unordered bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InternalFuzzTarget" data-name="InternalFuzzTarget">
               <h3>
                  InternalFuzzTarget
                  <span class="badge">struct</span>
                  <a href="#InternalFuzzTarget" class="anchor" title="Link to InternalFuzzTarget">#</a>
               </h3>
               
               <p>InternalFuzzTarget is an internal type but exported because it is
cross-package; it is part of the implementation of the "go test" command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InternalFuzzTarget struct {
Name string
Fn func(f *F)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InternalTest" data-name="InternalTest">
               <h3>
                  InternalTest
                  <span class="badge">struct</span>
                  <a href="#InternalTest" class="anchor" title="Link to InternalTest">#</a>
               </h3>
               
               <p>InternalTest is an internal type but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InternalTest struct {
Name string
F func(*T)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="M" data-name="M">
               <h3>
                  M
                  <span class="badge">struct</span>
                  <a href="#M" class="anchor" title="Link to M">#</a>
               </h3>
               
               <p>M is a type passed to a TestMain function to run the actual tests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type M struct {
deps testDeps
tests []InternalTest
benchmarks []InternalBenchmark
fuzzTargets []InternalFuzzTarget
examples []InternalExample
timer *time.Timer
afterOnce sync.Once
numRun int
exitCode int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PB" data-name="PB">
               <h3>
                  PB
                  <span class="badge">struct</span>
                  <a href="#PB" class="anchor" title="Link to PB">#</a>
               </h3>
               
               <p>A PB is used by RunParallel for running parallel benchmarks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PB struct {
globalN *atomic.Uint64
grain uint64
cache uint64
bN uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="T" data-name="T">
               <h3>
                  T
                  <span class="badge">struct</span>
                  <a href="#T" class="anchor" title="Link to T">#</a>
               </h3>
               
               <p>T is a type passed to Test functions to manage test state and support formatted test logs.
A test ends when its Test function returns or calls any of the methods
FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as
the Parallel method, must be called only from the goroutine running the
Test function.
The other reporting methods, such as the variations of Log and Error,
may be called simultaneously from multiple goroutines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type T struct {
common
denyParallel bool
tstate *testState
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="benchState" data-name="benchState">
               <h3>
                  benchState
                  <span class="badge">struct</span>
                  <a href="#benchState" class="anchor" title="Link to benchState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type benchState struct {
match *matcher
maxLen int
extLen int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="chattyFlag" data-name="chattyFlag">
               <h3>
                  chattyFlag
                  <span class="badge">struct</span>
                  <a href="#chattyFlag" class="anchor" title="Link to chattyFlag">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type chattyFlag struct {
on bool
json bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="chattyPrinter" data-name="chattyPrinter">
               <h3>
                  chattyPrinter
                  <span class="badge">struct</span>
                  <a href="#chattyPrinter" class="anchor" title="Link to chattyPrinter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type chattyPrinter struct {
w io.Writer
lastNameMu sync.Mutex
lastName string
json bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="common" data-name="common">
               <h3>
                  common
                  <span class="badge">struct</span>
                  <a href="#common" class="anchor" title="Link to common">#</a>
               </h3>
               
               <p>common holds the elements common between T and B and
captures common methods such as Errorf.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type common struct {
mu sync.RWMutex
output []byte
w io.Writer
ran bool
failed bool
skipped bool
done bool
helperPCs map[uintptr]struct{...}
helperNames map[string]struct{...}
cleanups []func()
cleanupName string
cleanupPc []uintptr
finished bool
inFuzzFn bool
chatty *chattyPrinter
bench bool
hasSub atomic.Bool
cleanupStarted atomic.Bool
runner string
isParallel bool
parent *common
level int
creator []uintptr
name string
start highPrecisionTime
duration time.Duration
barrier chan bool
signal chan bool
sub []*T
lastRaceErrors atomic.Int64
raceErrorLogged atomic.Bool
tempDirMu sync.Mutex
tempDir string
tempDirErr error
tempDirSeq int32
ctx context.Context
cancelCtx context.CancelFunc
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="corpusEntry" data-name="corpusEntry">
               <h3>
                  corpusEntry
                  <span class="badge">struct</span>
                  <a href="#corpusEntry" class="anchor" title="Link to corpusEntry">#</a>
               </h3>
               
               <p>corpusEntry is an alias to the same type as internal/fuzz.CorpusEntry.
We use a type alias because we don't want to export this type, and we can't
import internal/fuzz from testing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type corpusEntry struct {
Parent string
Path string
Data []byte
Values []any
Generation int
IsSeed bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="discard" data-name="discard">
               <h3>
                  discard
                  <span class="badge">struct</span>
                  <a href="#discard" class="anchor" title="Link to discard">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type discard struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="durationOrCountFlag" data-name="durationOrCountFlag">
               <h3>
                  durationOrCountFlag
                  <span class="badge">struct</span>
                  <a href="#durationOrCountFlag" class="anchor" title="Link to durationOrCountFlag">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type durationOrCountFlag struct {
d time.Duration
n int
allowZero bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzResult" data-name="fuzzResult">
               <h3>
                  fuzzResult
                  <span class="badge">struct</span>
                  <a href="#fuzzResult" class="anchor" title="Link to fuzzResult">#</a>
               </h3>
               
               <p>fuzzResult contains the results of a fuzz run.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzResult struct {
N int
T time.Duration
Error error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzState" data-name="fuzzState">
               <h3>
                  fuzzState
                  <span class="badge">struct</span>
                  <a href="#fuzzState" class="anchor" title="Link to fuzzState">#</a>
               </h3>
               
               <p>fuzzState holds fields common to all fuzz tests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzState struct {
deps testDeps
mode fuzzMode
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="highPrecisionTime" data-name="highPrecisionTime">
               <h3>
                  highPrecisionTime
                  <span class="badge">struct</span>
                  <a href="#highPrecisionTime" class="anchor" title="Link to highPrecisionTime">#</a>
               </h3>
               
               <p>highPrecisionTime represents a single point in time with query performance counter.
time.Time on Windows has low system granularity, which is not suitable for
measuring short time intervals.
TODO: If Windows runtime implements high resolution timing then highPrecisionTime
can be removed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type highPrecisionTime struct {
now int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="highPrecisionTime" data-name="highPrecisionTime">
               <h3>
                  highPrecisionTime
                  <span class="badge">struct</span>
                  <a href="#highPrecisionTime" class="anchor" title="Link to highPrecisionTime">#</a>
               </h3>
               
               <p>highPrecisionTime represents a single point in time.
On all systems except Windows, using time.Time is fine.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type highPrecisionTime struct {
now time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="indenter" data-name="indenter">
               <h3>
                  indenter
                  <span class="badge">struct</span>
                  <a href="#indenter" class="anchor" title="Link to indenter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type indenter struct {
c *common
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="matcher" data-name="matcher">
               <h3>
                  matcher
                  <span class="badge">struct</span>
                  <a href="#matcher" class="anchor" title="Link to matcher">#</a>
               </h3>
               
               <p>matcher sanitizes, uniques, and filters names of subtests and subbenchmarks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type matcher struct {
filter filterMatch
skip filterMatch
matchFunc func(pat string, str string) (bool, error)
mu sync.Mutex
subNames map[string]int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="testState" data-name="testState">
               <h3>
                  testState
                  <span class="badge">struct</span>
                  <a href="#testState" class="anchor" title="Link to testState">#</a>
               </h3>
               
               <p>testState holds all fields that are common to all tests. This includes
synchronization primitives to run at most *parallel tests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type testState struct {
match *matcher
deadline time.Time
isFuzzing bool
mu sync.Mutex
startParallel chan bool
running int
numWaiting int
maxParallel int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add will add the arguments to the seed corpus for the fuzz test. This will be
a no-op if called after or within the fuzz target, and args must match the
arguments for the fuzz target.</p>
               
               <pre><code class="language-go">func (f *F) Add(args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllocedBytesPerOp" data-name="AllocedBytesPerOp">
               <h3>
                  AllocedBytesPerOp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllocedBytesPerOp" class="anchor" title="Link to AllocedBytesPerOp">#</a>
               </h3>
               
               <p>AllocedBytesPerOp returns the "B/op" metric,
which is calculated as r.MemBytes / r.N.</p>
               
               <pre><code class="language-go">func (r BenchmarkResult) AllocedBytesPerOp() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllocsPerOp" data-name="AllocsPerOp">
               <h3>
                  AllocsPerOp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllocsPerOp" class="anchor" title="Link to AllocsPerOp">#</a>
               </h3>
               
               <p>AllocsPerOp returns the "allocs/op" metric,
which is calculated as r.MemAllocs / r.N.</p>
               
               <pre><code class="language-go">func (r BenchmarkResult) AllocsPerOp() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllocsPerRun" data-name="AllocsPerRun">
               <h3>
                  AllocsPerRun 
                  <span class="badge">function</span>
                  
                  <a href="#AllocsPerRun" class="anchor" title="Link to AllocsPerRun">#</a>
               </h3>
               
               <p>AllocsPerRun returns the average number of allocations during calls to f.
Although the return value has type float64, it will always be an integral value.
To compute the number of allocations, the function will first be run once as
a warm-up. The average number of allocations over the specified number of
runs will then be measured and returned.
AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore
it before returning.</p>
               
               <pre><code class="language-go">func AllocsPerRun(runs int, f func()) (avg float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chdir" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chdir" class="anchor" title="Link to Chdir">#</a>
               </h3>
               
               <p>Chdir calls os.Chdir(dir) and uses Cleanup to restore the current
working directory to its original value after the test. On Unix, it
also sets PWD environment variable for the duration of the test.
Because Chdir affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code class="language-go">func (c *common) Chdir(dir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chdir" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chdir" class="anchor" title="Link to Chdir">#</a>
               </h3>
               
               <p>Chdir calls os.Chdir(dir) and uses Cleanup to restore the current
working directory to its original value after the test. On Unix, it
also sets PWD environment variable for the duration of the test.
Because Chdir affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code class="language-go">func (t *T) Chdir(dir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckCorpus" data-name="CheckCorpus">
               <h3>
                  CheckCorpus 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckCorpus" class="anchor" title="Link to CheckCorpus">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) CheckCorpus([]any, []reflect.Type) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cleanup" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cleanup" class="anchor" title="Link to Cleanup">#</a>
               </h3>
               
               <p>Cleanup registers a function to be called when the test (or subtest) and all its
subtests complete. Cleanup functions will be called in last added,
first called order.</p>
               
               <pre><code class="language-go">func (c *common) Cleanup(f func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Context" data-name="Context">
               <h3>
                  Context 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Context" class="anchor" title="Link to Context">#</a>
               </h3>
               
               <p>Context returns a context that is canceled just before
Cleanup-registered functions are called.
Cleanup functions can wait for any resources
that shut down on Context.Done before the test or benchmark completes.</p>
               
               <pre><code class="language-go">func (c *common) Context() context.Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CoordinateFuzzing" data-name="CoordinateFuzzing">
               <h3>
                  CoordinateFuzzing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CoordinateFuzzing" class="anchor" title="Link to CoordinateFuzzing">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CoverMode" data-name="CoverMode">
               <h3>
                  CoverMode 
                  <span class="badge">function</span>
                  
                  <a href="#CoverMode" class="anchor" title="Link to CoverMode">#</a>
               </h3>
               
               <p>CoverMode reports what the test coverage mode is set to. The
values are "set", "count", or "atomic". The return value will be
empty if test coverage is not enabled.</p>
               
               <pre><code class="language-go">func CoverMode() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Coverage" data-name="Coverage">
               <h3>
                  Coverage 
                  <span class="badge">function</span>
                  
                  <a href="#Coverage" class="anchor" title="Link to Coverage">#</a>
               </h3>
               
               <p>Coverage reports the current code coverage as a fraction in the range [0, 1].
If coverage is not enabled, Coverage returns 0.
When running a large set of sequential test cases, checking Coverage after each one
can be useful for identifying which test cases exercise new code paths.
It is not a replacement for the reports generated by 'go test -cover' and
'go tool cover'.</p>
               
               <pre><code class="language-go">func Coverage() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Deadline" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Deadline" class="anchor" title="Link to Deadline">#</a>
               </h3>
               
               <p>Deadline reports the time at which the test binary will have
exceeded the timeout specified by the -timeout flag.
The ok result is false if the -timeout flag indicates “no timeout” (0).</p>
               
               <pre><code class="language-go">func (t *T) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elapsed" data-name="Elapsed">
               <h3>
                  Elapsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elapsed" class="anchor" title="Link to Elapsed">#</a>
               </h3>
               
               <p>Elapsed returns the measured elapsed time of the benchmark.
The duration reported by Elapsed matches the one measured by
[B.StartTimer], [B.StopTimer], and [B.ResetTimer].</p>
               
               <pre><code class="language-go">func (b *B) Elapsed() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error is equivalent to Log followed by Fail.</p>
               
               <pre><code class="language-go">func (c *common) Error(args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errorf" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Errorf" class="anchor" title="Link to Errorf">#</a>
               </h3>
               
               <p>Errorf is equivalent to Logf followed by Fail.</p>
               
               <pre><code class="language-go">func (c *common) Errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fail" data-name="Fail">
               <h3>
                  Fail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fail" class="anchor" title="Link to Fail">#</a>
               </h3>
               
               <p>Fail marks the function as having failed but continues execution.</p>
               
               <pre><code class="language-go">func (f *F) Fail()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fail" data-name="Fail">
               <h3>
                  Fail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fail" class="anchor" title="Link to Fail">#</a>
               </h3>
               
               <p>Fail marks the function as having failed but continues execution.</p>
               
               <pre><code class="language-go">func (c *common) Fail()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FailNow" data-name="FailNow">
               <h3>
                  FailNow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FailNow" class="anchor" title="Link to FailNow">#</a>
               </h3>
               
               <p>FailNow marks the function as having failed and stops its execution
by calling runtime.Goexit (which then runs all deferred calls in the
current goroutine).
Execution will continue at the next test or benchmark.
FailNow must be called from the goroutine running the
test or benchmark function, not from other goroutines
created during the test. Calling FailNow does not stop
those other goroutines.</p>
               
               <pre><code class="language-go">func (c *common) FailNow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Failed" data-name="Failed">
               <h3>
                  Failed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Failed" class="anchor" title="Link to Failed">#</a>
               </h3>
               
               <p>Failed reports whether the function has failed.</p>
               
               <pre><code class="language-go">func (c *common) Failed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatal" data-name="Fatal">
               <h3>
                  Fatal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatal" class="anchor" title="Link to Fatal">#</a>
               </h3>
               
               <p>Fatal is equivalent to Log followed by FailNow.</p>
               
               <pre><code class="language-go">func (c *common) Fatal(args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <p>Fatalf is equivalent to Logf followed by FailNow.</p>
               
               <pre><code class="language-go">func (c *common) Fatalf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fuzz" data-name="Fuzz">
               <h3>
                  Fuzz 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fuzz" class="anchor" title="Link to Fuzz">#</a>
               </h3>
               
               <p>Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of
arguments, those arguments will be added to the seed corpus.
ff must be a function with no return value whose first argument is *T and
whose remaining arguments are the types to be fuzzed.
For example:
f.Fuzz(func(t *testing.T, b []byte, i int) { ... })
The following types are allowed: []byte, string, bool, byte, rune, float32,
float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64.
More types may be supported in the future.
ff must not call any *F methods, e.g. (*F).Log, (*F).Error, (*F).Skip. Use
the corresponding *T method instead. The only *F methods that are allowed in
the (*F).Fuzz function are (*F).Failed and (*F).Name.
This function should be fast and deterministic, and its behavior should not
depend on shared state. No mutable input arguments, or pointers to them,
should be retained between executions of the fuzz function, as the memory
backing them may be mutated during a subsequent invocation. ff must not
modify the underlying data of the arguments provided by the fuzzing engine.
When fuzzing, F.Fuzz does not return until a problem is found, time runs out
(set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz
should be called exactly once, unless F.Skip or [F.Fail] is called beforehand.</p>
               
               <pre><code class="language-go">func (f *F) Fuzz(ff any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *chattyFlag) Get() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Helper" data-name="Helper">
               <h3>
                  Helper 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Helper" class="anchor" title="Link to Helper">#</a>
               </h3>
               
               <p>Helper marks the calling function as a test helper function.
When printing file and line information, that function will be skipped.
Helper may be called simultaneously from multiple goroutines.</p>
               
               <pre><code class="language-go">func (f *F) Helper()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Helper" data-name="Helper">
               <h3>
                  Helper 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Helper" class="anchor" title="Link to Helper">#</a>
               </h3>
               
               <p>Helper marks the calling function as a test helper function.
When printing file and line information, that function will be skipped.
Helper may be called simultaneously from multiple goroutines.</p>
               
               <pre><code class="language-go">func (c *common) Helper()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge">function</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>Init registers testing flags. These flags are automatically registered by
the "go test" command before running test functions, so Init is only needed
when calling functions such as Benchmark without using "go test".
Init is not safe to call concurrently. It has no effect if it was already called.</p>
               
               <pre><code class="language-go">func Init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitRuntimeCoverage" data-name="InitRuntimeCoverage">
               <h3>
                  InitRuntimeCoverage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InitRuntimeCoverage" class="anchor" title="Link to InitRuntimeCoverage">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) InitRuntimeCoverage() (mode string, tearDown func(string, string) (string, error), snapcov func() float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBoolFlag" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsBoolFlag" class="anchor" title="Link to IsBoolFlag">#</a>
               </h3>
               
               <pre><code class="language-go">func (*chattyFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Log" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Log" class="anchor" title="Link to Log">#</a>
               </h3>
               
               <p>Log formats its arguments using default formatting, analogous to Println,
and records the text in the error log. For tests, the text will be printed only if
the test fails or the -test.v flag is set. For benchmarks, the text is always
printed to avoid having performance depend on the value of the -test.v flag.</p>
               
               <pre><code class="language-go">func (c *common) Log(args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Logf" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Logf" class="anchor" title="Link to Logf">#</a>
               </h3>
               
               <p>Logf formats its arguments according to the format, analogous to Printf, and
records the text in the error log. A final newline is added if not provided. For
tests, the text will be printed only if the test fails or the -test.v flag is
set. For benchmarks, the text is always printed to avoid having performance
depend on the value of the -test.v flag.</p>
               
               <pre><code class="language-go">func (c *common) Logf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Loop" data-name="Loop">
               <h3>
                  Loop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Loop" class="anchor" title="Link to Loop">#</a>
               </h3>
               
               <p>Loop returns true as long as the benchmark should continue running.
A typical benchmark is structured like:
func Benchmark(b *testing.B) {
... setup ...
for b.Loop() {
... code to measure ...
}
... cleanup ...
}
Loop resets the benchmark timer the first time it is called in a benchmark,
so any setup performed prior to starting the benchmark loop does not count
toward the benchmark measurement. Likewise, when it returns false, it stops
the timer so cleanup code is not measured.
The compiler never optimizes away calls to functions within the body of a
"for b.Loop() { ... }" loop. This prevents surprises that can otherwise occur
if the compiler determines that the result of a benchmarked function is
unused. The loop must be written in exactly this form, and this only applies
to calls syntactically between the curly braces of the loop. Optimizations
are performed as usual in any functions called by the loop.
After Loop returns false, b.N contains the total number of iterations that
ran, so the benchmark may use b.N to compute other average metrics.
Prior to the introduction of Loop, benchmarks were expected to contain an
explicit loop from 0 to b.N. Benchmarks should either use Loop or contain a
loop to b.N, but not both. Loop offers more automatic management of the
benchmark timer, and runs each benchmark function only once per measurement,
whereas b.N-based benchmarks must run the benchmark function (and any
associated setup and cleanup) several times.</p>
               
               <pre><code class="language-go">func (b *B) Loop() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Main" data-name="Main">
               <h3>
                  Main 
                  <span class="badge">function</span>
                  
                  <a href="#Main" class="anchor" title="Link to Main">#</a>
               </h3>
               
               <p>Main is an internal function, part of the implementation of the "go test" command.
It was exported because it is cross-package and predates "internal" packages.
It is no longer used by "go test" but preserved, as much as possible, for other
systems that simulate "go test" using Main, but Main sometimes cannot be updated as
new functionality is added to the testing package.
Systems simulating "go test" should be updated to use MainStart.</p>
               
               <pre><code class="language-go">func Main(matchString func(pat string, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MainStart" data-name="MainStart">
               <h3>
                  MainStart 
                  <span class="badge">function</span>
                  
                  <a href="#MainStart" class="anchor" title="Link to MainStart">#</a>
               </h3>
               
               <p>MainStart is meant for use by tests generated by 'go test'.
It is not meant to be called directly and is not subject to the Go 1 compatibility document.
It may change signature from release to release.</p>
               
               <pre><code class="language-go">func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchString" data-name="MatchString">
               <h3>
                  MatchString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchString" class="anchor" title="Link to MatchString">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) MatchString(pat string, str string) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MemString" data-name="MemString">
               <h3>
                  MemString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MemString" class="anchor" title="Link to MemString">#</a>
               </h3>
               
               <p>MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.</p>
               
               <pre><code class="language-go">func (r BenchmarkResult) MemString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the name of the running (sub-) test or benchmark.
The name will include the name of the test along with the names of
any nested sub-tests. If two sibling sub-tests have the same name,
Name will append a suffix to guarantee the returned name is unique.</p>
               
               <pre><code class="language-go">func (c *common) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next reports whether there are more iterations to execute.</p>
               
               <pre><code class="language-go">func (pb *PB) Next() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NsPerOp" data-name="NsPerOp">
               <h3>
                  NsPerOp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NsPerOp" class="anchor" title="Link to NsPerOp">#</a>
               </h3>
               
               <p>NsPerOp returns the "ns/op" metric.</p>
               
               <pre><code class="language-go">func (r BenchmarkResult) NsPerOp() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parallel" data-name="Parallel">
               <h3>
                  Parallel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parallel" class="anchor" title="Link to Parallel">#</a>
               </h3>
               
               <p>Parallel signals that this test is to be run in parallel with (and only with)
other parallel tests. When a test is run multiple times due to use of
-test.count or -test.cpu, multiple instances of a single test never run in
parallel with each other.</p>
               
               <pre><code class="language-go">func (t *T) Parallel()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <p>Printf prints a message, generated by the named test, that does not
necessarily mention that tests's name itself.</p>
               
               <pre><code class="language-go">func (p *chattyPrinter) Printf(testName string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadCorpus" data-name="ReadCorpus">
               <h3>
                  ReadCorpus 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadCorpus" class="anchor" title="Link to ReadCorpus">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterCover" data-name="RegisterCover">
               <h3>
                  RegisterCover 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterCover" class="anchor" title="Link to RegisterCover">#</a>
               </h3>
               
               <p>RegisterCover records the coverage data accumulators for the tests.
NOTE: This function is internal to the testing infrastructure and may change.
It is not covered (yet) by the Go 1 compatibility guidelines.</p>
               
               <pre><code class="language-go">func RegisterCover(c Cover)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReportAllocs" data-name="ReportAllocs">
               <h3>
                  ReportAllocs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReportAllocs" class="anchor" title="Link to ReportAllocs">#</a>
               </h3>
               
               <p>ReportAllocs enables malloc statistics for this benchmark.
It is equivalent to setting -test.benchmem, but it only affects the
benchmark function that calls ReportAllocs.</p>
               
               <pre><code class="language-go">func (b *B) ReportAllocs()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReportMetric" data-name="ReportMetric">
               <h3>
                  ReportMetric 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReportMetric" class="anchor" title="Link to ReportMetric">#</a>
               </h3>
               
               <p>ReportMetric adds "n unit" to the reported benchmark results.
If the metric is per-iteration, the caller should divide by b.N,
and by convention units should end in "/op".
ReportMetric overrides any previously reported value for the same unit.
ReportMetric panics if unit is the empty string or if unit contains
any whitespace.
If unit is a unit normally reported by the benchmark framework itself
(such as "allocs/op"), ReportMetric will override that metric.
Setting "ns/op" to 0 will suppress that built-in metric.</p>
               
               <pre><code class="language-go">func (b *B) ReportMetric(n float64, unit string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ResetCoverage" data-name="ResetCoverage">
               <h3>
                  ResetCoverage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ResetCoverage" class="anchor" title="Link to ResetCoverage">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) ResetCoverage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ResetTimer" data-name="ResetTimer">
               <h3>
                  ResetTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ResetTimer" class="anchor" title="Link to ResetTimer">#</a>
               </h3>
               
               <p>ResetTimer zeroes the elapsed benchmark time and memory allocation counters
and deletes user-reported metrics.
It does not affect whether the timer is running.</p>
               
               <pre><code class="language-go">func (b *B) ResetTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Run" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Run" class="anchor" title="Link to Run">#</a>
               </h3>
               
               <p>Run benchmarks f as a subbenchmark with the given name. It reports
whether there were any failures.
A subbenchmark is like any other benchmark. A benchmark that calls Run at
least once will not be measured itself and will be called once with N=1.</p>
               
               <pre><code class="language-go">func (b *B) Run(name string, f func(b *B)) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Run" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Run" class="anchor" title="Link to Run">#</a>
               </h3>
               
               <p>Run runs f as a subtest of t called name. It runs f in a separate goroutine
and blocks until f returns or calls t.Parallel to become a parallel test.
Run reports whether f succeeded (or at least did not fail before calling t.Parallel).
Run may be called simultaneously from multiple goroutines, but all such calls
must return before the outer test function for t returns.</p>
               
               <pre><code class="language-go">func (t *T) Run(name string, f func(t *T)) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Run" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Run" class="anchor" title="Link to Run">#</a>
               </h3>
               
               <p>Run runs the tests. It returns an exit code to pass to os.Exit.</p>
               
               <pre><code class="language-go">func (m *M) Run() (code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RunBenchmarks" data-name="RunBenchmarks">
               <h3>
                  RunBenchmarks 
                  <span class="badge">function</span>
                  
                  <a href="#RunBenchmarks" class="anchor" title="Link to RunBenchmarks">#</a>
               </h3>
               
               <p>RunBenchmarks is an internal function but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre><code class="language-go">func RunBenchmarks(matchString func(pat string, str string) (bool, error), benchmarks []InternalBenchmark)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RunExamples" data-name="RunExamples">
               <h3>
                  RunExamples 
                  <span class="badge">function</span>
                  
                  <a href="#RunExamples" class="anchor" title="Link to RunExamples">#</a>
               </h3>
               
               <p>RunExamples is an internal function but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre><code class="language-go">func RunExamples(matchString func(pat string, str string) (bool, error), examples []InternalExample) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RunFuzzWorker" data-name="RunFuzzWorker">
               <h3>
                  RunFuzzWorker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RunFuzzWorker" class="anchor" title="Link to RunFuzzWorker">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) RunFuzzWorker(func(corpusEntry) error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RunParallel" data-name="RunParallel">
               <h3>
                  RunParallel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RunParallel" class="anchor" title="Link to RunParallel">#</a>
               </h3>
               
               <p>RunParallel runs a benchmark in parallel.
It creates multiple goroutines and distributes b.N iterations among them.
The number of goroutines defaults to GOMAXPROCS. To increase parallelism for
non-CPU-bound benchmarks, call [B.SetParallelism] before RunParallel.
RunParallel is usually used with the go test -cpu flag.
The body function will be run in each goroutine. It should set up any
goroutine-local state and then iterate until pb.Next returns false.
It should not use the [B.StartTimer], [B.StopTimer], or [B.ResetTimer] functions,
because they have global effect. It should also not call [B.Run].
RunParallel reports ns/op values as wall time for the benchmark as a whole,
not the sum of wall time or CPU time over each parallel goroutine.</p>
               
               <pre><code class="language-go">func (b *B) RunParallel(body func(*PB))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RunTests" data-name="RunTests">
               <h3>
                  RunTests 
                  <span class="badge">function</span>
                  
                  <a href="#RunTests" class="anchor" title="Link to RunTests">#</a>
               </h3>
               
               <p>RunTests is an internal function but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre><code class="language-go">func RunTests(matchString func(pat string, str string) (bool, error), tests []InternalTest) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *chattyFlag) Set(arg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *durationOrCountFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes records the number of bytes processed in a single operation.
If this is called, the benchmark will report ns/op and MB/s.</p>
               
               <pre><code class="language-go">func (b *B) SetBytes(n int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPanicOnExit0" data-name="SetPanicOnExit0">
               <h3>
                  SetPanicOnExit0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPanicOnExit0" class="anchor" title="Link to SetPanicOnExit0">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) SetPanicOnExit0(bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetParallelism" data-name="SetParallelism">
               <h3>
                  SetParallelism 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetParallelism" class="anchor" title="Link to SetParallelism">#</a>
               </h3>
               
               <p>SetParallelism sets the number of goroutines used by [B.RunParallel] to p*GOMAXPROCS.
There is usually no need to call SetParallelism for CPU-bound benchmarks.
If p is less than 1, this call will have no effect.</p>
               
               <pre><code class="language-go">func (b *B) SetParallelism(p int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Setenv" data-name="Setenv">
               <h3>
                  Setenv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Setenv" class="anchor" title="Link to Setenv">#</a>
               </h3>
               
               <p>Setenv calls os.Setenv(key, value) and uses Cleanup to
restore the environment variable to its original value
after the test.
Because Setenv affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code class="language-go">func (c *common) Setenv(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Setenv" data-name="Setenv">
               <h3>
                  Setenv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Setenv" class="anchor" title="Link to Setenv">#</a>
               </h3>
               
               <p>Setenv calls os.Setenv(key, value) and uses Cleanup to
restore the environment variable to its original value
after the test.
Because Setenv affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code class="language-go">func (t *T) Setenv(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Short" data-name="Short">
               <h3>
                  Short 
                  <span class="badge">function</span>
                  
                  <a href="#Short" class="anchor" title="Link to Short">#</a>
               </h3>
               
               <p>Short reports whether the -test.short flag is set.</p>
               
               <pre><code class="language-go">func Short() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Skip" data-name="Skip">
               <h3>
                  Skip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Skip" class="anchor" title="Link to Skip">#</a>
               </h3>
               
               <p>Skip is equivalent to Log followed by SkipNow.</p>
               
               <pre><code class="language-go">func (c *common) Skip(args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SkipNow" data-name="SkipNow">
               <h3>
                  SkipNow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SkipNow" class="anchor" title="Link to SkipNow">#</a>
               </h3>
               
               <p>SkipNow marks the test as having been skipped and stops its execution
by calling [runtime.Goexit].
If a test fails (see Error, Errorf, Fail) and is then skipped,
it is still considered to have failed.
Execution will continue at the next test or benchmark. See also FailNow.
SkipNow must be called from the goroutine running the test, not from
other goroutines created during the test. Calling SkipNow does not stop
those other goroutines.</p>
               
               <pre><code class="language-go">func (c *common) SkipNow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Skipf" data-name="Skipf">
               <h3>
                  Skipf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Skipf" class="anchor" title="Link to Skipf">#</a>
               </h3>
               
               <p>Skipf is equivalent to Logf followed by SkipNow.</p>
               
               <pre><code class="language-go">func (c *common) Skipf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Skipped" data-name="Skipped">
               <h3>
                  Skipped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Skipped" class="anchor" title="Link to Skipped">#</a>
               </h3>
               
               <p>Skipped reports whether the test was skipped.</p>
               
               <pre><code class="language-go">func (f *F) Skipped() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Skipped" data-name="Skipped">
               <h3>
                  Skipped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Skipped" class="anchor" title="Link to Skipped">#</a>
               </h3>
               
               <p>Skipped reports whether the test was skipped.</p>
               
               <pre><code class="language-go">func (c *common) Skipped() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SnapshotCoverage" data-name="SnapshotCoverage">
               <h3>
                  SnapshotCoverage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SnapshotCoverage" class="anchor" title="Link to SnapshotCoverage">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) SnapshotCoverage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartCPUProfile" data-name="StartCPUProfile">
               <h3>
                  StartCPUProfile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartCPUProfile" class="anchor" title="Link to StartCPUProfile">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) StartCPUProfile(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartTestLog" data-name="StartTestLog">
               <h3>
                  StartTestLog 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartTestLog" class="anchor" title="Link to StartTestLog">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) StartTestLog(io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartTimer" data-name="StartTimer">
               <h3>
                  StartTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartTimer" class="anchor" title="Link to StartTimer">#</a>
               </h3>
               
               <p>StartTimer starts timing a test. This function is called automatically
before a benchmark starts, but it can also be used to resume timing after
a call to [B.StopTimer].</p>
               
               <pre><code class="language-go">func (b *B) StartTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StopCPUProfile" data-name="StopCPUProfile">
               <h3>
                  StopCPUProfile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StopCPUProfile" class="anchor" title="Link to StopCPUProfile">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) StopCPUProfile()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StopTestLog" data-name="StopTestLog">
               <h3>
                  StopTestLog 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StopTestLog" class="anchor" title="Link to StopTestLog">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) StopTestLog() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StopTimer" data-name="StopTimer">
               <h3>
                  StopTimer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StopTimer" class="anchor" title="Link to StopTimer">#</a>
               </h3>
               
               <p>StopTimer stops timing a test. This can be used to pause the timer
while performing steps that you don't want to measure.</p>
               
               <pre><code class="language-go">func (b *B) StopTimer()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *durationOrCountFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a summary of the benchmark results.
It follows the benchmark result line format from
https://golang.org/design/14313-benchmark-format, not including the
benchmark name.
Extra metrics override built-in metrics of the same name.
String does not include allocs/op or B/op, since those are reported
by [BenchmarkResult.MemString].</p>
               
               <pre><code class="language-go">func (r BenchmarkResult) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *chattyFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (r fuzzResult) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TempDir" data-name="TempDir">
               <h3>
                  TempDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TempDir" class="anchor" title="Link to TempDir">#</a>
               </h3>
               
               <p>TempDir returns a temporary directory for the test to use.
The directory is automatically removed when the test and
all its subtests complete.
Each subsequent call to t.TempDir returns a unique directory;
if the directory creation fails, TempDir terminates the test by calling Fatal.</p>
               
               <pre><code class="language-go">func (c *common) TempDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Updatef" data-name="Updatef">
               <h3>
                  Updatef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Updatef" class="anchor" title="Link to Updatef">#</a>
               </h3>
               
               <p>Updatef prints a message about the status of the named test to w.
The formatted message must include the test name itself.</p>
               
               <pre><code class="language-go">func (p *chattyPrinter) Updatef(testName string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Verbose" data-name="Verbose">
               <h3>
                  Verbose 
                  <span class="badge">function</span>
                  
                  <a href="#Verbose" class="anchor" title="Link to Verbose">#</a>
               </h3>
               
               <p>Verbose reports whether the -test.v flag is set.</p>
               
               <pre><code class="language-go">func Verbose() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (w indenter) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (discard) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteProfileTo" data-name="WriteProfileTo">
               <h3>
                  WriteProfileTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteProfileTo" class="anchor" title="Link to WriteProfileTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add simulates running benchmarks in sequence in a single iteration. It is
used to give some meaningful results in case func Benchmark is used in
combination with Run.</p>
               
               <pre><code class="language-go">func (b *B) add(other BenchmarkResult)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="after" data-name="after">
               <h3>
                  after 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#after" class="anchor" title="Link to after">#</a>
               </h3>
               
               <p>after runs after all testing.</p>
               
               <pre><code class="language-go">func (m *M) after()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allMatcher" data-name="allMatcher">
               <h3>
                  allMatcher 
                  <span class="badge">function</span>
                  
                  <a href="#allMatcher" class="anchor" title="Link to allMatcher">#</a>
               </h3>
               
               <pre><code class="language-go">func allMatcher() *matcher</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="before" data-name="before">
               <h3>
                  before 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#before" class="anchor" title="Link to before">#</a>
               </h3>
               
               <p>before runs before all testing.</p>
               
               <pre><code class="language-go">func (m *M) before()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="benchmarkName" data-name="benchmarkName">
               <h3>
                  benchmarkName 
                  <span class="badge">function</span>
                  
                  <a href="#benchmarkName" class="anchor" title="Link to benchmarkName">#</a>
               </h3>
               
               <p>benchmarkName returns full name of benchmark including procs suffix.</p>
               
               <pre><code class="language-go">func benchmarkName(name string, n int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callerName" data-name="callerName">
               <h3>
                  callerName 
                  <span class="badge">function</span>
                  
                  <a href="#callerName" class="anchor" title="Link to callerName">#</a>
               </h3>
               
               <p>callerName gives the function name (qualified with a package path)
for the caller after skip frames (where 0 means the current function).</p>
               
               <pre><code class="language-go">func callerName(skip int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFuzzFn" data-name="checkFuzzFn">
               <h3>
                  checkFuzzFn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFuzzFn" class="anchor" title="Link to checkFuzzFn">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *common) checkFuzzFn(name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkParallel" data-name="checkParallel">
               <h3>
                  checkParallel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkParallel" class="anchor" title="Link to checkParallel">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *T) checkParallel()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkRaces" data-name="checkRaces">
               <h3>
                  checkRaces 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkRaces" class="anchor" title="Link to checkRaces">#</a>
               </h3>
               
               <p>checkRaces checks whether the global count of data race errors has increased
since c's count was last reset.
If so, it marks c as having failed due to those races (logging an error for
the first such race), and updates the race counts for the parents of c so
that if they are currently suspended (such as in a call to T.Run) they will
not log separate errors for the race(s).
Note that multiple tests may be marked as failed due to the same race if they
are executing in parallel.</p>
               
               <pre><code class="language-go">func (c *common) checkRaces() (raceErrors int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clearSubNames" data-name="clearSubNames">
               <h3>
                  clearSubNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clearSubNames" class="anchor" title="Link to clearSubNames">#</a>
               </h3>
               
               <p>clearSubNames clears the matcher's internal state, potentially freeing
memory. After this is called, T.Name may return the same strings as it did
for earlier subtests.</p>
               
               <pre><code class="language-go">func (m *matcher) clearSubNames()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coverReport" data-name="coverReport">
               <h3>
                  coverReport 
                  <span class="badge">function</span>
                  
                  <a href="#coverReport" class="anchor" title="Link to coverReport">#</a>
               </h3>
               
               <p>coverReport reports the coverage percentage and writes a coverage profile if requested.</p>
               
               <pre><code class="language-go">func coverReport()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coverReport2" data-name="coverReport2">
               <h3>
                  coverReport2 
                  <span class="badge">function</span>
                  
                  <a href="#coverReport2" class="anchor" title="Link to coverReport2">#</a>
               </h3>
               
               <p>coverReport2 invokes a callback in _testmain.go that will
emit coverage data at the point where test execution is complete,
for "go test -cover" runs.</p>
               
               <pre><code class="language-go">func coverReport2()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coverage2" data-name="coverage2">
               <h3>
                  coverage2 
                  <span class="badge">function</span>
                  
                  <a href="#coverage2" class="anchor" title="Link to coverage2">#</a>
               </h3>
               
               <p>coverage2 returns a rough "coverage percentage so far"
number to support the testing.Coverage() function.</p>
               
               <pre><code class="language-go">func coverage2() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="createTempFile" data-name="createTempFile">
               <h3>
                  createTempFile 
                  <span class="badge">function</span>
                  
                  <a href="#createTempFile" class="anchor" title="Link to createTempFile">#</a>
               </h3>
               
               <pre><code class="language-go">func createTempFile(exampleName string) *os.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decorate" data-name="decorate">
               <h3>
                  decorate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decorate" class="anchor" title="Link to decorate">#</a>
               </h3>
               
               <p>decorate prefixes the string with the file and line of the call site
and inserts the final newline if needed and indentation spaces for formatting.
This function must be called with c.mu held.</p>
               
               <pre><code class="language-go">func (c *common) decorate(s string, skip int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doBench" data-name="doBench">
               <h3>
                  doBench 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doBench" class="anchor" title="Link to doBench">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *B) doBench() BenchmarkResult</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fRunner" data-name="fRunner">
               <h3>
                  fRunner 
                  <span class="badge">function</span>
                  
                  <a href="#fRunner" class="anchor" title="Link to fRunner">#</a>
               </h3>
               
               <p>fRunner wraps a call to a fuzz test and ensures that cleanup functions are
called and status flags are set. fRunner should be called in its own
goroutine. To wait for its completion, receive from f.signal.
fRunner is analogous to tRunner, which wraps subtests started with T.Run.
Unit tests and fuzz tests work a little differently, so for now, these
functions aren't consolidated. In particular, because there are no F.Run and
F.Parallel methods, i.e., no fuzz sub-tests or parallel fuzz tests, a few
simplifications are made. We also require that F.Fuzz, F.Skip, or F.Fail is
called.</p>
               
               <pre><code class="language-go">func fRunner(f *F, fn func(*F))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flushToParent" data-name="flushToParent">
               <h3>
                  flushToParent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flushToParent" class="anchor" title="Link to flushToParent">#</a>
               </h3>
               
               <p>flushToParent writes c.output to the parent after first writing the header
with the given format and arguments.</p>
               
               <pre><code class="language-go">func (c *common) flushToParent(testName string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtDuration" data-name="fmtDuration">
               <h3>
                  fmtDuration 
                  <span class="badge">function</span>
                  
                  <a href="#fmtDuration" class="anchor" title="Link to fmtDuration">#</a>
               </h3>
               
               <p>fmtDuration returns a string representing d in the form "87.00s".</p>
               
               <pre><code class="language-go">func fmtDuration(d time.Duration) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="frameSkip" data-name="frameSkip">
               <h3>
                  frameSkip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#frameSkip" class="anchor" title="Link to frameSkip">#</a>
               </h3>
               
               <p>frameSkip searches, starting after skip frames, for the first caller frame
in a function not marked as a helper and returns that frame.
The search stops if it finds a tRunner function that
was the entry point into the test and the test is not a subtest.
This function must be called with c.mu held.</p>
               
               <pre><code class="language-go">func (c *common) frameSkip(skip int) runtime.Frame</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fullName" data-name="fullName">
               <h3>
                  fullName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fullName" class="anchor" title="Link to fullName">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *matcher) fullName(c *common, subname string) (name string, ok bool, partial bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="highPrecisionTimeNow" data-name="highPrecisionTimeNow">
               <h3>
                  highPrecisionTimeNow 
                  <span class="badge">function</span>
                  
                  <a href="#highPrecisionTimeNow" class="anchor" title="Link to highPrecisionTimeNow">#</a>
               </h3>
               
               <p>highPrecisionTimeNow returns high precision time for benchmarking.</p>
               
               <pre><code class="language-go">func highPrecisionTimeNow() highPrecisionTime</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="highPrecisionTimeNow" data-name="highPrecisionTimeNow">
               <h3>
                  highPrecisionTimeNow 
                  <span class="badge">function</span>
                  
                  <a href="#highPrecisionTimeNow" class="anchor" title="Link to highPrecisionTimeNow">#</a>
               </h3>
               
               <p>highPrecisionTimeNow returns high precision time for benchmarking.</p>
               
               <pre><code class="language-go">func highPrecisionTimeNow() highPrecisionTime</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="highPrecisionTimeSince" data-name="highPrecisionTimeSince">
               <h3>
                  highPrecisionTimeSince 
                  <span class="badge">function</span>
                  
                  <a href="#highPrecisionTimeSince" class="anchor" title="Link to highPrecisionTimeSince">#</a>
               </h3>
               
               <p>highPrecisionTimeSince returns duration since a.</p>
               
               <pre><code class="language-go">func highPrecisionTimeSince(a highPrecisionTime) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="highPrecisionTimeSince" data-name="highPrecisionTimeSince">
               <h3>
                  highPrecisionTimeSince 
                  <span class="badge">function</span>
                  
                  <a href="#highPrecisionTimeSince" class="anchor" title="Link to highPrecisionTimeSince">#</a>
               </h3>
               
               <p>highPrecisionTimeSince returns duration since b.</p>
               
               <pre><code class="language-go">func highPrecisionTimeSince(b highPrecisionTime) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initBenchmarkFlags" data-name="initBenchmarkFlags">
               <h3>
                  initBenchmarkFlags 
                  <span class="badge">function</span>
                  
                  <a href="#initBenchmarkFlags" class="anchor" title="Link to initBenchmarkFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func initBenchmarkFlags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initFuzzFlags" data-name="initFuzzFlags">
               <h3>
                  initFuzzFlags 
                  <span class="badge">function</span>
                  
                  <a href="#initFuzzFlags" class="anchor" title="Link to initFuzzFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func initFuzzFlags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSpace" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
                  <a href="#isSpace" class="anchor" title="Link to isSpace">#</a>
               </h3>
               
               <pre><code class="language-go">func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isWindowsRetryable" data-name="isWindowsRetryable">
               <h3>
                  isWindowsRetryable 
                  <span class="badge">function</span>
                  
                  <a href="#isWindowsRetryable" class="anchor" title="Link to isWindowsRetryable">#</a>
               </h3>
               
               <p>isWindowsRetryable reports whether err is a Windows error code
that may be fixed by retrying a failed filesystem operation.</p>
               
               <pre><code class="language-go">func isWindowsRetryable(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isWindowsRetryable" data-name="isWindowsRetryable">
               <h3>
                  isWindowsRetryable 
                  <span class="badge">function</span>
                  
                  <a href="#isWindowsRetryable" class="anchor" title="Link to isWindowsRetryable">#</a>
               </h3>
               
               <p>isWindowsRetryable reports whether err is a Windows error code
that may be fixed by retrying a failed filesystem operation.</p>
               
               <pre><code class="language-go">func isWindowsRetryable(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="launch" data-name="launch">
               <h3>
                  launch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#launch" class="anchor" title="Link to launch">#</a>
               </h3>
               
               <p>launch launches the benchmark function. It gradually increases the number
of benchmark iterations until the benchmark runs for the requested benchtime.
launch is run by the doBench function as a separate goroutine.
run1 must have been called on b.</p>
               
               <pre><code class="language-go">func (b *B) launch()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="listTests" data-name="listTests">
               <h3>
                  listTests 
                  <span class="badge">function</span>
                  
                  <a href="#listTests" class="anchor" title="Link to listTests">#</a>
               </h3>
               
               <pre><code class="language-go">func listTests(matchString func(pat string, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="log" data-name="log">
               <h3>
                  log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#log" class="anchor" title="Link to log">#</a>
               </h3>
               
               <p>log generates the output. It's always at the same stack depth.</p>
               
               <pre><code class="language-go">func (c *common) log(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logDepth" data-name="logDepth">
               <h3>
                  logDepth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logDepth" class="anchor" title="Link to logDepth">#</a>
               </h3>
               
               <p>logDepth generates the output at an arbitrary stack depth.</p>
               
               <pre><code class="language-go">func (c *common) logDepth(s string, depth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loopSlowPath" data-name="loopSlowPath">
               <h3>
                  loopSlowPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loopSlowPath" class="anchor" title="Link to loopSlowPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *B) loopSlowPath() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matches" data-name="matches">
               <h3>
                  matches 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matches" class="anchor" title="Link to matches">#</a>
               </h3>
               
               <pre><code class="language-go">func (m alternationMatch) matches(name []string, matchString func(pat string, str string) (bool, error)) (ok bool, partial bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matches" data-name="matches">
               <h3>
                  matches 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matches" class="anchor" title="Link to matches">#</a>
               </h3>
               
               <pre><code class="language-go">func (m simpleMatch) matches(name []string, matchString func(pat string, str string) (bool, error)) (ok bool, partial bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mbPerSec" data-name="mbPerSec">
               <h3>
                  mbPerSec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mbPerSec" class="anchor" title="Link to mbPerSec">#</a>
               </h3>
               
               <p>mbPerSec returns the "MB/s" metric.</p>
               
               <pre><code class="language-go">func (r BenchmarkResult) mbPerSec() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeNil" data-name="mustBeNil">
               <h3>
                  mustBeNil 
                  <span class="badge">function</span>
                  
                  <a href="#mustBeNil" class="anchor" title="Link to mustBeNil">#</a>
               </h3>
               
               <p>mustBeNil checks the error and, if present, reports it and exits.</p>
               
               <pre><code class="language-go">func mustBeNil(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newChattyPrinter" data-name="newChattyPrinter">
               <h3>
                  newChattyPrinter 
                  <span class="badge">function</span>
                  
                  <a href="#newChattyPrinter" class="anchor" title="Link to newChattyPrinter">#</a>
               </h3>
               
               <pre><code class="language-go">func newChattyPrinter(w io.Writer) *chattyPrinter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newMatcher" data-name="newMatcher">
               <h3>
                  newMatcher 
                  <span class="badge">function</span>
                  
                  <a href="#newMatcher" class="anchor" title="Link to newMatcher">#</a>
               </h3>
               
               <pre><code class="language-go">func newMatcher(matchString func(pat string, str string) (bool, error), patterns string, name string, skips string) *matcher</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTestState" data-name="newTestState">
               <h3>
                  newTestState 
                  <span class="badge">function</span>
                  
                  <a href="#newTestState" class="anchor" title="Link to newTestState">#</a>
               </h3>
               
               <pre><code class="language-go">func newTestState(maxParallel int, m *matcher) *testState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseCpuList" data-name="parseCpuList">
               <h3>
                  parseCpuList 
                  <span class="badge">function</span>
                  
                  <a href="#parseCpuList" class="anchor" title="Link to parseCpuList">#</a>
               </h3>
               
               <pre><code class="language-go">func parseCpuList()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSubtestNumber" data-name="parseSubtestNumber">
               <h3>
                  parseSubtestNumber 
                  <span class="badge">function</span>
                  
                  <a href="#parseSubtestNumber" class="anchor" title="Link to parseSubtestNumber">#</a>
               </h3>
               
               <p>parseSubtestNumber splits a subtest name into a "#%02d"-formatted int32
suffix (if present), and a prefix preceding that suffix (always).</p>
               
               <pre><code class="language-go">func parseSubtestNumber(s string) (prefix string, nn int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pcToName" data-name="pcToName">
               <h3>
                  pcToName 
                  <span class="badge">function</span>
                  
                  <a href="#pcToName" class="anchor" title="Link to pcToName">#</a>
               </h3>
               
               <pre><code class="language-go">func pcToName(pc uintptr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="predictN" data-name="predictN">
               <h3>
                  predictN 
                  <span class="badge">function</span>
                  
                  <a href="#predictN" class="anchor" title="Link to predictN">#</a>
               </h3>
               
               <pre><code class="language-go">func predictN(goalns int64, prevIters int64, prevns int64, last int64) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prefix" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prefix" class="anchor" title="Link to prefix">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *chattyFlag) prefix() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prefix" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prefix" class="anchor" title="Link to prefix">#</a>
               </h3>
               
               <p>prefix is like chatty.prefix but using p.json instead of chatty.json.
Using p.json allows tests to check the json behavior without modifying
the global variable. For convenience, we allow p == nil and treat
that as not in json mode (because it's not chatty at all).</p>
               
               <pre><code class="language-go">func (p *chattyPrinter) prefix() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prettyPrint" data-name="prettyPrint">
               <h3>
                  prettyPrint 
                  <span class="badge">function</span>
                  
                  <a href="#prettyPrint" class="anchor" title="Link to prettyPrint">#</a>
               </h3>
               
               <pre><code class="language-go">func prettyPrint(w io.Writer, x float64, unit string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="private" data-name="private">
               <h3>
                  private 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#private" class="anchor" title="Link to private">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *common) private()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processBench" data-name="processBench">
               <h3>
                  processBench 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processBench" class="anchor" title="Link to processBench">#</a>
               </h3>
               
               <p>processBench runs bench b for the configured CPU counts and prints the results.</p>
               
               <pre><code class="language-go">func (s *benchState) processBench(b *B)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processRunResult" data-name="processRunResult">
               <h3>
                  processRunResult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processRunResult" class="anchor" title="Link to processRunResult">#</a>
               </h3>
               
               <p>processRunResult computes a summary and status of the result of running an example test.
stdout is the captured output from stdout of the test.
recovered is the result of invoking recover after running the test, in case it panicked.
If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout.
If the test is chatty/verbose, it'll print a success message to stdout.
If recovered is non-nil, it'll panic with that value.
If the test panicked with nil, or invoked runtime.Goexit, it'll be
made to fail and panic with errNilPanicOrGoexit</p>
               
               <pre><code class="language-go">func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered any) (passed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerCover2" data-name="registerCover2">
               <h3>
                  registerCover2 
                  <span class="badge">function</span>
                  
                  <a href="#registerCover2" class="anchor" title="Link to registerCover2">#</a>
               </h3>
               
               <p>registerCover2 is invoked during "go test -cover" runs.
It is used to record a 'tear down' function
(to be called when the test is complete) and the coverage mode.</p>
               
               <pre><code class="language-go">func registerCover2(mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="release" data-name="release">
               <h3>
                  release 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#release" class="anchor" title="Link to release">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *testState) release()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeAll" data-name="removeAll">
               <h3>
                  removeAll 
                  <span class="badge">function</span>
                  
                  <a href="#removeAll" class="anchor" title="Link to removeAll">#</a>
               </h3>
               
               <p>removeAll is like os.RemoveAll, but retries Windows "Access is denied."
errors up to an arbitrary timeout.
Those errors have been known to occur spuriously on at least the
windows-amd64-2012 builder (https://go.dev/issue/50051), and can only occur
legitimately if the test leaves behind a temp file that either is still open
or the test otherwise lacks permission to delete. In the case of legitimate
failures, a failing test may take a bit longer to fail, but once the test is
fixed the extra latency will go away.</p>
               
               <pre><code class="language-go">func removeAll(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="report" data-name="report">
               <h3>
                  report 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#report" class="anchor" title="Link to report">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *F) report()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="report" data-name="report">
               <h3>
                  report 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#report" class="anchor" title="Link to report">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *T) report()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetRaces" data-name="resetRaces">
               <h3>
                  resetRaces 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resetRaces" class="anchor" title="Link to resetRaces">#</a>
               </h3>
               
               <p>resetRaces updates c.parent's count of data race errors (or the global count,
if c has no parent), and updates c.lastRaceErrors to match.
Any races that occurred prior to this call to resetRaces will
not be attributed to c.</p>
               
               <pre><code class="language-go">func (c *common) resetRaces()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewrite" data-name="rewrite">
               <h3>
                  rewrite 
                  <span class="badge">function</span>
                  
                  <a href="#rewrite" class="anchor" title="Link to rewrite">#</a>
               </h3>
               
               <p>rewrite rewrites a subname to having only printable characters and no white
space.</p>
               
               <pre><code class="language-go">func rewrite(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <p>run executes the benchmark in a separate goroutine, including all of its
subbenchmarks. b must not have subbenchmarks.</p>
               
               <pre><code class="language-go">func (b *B) run()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run1" data-name="run1">
               <h3>
                  run1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run1" class="anchor" title="Link to run1">#</a>
               </h3>
               
               <p>run1 runs the first iteration of benchFunc. It reports whether more
iterations of this benchmarks should be run.</p>
               
               <pre><code class="language-go">func (b *B) run1() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runBenchmarks" data-name="runBenchmarks">
               <h3>
                  runBenchmarks 
                  <span class="badge">function</span>
                  
                  <a href="#runBenchmarks" class="anchor" title="Link to runBenchmarks">#</a>
               </h3>
               
               <pre><code class="language-go">func runBenchmarks(importPath string, matchString func(pat string, str string) (bool, error), benchmarks []InternalBenchmark) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runCleanup" data-name="runCleanup">
               <h3>
                  runCleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runCleanup" class="anchor" title="Link to runCleanup">#</a>
               </h3>
               
               <p>runCleanup is called at the end of the test.
If ph is recoverAndReturnPanic, it will catch panics, and return the
recovered value if any.</p>
               
               <pre><code class="language-go">func (c *common) runCleanup(ph panicHandling) (panicVal any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runExample" data-name="runExample">
               <h3>
                  runExample 
                  <span class="badge">function</span>
                  
                  <a href="#runExample" class="anchor" title="Link to runExample">#</a>
               </h3>
               
               <p>TODO(@musiol, @odeke-em): unify this code back into
example.go when js/wasm gets an os.Pipe implementation.</p>
               
               <pre><code class="language-go">func runExample(eg InternalExample) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runExample" data-name="runExample">
               <h3>
                  runExample 
                  <span class="badge">function</span>
                  
                  <a href="#runExample" class="anchor" title="Link to runExample">#</a>
               </h3>
               
               <pre><code class="language-go">func runExample(eg InternalExample) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runExamples" data-name="runExamples">
               <h3>
                  runExamples 
                  <span class="badge">function</span>
                  
                  <a href="#runExamples" class="anchor" title="Link to runExamples">#</a>
               </h3>
               
               <pre><code class="language-go">func runExamples(matchString func(pat string, str string) (bool, error), examples []InternalExample) (ran bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runFuzzTests" data-name="runFuzzTests">
               <h3>
                  runFuzzTests 
                  <span class="badge">function</span>
                  
                  <a href="#runFuzzTests" class="anchor" title="Link to runFuzzTests">#</a>
               </h3>
               
               <p>runFuzzTests runs the fuzz tests matching the pattern for -run. This will
only run the (*F).Fuzz function for each seed corpus without using the
fuzzing engine to generate or mutate inputs.</p>
               
               <pre><code class="language-go">func runFuzzTests(deps testDeps, fuzzTests []InternalFuzzTarget, deadline time.Time) (ran bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runFuzzing" data-name="runFuzzing">
               <h3>
                  runFuzzing 
                  <span class="badge">function</span>
                  
                  <a href="#runFuzzing" class="anchor" title="Link to runFuzzing">#</a>
               </h3>
               
               <p>runFuzzing runs the fuzz test matching the pattern for -fuzz. Only one such
fuzz test must match. This will run the fuzzing engine to generate and
mutate new inputs against the fuzz target.
If fuzzing is disabled (-test.fuzz is not set), runFuzzing
returns immediately.</p>
               
               <pre><code class="language-go">func runFuzzing(deps testDeps, fuzzTests []InternalFuzzTarget) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runN" data-name="runN">
               <h3>
                  runN 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runN" class="anchor" title="Link to runN">#</a>
               </h3>
               
               <p>runN runs a single benchmark for the specified number of iterations.</p>
               
               <pre><code class="language-go">func (b *B) runN(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runTests" data-name="runTests">
               <h3>
                  runTests 
                  <span class="badge">function</span>
                  
                  <a href="#runTests" class="anchor" title="Link to runTests">#</a>
               </h3>
               
               <pre><code class="language-go">func runTests(matchString func(pat string, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runningList" data-name="runningList">
               <h3>
                  runningList 
                  <span class="badge">function</span>
                  
                  <a href="#runningList" class="anchor" title="Link to runningList">#</a>
               </h3>
               
               <p>runningList returns the list of running tests.</p>
               
               <pre><code class="language-go">func runningList() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setRan" data-name="setRan">
               <h3>
                  setRan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setRan" class="anchor" title="Link to setRan">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *common) setRan()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldFailFast" data-name="shouldFailFast">
               <h3>
                  shouldFailFast 
                  <span class="badge">function</span>
                  
                  <a href="#shouldFailFast" class="anchor" title="Link to shouldFailFast">#</a>
               </h3>
               
               <pre><code class="language-go">func shouldFailFast() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortLines" data-name="sortLines">
               <h3>
                  sortLines 
                  <span class="badge">function</span>
                  
                  <a href="#sortLines" class="anchor" title="Link to sortLines">#</a>
               </h3>
               
               <pre><code class="language-go">func sortLines(output string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitRegexp" data-name="splitRegexp">
               <h3>
                  splitRegexp 
                  <span class="badge">function</span>
                  
                  <a href="#splitRegexp" class="anchor" title="Link to splitRegexp">#</a>
               </h3>
               
               <pre><code class="language-go">func splitRegexp(s string) filterMatch</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startAlarm" data-name="startAlarm">
               <h3>
                  startAlarm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startAlarm" class="anchor" title="Link to startAlarm">#</a>
               </h3>
               
               <p>startAlarm starts an alarm if requested.</p>
               
               <pre><code class="language-go">func (m *M) startAlarm() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stopAlarm" data-name="stopAlarm">
               <h3>
                  stopAlarm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stopAlarm" class="anchor" title="Link to stopAlarm">#</a>
               </h3>
               
               <p>stopAlarm turns off the alarm.</p>
               
               <pre><code class="language-go">func (m *M) stopAlarm()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stopOrScaleBLoop" data-name="stopOrScaleBLoop">
               <h3>
                  stopOrScaleBLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stopOrScaleBLoop" class="anchor" title="Link to stopOrScaleBLoop">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *B) stopOrScaleBLoop() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sub" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sub" class="anchor" title="Link to sub">#</a>
               </h3>
               
               <pre><code class="language-go">func (a highPrecisionTime) sub(b highPrecisionTime) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tRunner" data-name="tRunner">
               <h3>
                  tRunner 
                  <span class="badge">function</span>
                  
                  <a href="#tRunner" class="anchor" title="Link to tRunner">#</a>
               </h3>
               
               <pre><code class="language-go">func tRunner(t *T, fn func(t *T))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toOutputDir" data-name="toOutputDir">
               <h3>
                  toOutputDir 
                  <span class="badge">function</span>
                  
                  <a href="#toOutputDir" class="anchor" title="Link to toOutputDir">#</a>
               </h3>
               
               <p>toOutputDir returns the file name relocated, if required, to outputDir.
Simple implementation to avoid pulling in path/filepath.</p>
               
               <pre><code class="language-go">func toOutputDir(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimOutput" data-name="trimOutput">
               <h3>
                  trimOutput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trimOutput" class="anchor" title="Link to trimOutput">#</a>
               </h3>
               
               <p>trimOutput shortens the output from a benchmark, which can be very long.</p>
               
               <pre><code class="language-go">func (b *B) trimOutput()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unique" data-name="unique">
               <h3>
                  unique 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unique" class="anchor" title="Link to unique">#</a>
               </h3>
               
               <p>unique creates a unique name for the given parent and subname by affixing it
with one or more counts, if necessary.</p>
               
               <pre><code class="language-go">func (m *matcher) unique(parent string, subname string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verify" data-name="verify">
               <h3>
                  verify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#verify" class="anchor" title="Link to verify">#</a>
               </h3>
               
               <pre><code class="language-go">func (m alternationMatch) verify(name string, matchString func(pat string, str string) (bool, error)) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verify" data-name="verify">
               <h3>
                  verify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#verify" class="anchor" title="Link to verify">#</a>
               </h3>
               
               <pre><code class="language-go">func (m simpleMatch) verify(name string, matchString func(pat string, str string) (bool, error)) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="waitParallel" data-name="waitParallel">
               <h3>
                  waitParallel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#waitParallel" class="anchor" title="Link to waitParallel">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *testState) waitParallel()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeProfiles" data-name="writeProfiles">
               <h3>
                  writeProfiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeProfiles" class="anchor" title="Link to writeProfiles">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *M) writeProfiles()</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>