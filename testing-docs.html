<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - testing</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="testing_fstest-docs.html">fstest</a></li>
               
               <li><a href="testing_iotest-docs.html">iotest</a></li>
               
               <li><a href="testing_quick-docs.html">quick</a></li>
               
               <li><a href="testing_slogtest-docs.html">slogtest</a></li>
               
               <li><a href="testing_synctest-docs.html">synctest</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>testing</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"fmt"
"os"
"strconv"
"strings"
"sync"
"fmt"
"internal/goexperiment"
"os"
_ "unsafe"
"fmt"
"io"
"os"
"strings"
"time"
"time"
"errors"
"internal/syscall/windows"
"math/bits"
"syscall"
"time"
"runtime"
"context"
"flag"
"fmt"
"internal/sysinfo"
"io"
"math"
"os"
"runtime"
"slices"
"strconv"
"strings"
"sync"
"sync/atomic"
"time"
"unicode"
"fmt"
"internal/goexperiment"
"os"
"sync/atomic"
"fmt"
"runtime"
"slices"
"strings"
"time"
"fmt"
"io"
"os"
"strings"
"time"
"bytes"
"context"
"errors"
"flag"
"fmt"
"internal/goexperiment"
"internal/race"
"io"
"math/rand"
"os"
"path/filepath"
"reflect"
"runtime"
"runtime/debug"
"runtime/trace"
"slices"
"strconv"
"strings"
"sync"
"sync/atomic"
"time"
"unicode"
"unicode/utf8"
"context"
"errors"
"flag"
"fmt"
"io"
"os"
"path/filepath"
"reflect"
"runtime"
"strings"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ TB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ TB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ TB = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="benchTime">
               <h3>
                  benchTime 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var benchTime = durationOrCountFlag{...}</code></pre>
            </article>
            
            <article class="global" data-name="benchmarkLock">
               <h3>
                  benchmarkLock 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Global lock to ensure only one benchmark runs at a time.</p>
               
               <pre><code>var benchmarkLock sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="benchmarkMemory">
               <h3>
                  benchmarkMemory 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var benchmarkMemory *bool</code></pre>
            </article>
            
            <article class="global" data-name="blockProfile">
               <h3>
                  blockProfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var blockProfile *string</code></pre>
            </article>
            
            <article class="global" data-name="blockProfileRate">
               <h3>
                  blockProfileRate 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var blockProfileRate *int</code></pre>
            </article>
            
            <article class="global" data-name="chatty">
               <h3>
                  chatty 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var chatty chattyFlag</code></pre>
            </article>
            
            <article class="global" data-name="corpusDir">
               <h3>
                  corpusDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>corpusDir is the parent directory of the fuzz test's seed corpus within
the package.</p>
               
               <pre><code>var corpusDir = "testdata/fuzz"</code></pre>
            </article>
            
            <article class="global" data-name="count">
               <h3>
                  count 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var count *uint</code></pre>
            </article>
            
            <article class="global" data-name="cover">
               <h3>
                  cover 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cover Cover</code></pre>
            </article>
            
            <article class="global" data-name="cover2">
               <h3>
                  cover2 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>cover2 variable stores the current coverage mode and a
tear-down function to be called at the end of the testing run.</p>
               
               <pre><code>var cover2 struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="coverProfile">
               <h3>
                  coverProfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var coverProfile *string</code></pre>
            </article>
            
            <article class="global" data-name="cpuList">
               <h3>
                  cpuList 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cpuList []int</code></pre>
            </article>
            
            <article class="global" data-name="cpuListStr">
               <h3>
                  cpuListStr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cpuListStr *string</code></pre>
            </article>
            
            <article class="global" data-name="cpuProfile">
               <h3>
                  cpuProfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cpuProfile *string</code></pre>
            </article>
            
            <article class="global" data-name="errMain">
               <h3>
                  errMain 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>No one should be using func Main anymore.
See the doc comment on func Main and use MainStart instead.</p>
               
               <pre><code>var errMain = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNilPanicOrGoexit">
               <h3>
                  errNilPanicOrGoexit 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNilPanicOrGoexit = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="failFast">
               <h3>
                  failFast 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var failFast *bool</code></pre>
            </article>
            
            <article class="global" data-name="fullPath">
               <h3>
                  fullPath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fullPath *bool</code></pre>
            </article>
            
            <article class="global" data-name="fuzzCacheDir">
               <h3>
                  fuzzCacheDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fuzzCacheDir *string</code></pre>
            </article>
            
            <article class="global" data-name="fuzzCoordinator">
               <h3>
                  fuzzCoordinator 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fuzzCoordinator</code></pre>
            </article>
            
            <article class="global" data-name="fuzzDuration">
               <h3>
                  fuzzDuration 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fuzzDuration durationOrCountFlag</code></pre>
            </article>
            
            <article class="global" data-name="fuzzWorker">
               <h3>
                  fuzzWorker 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fuzzWorker</code></pre>
            </article>
            
            <article class="global" data-name="fuzzWorkerExitCode">
               <h3>
                  fuzzWorkerExitCode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fuzzWorkerExitCode is used as an exit code by fuzz worker processes after an
internal error. This distinguishes internal errors from uncontrolled panics
and other failures. Keep in sync with internal/fuzz.workerExitCode.</p>
               
               <pre><code>const fuzzWorkerExitCode = 70</code></pre>
            </article>
            
            <article class="global" data-name="gocoverdir">
               <h3>
                  gocoverdir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gocoverdir *string</code></pre>
            </article>
            
            <article class="global" data-name="haveExamples">
               <h3>
                  haveExamples 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var haveExamples bool</code></pre>
            </article>
            
            <article class="global" data-name="hideStdoutForTesting">
               <h3>
                  hideStdoutForTesting 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>If hideStdoutForTesting is true, Run does not print the benchName.
This avoids a spurious print during 'go test' on package testing itself,
which invokes b.Run in its own tests (see sub_test.go).</p>
               
               <pre><code>var hideStdoutForTesting = false</code></pre>
            </article>
            
            <article class="global" data-name="initRan">
               <h3>
                  initRan 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var initRan bool</code></pre>
            </article>
            
            <article class="global" data-name="isFuzzWorker">
               <h3>
                  isFuzzWorker 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var isFuzzWorker *bool</code></pre>
            </article>
            
            <article class="global" data-name="labelsOnce">
               <h3>
                  labelsOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var labelsOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="loopPoisonMask">
               <h3>
                  loopPoisonMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>loopPoisonMask is the set of all loop poison bits. (iota-1) is the index
of the bit we just set, from which we recreate that bit mask. We subtract
1 to set all of the bits below that bit, then complement the result to
get the mask. Sorry, not sorry.</p>
               
               <pre><code>const loopPoisonMask = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="loopPoisonTimer">
               <h3>
                  loopPoisonTimer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The loopPoison constants can be OR'd into B.loop.i to cause it to fall back
to the slow path.</p>
               
               <pre><code>const loopPoisonTimer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="marker">
               <h3>
                  marker 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const marker = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="match">
               <h3>
                  match 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var match *string</code></pre>
            </article>
            
            <article class="global" data-name="matchBenchmarks">
               <h3>
                  matchBenchmarks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var matchBenchmarks *string</code></pre>
            </article>
            
            <article class="global" data-name="matchFuzz">
               <h3>
                  matchFuzz 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var matchFuzz *string</code></pre>
            </article>
            
            <article class="global" data-name="matchList">
               <h3>
                  matchList 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var matchList *string</code></pre>
            </article>
            
            <article class="global" data-name="matchMutex">
               <h3>
                  matchMutex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>TODO: fix test_main to avoid race and improve caching, also allowing to
eliminate this Mutex.</p>
               
               <pre><code>var matchMutex sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="maxStackLen">
               <h3>
                  maxStackLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The maximum number of stack frames to go through when skipping helper functions for
the purpose of decorating log messages.</p>
               
               <pre><code>const maxStackLen = 50</code></pre>
            </article>
            
            <article class="global" data-name="memProfile">
               <h3>
                  memProfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var memProfile *string</code></pre>
            </article>
            
            <article class="global" data-name="memProfileRate">
               <h3>
                  memProfileRate 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var memProfileRate *int</code></pre>
            </article>
            
            <article class="global" data-name="memStats">
               <h3>
                  memStats 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Used for every benchmark for measuring memory.</p>
               
               <pre><code>var memStats runtime.MemStats</code></pre>
            </article>
            
            <article class="global" data-name="minimizeDuration">
               <h3>
                  minimizeDuration 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var minimizeDuration = durationOrCountFlag{...}</code></pre>
            </article>
            
            <article class="global" data-name="mutexProfile">
               <h3>
                  mutexProfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var mutexProfile *string</code></pre>
            </article>
            
            <article class="global" data-name="mutexProfileFraction">
               <h3>
                  mutexProfileFraction 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var mutexProfileFraction *int</code></pre>
            </article>
            
            <article class="global" data-name="normalPanic">
               <h3>
                  normalPanic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const normalPanic panicHandling = iota</code></pre>
            </article>
            
            <article class="global" data-name="numFailed">
               <h3>
                  numFailed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var numFailed atomic.Uint32</code></pre>
            </article>
            
            <article class="global" data-name="outputDir">
               <h3>
                  outputDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var outputDir *string</code></pre>
            </article>
            
            <article class="global" data-name="panicOnExit0">
               <h3>
                  panicOnExit0 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var panicOnExit0 *bool</code></pre>
            </article>
            
            <article class="global" data-name="parallel">
               <h3>
                  parallel 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var parallel *int</code></pre>
            </article>
            
            <article class="global" data-name="parallelConflict">
               <h3>
                  parallelConflict 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const parallelConflict = `testing: test using t.Setenv or t.Chdir can not use t.Parallel`</code></pre>
            </article>
            
            <article class="global" data-name="queryPerformanceFrequency">
               <h3>
                  queryPerformanceFrequency 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var queryPerformanceFrequency int64</code></pre>
            </article>
            
            <article class="global" data-name="realStderr">
               <h3>
                  realStderr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var realStderr *os.File</code></pre>
            </article>
            
            <article class="global" data-name="recoverAndReturnPanic">
               <h3>
                  recoverAndReturnPanic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const recoverAndReturnPanic</code></pre>
            </article>
            
            <article class="global" data-name="running">
               <h3>
                  running 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var running sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="seedCorpusOnly">
               <h3>
                  seedCorpusOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const seedCorpusOnly fuzzMode = iota</code></pre>
            </article>
            
            <article class="global" data-name="short">
               <h3>
                  short 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags, registered during Init.</p>
               
               <pre><code>var short *bool</code></pre>
            </article>
            
            <article class="global" data-name="shuffle">
               <h3>
                  shuffle 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var shuffle *string</code></pre>
            </article>
            
            <article class="global" data-name="skip">
               <h3>
                  skip 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var skip *string</code></pre>
            </article>
            
            <article class="global" data-name="supportedTypes">
               <h3>
                  supportedTypes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>supportedTypes represents all of the supported types which can be fuzzed.</p>
               
               <pre><code>var supportedTypes = map[reflect.Type]bool{...}</code></pre>
            </article>
            
            <article class="global" data-name="testBinary">
               <h3>
                  testBinary 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>testBinary is set by cmd/go to "1" if this is a binary built by "go test".
The value is set to "1" by a -X option to cmd/link. We assume that
because this is possible, the compiler will not optimize testBinary
into a constant on the basis that it is an unexported package-scope
variable that is never changed. If the compiler ever starts implementing
such an optimization, we will need some technique to mark this variable
as "changed by a cmd/link -X option".</p>
               
               <pre><code>var testBinary = "0"</code></pre>
            </article>
            
            <article class="global" data-name="testingTesting">
               <h3>
                  testingTesting 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testingTesting bool</code></pre>
            </article>
            
            <article class="global" data-name="testlog">
               <h3>
                  testlog 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testlog *string</code></pre>
            </article>
            
            <article class="global" data-name="testlogFile">
               <h3>
                  testlogFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testlogFile *os.File</code></pre>
            </article>
            
            <article class="global" data-name="timeout">
               <h3>
                  timeout 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var timeout *time.Duration</code></pre>
            </article>
            
            <article class="global" data-name="traceFile">
               <h3>
                  traceFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var traceFile *string</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="alternationMatch">
               <h3>
                  alternationMatch
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>alternationMatch matches a test name if one of the alternations match.</p>
               
               <pre><code>type alternationMatch []filterMatch</code></pre>
            </article>
            
            <article class="type" data-name="fuzzMode">
               <h3>
                  fuzzMode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type fuzzMode uint8</code></pre>
            </article>
            
            <article class="type" data-name="matchStringOnly">
               <h3>
                  matchStringOnly
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type matchStringOnly func(pat string, str string) (bool, error)</code></pre>
            </article>
            
            <article class="type" data-name="panicHandling">
               <h3>
                  panicHandling
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>panicHandling controls the panic handling used by runCleanup.</p>
               
               <pre><code>type panicHandling int</code></pre>
            </article>
            
            <article class="type" data-name="simpleMatch">
               <h3>
                  simpleMatch
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>simpleMatch matches a test name if all of the pattern strings match in
sequence.</p>
               
               <pre><code>type simpleMatch []string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="TB">
               <h3>
                  TB
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>TB is the interface common to T, B, and F.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type TB interface {
Cleanup(func())
Error(args ...any)
Errorf(format string, args ...any)
Fail()
FailNow()
Failed() bool
Fatal(args ...any)
Fatalf(format string, args ...any)
Helper()
Log(args ...any)
Logf(format string, args ...any)
Name() string
Setenv(key string, value string)
Chdir(dir string)
Skip(args ...any)
SkipNow()
Skipf(format string, args ...any)
Skipped() bool
TempDir() string
Context() context.Context
private()
}</code></pre>
            </article>
            
            <article class="interface" data-name="filterMatch">
               <h3>
                  filterMatch
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type filterMatch interface {
matches(name []string, matchString func(pat string, str string) (bool, error)) (ok bool, partial bool)
verify(name string, matchString func(pat string, str string) (bool, error)) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="fuzzCrashError">
               <h3>
                  fuzzCrashError
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>fuzzCrashError is satisfied by a failing input detected while fuzzing.
These errors are written to the seed corpus and can be re-run with 'go test'.
Errors within the fuzzing framework (like I/O errors between coordinator
and worker processes) don't satisfy this interface.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type fuzzCrashError interface {
error
Unwrap() error
CrashPath() string
}</code></pre>
            </article>
            
            <article class="interface" data-name="testDeps">
               <h3>
                  testDeps
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>testDeps is an internal interface of functionality that is
passed into this package by a test's generated main package.
The canonical implementation of this interface is
testing/internal/testdeps's TestDeps.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type testDeps interface {
ImportPath() string
MatchString(pat string, str string) (bool, error)
SetPanicOnExit0(bool)
StartCPUProfile(io.Writer) error
StopCPUProfile()
StartTestLog(io.Writer)
StopTestLog() error
WriteProfileTo(string, io.Writer, int) error
CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error
RunFuzzWorker(func(corpusEntry) error) error
ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)
CheckCorpus([]any, []reflect.Type) error
ResetCoverage()
SnapshotCoverage()
InitRuntimeCoverage() (mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="B">
               <h3>
                  B
                  <span class="badge">struct</span>
               </h3>
               
               <p>B is a type passed to [Benchmark] functions to manage benchmark
timing and control the number of iterations.
A benchmark ends when its Benchmark function returns or calls any of the methods
FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called
only from the goroutine running the Benchmark function.
The other reporting methods, such as the variations of Log and Error,
may be called simultaneously from multiple goroutines.
Like in tests, benchmark logs are accumulated during execution
and dumped to standard output when done. Unlike in tests, benchmark logs
are always printed, so as not to hide output whose existence may be
affecting benchmark results.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type B struct {
common
importPath string
bstate *benchState
N int
previousN int
previousDuration time.Duration
benchFunc func(b *B)
benchTime durationOrCountFlag
bytes int64
missingBytes bool
timerOn bool
showAllocResult bool
result BenchmarkResult
parallelism int
startAllocs uint64
startBytes uint64
netAllocs uint64
netBytes uint64
extra map[string]float64
loop struct{...}
}</code></pre>
            </article>
            
            <article class="struct" data-name="BenchmarkResult">
               <h3>
                  BenchmarkResult
                  <span class="badge">struct</span>
               </h3>
               
               <p>BenchmarkResult contains the results of a benchmark run.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BenchmarkResult struct {
N int
T time.Duration
Bytes int64
MemAllocs uint64
MemBytes uint64
Extra map[string]float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Cover">
               <h3>
                  Cover
                  <span class="badge">struct</span>
               </h3>
               
               <p>Cover records information about test coverage checking.
NOTE: This struct is internal to the testing infrastructure and may change.
It is not covered (yet) by the Go 1 compatibility guidelines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Cover struct {
Mode string
Counters map[string][]uint32
Blocks map[string][]CoverBlock
CoveredPackages string
}</code></pre>
            </article>
            
            <article class="struct" data-name="CoverBlock">
               <h3>
                  CoverBlock
                  <span class="badge">struct</span>
               </h3>
               
               <p>CoverBlock records the coverage data for a single basic block.
The fields are 1-indexed, as in an editor: The opening line of
the file is number 1, for example. Columns are measured
in bytes.
NOTE: This struct is internal to the testing infrastructure and may change.
It is not covered (yet) by the Go 1 compatibility guidelines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CoverBlock struct {
Line0 uint32
Col0 uint16
Line1 uint32
Col1 uint16
Stmts uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="F">
               <h3>
                  F
                  <span class="badge">struct</span>
               </h3>
               
               <p>F is a type passed to fuzz tests.
Fuzz tests run generated inputs against a provided fuzz target, which can
find and report potential bugs in the code being tested.
A fuzz test runs the seed corpus by default, which includes entries provided
by (*F).Add and entries in the testdata/fuzz/<FuzzTestName> directory. After
any necessary setup and calls to (*F).Add, the fuzz test must then call
(*F).Fuzz to provide the fuzz target. See the testing package documentation
for an example, and see the [F.Fuzz] and [F.Add] method documentation for
details.
*F methods can only be called before (*F).Fuzz. Once the test is
executing the fuzz target, only (*T) methods can be used. The only *F methods
that are allowed in the (*F).Fuzz function are (*F).Failed and (*F).Name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type F struct {
common
fstate *fuzzState
tstate *testState
inFuzzFn bool
corpus []corpusEntry
result fuzzResult
fuzzCalled bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="InternalBenchmark">
               <h3>
                  InternalBenchmark
                  <span class="badge">struct</span>
               </h3>
               
               <p>InternalBenchmark is an internal type but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InternalBenchmark struct {
Name string
F func(b *B)
}</code></pre>
            </article>
            
            <article class="struct" data-name="InternalExample">
               <h3>
                  InternalExample
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InternalExample struct {
Name string
F func()
Output string
Unordered bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="InternalFuzzTarget">
               <h3>
                  InternalFuzzTarget
                  <span class="badge">struct</span>
               </h3>
               
               <p>InternalFuzzTarget is an internal type but exported because it is
cross-package; it is part of the implementation of the "go test" command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InternalFuzzTarget struct {
Name string
Fn func(f *F)
}</code></pre>
            </article>
            
            <article class="struct" data-name="InternalTest">
               <h3>
                  InternalTest
                  <span class="badge">struct</span>
               </h3>
               
               <p>InternalTest is an internal type but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InternalTest struct {
Name string
F func(*T)
}</code></pre>
            </article>
            
            <article class="struct" data-name="M">
               <h3>
                  M
                  <span class="badge">struct</span>
               </h3>
               
               <p>M is a type passed to a TestMain function to run the actual tests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type M struct {
deps testDeps
tests []InternalTest
benchmarks []InternalBenchmark
fuzzTargets []InternalFuzzTarget
examples []InternalExample
timer *time.Timer
afterOnce sync.Once
numRun int
exitCode int
}</code></pre>
            </article>
            
            <article class="struct" data-name="PB">
               <h3>
                  PB
                  <span class="badge">struct</span>
               </h3>
               
               <p>A PB is used by RunParallel for running parallel benchmarks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PB struct {
globalN *atomic.Uint64
grain uint64
cache uint64
bN uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="T">
               <h3>
                  T
                  <span class="badge">struct</span>
               </h3>
               
               <p>T is a type passed to Test functions to manage test state and support formatted test logs.
A test ends when its Test function returns or calls any of the methods
FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as
the Parallel method, must be called only from the goroutine running the
Test function.
The other reporting methods, such as the variations of Log and Error,
may be called simultaneously from multiple goroutines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type T struct {
common
denyParallel bool
tstate *testState
}</code></pre>
            </article>
            
            <article class="struct" data-name="benchState">
               <h3>
                  benchState
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type benchState struct {
match *matcher
maxLen int
extLen int
}</code></pre>
            </article>
            
            <article class="struct" data-name="chattyFlag">
               <h3>
                  chattyFlag
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type chattyFlag struct {
on bool
json bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="chattyPrinter">
               <h3>
                  chattyPrinter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type chattyPrinter struct {
w io.Writer
lastNameMu sync.Mutex
lastName string
json bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="common">
               <h3>
                  common
                  <span class="badge">struct</span>
               </h3>
               
               <p>common holds the elements common between T and B and
captures common methods such as Errorf.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type common struct {
mu sync.RWMutex
output []byte
w io.Writer
ran bool
failed bool
skipped bool
done bool
helperPCs map[uintptr]struct{...}
helperNames map[string]struct{...}
cleanups []func()
cleanupName string
cleanupPc []uintptr
finished bool
inFuzzFn bool
chatty *chattyPrinter
bench bool
hasSub atomic.Bool
cleanupStarted atomic.Bool
runner string
isParallel bool
parent *common
level int
creator []uintptr
name string
start highPrecisionTime
duration time.Duration
barrier chan bool
signal chan bool
sub []*T
lastRaceErrors atomic.Int64
raceErrorLogged atomic.Bool
tempDirMu sync.Mutex
tempDir string
tempDirErr error
tempDirSeq int32
ctx context.Context
cancelCtx context.CancelFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="corpusEntry">
               <h3>
                  corpusEntry
                  <span class="badge">struct</span>
               </h3>
               
               <p>corpusEntry is an alias to the same type as internal/fuzz.CorpusEntry.
We use a type alias because we don't want to export this type, and we can't
import internal/fuzz from testing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type corpusEntry struct {
Parent string
Path string
Data []byte
Values []any
Generation int
IsSeed bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="discard">
               <h3>
                  discard
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type discard struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="durationOrCountFlag">
               <h3>
                  durationOrCountFlag
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type durationOrCountFlag struct {
d time.Duration
n int
allowZero bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="fuzzResult">
               <h3>
                  fuzzResult
                  <span class="badge">struct</span>
               </h3>
               
               <p>fuzzResult contains the results of a fuzz run.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fuzzResult struct {
N int
T time.Duration
Error error
}</code></pre>
            </article>
            
            <article class="struct" data-name="fuzzState">
               <h3>
                  fuzzState
                  <span class="badge">struct</span>
               </h3>
               
               <p>fuzzState holds fields common to all fuzz tests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fuzzState struct {
deps testDeps
mode fuzzMode
}</code></pre>
            </article>
            
            <article class="struct" data-name="highPrecisionTime">
               <h3>
                  highPrecisionTime
                  <span class="badge">struct</span>
               </h3>
               
               <p>highPrecisionTime represents a single point in time with query performance counter.
time.Time on Windows has low system granularity, which is not suitable for
measuring short time intervals.
TODO: If Windows runtime implements high resolution timing then highPrecisionTime
can be removed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type highPrecisionTime struct {
now int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="highPrecisionTime">
               <h3>
                  highPrecisionTime
                  <span class="badge">struct</span>
               </h3>
               
               <p>highPrecisionTime represents a single point in time.
On all systems except Windows, using time.Time is fine.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type highPrecisionTime struct {
now time.Time
}</code></pre>
            </article>
            
            <article class="struct" data-name="indenter">
               <h3>
                  indenter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type indenter struct {
c *common
}</code></pre>
            </article>
            
            <article class="struct" data-name="matcher">
               <h3>
                  matcher
                  <span class="badge">struct</span>
               </h3>
               
               <p>matcher sanitizes, uniques, and filters names of subtests and subbenchmarks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type matcher struct {
filter filterMatch
skip filterMatch
matchFunc func(pat string, str string) (bool, error)
mu sync.Mutex
subNames map[string]int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="testState">
               <h3>
                  testState
                  <span class="badge">struct</span>
               </h3>
               
               <p>testState holds all fields that are common to all tests. This includes
synchronization primitives to run at most *parallel tests.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type testState struct {
match *matcher
deadline time.Time
isFuzzing bool
mu sync.Mutex
startParallel chan bool
running int
numWaiting int
maxParallel int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add will add the arguments to the seed corpus for the fuzz test. This will be
a no-op if called after or within the fuzz target, and args must match the
arguments for the fuzz target.</p>
               
               <pre><code>func (f *F) Add(args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="AllocedBytesPerOp">
               <h3>
                  AllocedBytesPerOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AllocedBytesPerOp returns the "B/op" metric,
which is calculated as r.MemBytes / r.N.</p>
               
               <pre><code>func (r BenchmarkResult) AllocedBytesPerOp() int64</code></pre>
            </article>
            
            <article class="function" data-name="AllocsPerOp">
               <h3>
                  AllocsPerOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AllocsPerOp returns the "allocs/op" metric,
which is calculated as r.MemAllocs / r.N.</p>
               
               <pre><code>func (r BenchmarkResult) AllocsPerOp() int64</code></pre>
            </article>
            
            <article class="function" data-name="AllocsPerRun">
               <h3>
                  AllocsPerRun 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AllocsPerRun returns the average number of allocations during calls to f.
Although the return value has type float64, it will always be an integral value.
To compute the number of allocations, the function will first be run once as
a warm-up. The average number of allocations over the specified number of
runs will then be measured and returned.
AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore
it before returning.</p>
               
               <pre><code>func AllocsPerRun(runs int, f func()) (avg float64)</code></pre>
            </article>
            
            <article class="function" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Chdir calls os.Chdir(dir) and uses Cleanup to restore the current
working directory to its original value after the test. On Unix, it
also sets PWD environment variable for the duration of the test.
Because Chdir affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code>func (c *common) Chdir(dir string)</code></pre>
            </article>
            
            <article class="function" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Chdir calls os.Chdir(dir) and uses Cleanup to restore the current
working directory to its original value after the test. On Unix, it
also sets PWD environment variable for the duration of the test.
Because Chdir affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code>func (t *T) Chdir(dir string)</code></pre>
            </article>
            
            <article class="function" data-name="CheckCorpus">
               <h3>
                  CheckCorpus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) CheckCorpus([]any, []reflect.Type) error</code></pre>
            </article>
            
            <article class="function" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cleanup registers a function to be called when the test (or subtest) and all its
subtests complete. Cleanup functions will be called in last added,
first called order.</p>
               
               <pre><code>func (c *common) Cleanup(f func())</code></pre>
            </article>
            
            <article class="function" data-name="Context">
               <h3>
                  Context 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Context returns a context that is canceled just before
Cleanup-registered functions are called.
Cleanup functions can wait for any resources
that shut down on Context.Done before the test or benchmark completes.</p>
               
               <pre><code>func (c *common) Context() context.Context</code></pre>
            </article>
            
            <article class="function" data-name="CoordinateFuzzing">
               <h3>
                  CoordinateFuzzing 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error</code></pre>
            </article>
            
            <article class="function" data-name="CoverMode">
               <h3>
                  CoverMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CoverMode reports what the test coverage mode is set to. The
values are "set", "count", or "atomic". The return value will be
empty if test coverage is not enabled.</p>
               
               <pre><code>func CoverMode() string</code></pre>
            </article>
            
            <article class="function" data-name="Coverage">
               <h3>
                  Coverage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Coverage reports the current code coverage as a fraction in the range [0, 1].
If coverage is not enabled, Coverage returns 0.
When running a large set of sequential test cases, checking Coverage after each one
can be useful for identifying which test cases exercise new code paths.
It is not a replacement for the reports generated by 'go test -cover' and
'go tool cover'.</p>
               
               <pre><code>func Coverage() float64</code></pre>
            </article>
            
            <article class="function" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Deadline reports the time at which the test binary will have
exceeded the timeout specified by the -timeout flag.
The ok result is false if the -timeout flag indicates “no timeout” (0).</p>
               
               <pre><code>func (t *T) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Elapsed">
               <h3>
                  Elapsed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Elapsed returns the measured elapsed time of the benchmark.
The duration reported by Elapsed matches the one measured by
[B.StartTimer], [B.StopTimer], and [B.ResetTimer].</p>
               
               <pre><code>func (b *B) Elapsed() time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Error is equivalent to Log followed by Fail.</p>
               
               <pre><code>func (c *common) Error(args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Errorf is equivalent to Logf followed by Fail.</p>
               
               <pre><code>func (c *common) Errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Fail">
               <h3>
                  Fail 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fail marks the function as having failed but continues execution.</p>
               
               <pre><code>func (f *F) Fail()</code></pre>
            </article>
            
            <article class="function" data-name="Fail">
               <h3>
                  Fail 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fail marks the function as having failed but continues execution.</p>
               
               <pre><code>func (c *common) Fail()</code></pre>
            </article>
            
            <article class="function" data-name="FailNow">
               <h3>
                  FailNow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FailNow marks the function as having failed and stops its execution
by calling runtime.Goexit (which then runs all deferred calls in the
current goroutine).
Execution will continue at the next test or benchmark.
FailNow must be called from the goroutine running the
test or benchmark function, not from other goroutines
created during the test. Calling FailNow does not stop
those other goroutines.</p>
               
               <pre><code>func (c *common) FailNow()</code></pre>
            </article>
            
            <article class="function" data-name="Failed">
               <h3>
                  Failed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Failed reports whether the function has failed.</p>
               
               <pre><code>func (c *common) Failed() bool</code></pre>
            </article>
            
            <article class="function" data-name="Fatal">
               <h3>
                  Fatal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fatal is equivalent to Log followed by FailNow.</p>
               
               <pre><code>func (c *common) Fatal(args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fatalf is equivalent to Logf followed by FailNow.</p>
               
               <pre><code>func (c *common) Fatalf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Fuzz">
               <h3>
                  Fuzz 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of
arguments, those arguments will be added to the seed corpus.
ff must be a function with no return value whose first argument is *T and
whose remaining arguments are the types to be fuzzed.
For example:
f.Fuzz(func(t *testing.T, b []byte, i int) { ... })
The following types are allowed: []byte, string, bool, byte, rune, float32,
float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64.
More types may be supported in the future.
ff must not call any *F methods, e.g. (*F).Log, (*F).Error, (*F).Skip. Use
the corresponding *T method instead. The only *F methods that are allowed in
the (*F).Fuzz function are (*F).Failed and (*F).Name.
This function should be fast and deterministic, and its behavior should not
depend on shared state. No mutable input arguments, or pointers to them,
should be retained between executions of the fuzz function, as the memory
backing them may be mutated during a subsequent invocation. ff must not
modify the underlying data of the arguments provided by the fuzzing engine.
When fuzzing, F.Fuzz does not return until a problem is found, time runs out
(set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz
should be called exactly once, unless F.Skip or [F.Fail] is called beforehand.</p>
               
               <pre><code>func (f *F) Fuzz(ff any)</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *chattyFlag) Get() any</code></pre>
            </article>
            
            <article class="function" data-name="Helper">
               <h3>
                  Helper 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Helper marks the calling function as a test helper function.
When printing file and line information, that function will be skipped.
Helper may be called simultaneously from multiple goroutines.</p>
               
               <pre><code>func (c *common) Helper()</code></pre>
            </article>
            
            <article class="function" data-name="Helper">
               <h3>
                  Helper 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Helper marks the calling function as a test helper function.
When printing file and line information, that function will be skipped.
Helper may be called simultaneously from multiple goroutines.</p>
               
               <pre><code>func (f *F) Helper()</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Init registers testing flags. These flags are automatically registered by
the "go test" command before running test functions, so Init is only needed
when calling functions such as Benchmark without using "go test".
Init is not safe to call concurrently. It has no effect if it was already called.</p>
               
               <pre><code>func Init()</code></pre>
            </article>
            
            <article class="function" data-name="InitRuntimeCoverage">
               <h3>
                  InitRuntimeCoverage 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) InitRuntimeCoverage() (mode string, tearDown func(string, string) (string, error), snapcov func() float64)</code></pre>
            </article>
            
            <article class="function" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*chattyFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Log formats its arguments using default formatting, analogous to Println,
and records the text in the error log. For tests, the text will be printed only if
the test fails or the -test.v flag is set. For benchmarks, the text is always
printed to avoid having performance depend on the value of the -test.v flag.</p>
               
               <pre><code>func (c *common) Log(args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Logf formats its arguments according to the format, analogous to Printf, and
records the text in the error log. A final newline is added if not provided. For
tests, the text will be printed only if the test fails or the -test.v flag is
set. For benchmarks, the text is always printed to avoid having performance
depend on the value of the -test.v flag.</p>
               
               <pre><code>func (c *common) Logf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Loop">
               <h3>
                  Loop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Loop returns true as long as the benchmark should continue running.
A typical benchmark is structured like:
func Benchmark(b *testing.B) {
... setup ...
for b.Loop() {
... code to measure ...
}
... cleanup ...
}
Loop resets the benchmark timer the first time it is called in a benchmark,
so any setup performed prior to starting the benchmark loop does not count
toward the benchmark measurement. Likewise, when it returns false, it stops
the timer so cleanup code is not measured.
The compiler never optimizes away calls to functions within the body of a
"for b.Loop() { ... }" loop. This prevents surprises that can otherwise occur
if the compiler determines that the result of a benchmarked function is
unused. The loop must be written in exactly this form, and this only applies
to calls syntactically between the curly braces of the loop. Optimizations
are performed as usual in any functions called by the loop.
After Loop returns false, b.N contains the total number of iterations that
ran, so the benchmark may use b.N to compute other average metrics.
Prior to the introduction of Loop, benchmarks were expected to contain an
explicit loop from 0 to b.N. Benchmarks should either use Loop or contain a
loop to b.N, but not both. Loop offers more automatic management of the
benchmark timer, and runs each benchmark function only once per measurement,
whereas b.N-based benchmarks must run the benchmark function (and any
associated setup and cleanup) several times.</p>
               
               <pre><code>func (b *B) Loop() bool</code></pre>
            </article>
            
            <article class="function" data-name="Main">
               <h3>
                  Main 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Main is an internal function, part of the implementation of the "go test" command.
It was exported because it is cross-package and predates "internal" packages.
It is no longer used by "go test" but preserved, as much as possible, for other
systems that simulate "go test" using Main, but Main sometimes cannot be updated as
new functionality is added to the testing package.
Systems simulating "go test" should be updated to use MainStart.</p>
               
               <pre><code>func Main(matchString func(pat string, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</code></pre>
            </article>
            
            <article class="function" data-name="MainStart">
               <h3>
                  MainStart 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MainStart is meant for use by tests generated by 'go test'.
It is not meant to be called directly and is not subject to the Go 1 compatibility document.
It may change signature from release to release.</p>
               
               <pre><code>func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M</code></pre>
            </article>
            
            <article class="function" data-name="MatchString">
               <h3>
                  MatchString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) MatchString(pat string, str string) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="MemString">
               <h3>
                  MemString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.</p>
               
               <pre><code>func (r BenchmarkResult) MemString() string</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name returns the name of the running (sub-) test or benchmark.
The name will include the name of the test along with the names of
any nested sub-tests. If two sibling sub-tests have the same name,
Name will append a suffix to guarantee the returned name is unique.</p>
               
               <pre><code>func (c *common) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next reports whether there are more iterations to execute.</p>
               
               <pre><code>func (pb *PB) Next() bool</code></pre>
            </article>
            
            <article class="function" data-name="NsPerOp">
               <h3>
                  NsPerOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NsPerOp returns the "ns/op" metric.</p>
               
               <pre><code>func (r BenchmarkResult) NsPerOp() int64</code></pre>
            </article>
            
            <article class="function" data-name="Parallel">
               <h3>
                  Parallel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Parallel signals that this test is to be run in parallel with (and only with)
other parallel tests. When a test is run multiple times due to use of
-test.count or -test.cpu, multiple instances of a single test never run in
parallel with each other.</p>
               
               <pre><code>func (t *T) Parallel()</code></pre>
            </article>
            
            <article class="function" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Printf prints a message, generated by the named test, that does not
necessarily mention that tests's name itself.</p>
               
               <pre><code>func (p *chattyPrinter) Printf(testName string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="ReadCorpus">
               <h3>
                  ReadCorpus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)</code></pre>
            </article>
            
            <article class="function" data-name="RegisterCover">
               <h3>
                  RegisterCover 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RegisterCover records the coverage data accumulators for the tests.
NOTE: This function is internal to the testing infrastructure and may change.
It is not covered (yet) by the Go 1 compatibility guidelines.</p>
               
               <pre><code>func RegisterCover(c Cover)</code></pre>
            </article>
            
            <article class="function" data-name="ReportAllocs">
               <h3>
                  ReportAllocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReportAllocs enables malloc statistics for this benchmark.
It is equivalent to setting -test.benchmem, but it only affects the
benchmark function that calls ReportAllocs.</p>
               
               <pre><code>func (b *B) ReportAllocs()</code></pre>
            </article>
            
            <article class="function" data-name="ReportMetric">
               <h3>
                  ReportMetric 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReportMetric adds "n unit" to the reported benchmark results.
If the metric is per-iteration, the caller should divide by b.N,
and by convention units should end in "/op".
ReportMetric overrides any previously reported value for the same unit.
ReportMetric panics if unit is the empty string or if unit contains
any whitespace.
If unit is a unit normally reported by the benchmark framework itself
(such as "allocs/op"), ReportMetric will override that metric.
Setting "ns/op" to 0 will suppress that built-in metric.</p>
               
               <pre><code>func (b *B) ReportMetric(n float64, unit string)</code></pre>
            </article>
            
            <article class="function" data-name="ResetCoverage">
               <h3>
                  ResetCoverage 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) ResetCoverage()</code></pre>
            </article>
            
            <article class="function" data-name="ResetTimer">
               <h3>
                  ResetTimer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ResetTimer zeroes the elapsed benchmark time and memory allocation counters
and deletes user-reported metrics.
It does not affect whether the timer is running.</p>
               
               <pre><code>func (b *B) ResetTimer()</code></pre>
            </article>
            
            <article class="function" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Run runs the tests. It returns an exit code to pass to os.Exit.</p>
               
               <pre><code>func (m *M) Run() (code int)</code></pre>
            </article>
            
            <article class="function" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Run benchmarks f as a subbenchmark with the given name. It reports
whether there were any failures.
A subbenchmark is like any other benchmark. A benchmark that calls Run at
least once will not be measured itself and will be called once with N=1.</p>
               
               <pre><code>func (b *B) Run(name string, f func(b *B)) bool</code></pre>
            </article>
            
            <article class="function" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Run runs f as a subtest of t called name. It runs f in a separate goroutine
and blocks until f returns or calls t.Parallel to become a parallel test.
Run reports whether f succeeded (or at least did not fail before calling t.Parallel).
Run may be called simultaneously from multiple goroutines, but all such calls
must return before the outer test function for t returns.</p>
               
               <pre><code>func (t *T) Run(name string, f func(t *T)) bool</code></pre>
            </article>
            
            <article class="function" data-name="RunBenchmarks">
               <h3>
                  RunBenchmarks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RunBenchmarks is an internal function but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre><code>func RunBenchmarks(matchString func(pat string, str string) (bool, error), benchmarks []InternalBenchmark)</code></pre>
            </article>
            
            <article class="function" data-name="RunExamples">
               <h3>
                  RunExamples 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RunExamples is an internal function but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre><code>func RunExamples(matchString func(pat string, str string) (bool, error), examples []InternalExample) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="RunFuzzWorker">
               <h3>
                  RunFuzzWorker 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) RunFuzzWorker(func(corpusEntry) error) error</code></pre>
            </article>
            
            <article class="function" data-name="RunParallel">
               <h3>
                  RunParallel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RunParallel runs a benchmark in parallel.
It creates multiple goroutines and distributes b.N iterations among them.
The number of goroutines defaults to GOMAXPROCS. To increase parallelism for
non-CPU-bound benchmarks, call [B.SetParallelism] before RunParallel.
RunParallel is usually used with the go test -cpu flag.
The body function will be run in each goroutine. It should set up any
goroutine-local state and then iterate until pb.Next returns false.
It should not use the [B.StartTimer], [B.StopTimer], or [B.ResetTimer] functions,
because they have global effect. It should also not call [B.Run].
RunParallel reports ns/op values as wall time for the benchmark as a whole,
not the sum of wall time or CPU time over each parallel goroutine.</p>
               
               <pre><code>func (b *B) RunParallel(body func(*PB))</code></pre>
            </article>
            
            <article class="function" data-name="RunTests">
               <h3>
                  RunTests 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RunTests is an internal function but exported because it is cross-package;
it is part of the implementation of the "go test" command.</p>
               
               <pre><code>func RunTests(matchString func(pat string, str string) (bool, error), tests []InternalTest) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *durationOrCountFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *chattyFlag) Set(arg string) error</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes records the number of bytes processed in a single operation.
If this is called, the benchmark will report ns/op and MB/s.</p>
               
               <pre><code>func (b *B) SetBytes(n int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetPanicOnExit0">
               <h3>
                  SetPanicOnExit0 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) SetPanicOnExit0(bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetParallelism">
               <h3>
                  SetParallelism 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetParallelism sets the number of goroutines used by [B.RunParallel] to p*GOMAXPROCS.
There is usually no need to call SetParallelism for CPU-bound benchmarks.
If p is less than 1, this call will have no effect.</p>
               
               <pre><code>func (b *B) SetParallelism(p int)</code></pre>
            </article>
            
            <article class="function" data-name="Setenv">
               <h3>
                  Setenv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Setenv calls os.Setenv(key, value) and uses Cleanup to
restore the environment variable to its original value
after the test.
Because Setenv affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code>func (t *T) Setenv(key string, value string)</code></pre>
            </article>
            
            <article class="function" data-name="Setenv">
               <h3>
                  Setenv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Setenv calls os.Setenv(key, value) and uses Cleanup to
restore the environment variable to its original value
after the test.
Because Setenv affects the whole process, it cannot be used
in parallel tests or tests with parallel ancestors.</p>
               
               <pre><code>func (c *common) Setenv(key string, value string)</code></pre>
            </article>
            
            <article class="function" data-name="Short">
               <h3>
                  Short 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Short reports whether the -test.short flag is set.</p>
               
               <pre><code>func Short() bool</code></pre>
            </article>
            
            <article class="function" data-name="Skip">
               <h3>
                  Skip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Skip is equivalent to Log followed by SkipNow.</p>
               
               <pre><code>func (c *common) Skip(args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="SkipNow">
               <h3>
                  SkipNow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SkipNow marks the test as having been skipped and stops its execution
by calling [runtime.Goexit].
If a test fails (see Error, Errorf, Fail) and is then skipped,
it is still considered to have failed.
Execution will continue at the next test or benchmark. See also FailNow.
SkipNow must be called from the goroutine running the test, not from
other goroutines created during the test. Calling SkipNow does not stop
those other goroutines.</p>
               
               <pre><code>func (c *common) SkipNow()</code></pre>
            </article>
            
            <article class="function" data-name="Skipf">
               <h3>
                  Skipf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Skipf is equivalent to Logf followed by SkipNow.</p>
               
               <pre><code>func (c *common) Skipf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Skipped">
               <h3>
                  Skipped 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Skipped reports whether the test was skipped.</p>
               
               <pre><code>func (c *common) Skipped() bool</code></pre>
            </article>
            
            <article class="function" data-name="Skipped">
               <h3>
                  Skipped 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Skipped reports whether the test was skipped.</p>
               
               <pre><code>func (f *F) Skipped() bool</code></pre>
            </article>
            
            <article class="function" data-name="SnapshotCoverage">
               <h3>
                  SnapshotCoverage 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) SnapshotCoverage()</code></pre>
            </article>
            
            <article class="function" data-name="StartCPUProfile">
               <h3>
                  StartCPUProfile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) StartCPUProfile(w io.Writer) error</code></pre>
            </article>
            
            <article class="function" data-name="StartTestLog">
               <h3>
                  StartTestLog 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) StartTestLog(io.Writer)</code></pre>
            </article>
            
            <article class="function" data-name="StartTimer">
               <h3>
                  StartTimer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StartTimer starts timing a test. This function is called automatically
before a benchmark starts, but it can also be used to resume timing after
a call to [B.StopTimer].</p>
               
               <pre><code>func (b *B) StartTimer()</code></pre>
            </article>
            
            <article class="function" data-name="StopCPUProfile">
               <h3>
                  StopCPUProfile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) StopCPUProfile()</code></pre>
            </article>
            
            <article class="function" data-name="StopTestLog">
               <h3>
                  StopTestLog 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) StopTestLog() error</code></pre>
            </article>
            
            <article class="function" data-name="StopTimer">
               <h3>
                  StopTimer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StopTimer stops timing a test. This can be used to pause the timer
while performing steps that you don't want to measure.</p>
               
               <pre><code>func (b *B) StopTimer()</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a summary of the benchmark results.
It follows the benchmark result line format from
https://golang.org/design/14313-benchmark-format, not including the
benchmark name.
Extra metrics override built-in metrics of the same name.
String does not include allocs/op or B/op, since those are reported
by [BenchmarkResult.MemString].</p>
               
               <pre><code>func (r BenchmarkResult) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *durationOrCountFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *chattyFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r fuzzResult) String() string</code></pre>
            </article>
            
            <article class="function" data-name="TempDir">
               <h3>
                  TempDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TempDir returns a temporary directory for the test to use.
The directory is automatically removed when the test and
all its subtests complete.
Each subsequent call to t.TempDir returns a unique directory;
if the directory creation fails, TempDir terminates the test by calling Fatal.</p>
               
               <pre><code>func (c *common) TempDir() string</code></pre>
            </article>
            
            <article class="function" data-name="Updatef">
               <h3>
                  Updatef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Updatef prints a message about the status of the named test to w.
The formatted message must include the test name itself.</p>
               
               <pre><code>func (p *chattyPrinter) Updatef(testName string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Verbose">
               <h3>
                  Verbose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Verbose reports whether the -test.v flag is set.</p>
               
               <pre><code>func Verbose() bool</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (discard) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w indenter) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteProfileTo">
               <h3>
                  WriteProfileTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add simulates running benchmarks in sequence in a single iteration. It is
used to give some meaningful results in case func Benchmark is used in
combination with Run.</p>
               
               <pre><code>func (b *B) add(other BenchmarkResult)</code></pre>
            </article>
            
            <article class="function" data-name="after">
               <h3>
                  after 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>after runs after all testing.</p>
               
               <pre><code>func (m *M) after()</code></pre>
            </article>
            
            <article class="function" data-name="allMatcher">
               <h3>
                  allMatcher 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func allMatcher() *matcher</code></pre>
            </article>
            
            <article class="function" data-name="before">
               <h3>
                  before 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>before runs before all testing.</p>
               
               <pre><code>func (m *M) before()</code></pre>
            </article>
            
            <article class="function" data-name="benchmarkName">
               <h3>
                  benchmarkName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>benchmarkName returns full name of benchmark including procs suffix.</p>
               
               <pre><code>func benchmarkName(name string, n int) string</code></pre>
            </article>
            
            <article class="function" data-name="callerName">
               <h3>
                  callerName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>callerName gives the function name (qualified with a package path)
for the caller after skip frames (where 0 means the current function).</p>
               
               <pre><code>func callerName(skip int) string</code></pre>
            </article>
            
            <article class="function" data-name="checkFuzzFn">
               <h3>
                  checkFuzzFn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *common) checkFuzzFn(name string)</code></pre>
            </article>
            
            <article class="function" data-name="checkParallel">
               <h3>
                  checkParallel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *T) checkParallel()</code></pre>
            </article>
            
            <article class="function" data-name="checkRaces">
               <h3>
                  checkRaces 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkRaces checks whether the global count of data race errors has increased
since c's count was last reset.
If so, it marks c as having failed due to those races (logging an error for
the first such race), and updates the race counts for the parents of c so
that if they are currently suspended (such as in a call to T.Run) they will
not log separate errors for the race(s).
Note that multiple tests may be marked as failed due to the same race if they
are executing in parallel.</p>
               
               <pre><code>func (c *common) checkRaces() (raceErrors int64)</code></pre>
            </article>
            
            <article class="function" data-name="clearSubNames">
               <h3>
                  clearSubNames 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>clearSubNames clears the matcher's internal state, potentially freeing
memory. After this is called, T.Name may return the same strings as it did
for earlier subtests.</p>
               
               <pre><code>func (m *matcher) clearSubNames()</code></pre>
            </article>
            
            <article class="function" data-name="coverReport">
               <h3>
                  coverReport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>coverReport reports the coverage percentage and writes a coverage profile if requested.</p>
               
               <pre><code>func coverReport()</code></pre>
            </article>
            
            <article class="function" data-name="coverReport2">
               <h3>
                  coverReport2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>coverReport2 invokes a callback in _testmain.go that will
emit coverage data at the point where test execution is complete,
for "go test -cover" runs.</p>
               
               <pre><code>func coverReport2()</code></pre>
            </article>
            
            <article class="function" data-name="coverage2">
               <h3>
                  coverage2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>coverage2 returns a rough "coverage percentage so far"
number to support the testing.Coverage() function.</p>
               
               <pre><code>func coverage2() float64</code></pre>
            </article>
            
            <article class="function" data-name="createTempFile">
               <h3>
                  createTempFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func createTempFile(exampleName string) *os.File</code></pre>
            </article>
            
            <article class="function" data-name="decorate">
               <h3>
                  decorate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>decorate prefixes the string with the file and line of the call site
and inserts the final newline if needed and indentation spaces for formatting.
This function must be called with c.mu held.</p>
               
               <pre><code>func (c *common) decorate(s string, skip int) string</code></pre>
            </article>
            
            <article class="function" data-name="doBench">
               <h3>
                  doBench 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *B) doBench() BenchmarkResult</code></pre>
            </article>
            
            <article class="function" data-name="fRunner">
               <h3>
                  fRunner 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fRunner wraps a call to a fuzz test and ensures that cleanup functions are
called and status flags are set. fRunner should be called in its own
goroutine. To wait for its completion, receive from f.signal.
fRunner is analogous to tRunner, which wraps subtests started with T.Run.
Unit tests and fuzz tests work a little differently, so for now, these
functions aren't consolidated. In particular, because there are no F.Run and
F.Parallel methods, i.e., no fuzz sub-tests or parallel fuzz tests, a few
simplifications are made. We also require that F.Fuzz, F.Skip, or F.Fail is
called.</p>
               
               <pre><code>func fRunner(f *F, fn func(*F))</code></pre>
            </article>
            
            <article class="function" data-name="flushToParent">
               <h3>
                  flushToParent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>flushToParent writes c.output to the parent after first writing the header
with the given format and arguments.</p>
               
               <pre><code>func (c *common) flushToParent(testName string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="fmtDuration">
               <h3>
                  fmtDuration 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fmtDuration returns a string representing d in the form "87.00s".</p>
               
               <pre><code>func fmtDuration(d time.Duration) string</code></pre>
            </article>
            
            <article class="function" data-name="frameSkip">
               <h3>
                  frameSkip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>frameSkip searches, starting after skip frames, for the first caller frame
in a function not marked as a helper and returns that frame.
The search stops if it finds a tRunner function that
was the entry point into the test and the test is not a subtest.
This function must be called with c.mu held.</p>
               
               <pre><code>func (c *common) frameSkip(skip int) runtime.Frame</code></pre>
            </article>
            
            <article class="function" data-name="fullName">
               <h3>
                  fullName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *matcher) fullName(c *common, subname string) (name string, ok bool, partial bool)</code></pre>
            </article>
            
            <article class="function" data-name="highPrecisionTimeNow">
               <h3>
                  highPrecisionTimeNow 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>highPrecisionTimeNow returns high precision time for benchmarking.</p>
               
               <pre><code>func highPrecisionTimeNow() highPrecisionTime</code></pre>
            </article>
            
            <article class="function" data-name="highPrecisionTimeNow">
               <h3>
                  highPrecisionTimeNow 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>highPrecisionTimeNow returns high precision time for benchmarking.</p>
               
               <pre><code>func highPrecisionTimeNow() highPrecisionTime</code></pre>
            </article>
            
            <article class="function" data-name="highPrecisionTimeSince">
               <h3>
                  highPrecisionTimeSince 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>highPrecisionTimeSince returns duration since b.</p>
               
               <pre><code>func highPrecisionTimeSince(b highPrecisionTime) time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="highPrecisionTimeSince">
               <h3>
                  highPrecisionTimeSince 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>highPrecisionTimeSince returns duration since a.</p>
               
               <pre><code>func highPrecisionTimeSince(a highPrecisionTime) time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="initBenchmarkFlags">
               <h3>
                  initBenchmarkFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initBenchmarkFlags()</code></pre>
            </article>
            
            <article class="function" data-name="initFuzzFlags">
               <h3>
                  initFuzzFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initFuzzFlags()</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWindowsRetryable">
               <h3>
                  isWindowsRetryable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isWindowsRetryable reports whether err is a Windows error code
that may be fixed by retrying a failed filesystem operation.</p>
               
               <pre><code>func isWindowsRetryable(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWindowsRetryable">
               <h3>
                  isWindowsRetryable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isWindowsRetryable reports whether err is a Windows error code
that may be fixed by retrying a failed filesystem operation.</p>
               
               <pre><code>func isWindowsRetryable(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="launch">
               <h3>
                  launch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>launch launches the benchmark function. It gradually increases the number
of benchmark iterations until the benchmark runs for the requested benchtime.
launch is run by the doBench function as a separate goroutine.
run1 must have been called on b.</p>
               
               <pre><code>func (b *B) launch()</code></pre>
            </article>
            
            <article class="function" data-name="listTests">
               <h3>
                  listTests 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func listTests(matchString func(pat string, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample)</code></pre>
            </article>
            
            <article class="function" data-name="log">
               <h3>
                  log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>log generates the output. It's always at the same stack depth.</p>
               
               <pre><code>func (c *common) log(s string)</code></pre>
            </article>
            
            <article class="function" data-name="logDepth">
               <h3>
                  logDepth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>logDepth generates the output at an arbitrary stack depth.</p>
               
               <pre><code>func (c *common) logDepth(s string, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="loopSlowPath">
               <h3>
                  loopSlowPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *B) loopSlowPath() bool</code></pre>
            </article>
            
            <article class="function" data-name="matches">
               <h3>
                  matches 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m simpleMatch) matches(name []string, matchString func(pat string, str string) (bool, error)) (ok bool, partial bool)</code></pre>
            </article>
            
            <article class="function" data-name="matches">
               <h3>
                  matches 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m alternationMatch) matches(name []string, matchString func(pat string, str string) (bool, error)) (ok bool, partial bool)</code></pre>
            </article>
            
            <article class="function" data-name="mbPerSec">
               <h3>
                  mbPerSec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mbPerSec returns the "MB/s" metric.</p>
               
               <pre><code>func (r BenchmarkResult) mbPerSec() float64</code></pre>
            </article>
            
            <article class="function" data-name="mustBeNil">
               <h3>
                  mustBeNil 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mustBeNil checks the error and, if present, reports it and exits.</p>
               
               <pre><code>func mustBeNil(err error)</code></pre>
            </article>
            
            <article class="function" data-name="newChattyPrinter">
               <h3>
                  newChattyPrinter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newChattyPrinter(w io.Writer) *chattyPrinter</code></pre>
            </article>
            
            <article class="function" data-name="newMatcher">
               <h3>
                  newMatcher 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newMatcher(matchString func(pat string, str string) (bool, error), patterns string, name string, skips string) *matcher</code></pre>
            </article>
            
            <article class="function" data-name="newTestState">
               <h3>
                  newTestState 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newTestState(maxParallel int, m *matcher) *testState</code></pre>
            </article>
            
            <article class="function" data-name="parseCpuList">
               <h3>
                  parseCpuList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseCpuList()</code></pre>
            </article>
            
            <article class="function" data-name="parseSubtestNumber">
               <h3>
                  parseSubtestNumber 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseSubtestNumber splits a subtest name into a "#%02d"-formatted int32
suffix (if present), and a prefix preceding that suffix (always).</p>
               
               <pre><code>func parseSubtestNumber(s string) (prefix string, nn int32)</code></pre>
            </article>
            
            <article class="function" data-name="pcToName">
               <h3>
                  pcToName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pcToName(pc uintptr) string</code></pre>
            </article>
            
            <article class="function" data-name="predictN">
               <h3>
                  predictN 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func predictN(goalns int64, prevIters int64, prevns int64, last int64) int</code></pre>
            </article>
            
            <article class="function" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>prefix is like chatty.prefix but using p.json instead of chatty.json.
Using p.json allows tests to check the json behavior without modifying
the global variable. For convenience, we allow p == nil and treat
that as not in json mode (because it's not chatty at all).</p>
               
               <pre><code>func (p *chattyPrinter) prefix() string</code></pre>
            </article>
            
            <article class="function" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *chattyFlag) prefix() string</code></pre>
            </article>
            
            <article class="function" data-name="prettyPrint">
               <h3>
                  prettyPrint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func prettyPrint(w io.Writer, x float64, unit string)</code></pre>
            </article>
            
            <article class="function" data-name="private">
               <h3>
                  private 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *common) private()</code></pre>
            </article>
            
            <article class="function" data-name="processBench">
               <h3>
                  processBench 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>processBench runs bench b for the configured CPU counts and prints the results.</p>
               
               <pre><code>func (s *benchState) processBench(b *B)</code></pre>
            </article>
            
            <article class="function" data-name="processRunResult">
               <h3>
                  processRunResult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>processRunResult computes a summary and status of the result of running an example test.
stdout is the captured output from stdout of the test.
recovered is the result of invoking recover after running the test, in case it panicked.
If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout.
If the test is chatty/verbose, it'll print a success message to stdout.
If recovered is non-nil, it'll panic with that value.
If the test panicked with nil, or invoked runtime.Goexit, it'll be
made to fail and panic with errNilPanicOrGoexit</p>
               
               <pre><code>func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered any) (passed bool)</code></pre>
            </article>
            
            <article class="function" data-name="registerCover2">
               <h3>
                  registerCover2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>registerCover2 is invoked during "go test -cover" runs.
It is used to record a 'tear down' function
(to be called when the test is complete) and the coverage mode.</p>
               
               <pre><code>func registerCover2(mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64)</code></pre>
            </article>
            
            <article class="function" data-name="release">
               <h3>
                  release 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *testState) release()</code></pre>
            </article>
            
            <article class="function" data-name="removeAll">
               <h3>
                  removeAll 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>removeAll is like os.RemoveAll, but retries Windows "Access is denied."
errors up to an arbitrary timeout.
Those errors have been known to occur spuriously on at least the
windows-amd64-2012 builder (https://go.dev/issue/50051), and can only occur
legitimately if the test leaves behind a temp file that either is still open
or the test otherwise lacks permission to delete. In the case of legitimate
failures, a failing test may take a bit longer to fail, but once the test is
fixed the extra latency will go away.</p>
               
               <pre><code>func removeAll(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="report">
               <h3>
                  report 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *T) report()</code></pre>
            </article>
            
            <article class="function" data-name="report">
               <h3>
                  report 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *F) report()</code></pre>
            </article>
            
            <article class="function" data-name="resetRaces">
               <h3>
                  resetRaces 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resetRaces updates c.parent's count of data race errors (or the global count,
if c has no parent), and updates c.lastRaceErrors to match.
Any races that occurred prior to this call to resetRaces will
not be attributed to c.</p>
               
               <pre><code>func (c *common) resetRaces()</code></pre>
            </article>
            
            <article class="function" data-name="rewrite">
               <h3>
                  rewrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rewrite rewrites a subname to having only printable characters and no white
space.</p>
               
               <pre><code>func rewrite(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>run executes the benchmark in a separate goroutine, including all of its
subbenchmarks. b must not have subbenchmarks.</p>
               
               <pre><code>func (b *B) run()</code></pre>
            </article>
            
            <article class="function" data-name="run1">
               <h3>
                  run1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>run1 runs the first iteration of benchFunc. It reports whether more
iterations of this benchmarks should be run.</p>
               
               <pre><code>func (b *B) run1() bool</code></pre>
            </article>
            
            <article class="function" data-name="runBenchmarks">
               <h3>
                  runBenchmarks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runBenchmarks(importPath string, matchString func(pat string, str string) (bool, error), benchmarks []InternalBenchmark) bool</code></pre>
            </article>
            
            <article class="function" data-name="runCleanup">
               <h3>
                  runCleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>runCleanup is called at the end of the test.
If ph is recoverAndReturnPanic, it will catch panics, and return the
recovered value if any.</p>
               
               <pre><code>func (c *common) runCleanup(ph panicHandling) (panicVal any)</code></pre>
            </article>
            
            <article class="function" data-name="runExample">
               <h3>
                  runExample 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TODO(@musiol, @odeke-em): unify this code back into
example.go when js/wasm gets an os.Pipe implementation.</p>
               
               <pre><code>func runExample(eg InternalExample) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="runExample">
               <h3>
                  runExample 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runExample(eg InternalExample) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="runExamples">
               <h3>
                  runExamples 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runExamples(matchString func(pat string, str string) (bool, error), examples []InternalExample) (ran bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="runFuzzTests">
               <h3>
                  runFuzzTests 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runFuzzTests runs the fuzz tests matching the pattern for -run. This will
only run the (*F).Fuzz function for each seed corpus without using the
fuzzing engine to generate or mutate inputs.</p>
               
               <pre><code>func runFuzzTests(deps testDeps, fuzzTests []InternalFuzzTarget, deadline time.Time) (ran bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="runFuzzing">
               <h3>
                  runFuzzing 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runFuzzing runs the fuzz test matching the pattern for -fuzz. Only one such
fuzz test must match. This will run the fuzzing engine to generate and
mutate new inputs against the fuzz target.
If fuzzing is disabled (-test.fuzz is not set), runFuzzing
returns immediately.</p>
               
               <pre><code>func runFuzzing(deps testDeps, fuzzTests []InternalFuzzTarget) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="runN">
               <h3>
                  runN 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>runN runs a single benchmark for the specified number of iterations.</p>
               
               <pre><code>func (b *B) runN(n int)</code></pre>
            </article>
            
            <article class="function" data-name="runTests">
               <h3>
                  runTests 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runTests(matchString func(pat string, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="runningList">
               <h3>
                  runningList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runningList returns the list of running tests.</p>
               
               <pre><code>func runningList() []string</code></pre>
            </article>
            
            <article class="function" data-name="setRan">
               <h3>
                  setRan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *common) setRan()</code></pre>
            </article>
            
            <article class="function" data-name="shouldFailFast">
               <h3>
                  shouldFailFast 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func shouldFailFast() bool</code></pre>
            </article>
            
            <article class="function" data-name="sortLines">
               <h3>
                  sortLines 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sortLines(output string) string</code></pre>
            </article>
            
            <article class="function" data-name="splitRegexp">
               <h3>
                  splitRegexp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func splitRegexp(s string) filterMatch</code></pre>
            </article>
            
            <article class="function" data-name="startAlarm">
               <h3>
                  startAlarm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>startAlarm starts an alarm if requested.</p>
               
               <pre><code>func (m *M) startAlarm() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="stopAlarm">
               <h3>
                  stopAlarm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stopAlarm turns off the alarm.</p>
               
               <pre><code>func (m *M) stopAlarm()</code></pre>
            </article>
            
            <article class="function" data-name="stopOrScaleBLoop">
               <h3>
                  stopOrScaleBLoop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *B) stopOrScaleBLoop() bool</code></pre>
            </article>
            
            <article class="function" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a highPrecisionTime) sub(b highPrecisionTime) time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="tRunner">
               <h3>
                  tRunner 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func tRunner(t *T, fn func(t *T))</code></pre>
            </article>
            
            <article class="function" data-name="toOutputDir">
               <h3>
                  toOutputDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>toOutputDir returns the file name relocated, if required, to outputDir.
Simple implementation to avoid pulling in path/filepath.</p>
               
               <pre><code>func toOutputDir(path string) string</code></pre>
            </article>
            
            <article class="function" data-name="trimOutput">
               <h3>
                  trimOutput 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>trimOutput shortens the output from a benchmark, which can be very long.</p>
               
               <pre><code>func (b *B) trimOutput()</code></pre>
            </article>
            
            <article class="function" data-name="unique">
               <h3>
                  unique 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unique creates a unique name for the given parent and subname by affixing it
with one or more counts, if necessary.</p>
               
               <pre><code>func (m *matcher) unique(parent string, subname string) string</code></pre>
            </article>
            
            <article class="function" data-name="verify">
               <h3>
                  verify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m simpleMatch) verify(name string, matchString func(pat string, str string) (bool, error)) error</code></pre>
            </article>
            
            <article class="function" data-name="verify">
               <h3>
                  verify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m alternationMatch) verify(name string, matchString func(pat string, str string) (bool, error)) error</code></pre>
            </article>
            
            <article class="function" data-name="waitParallel">
               <h3>
                  waitParallel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *testState) waitParallel()</code></pre>
            </article>
            
            <article class="function" data-name="writeProfiles">
               <h3>
                  writeProfiles 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *M) writeProfiles()</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
