<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - netip</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>netip</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmp"
"errors"
"internal/bytealg"
"internal/byteorder"
"internal/itoa"
"math"
"strconv"
"unique"
"math/bits"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="digits">
               <h3>
                  digits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>digits is a string of the hex digits from 0 to f. It's used in
appendDecimal and appendHex to format IP addresses.</p>
               
               <pre><code>const digits = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global" data-name="z0">
               <h3>
                  z0 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>z0, z4, and z6noz are sentinel Addr.z values.
See the Addr type's field docs.</p>
               
               <pre><code>var z0 *ast.IndexExpr</code></pre>
            </article>
            
            <article class="global" data-name="z4">
               <h3>
                  z4 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>z0, z4, and z6noz are sentinel Addr.z values.
See the Addr type's field docs.</p>
               
               <pre><code>var z4 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="z6noz">
               <h3>
                  z6noz 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>z0, z4, and z6noz are sentinel Addr.z values.
See the Addr type's field docs.</p>
               
               <pre><code>var z6noz = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Addr">
               <h3>
                  Addr
                  <span class="badge">struct</span>
               </h3>
               
               <p>Addr represents an IPv4 or IPv6 address (with or without a scoped
addressing zone), similar to [net.IP] or [net.IPAddr].
Unlike [net.IP] or [net.IPAddr], Addr is a comparable value
type (it supports == and can be a map key) and is immutable.
The zero Addr is not a valid IP address.
Addr{} is distinct from both 0.0.0.0 and ::.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Addr struct {
addr uint128
z *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="AddrPort">
               <h3>
                  AddrPort
                  <span class="badge">struct</span>
               </h3>
               
               <p>AddrPort is an IP and a port number.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AddrPort struct {
ip Addr
port uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="Prefix">
               <h3>
                  Prefix
                  <span class="badge">struct</span>
               </h3>
               
               <p>Prefix is an IP address prefix (CIDR) representing an IP network.
The first [Prefix.Bits]() of [Addr]() are specified. The remaining bits match any address.
The range of Bits() is [0,32] for IPv4 or [0,128] for IPv6.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Prefix struct {
ip Addr
bitsPlusOne uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="addrDetail">
               <h3>
                  addrDetail
                  <span class="badge">struct</span>
               </h3>
               
               <p>addrDetail represents the details of an Addr, like address family and IPv6 zone.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type addrDetail struct {
isV6 bool
zoneV6 string
}</code></pre>
            </article>
            
            <article class="struct" data-name="parseAddrError">
               <h3>
                  parseAddrError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parseAddrError struct {
in string
msg string
at string
}</code></pre>
            </article>
            
            <article class="struct" data-name="parsePrefixError">
               <h3>
                  parsePrefixError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parsePrefixError struct {
in string
msg string
}</code></pre>
            </article>
            
            <article class="struct" data-name="uint128">
               <h3>
                  uint128
                  <span class="badge">struct</span>
               </h3>
               
               <p>uint128 represents a uint128 using two uint64s.
When the methods below mention a bit number, bit 0 is the most
significant bit (in hi) and bit 127 is the lowest (lo&1).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type uint128 struct {
hi uint64
lo uint64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Addr returns p's IP address.</p>
               
               <pre><code>func (p Prefix) Addr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Addr returns p's IP address.</p>
               
               <pre><code>func (p AddrPort) Addr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="AddrFrom16">
               <h3>
                  AddrFrom16 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddrFrom16 returns the IPv6 address given by the bytes in addr.
An IPv4-mapped IPv6 address is left as an IPv6 address.
(Use Unmap to convert them if needed.)</p>
               
               <pre><code>func AddrFrom16(addr [16]byte) Addr</code></pre>
            </article>
            
            <article class="function" data-name="AddrFrom4">
               <h3>
                  AddrFrom4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddrFrom4 returns the address of the IPv4 address given by the bytes in addr.</p>
               
               <pre><code>func AddrFrom4(addr [4]byte) Addr</code></pre>
            </article>
            
            <article class="function" data-name="AddrFromSlice">
               <h3>
                  AddrFromSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6 address.
Note that a [net.IP] can be passed directly as the []byte argument.
If slice's length is not 4 or 16, AddrFromSlice returns [Addr]{}, false.</p>
               
               <pre><code>func AddrFromSlice(slice []byte) (ip Addr, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="AddrPortFrom">
               <h3>
                  AddrPortFrom 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddrPortFrom returns an [AddrPort] with the provided IP and port.
It does not allocate.</p>
               
               <pre><code>func AddrPortFrom(ip Addr, port uint16) AddrPort</code></pre>
            </article>
            
            <article class="function" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendBinary implements the [encoding.BinaryAppender] interface.</p>
               
               <pre><code>func (ip Addr) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendBinary implements the [encoding.BinaryAppendler] interface.
It returns [Addr.AppendBinary] with an additional two bytes appended
containing the port in little-endian.</p>
               
               <pre><code>func (p AddrPort) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendBinary implements the [encoding.AppendMarshaler] interface.
It returns [Addr.AppendBinary] with an additional byte appended
containing the prefix bits.</p>
               
               <pre><code>func (p Prefix) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.
It is the same as [Prefix.AppendTo].</p>
               
               <pre><code>func (p Prefix) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface,
It is the same as [Addr.AppendTo].</p>
               
               <pre><code>func (ip Addr) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface. The
encoding is the same as returned by [AddrPort.AppendTo].</p>
               
               <pre><code>func (p AddrPort) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendTo">
               <h3>
                  AppendTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendTo appends a text encoding of p,
as generated by [Prefix.MarshalText],
to b and returns the extended buffer.</p>
               
               <pre><code>func (p Prefix) AppendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="AppendTo">
               <h3>
                  AppendTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendTo appends a text encoding of p,
as generated by [AddrPort.MarshalText],
to b and returns the extended buffer.</p>
               
               <pre><code>func (p AddrPort) AppendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="AppendTo">
               <h3>
                  AppendTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendTo appends a text encoding of ip,
as generated by [Addr.MarshalText],
to b and returns the extended buffer.</p>
               
               <pre><code>func (ip Addr) AppendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="As16">
               <h3>
                  As16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>As16 returns the IP address in its 16-byte representation.
IPv4 addresses are returned as IPv4-mapped IPv6 addresses.
IPv6 addresses with zones are returned without their zone (use the
[Addr.Zone] method to get it).
The ip zero value returns all zeroes.</p>
               
               <pre><code>func (ip Addr) As16() (a16 [16]byte)</code></pre>
            </article>
            
            <article class="function" data-name="As4">
               <h3>
                  As4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation.
If ip is the zero [Addr] or an IPv6 address, As4 panics.
Note that 0.0.0.0 is not the zero Addr.</p>
               
               <pre><code>func (ip Addr) As4() (a4 [4]byte)</code></pre>
            </article>
            
            <article class="function" data-name="AsSlice">
               <h3>
                  AsSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte representation.</p>
               
               <pre><code>func (ip Addr) AsSlice() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BitLen">
               <h3>
                  BitLen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BitLen returns the number of bits in the IP address:
128 for IPv6, 32 for IPv4, and 0 for the zero [Addr].
Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses
and therefore have bit length 128.</p>
               
               <pre><code>func (ip Addr) BitLen() int</code></pre>
            </article>
            
            <article class="function" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bits returns p's prefix length.
It reports -1 if invalid.</p>
               
               <pre><code>func (p Prefix) Bits() int</code></pre>
            </article>
            
            <article class="function" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compare returns an integer comparing two AddrPorts.
The result will be 0 if p == p2, -1 if p < p2, and +1 if p > p2.
AddrPorts sort first by IP address, then port.</p>
               
               <pre><code>func (p AddrPort) Compare(p2 AddrPort) int</code></pre>
            </article>
            
            <article class="function" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compare returns an integer comparing two IPs.
The result will be 0 if ip == ip2, -1 if ip < ip2, and +1 if ip > ip2.
The definition of "less than" is the same as the [Addr.Less] method.</p>
               
               <pre><code>func (ip Addr) Compare(ip2 Addr) int</code></pre>
            </article>
            
            <article class="function" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Contains reports whether the network p includes ip.
An IPv4 address will not match an IPv6 prefix.
An IPv4-mapped IPv6 address will not match an IPv4 prefix.
A zero-value IP will not match any prefix.
If ip has an IPv6 zone, Contains returns false,
because Prefixes strip zones.</p>
               
               <pre><code>func (p Prefix) Contains(ip Addr) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (err parseAddrError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (err parsePrefixError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="IPv4Unspecified">
               <h3>
                  IPv4Unspecified 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv4Unspecified returns the IPv4 unspecified address "0.0.0.0".</p>
               
               <pre><code>func IPv4Unspecified() Addr</code></pre>
            </article>
            
            <article class="function" data-name="IPv6LinkLocalAllNodes">
               <h3>
                  IPv6LinkLocalAllNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast
address ff02::1.</p>
               
               <pre><code>func IPv6LinkLocalAllNodes() Addr</code></pre>
            </article>
            
            <article class="function" data-name="IPv6LinkLocalAllRouters">
               <h3>
                  IPv6LinkLocalAllRouters 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast
address ff02::2.</p>
               
               <pre><code>func IPv6LinkLocalAllRouters() Addr</code></pre>
            </article>
            
            <article class="function" data-name="IPv6Loopback">
               <h3>
                  IPv6Loopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv6Loopback returns the IPv6 loopback address ::1.</p>
               
               <pre><code>func IPv6Loopback() Addr</code></pre>
            </article>
            
            <article class="function" data-name="IPv6Unspecified">
               <h3>
                  IPv6Unspecified 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv6Unspecified returns the IPv6 unspecified address "::".</p>
               
               <pre><code>func IPv6Unspecified() Addr</code></pre>
            </article>
            
            <article class="function" data-name="Is4">
               <h3>
                  Is4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Is4 reports whether ip is an IPv4 address.
It returns false for IPv4-mapped IPv6 addresses. See [Addr.Unmap].</p>
               
               <pre><code>func (ip Addr) Is4() bool</code></pre>
            </article>
            
            <article class="function" data-name="Is4In6">
               <h3>
                  Is4In6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Is4In6 reports whether ip is an "IPv4-mapped IPv6 address"
as defined by RFC 4291.
That is, it reports whether ip is in ::ffff:0:0/96.</p>
               
               <pre><code>func (ip Addr) Is4In6() bool</code></pre>
            </article>
            
            <article class="function" data-name="Is6">
               <h3>
                  Is6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Is6 reports whether ip is an IPv6 address, including IPv4-mapped
IPv6 addresses.</p>
               
               <pre><code>func (ip Addr) Is6() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsGlobalUnicast">
               <h3>
                  IsGlobalUnicast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsGlobalUnicast reports whether ip is a global unicast address.
It returns true for IPv6 addresses which fall outside of the current
IANA-allocated 2000::/3 global unicast space, with the exception of the
link-local address space. It also returns true even if ip is in the IPv4
private address space or IPv6 unique local address space.
It returns false for the zero [Addr].
For reference, see RFC 1122, RFC 4291, and RFC 4632.</p>
               
               <pre><code>func (ip Addr) IsGlobalUnicast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsInterfaceLocalMulticast">
               <h3>
                  IsInterfaceLocalMulticast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local
multicast address.</p>
               
               <pre><code>func (ip Addr) IsInterfaceLocalMulticast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLinkLocalMulticast">
               <h3>
                  IsLinkLocalMulticast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</p>
               
               <pre><code>func (ip Addr) IsLinkLocalMulticast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLinkLocalUnicast">
               <h3>
                  IsLinkLocalUnicast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</p>
               
               <pre><code>func (ip Addr) IsLinkLocalUnicast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLoopback">
               <h3>
                  IsLoopback 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLoopback reports whether ip is a loopback address.</p>
               
               <pre><code>func (ip Addr) IsLoopback() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMulticast">
               <h3>
                  IsMulticast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsMulticast reports whether ip is a multicast address.</p>
               
               <pre><code>func (ip Addr) IsMulticast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPrivate">
               <h3>
                  IsPrivate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPrivate reports whether ip is a private address, according to RFC 1918
(IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether
ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the
same as [net.IP.IsPrivate].</p>
               
               <pre><code>func (ip Addr) IsPrivate() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSingleIP">
               <h3>
                  IsSingleIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsSingleIP reports whether p contains exactly one IP.</p>
               
               <pre><code>func (p Prefix) IsSingleIP() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsUnspecified">
               <h3>
                  IsUnspecified 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsUnspecified reports whether ip is an unspecified address, either the IPv4
address "0.0.0.0" or the IPv6 address "::".
Note that the zero [Addr] is not an unspecified address.</p>
               
               <pre><code>func (ip Addr) IsUnspecified() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsValid reports whether p.Addr() is valid.
All ports are valid, including zero.</p>
               
               <pre><code>func (p AddrPort) IsValid() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsValid reports whether the [Addr] is an initialized address (not the zero Addr).
Note that "0.0.0.0" and "::" are both valid values.</p>
               
               <pre><code>func (ip Addr) IsValid() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsValid reports whether p.Bits() has a valid range for p.Addr().
If p.Addr() is the zero [Addr], IsValid returns false.
Note that if p is the zero [Prefix], then p.IsValid() == false.</p>
               
               <pre><code>func (p Prefix) IsValid() bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Less reports whether ip sorts before ip2.
IP addresses sort first by length, then their address.
IPv6 addresses with zones sort just after the same address without a zone.</p>
               
               <pre><code>func (ip Addr) Less(ip2 Addr) bool</code></pre>
            </article>
            
            <article class="function" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.
It returns [Addr.MarshalBinary] with an additional two bytes appended
containing the port in little-endian.</p>
               
               <pre><code>func (p AddrPort) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.
It returns a zero-length slice for the zero [Addr],
the 4-byte form for an IPv4 address,
and the 16-byte form with zone appended for an IPv6 address.</p>
               
               <pre><code>func (ip Addr) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.
It returns [Addr.MarshalBinary] with an additional byte appended
containing the prefix bits.</p>
               
               <pre><code>func (p Prefix) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface. The
encoding is the same as returned by [AddrPort.String], with one exception: if
p.Addr() is the zero [Addr], the encoding is the empty string.</p>
               
               <pre><code>func (p AddrPort) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface,
The encoding is the same as returned by [Addr.String], with one exception:
If ip is the zero [Addr], the encoding is the empty string.</p>
               
               <pre><code>func (ip Addr) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface,
The encoding is the same as returned by [Prefix.String], with one exception:
If p is the zero value, the encoding is the empty string.</p>
               
               <pre><code>func (p Prefix) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Masked">
               <h3>
                  Masked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Masked returns p in its canonical form, with all but the high
p.Bits() bits of p.Addr() masked off.
If p is zero or otherwise invalid, Masked returns the zero [Prefix].</p>
               
               <pre><code>func (p Prefix) Masked() Prefix</code></pre>
            </article>
            
            <article class="function" data-name="MustParseAddr">
               <h3>
                  MustParseAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParseAddr calls [ParseAddr](s) and panics on error.
It is intended for use in tests with hard-coded strings.</p>
               
               <pre><code>func MustParseAddr(s string) Addr</code></pre>
            </article>
            
            <article class="function" data-name="MustParseAddrPort">
               <h3>
                  MustParseAddrPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParseAddrPort calls [ParseAddrPort](s) and panics on error.
It is intended for use in tests with hard-coded strings.</p>
               
               <pre><code>func MustParseAddrPort(s string) AddrPort</code></pre>
            </article>
            
            <article class="function" data-name="MustParsePrefix">
               <h3>
                  MustParsePrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustParsePrefix calls [ParsePrefix](s) and panics on error.
It is intended for use in tests with hard-coded strings.</p>
               
               <pre><code>func MustParsePrefix(s string) Prefix</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next returns the address following ip.
If there is none, it returns the zero [Addr].</p>
               
               <pre><code>func (ip Addr) Next() Addr</code></pre>
            </article>
            
            <article class="function" data-name="Overlaps">
               <h3>
                  Overlaps 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Overlaps reports whether p and o contain any IP addresses in common.
If p and o are of different address families or either have a zero
IP, it reports false. Like the Contains method, a prefix with an
IPv4-mapped IPv6 address is still treated as an IPv6 mask.</p>
               
               <pre><code>func (p Prefix) Overlaps(o Prefix) bool</code></pre>
            </article>
            
            <article class="function" data-name="ParseAddr">
               <h3>
                  ParseAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseAddr parses s as an IP address, returning the result. The string
s can be in dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"),
or IPv6 with a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").</p>
               
               <pre><code>func ParseAddr(s string) (Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseAddrPort">
               <h3>
                  ParseAddrPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseAddrPort parses s as an [AddrPort].
It doesn't do any name resolution: both the address and the port
must be numeric.</p>
               
               <pre><code>func ParseAddrPort(s string) (AddrPort, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParsePrefix">
               <h3>
                  ParsePrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParsePrefix parses s as an IP address prefix.
The string can be in the form "192.168.1.0/24" or "2001:db8::/32",
the CIDR notation defined in RFC 4632 and RFC 4291.
IPv6 zones are not permitted in prefixes, and an error will be returned if a
zone is present.
Note that masked address bits are not zeroed. Use Masked for that.</p>
               
               <pre><code>func ParsePrefix(s string) (Prefix, error)</code></pre>
            </article>
            
            <article class="function" data-name="Port">
               <h3>
                  Port 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Port returns p's port.</p>
               
               <pre><code>func (p AddrPort) Port() uint16</code></pre>
            </article>
            
            <article class="function" data-name="Prefix">
               <h3>
                  Prefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prefix keeps only the top b bits of IP, producing a Prefix
of the specified length.
If ip is a zero [Addr], Prefix always returns a zero Prefix and a nil error.
Otherwise, if bits is less than zero or greater than ip.BitLen(),
Prefix returns an error.</p>
               
               <pre><code>func (ip Addr) Prefix(b int) (Prefix, error)</code></pre>
            </article>
            
            <article class="function" data-name="PrefixFrom">
               <h3>
                  PrefixFrom 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PrefixFrom returns a [Prefix] with the provided IP address and bit
prefix length.
It does not allocate. Unlike [Addr.Prefix], [PrefixFrom] does not mask
off the host bits of ip.
If bits is less than zero or greater than ip.BitLen, [Prefix.Bits]
will return an invalid value -1.</p>
               
               <pre><code>func PrefixFrom(ip Addr, bits int) Prefix</code></pre>
            </article>
            
            <article class="function" data-name="Prev">
               <h3>
                  Prev 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prev returns the IP before ip.
If there is none, it returns the IP zero value.</p>
               
               <pre><code>func (ip Addr) Prev() Addr</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p AddrPort) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the CIDR notation of p: "<ip>/<bits>".</p>
               
               <pre><code>func (p Prefix) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the string form of the IP address ip.
It returns one of 5 forms:
- "invalid IP", if ip is the zero [Addr]
- IPv4 dotted decimal ("192.0.2.1")
- IPv6 ("2001:db8::1")
- "::ffff:1.2.3.4" (if [Addr.Is4In6])
- IPv6 with zone ("fe80:db8::1%eth0")
Note that unlike package net's IP.String method,
IPv4-mapped IPv6 addresses format with a "::ffff:"
prefix before the dotted quad.</p>
               
               <pre><code>func (ip Addr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="StringExpanded">
               <h3>
                  StringExpanded 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StringExpanded is like [Addr.String] but IPv6 addresses are expanded with leading
zeroes and no "::" compression. For example, "2001:db8::1" becomes
"2001:0db8:0000:0000:0000:0000:0000:0001".</p>
               
               <pre><code>func (ip Addr) StringExpanded() string</code></pre>
            </article>
            
            <article class="function" data-name="Unmap">
               <h3>
                  Unmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unmap returns ip with any IPv4-mapped IPv6 address prefix removed.
That is, if ip is an IPv6 address wrapping an IPv4 address, it
returns the wrapped IPv4 address. Otherwise it returns ip unmodified.</p>
               
               <pre><code>func (ip Addr) Unmap() Addr</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.
It expects data in the form generated by [Prefix.MarshalBinary].</p>
               
               <pre><code>func (p *Prefix) UnmarshalBinary(b []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.
It expects data in the form generated by MarshalBinary.</p>
               
               <pre><code>func (ip *Addr) UnmarshalBinary(b []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.
It expects data in the form generated by [AddrPort.MarshalBinary].</p>
               
               <pre><code>func (p *AddrPort) UnmarshalBinary(b []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements the encoding.TextUnmarshaler interface.
The IP address is expected in a form accepted by [ParsePrefix]
or generated by [Prefix.MarshalText].</p>
               
               <pre><code>func (p *Prefix) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements the encoding.TextUnmarshaler interface.
The IP address is expected in a form accepted by [ParseAddr].
If text is empty, UnmarshalText sets *ip to the zero [Addr] and
returns no error.</p>
               
               <pre><code>func (ip *Addr) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements the encoding.TextUnmarshaler
interface. The [AddrPort] is expected in a form
generated by [AddrPort.MarshalText] or accepted by [ParseAddrPort].</p>
               
               <pre><code>func (p *AddrPort) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="WithZone">
               <h3>
                  WithZone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WithZone returns an IP that's the same as ip but with the provided
zone. If zone is empty, the zone is removed. If ip is an IPv4
address, WithZone is a no-op and returns ip unchanged.</p>
               
               <pre><code>func (ip Addr) WithZone(zone string) Addr</code></pre>
            </article>
            
            <article class="function" data-name="Zone">
               <h3>
                  Zone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Zone returns ip's IPv6 scoped addressing zone, if any.</p>
               
               <pre><code>func (ip Addr) Zone() string</code></pre>
            </article>
            
            <article class="function" data-name="addOne">
               <h3>
                  addOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addOne returns u + 1.</p>
               
               <pre><code>func (u uint128) addOne() uint128</code></pre>
            </article>
            
            <article class="function" data-name="and">
               <h3>
                  and 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>and returns the bitwise AND of u and m (u&m).</p>
               
               <pre><code>func (u uint128) and(m uint128) uint128</code></pre>
            </article>
            
            <article class="function" data-name="appendDecimal">
               <h3>
                  appendDecimal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendDecimal appends the decimal string representation of x to b.</p>
               
               <pre><code>func appendDecimal(b []byte, x uint8) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendHex">
               <h3>
                  appendHex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendHex appends the hex string representation of x to b.</p>
               
               <pre><code>func appendHex(b []byte, x uint16) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendHexPad">
               <h3>
                  appendHexPad 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendHexPad appends the fully padded hex string representation of x to b.</p>
               
               <pre><code>func appendHexPad(b []byte, x uint16) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendTo4">
               <h3>
                  appendTo4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip Addr) appendTo4(ret []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendTo4In6">
               <h3>
                  appendTo4In6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip Addr) appendTo4In6(ret []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendTo6">
               <h3>
                  appendTo6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip Addr) appendTo6(ret []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bitsClearedFrom">
               <h3>
                  bitsClearedFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bitsClearedFrom returns a copy of u with the given bit
and all subsequent ones cleared.</p>
               
               <pre><code>func (u uint128) bitsClearedFrom(bit uint8) uint128</code></pre>
            </article>
            
            <article class="function" data-name="bitsSetFrom">
               <h3>
                  bitsSetFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bitsSetFrom returns a copy of u with the given bit
and all subsequent ones set.</p>
               
               <pre><code>func (u uint128) bitsSetFrom(bit uint8) uint128</code></pre>
            </article>
            
            <article class="function" data-name="compare">
               <h3>
                  compare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>compare returns an integer comparing two prefixes.
The result will be 0 if p == p2, -1 if p < p2, and +1 if p > p2.
Prefixes sort first by validity (invalid before valid), then
address family (IPv4 before IPv6), then prefix length, then
address.
Unexported for Go 1.22 because we may want to compare by p.Addr first.
See post-acceptance discussion on go.dev/issue/61642.</p>
               
               <pre><code>func (p Prefix) compare(p2 Prefix) int</code></pre>
            </article>
            
            <article class="function" data-name="halves">
               <h3>
                  halves 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>halves returns the two uint64 halves of the uint128.
Logically, think of it as returning two uint64s.
It only returns pointers for inlining reasons on 32-bit platforms.</p>
               
               <pre><code>func (u *uint128) halves() [2]*uint64</code></pre>
            </article>
            
            <article class="function" data-name="hasZone">
               <h3>
                  hasZone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hasZone reports whether ip has an IPv6 zone.</p>
               
               <pre><code>func (ip Addr) hasZone() bool</code></pre>
            </article>
            
            <article class="function" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isZero reports whether ip is the zero value of the IP type.
The zero value is not a valid IP address of any type.
Note that "0.0.0.0" and "::" are not the zero value. Use IsUnspecified to
check for these values instead.</p>
               
               <pre><code>func (ip Addr) isZero() bool</code></pre>
            </article>
            
            <article class="function" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Prefix) isZero() bool</code></pre>
            </article>
            
            <article class="function" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isZero reports whether u == 0.
It's faster than u == (uint128{}) because the compiler (as of Go
1.15/1.16b1) doesn't do this trick and instead inserts a branch in
its eq alg's generated code.</p>
               
               <pre><code>func (u uint128) isZero() bool</code></pre>
            </article>
            
            <article class="function" data-name="marshalBinarySize">
               <h3>
                  marshalBinarySize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip Addr) marshalBinarySize() int</code></pre>
            </article>
            
            <article class="function" data-name="mask6">
               <h3>
                  mask6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mask6 returns a uint128 bitmask with the topmost n bits of a
128-bit number.</p>
               
               <pre><code>func mask6(n int) uint128</code></pre>
            </article>
            
            <article class="function" data-name="not">
               <h3>
                  not 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>not returns the bitwise NOT of u.</p>
               
               <pre><code>func (u uint128) not() uint128</code></pre>
            </article>
            
            <article class="function" data-name="or">
               <h3>
                  or 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>or returns the bitwise OR of u and m (u|m).</p>
               
               <pre><code>func (u uint128) or(m uint128) uint128</code></pre>
            </article>
            
            <article class="function" data-name="parseIPv4">
               <h3>
                  parseIPv4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseIPv4 parses s as an IPv4 address (in form "192.168.0.1").</p>
               
               <pre><code>func parseIPv4(s string) (ip Addr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseIPv4Fields">
               <h3>
                  parseIPv4Fields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseIPv4Fields(in string, off int, end int, fields []uint8) error</code></pre>
            </article>
            
            <article class="function" data-name="parseIPv6">
               <h3>
                  parseIPv6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseIPv6 parses s as an IPv6 address (in form "2001:db8::68").</p>
               
               <pre><code>func parseIPv6(in string) (Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="splitAddrPort">
               <h3>
                  splitAddrPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitAddrPort splits s into an IP address string and a port
string. It splits strings shaped like "foo:bar" or "[foo]:bar",
without further validating the substrings. v6 indicates whether the
ip string should parse as an IPv6 address or an IPv4 address, in
order for s to be a valid ip:port string.</p>
               
               <pre><code>func splitAddrPort(s string) (ip string, port string, v6 bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="string4">
               <h3>
                  string4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip Addr) string4() string</code></pre>
            </article>
            
            <article class="function" data-name="string4In6">
               <h3>
                  string4In6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip Addr) string4In6() string</code></pre>
            </article>
            
            <article class="function" data-name="string6">
               <h3>
                  string6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>string6 formats ip in IPv6 textual representation. It follows the
guidelines in section 4 of RFC 5952
(https://tools.ietf.org/html/rfc5952#section-4): no unnecessary
zeros, use :: to elide the longest run of zeros, and don't use ::
to compact a single zero field.</p>
               
               <pre><code>func (ip Addr) string6() string</code></pre>
            </article>
            
            <article class="function" data-name="subOne">
               <h3>
                  subOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>subOne returns u - 1.</p>
               
               <pre><code>func (u uint128) subOne() uint128</code></pre>
            </article>
            
            <article class="function" data-name="v4">
               <h3>
                  v4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>v4 returns the i'th byte of ip. If ip is not an IPv4, v4 returns
unspecified garbage.</p>
               
               <pre><code>func (ip Addr) v4(i uint8) uint8</code></pre>
            </article>
            
            <article class="function" data-name="v6">
               <h3>
                  v6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>v6 returns the i'th byte of ip. If ip is an IPv4 address, this
accesses the IPv4-mapped IPv6 address form of the IP.</p>
               
               <pre><code>func (ip Addr) v6(i uint8) uint8</code></pre>
            </article>
            
            <article class="function" data-name="v6u16">
               <h3>
                  v6u16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>v6u16 returns the i'th 16-bit word of ip. If ip is an IPv4 address,
this accesses the IPv4-mapped IPv6 address form of the IP.</p>
               
               <pre><code>func (ip Addr) v6u16(i uint8) uint16</code></pre>
            </article>
            
            <article class="function" data-name="withoutZone">
               <h3>
                  withoutZone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>withoutZone unconditionally strips the zone from ip.
It's similar to WithZone, but small enough to be inlinable.</p>
               
               <pre><code>func (ip Addr) withoutZone() Addr</code></pre>
            </article>
            
            <article class="function" data-name="xor">
               <h3>
                  xor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>xor returns the bitwise XOR of u and m (u^m).</p>
               
               <pre><code>func (u uint128) xor(m uint128) uint128</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
