<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - netip_test</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>netip_test</code>
         </h1>
         <hr />
         
         <article class="global" data-name="corpus">
            <h2>corpus</h2>
            <hr />
            
            <pre><code>corpus</code></pre>
         </article>
         
         <article class="global" data-name="long">
            <h2>long</h2>
            <hr />
            
            <pre><code>long</code></pre>
         </article>
         
         <article class="global" data-name="mustPrefix">
            <h2>mustPrefix</h2>
            <hr />
            
            <pre><code>mustPrefix</code></pre>
         </article>
         
         <article class="global" data-name="mustIP">
            <h2>mustIP</h2>
            <hr />
            
            <pre><code>mustIP</code></pre>
         </article>
         
         <article class="global" data-name="mustIPPort">
            <h2>mustIPPort</h2>
            <hr />
            
            <pre><code>mustIPPort</code></pre>
         </article>
         
         <article class="global" data-name="parseBenchInputs">
            <h2>parseBenchInputs</h2>
            <hr />
            
            <pre><code>parseBenchInputs</code></pre>
         </article>
         
         <article class="global" data-name="sinkIP">
            <h2>sinkIP</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkIP Addr</code></pre>
         </article>
         
         <article class="global" data-name="sinkStdIP">
            <h2>sinkStdIP</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkStdIP net.IP</code></pre>
         </article>
         
         <article class="global" data-name="sinkAddrPort">
            <h2>sinkAddrPort</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkAddrPort AddrPort</code></pre>
         </article>
         
         <article class="global" data-name="sinkPrefix">
            <h2>sinkPrefix</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkPrefix Prefix</code></pre>
         </article>
         
         <article class="global" data-name="sinkPrefixSlice">
            <h2>sinkPrefixSlice</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkPrefixSlice []Prefix</code></pre>
         </article>
         
         <article class="global" data-name="sinkInternValue">
            <h2>sinkInternValue</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkInternValue *ast.IndexExpr</code></pre>
         </article>
         
         <article class="global" data-name="sinkIP16">
            <h2>sinkIP16</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkIP16 []byte</code></pre>
         </article>
         
         <article class="global" data-name="sinkIP4">
            <h2>sinkIP4</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkIP4 []byte</code></pre>
         </article>
         
         <article class="global" data-name="sinkBool">
            <h2>sinkBool</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkBool bool</code></pre>
         </article>
         
         <article class="global" data-name="sinkString">
            <h2>sinkString</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkString string</code></pre>
         </article>
         
         <article class="global" data-name="sinkBytes">
            <h2>sinkBytes</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkBytes []byte</code></pre>
         </article>
         
         <article class="global" data-name="sinkUDPAddr">
            <h2>sinkUDPAddr</h2>
            <hr />
            
            <p>Sink variables are here to force the compiler to not elide
seemingly useless work in benchmarks and allocation tests. If you
were to just `_ = foo()` within a test function, the compiler could
correctly deduce that foo() does nothing and doesn't need to be
called. By writing results to a global variable, we hide that fact
from the compiler and force it to keep the code under test.</p>
            
            <pre><code>sinkUDPAddr</code></pre>
         </article>
         
         <article class="global" data-name="sink16">
            <h2>sink16</h2>
            <hr />
            
            <pre><code>sink16 []byte</code></pre>
         </article>
         
         <article class="global" data-name="zeros">
            <h2>zeros</h2>
            <hr />
            
            <p>zeros is a slice of eight stringified zeros. It's used in
parseIPSlow to construct slices of specific amounts of zero fields,
from 1 to 8.</p>
            
            <pre><code>zeros</code></pre>
         </article>
          
         <article class="struct" data-name="ip4i">
            <h2>type ip4i struct</h2>
            <hr />
            
            <p>ip4i was one of the possible representations of IP that came up in
discussions, inlining IPv4 addresses, but having an "overflow"
interface for IPv6 or IPv6 + zone. This is here for benchmarking.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ip4 []byte
flags1 byte
flags2 byte
flags3 byte
flags4 byte
ipv6 any</code></pre>
         </article>
          
         <article class="function" data-name="FuzzParse">
            <h2>FuzzParse</h2>
            <hr />
            
            <pre><code>func FuzzParse(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="checkTextMarshaler">
            <h2>checkTextMarshaler</h2>
            <hr />
            
            <p>checkTextMarshaler checks that x's MarshalText and UnmarshalText functions round trip correctly.</p>
            
            <pre><code>func checkTextMarshaler(t *testing.T, x encoding.TextMarshaler)</code></pre>
         </article>
         
         <article class="function" data-name="checkBinaryMarshaler">
            <h2>checkBinaryMarshaler</h2>
            <hr />
            
            <p>checkBinaryMarshaler checks that x's MarshalText and UnmarshalText functions round trip correctly.</p>
            
            <pre><code>func checkBinaryMarshaler(t *testing.T, x encoding.BinaryMarshaler)</code></pre>
         </article>
         
         <article class="function" data-name="checkTextMarshalMatchesString">
            <h2>checkTextMarshalMatchesString</h2>
            <hr />
            
            <pre><code>func checkTextMarshalMatchesString(t *testing.T, x netipType)</code></pre>
         </article>
         
         <article class="function" data-name="checkTextMarshalMatchesAppendTo">
            <h2>checkTextMarshalMatchesAppendTo</h2>
            <hr />
            
            <p>checkTextMarshalMatchesAppendTo checks that x's MarshalText matches x's AppendTo.</p>
            
            <pre><code>func checkTextMarshalMatchesAppendTo(t *testing.T, x appendMarshaler)</code></pre>
         </article>
         
         <article class="function" data-name="checkStringParseRoundTrip">
            <h2>checkStringParseRoundTrip</h2>
            <hr />
            
            <p>checkStringParseRoundTrip checks that x's String method and the provided parse function can round trip correctly.</p>
            
            <pre><code>func checkStringParseRoundTrip(t *testing.T, x P, parse func)</code></pre>
         </article>
         
         <article class="function" data-name="checkEncoding">
            <h2>checkEncoding</h2>
            <hr />
            
            <pre><code>func checkEncoding(t *testing.T, x netipType)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseAddr">
            <h2>TestParseAddr</h2>
            <hr />
            
            <pre><code>func TestParseAddr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrFromSlice">
            <h2>TestAddrFromSlice</h2>
            <hr />
            
            <pre><code>func TestAddrFromSlice(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIPv4Constructors">
            <h2>TestIPv4Constructors</h2>
            <hr />
            
            <pre><code>func TestIPv4Constructors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrAppendText">
            <h2>TestAddrAppendText</h2>
            <hr />
            
            <pre><code>func TestAddrAppendText(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrMarshalUnmarshalBinary">
            <h2>TestAddrMarshalUnmarshalBinary</h2>
            <hr />
            
            <pre><code>func TestAddrMarshalUnmarshalBinary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrPortMarshalTextString">
            <h2>TestAddrPortMarshalTextString</h2>
            <hr />
            
            <pre><code>func TestAddrPortMarshalTextString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrPortMarshalUnmarshalBinary">
            <h2>TestAddrPortMarshalUnmarshalBinary</h2>
            <hr />
            
            <pre><code>func TestAddrPortMarshalUnmarshalBinary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixMarshalTextString">
            <h2>TestPrefixMarshalTextString</h2>
            <hr />
            
            <pre><code>func TestPrefixMarshalTextString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixMarshalUnmarshalBinary">
            <h2>TestPrefixMarshalUnmarshalBinary</h2>
            <hr />
            
            <pre><code>func TestPrefixMarshalUnmarshalBinary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrMarshalUnmarshal">
            <h2>TestAddrMarshalUnmarshal</h2>
            <hr />
            
            <pre><code>func TestAddrMarshalUnmarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrFrom16">
            <h2>TestAddrFrom16</h2>
            <hr />
            
            <pre><code>func TestAddrFrom16(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIPProperties">
            <h2>TestIPProperties</h2>
            <hr />
            
            <pre><code>func TestIPProperties(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrWellKnown">
            <h2>TestAddrWellKnown</h2>
            <hr />
            
            <pre><code>func TestAddrWellKnown(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrLessCompare">
            <h2>TestAddrLessCompare</h2>
            <hr />
            
            <pre><code>func TestAddrLessCompare(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrPortCompare">
            <h2>TestAddrPortCompare</h2>
            <hr />
            
            <pre><code>func TestAddrPortCompare(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixCompare">
            <h2>TestPrefixCompare</h2>
            <hr />
            
            <pre><code>func TestPrefixCompare(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIPStringExpanded">
            <h2>TestIPStringExpanded</h2>
            <hr />
            
            <pre><code>func TestIPStringExpanded(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixMasking">
            <h2>TestPrefixMasking</h2>
            <hr />
            
            <pre><code>func TestPrefixMasking(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixMarshalUnmarshal">
            <h2>TestPrefixMarshalUnmarshal</h2>
            <hr />
            
            <pre><code>func TestPrefixMarshalUnmarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixUnmarshalTextNonZero">
            <h2>TestPrefixUnmarshalTextNonZero</h2>
            <hr />
            
            <pre><code>func TestPrefixUnmarshalTextNonZero(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIs4AndIs6">
            <h2>TestIs4AndIs6</h2>
            <hr />
            
            <pre><code>func TestIs4AndIs6(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIs4In6">
            <h2>TestIs4In6</h2>
            <hr />
            
            <pre><code>func TestIs4In6(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixMasked">
            <h2>TestPrefixMasked</h2>
            <hr />
            
            <pre><code>func TestPrefixMasked(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefix">
            <h2>TestPrefix</h2>
            <hr />
            
            <pre><code>func TestPrefix(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixFromInvalidBits">
            <h2>TestPrefixFromInvalidBits</h2>
            <hr />
            
            <pre><code>func TestPrefixFromInvalidBits(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParsePrefixAllocs">
            <h2>TestParsePrefixAllocs</h2>
            <hr />
            
            <pre><code>func TestParsePrefixAllocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParsePrefixError">
            <h2>TestParsePrefixError</h2>
            <hr />
            
            <pre><code>func TestParsePrefixError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixIsSingleIP">
            <h2>TestPrefixIsSingleIP</h2>
            <hr />
            
            <pre><code>func TestPrefixIsSingleIP(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="mustIPs">
            <h2>mustIPs</h2>
            <hr />
            
            <pre><code>func mustIPs(strs ...string) []Addr</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkBinaryMarshalRoundTrip">
            <h2>BenchmarkBinaryMarshalRoundTrip</h2>
            <hr />
            
            <pre><code>func BenchmarkBinaryMarshalRoundTrip(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkStdIPv4">
            <h2>BenchmarkStdIPv4</h2>
            <hr />
            
            <pre><code>func BenchmarkStdIPv4(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIPv4">
            <h2>BenchmarkIPv4</h2>
            <hr />
            
            <pre><code>func BenchmarkIPv4(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="newip4i_v4">
            <h2>newip4i_v4</h2>
            <hr />
            
            <pre><code>func newip4i_v4(a byte, b byte, c byte, d byte) ip4i</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIPv4_inline">
            <h2>BenchmarkIPv4_inline</h2>
            <hr />
            
            <p>BenchmarkIPv4_inline benchmarks the candidate representation, ip4i.</p>
            
            <pre><code>func BenchmarkIPv4_inline(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkStdIPv6">
            <h2>BenchmarkStdIPv6</h2>
            <hr />
            
            <pre><code>func BenchmarkStdIPv6(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIPv6">
            <h2>BenchmarkIPv6</h2>
            <hr />
            
            <pre><code>func BenchmarkIPv6(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIPv4Contains">
            <h2>BenchmarkIPv4Contains</h2>
            <hr />
            
            <pre><code>func BenchmarkIPv4Contains(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIPv6Contains">
            <h2>BenchmarkIPv6Contains</h2>
            <hr />
            
            <pre><code>func BenchmarkIPv6Contains(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkParseAddr">
            <h2>BenchmarkParseAddr</h2>
            <hr />
            
            <pre><code>func BenchmarkParseAddr(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkStdParseIP">
            <h2>BenchmarkStdParseIP</h2>
            <hr />
            
            <pre><code>func BenchmarkStdParseIP(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkAddrString">
            <h2>BenchmarkAddrString</h2>
            <hr />
            
            <pre><code>func BenchmarkAddrString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIPStringExpanded">
            <h2>BenchmarkIPStringExpanded</h2>
            <hr />
            
            <pre><code>func BenchmarkIPStringExpanded(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkAddrMarshalText">
            <h2>BenchmarkAddrMarshalText</h2>
            <hr />
            
            <pre><code>func BenchmarkAddrMarshalText(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkAddrPortString">
            <h2>BenchmarkAddrPortString</h2>
            <hr />
            
            <pre><code>func BenchmarkAddrPortString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkAddrPortMarshalText">
            <h2>BenchmarkAddrPortMarshalText</h2>
            <hr />
            
            <pre><code>func BenchmarkAddrPortMarshalText(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPrefixMasking">
            <h2>BenchmarkPrefixMasking</h2>
            <hr />
            
            <pre><code>func BenchmarkPrefixMasking(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPrefixMarshalText">
            <h2>BenchmarkPrefixMarshalText</h2>
            <hr />
            
            <pre><code>func BenchmarkPrefixMarshalText(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkParseAddrPort">
            <h2>BenchmarkParseAddrPort</h2>
            <hr />
            
            <pre><code>func BenchmarkParseAddrPort(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestAs4">
            <h2>TestAs4</h2>
            <hr />
            
            <pre><code>func TestAs4(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixOverlaps">
            <h2>TestPrefixOverlaps</h2>
            <hr />
            
            <pre><code>func TestPrefixOverlaps(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoAllocs">
            <h2>TestNoAllocs</h2>
            <hr />
            
            <pre><code>func TestNoAllocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrStringAllocs">
            <h2>TestAddrStringAllocs</h2>
            <hr />
            
            <pre><code>func TestAddrStringAllocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrefixString">
            <h2>TestPrefixString</h2>
            <hr />
            
            <pre><code>func TestPrefixString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddrPortString">
            <h2>TestAddrPortString</h2>
            <hr />
            
            <pre><code>func TestAddrPortString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAsSlice">
            <h2>TestAsSlice</h2>
            <hr />
            
            <pre><code>func TestAsSlice(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkAs16">
            <h2>BenchmarkAs16</h2>
            <hr />
            
            <pre><code>func BenchmarkAs16(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="parseIPSlow">
            <h2>parseIPSlow</h2>
            <hr />
            
            <p>parseIPSlow is like ParseIP, but aims for readability above
speed. It's the reference implementation for correctness checking
and against which we measure optimized parsers.

parseIPSlow understands the following forms of IP addresses:
  - Regular IPv4: 1.2.3.4
  - IPv4 with many leading zeros: 0000001.0000002.0000003.0000004
  - Regular IPv6: 1111:2222:3333:4444:5555:6666:7777:8888
  - IPv6 with many leading zeros: 00000001:0000002:0000003:0000004:0000005:0000006:0000007:0000008
  - IPv6 with zero blocks elided: 1111:2222::7777:8888
  - IPv6 with trailing 32 bits expressed as IPv4: 1111:2222:3333:4444:5555:6666:77.77.88.88

It does not process the following IP address forms, which have been
varyingly accepted by some programs due to an under-specification
of the shapes of IPv4 addresses:

  - IPv4 as a single 32-bit uint: 4660 (same as "1.2.3.4")
  - IPv4 with octal numbers: 0300.0250.0.01 (same as "192.168.0.1")
  - IPv4 with hex numbers: 0xc0.0xa8.0x0.0x1 (same as "192.168.0.1")
  - IPv4 in "class-B style": 1.2.52 (same as "1.2.3.4")
  - IPv4 in "class-A style": 1.564 (same as "1.2.3.4")</p>
            
            <pre><code>func parseIPSlow(s string) (Addr, error)</code></pre>
         </article>
         
         <article class="function" data-name="normalizeIPv6Slow">
            <h2>normalizeIPv6Slow</h2>
            <hr />
            
            <p>normalizeIPv6Slow expands s, which is assumed to be an IPv6
address, to its canonical text form.

The canonical form of an IPv6 address is 8 colon-separated fields,
where each field should be a hex value from 0 to ffff. This
function does not verify the contents of each field.

This function performs two transformations:
  - The last 32 bits of an IPv6 address may be represented in
    IPv4-style dotted quad form, as in 1:2:3:4:5:6:7.8.9.10. That
    address is transformed to its hex equivalent,
    e.g. 1:2:3:4:5:6:708:90a.
  - An address may contain one "::", which expands into as many
    16-bit blocks of zeros as needed to make the address its correct
    full size. For example, fe80::1:2 expands to fe80:0:0:0:0:0:1:2.

Both short forms may be present in a single address,
e.g. fe80::1.2.3.4.</p>
            
            <pre><code>func normalizeIPv6Slow(orig string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseIPv4Slow">
            <h2>parseIPv4Slow</h2>
            <hr />
            
            <p>parseIPv4Slow parses and returns an IPv4 address in dotted quad
form, e.g. "192.168.0.1". It is slow but easy to read, and the
reference implementation against which we compare faster
implementations for correctness.</p>
            
            <pre><code>func parseIPv4Slow(s string) (Addr, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseWord">
            <h2>parseWord</h2>
            <hr />
            
            <p>parseWord converts a 16-bit hex string into its corresponding
two-byte value.</p>
            
            <pre><code>func parseWord(s string) (byte, byte, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
