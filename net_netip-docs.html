<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>netip - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>netip</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"math/bits"
"cmp"
"errors"
"internal/bytealg"
"internal/byteorder"
"internal/itoa"
"math"
"strconv"
"unique"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="digits" data-name="digits">
               <h3>
                  digits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#digits" class="anchor" title="Link to digits">#</a>
               </h3>
               
                  <p class="doc-comment">digits is a string of the hex digits from 0 to f. It's used in
appendDecimal and appendHex to format IP addresses.</p>
               
               <pre><code class="language-go">const digits = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="z0" data-name="z0">
               <h3>
                  z0 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#z0" class="anchor" title="Link to z0">#</a>
               </h3>
               
                  <p class="doc-comment">z0, z4, and z6noz are sentinel Addr.z values.
See the Addr type's field docs.</p>
               
               <pre><code class="language-go">var z0 *ast.IndexExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="z4" data-name="z4">
               <h3>
                  z4 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#z4" class="anchor" title="Link to z4">#</a>
               </h3>
               
                  <p class="doc-comment">z0, z4, and z6noz are sentinel Addr.z values.
See the Addr type's field docs.</p>
               
               <pre><code class="language-go">var z4 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="z6noz" data-name="z6noz">
               <h3>
                  z6noz 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#z6noz" class="anchor" title="Link to z6noz">#</a>
               </h3>
               
                  <p class="doc-comment">z0, z4, and z6noz are sentinel Addr.z values.
See the Addr type's field docs.</p>
               
               <pre><code class="language-go">var z6noz = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Addr" data-name="Addr">
               <h3>
                  Addr
                  <span class="badge">struct</span>
                  <a href="#Addr" class="anchor" title="Link to Addr">#</a>
               </h3>
               
               <p>Addr represents an IPv4 or IPv6 address (with or without a scoped
addressing zone), similar to [net.IP] or [net.IPAddr].
Unlike [net.IP] or [net.IPAddr], Addr is a comparable value
type (it supports == and can be a map key) and is immutable.
The zero Addr is not a valid IP address.
Addr{} is distinct from both 0.0.0.0 and ::.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Addr struct {
addr uint128
z *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="AddrPort" data-name="AddrPort">
               <h3>
                  AddrPort
                  <span class="badge">struct</span>
                  <a href="#AddrPort" class="anchor" title="Link to AddrPort">#</a>
               </h3>
               
               <p>AddrPort is an IP and a port number.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type AddrPort struct {
ip Addr
port uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Prefix" data-name="Prefix">
               <h3>
                  Prefix
                  <span class="badge">struct</span>
                  <a href="#Prefix" class="anchor" title="Link to Prefix">#</a>
               </h3>
               
               <p>Prefix is an IP address prefix (CIDR) representing an IP network.
The first [Prefix.Bits]() of [Addr]() are specified. The remaining bits match any address.
The range of Bits() is [0,32] for IPv4 or [0,128] for IPv6.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Prefix struct {
ip Addr
bitsPlusOne uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="addrDetail" data-name="addrDetail">
               <h3>
                  addrDetail
                  <span class="badge">struct</span>
                  <a href="#addrDetail" class="anchor" title="Link to addrDetail">#</a>
               </h3>
               
               <p>addrDetail represents the details of an Addr, like address family and IPv6 zone.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type addrDetail struct {
isV6 bool
zoneV6 string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parseAddrError" data-name="parseAddrError">
               <h3>
                  parseAddrError
                  <span class="badge">struct</span>
                  <a href="#parseAddrError" class="anchor" title="Link to parseAddrError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parseAddrError struct {
in string
msg string
at string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parsePrefixError" data-name="parsePrefixError">
               <h3>
                  parsePrefixError
                  <span class="badge">struct</span>
                  <a href="#parsePrefixError" class="anchor" title="Link to parsePrefixError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parsePrefixError struct {
in string
msg string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="uint128" data-name="uint128">
               <h3>
                  uint128
                  <span class="badge">struct</span>
                  <a href="#uint128" class="anchor" title="Link to uint128">#</a>
               </h3>
               
               <p>uint128 represents a uint128 using two uint64s.
When the methods below mention a bit number, bit 0 is the most
significant bit (in hi) and bit 127 is the lowest (lo&1).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type uint128 struct {
hi uint64
lo uint64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Addr" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Addr" class="anchor" title="Link to Addr">#</a>
               </h3>
               
               <p>Addr returns p's IP address.</p>
               
               <pre><code class="language-go">func (p AddrPort) Addr() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Addr" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Addr" class="anchor" title="Link to Addr">#</a>
               </h3>
               
               <p>Addr returns p's IP address.</p>
               
               <pre><code class="language-go">func (p Prefix) Addr() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddrFrom16" data-name="AddrFrom16">
               <h3>
                  AddrFrom16 
                  <span class="badge">function</span>
                  
                  <a href="#AddrFrom16" class="anchor" title="Link to AddrFrom16">#</a>
               </h3>
               
               <p>AddrFrom16 returns the IPv6 address given by the bytes in addr.
An IPv4-mapped IPv6 address is left as an IPv6 address.
(Use Unmap to convert them if needed.)</p>
               
               <pre><code class="language-go">func AddrFrom16(addr [16]byte) Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddrFrom4" data-name="AddrFrom4">
               <h3>
                  AddrFrom4 
                  <span class="badge">function</span>
                  
                  <a href="#AddrFrom4" class="anchor" title="Link to AddrFrom4">#</a>
               </h3>
               
               <p>AddrFrom4 returns the address of the IPv4 address given by the bytes in addr.</p>
               
               <pre><code class="language-go">func AddrFrom4(addr [4]byte) Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddrFromSlice" data-name="AddrFromSlice">
               <h3>
                  AddrFromSlice 
                  <span class="badge">function</span>
                  
                  <a href="#AddrFromSlice" class="anchor" title="Link to AddrFromSlice">#</a>
               </h3>
               
               <p>AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6 address.
Note that a [net.IP] can be passed directly as the []byte argument.
If slice's length is not 4 or 16, AddrFromSlice returns [Addr]{}, false.</p>
               
               <pre><code class="language-go">func AddrFromSlice(slice []byte) (ip Addr, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddrPortFrom" data-name="AddrPortFrom">
               <h3>
                  AddrPortFrom 
                  <span class="badge">function</span>
                  
                  <a href="#AddrPortFrom" class="anchor" title="Link to AddrPortFrom">#</a>
               </h3>
               
               <p>AddrPortFrom returns an [AddrPort] with the provided IP and port.
It does not allocate.</p>
               
               <pre><code class="language-go">func AddrPortFrom(ip Addr, port uint16) AddrPort</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendBinary" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendBinary" class="anchor" title="Link to AppendBinary">#</a>
               </h3>
               
               <p>AppendBinary implements the [encoding.AppendMarshaler] interface.
It returns [Addr.AppendBinary] with an additional byte appended
containing the prefix bits.</p>
               
               <pre><code class="language-go">func (p Prefix) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendBinary" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendBinary" class="anchor" title="Link to AppendBinary">#</a>
               </h3>
               
               <p>AppendBinary implements the [encoding.BinaryAppender] interface.</p>
               
               <pre><code class="language-go">func (ip Addr) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendBinary" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendBinary" class="anchor" title="Link to AppendBinary">#</a>
               </h3>
               
               <p>AppendBinary implements the [encoding.BinaryAppendler] interface.
It returns [Addr.AppendBinary] with an additional two bytes appended
containing the port in little-endian.</p>
               
               <pre><code class="language-go">func (p AddrPort) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.
It is the same as [Prefix.AppendTo].</p>
               
               <pre><code class="language-go">func (p Prefix) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface. The
encoding is the same as returned by [AddrPort.AppendTo].</p>
               
               <pre><code class="language-go">func (p AddrPort) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface,
It is the same as [Addr.AppendTo].</p>
               
               <pre><code class="language-go">func (ip Addr) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendTo" data-name="AppendTo">
               <h3>
                  AppendTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendTo" class="anchor" title="Link to AppendTo">#</a>
               </h3>
               
               <p>AppendTo appends a text encoding of p,
as generated by [Prefix.MarshalText],
to b and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (p Prefix) AppendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendTo" data-name="AppendTo">
               <h3>
                  AppendTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendTo" class="anchor" title="Link to AppendTo">#</a>
               </h3>
               
               <p>AppendTo appends a text encoding of ip,
as generated by [Addr.MarshalText],
to b and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (ip Addr) AppendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendTo" data-name="AppendTo">
               <h3>
                  AppendTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendTo" class="anchor" title="Link to AppendTo">#</a>
               </h3>
               
               <p>AppendTo appends a text encoding of p,
as generated by [AddrPort.MarshalText],
to b and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (p AddrPort) AppendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="As16" data-name="As16">
               <h3>
                  As16 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#As16" class="anchor" title="Link to As16">#</a>
               </h3>
               
               <p>As16 returns the IP address in its 16-byte representation.
IPv4 addresses are returned as IPv4-mapped IPv6 addresses.
IPv6 addresses with zones are returned without their zone (use the
[Addr.Zone] method to get it).
The ip zero value returns all zeroes.</p>
               
               <pre><code class="language-go">func (ip Addr) As16() (a16 [16]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="As4" data-name="As4">
               <h3>
                  As4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#As4" class="anchor" title="Link to As4">#</a>
               </h3>
               
               <p>As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation.
If ip is the zero [Addr] or an IPv6 address, As4 panics.
Note that 0.0.0.0 is not the zero Addr.</p>
               
               <pre><code class="language-go">func (ip Addr) As4() (a4 [4]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AsSlice" data-name="AsSlice">
               <h3>
                  AsSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AsSlice" class="anchor" title="Link to AsSlice">#</a>
               </h3>
               
               <p>AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte representation.</p>
               
               <pre><code class="language-go">func (ip Addr) AsSlice() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BitLen" data-name="BitLen">
               <h3>
                  BitLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BitLen" class="anchor" title="Link to BitLen">#</a>
               </h3>
               
               <p>BitLen returns the number of bits in the IP address:
128 for IPv6, 32 for IPv4, and 0 for the zero [Addr].
Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses
and therefore have bit length 128.</p>
               
               <pre><code class="language-go">func (ip Addr) BitLen() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bits" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bits" class="anchor" title="Link to Bits">#</a>
               </h3>
               
               <p>Bits returns p's prefix length.
It reports -1 if invalid.</p>
               
               <pre><code class="language-go">func (p Prefix) Bits() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compare" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Compare" class="anchor" title="Link to Compare">#</a>
               </h3>
               
               <p>Compare returns an integer comparing two IPs.
The result will be 0 if ip == ip2, -1 if ip < ip2, and +1 if ip > ip2.
The definition of "less than" is the same as the [Addr.Less] method.</p>
               
               <pre><code class="language-go">func (ip Addr) Compare(ip2 Addr) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compare" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Compare" class="anchor" title="Link to Compare">#</a>
               </h3>
               
               <p>Compare returns an integer comparing two AddrPorts.
The result will be 0 if p == p2, -1 if p < p2, and +1 if p > p2.
AddrPorts sort first by IP address, then port.</p>
               
               <pre><code class="language-go">func (p AddrPort) Compare(p2 AddrPort) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Contains" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Contains" class="anchor" title="Link to Contains">#</a>
               </h3>
               
               <p>Contains reports whether the network p includes ip.
An IPv4 address will not match an IPv6 prefix.
An IPv4-mapped IPv6 address will not match an IPv4 prefix.
A zero-value IP will not match any prefix.
If ip has an IPv6 zone, Contains returns false,
because Prefixes strip zones.</p>
               
               <pre><code class="language-go">func (p Prefix) Contains(ip Addr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (err parsePrefixError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (err parseAddrError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IPv4Unspecified" data-name="IPv4Unspecified">
               <h3>
                  IPv4Unspecified 
                  <span class="badge">function</span>
                  
                  <a href="#IPv4Unspecified" class="anchor" title="Link to IPv4Unspecified">#</a>
               </h3>
               
               <p>IPv4Unspecified returns the IPv4 unspecified address "0.0.0.0".</p>
               
               <pre><code class="language-go">func IPv4Unspecified() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IPv6LinkLocalAllNodes" data-name="IPv6LinkLocalAllNodes">
               <h3>
                  IPv6LinkLocalAllNodes 
                  <span class="badge">function</span>
                  
                  <a href="#IPv6LinkLocalAllNodes" class="anchor" title="Link to IPv6LinkLocalAllNodes">#</a>
               </h3>
               
               <p>IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast
address ff02::1.</p>
               
               <pre><code class="language-go">func IPv6LinkLocalAllNodes() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IPv6LinkLocalAllRouters" data-name="IPv6LinkLocalAllRouters">
               <h3>
                  IPv6LinkLocalAllRouters 
                  <span class="badge">function</span>
                  
                  <a href="#IPv6LinkLocalAllRouters" class="anchor" title="Link to IPv6LinkLocalAllRouters">#</a>
               </h3>
               
               <p>IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast
address ff02::2.</p>
               
               <pre><code class="language-go">func IPv6LinkLocalAllRouters() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IPv6Loopback" data-name="IPv6Loopback">
               <h3>
                  IPv6Loopback 
                  <span class="badge">function</span>
                  
                  <a href="#IPv6Loopback" class="anchor" title="Link to IPv6Loopback">#</a>
               </h3>
               
               <p>IPv6Loopback returns the IPv6 loopback address ::1.</p>
               
               <pre><code class="language-go">func IPv6Loopback() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IPv6Unspecified" data-name="IPv6Unspecified">
               <h3>
                  IPv6Unspecified 
                  <span class="badge">function</span>
                  
                  <a href="#IPv6Unspecified" class="anchor" title="Link to IPv6Unspecified">#</a>
               </h3>
               
               <p>IPv6Unspecified returns the IPv6 unspecified address "::".</p>
               
               <pre><code class="language-go">func IPv6Unspecified() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is4" data-name="Is4">
               <h3>
                  Is4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is4" class="anchor" title="Link to Is4">#</a>
               </h3>
               
               <p>Is4 reports whether ip is an IPv4 address.
It returns false for IPv4-mapped IPv6 addresses. See [Addr.Unmap].</p>
               
               <pre><code class="language-go">func (ip Addr) Is4() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is4In6" data-name="Is4In6">
               <h3>
                  Is4In6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is4In6" class="anchor" title="Link to Is4In6">#</a>
               </h3>
               
               <p>Is4In6 reports whether ip is an "IPv4-mapped IPv6 address"
as defined by RFC 4291.
That is, it reports whether ip is in ::ffff:0:0/96.</p>
               
               <pre><code class="language-go">func (ip Addr) Is4In6() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is6" data-name="Is6">
               <h3>
                  Is6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is6" class="anchor" title="Link to Is6">#</a>
               </h3>
               
               <p>Is6 reports whether ip is an IPv6 address, including IPv4-mapped
IPv6 addresses.</p>
               
               <pre><code class="language-go">func (ip Addr) Is6() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsGlobalUnicast" data-name="IsGlobalUnicast">
               <h3>
                  IsGlobalUnicast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsGlobalUnicast" class="anchor" title="Link to IsGlobalUnicast">#</a>
               </h3>
               
               <p>IsGlobalUnicast reports whether ip is a global unicast address.
It returns true for IPv6 addresses which fall outside of the current
IANA-allocated 2000::/3 global unicast space, with the exception of the
link-local address space. It also returns true even if ip is in the IPv4
private address space or IPv6 unique local address space.
It returns false for the zero [Addr].
For reference, see RFC 1122, RFC 4291, and RFC 4632.</p>
               
               <pre><code class="language-go">func (ip Addr) IsGlobalUnicast() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsInterfaceLocalMulticast" data-name="IsInterfaceLocalMulticast">
               <h3>
                  IsInterfaceLocalMulticast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsInterfaceLocalMulticast" class="anchor" title="Link to IsInterfaceLocalMulticast">#</a>
               </h3>
               
               <p>IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local
multicast address.</p>
               
               <pre><code class="language-go">func (ip Addr) IsInterfaceLocalMulticast() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLinkLocalMulticast" data-name="IsLinkLocalMulticast">
               <h3>
                  IsLinkLocalMulticast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsLinkLocalMulticast" class="anchor" title="Link to IsLinkLocalMulticast">#</a>
               </h3>
               
               <p>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</p>
               
               <pre><code class="language-go">func (ip Addr) IsLinkLocalMulticast() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLinkLocalUnicast" data-name="IsLinkLocalUnicast">
               <h3>
                  IsLinkLocalUnicast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsLinkLocalUnicast" class="anchor" title="Link to IsLinkLocalUnicast">#</a>
               </h3>
               
               <p>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</p>
               
               <pre><code class="language-go">func (ip Addr) IsLinkLocalUnicast() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLoopback" data-name="IsLoopback">
               <h3>
                  IsLoopback 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsLoopback" class="anchor" title="Link to IsLoopback">#</a>
               </h3>
               
               <p>IsLoopback reports whether ip is a loopback address.</p>
               
               <pre><code class="language-go">func (ip Addr) IsLoopback() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsMulticast" data-name="IsMulticast">
               <h3>
                  IsMulticast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsMulticast" class="anchor" title="Link to IsMulticast">#</a>
               </h3>
               
               <p>IsMulticast reports whether ip is a multicast address.</p>
               
               <pre><code class="language-go">func (ip Addr) IsMulticast() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPrivate" data-name="IsPrivate">
               <h3>
                  IsPrivate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsPrivate" class="anchor" title="Link to IsPrivate">#</a>
               </h3>
               
               <p>IsPrivate reports whether ip is a private address, according to RFC 1918
(IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether
ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the
same as [net.IP.IsPrivate].</p>
               
               <pre><code class="language-go">func (ip Addr) IsPrivate() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsSingleIP" data-name="IsSingleIP">
               <h3>
                  IsSingleIP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsSingleIP" class="anchor" title="Link to IsSingleIP">#</a>
               </h3>
               
               <p>IsSingleIP reports whether p contains exactly one IP.</p>
               
               <pre><code class="language-go">func (p Prefix) IsSingleIP() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsUnspecified" data-name="IsUnspecified">
               <h3>
                  IsUnspecified 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsUnspecified" class="anchor" title="Link to IsUnspecified">#</a>
               </h3>
               
               <p>IsUnspecified reports whether ip is an unspecified address, either the IPv4
address "0.0.0.0" or the IPv6 address "::".
Note that the zero [Addr] is not an unspecified address.</p>
               
               <pre><code class="language-go">func (ip Addr) IsUnspecified() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValid" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsValid" class="anchor" title="Link to IsValid">#</a>
               </h3>
               
               <p>IsValid reports whether the [Addr] is an initialized address (not the zero Addr).
Note that "0.0.0.0" and "::" are both valid values.</p>
               
               <pre><code class="language-go">func (ip Addr) IsValid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValid" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsValid" class="anchor" title="Link to IsValid">#</a>
               </h3>
               
               <p>IsValid reports whether p.Addr() is valid.
All ports are valid, including zero.</p>
               
               <pre><code class="language-go">func (p AddrPort) IsValid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValid" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsValid" class="anchor" title="Link to IsValid">#</a>
               </h3>
               
               <p>IsValid reports whether p.Bits() has a valid range for p.Addr().
If p.Addr() is the zero [Addr], IsValid returns false.
Note that if p is the zero [Prefix], then p.IsValid() == false.</p>
               
               <pre><code class="language-go">func (p Prefix) IsValid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <p>Less reports whether ip sorts before ip2.
IP addresses sort first by length, then their address.
IPv6 addresses with zones sort just after the same address without a zone.</p>
               
               <pre><code class="language-go">func (ip Addr) Less(ip2 Addr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalBinary" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalBinary" class="anchor" title="Link to MarshalBinary">#</a>
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.
It returns a zero-length slice for the zero [Addr],
the 4-byte form for an IPv4 address,
and the 16-byte form with zone appended for an IPv6 address.</p>
               
               <pre><code class="language-go">func (ip Addr) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalBinary" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalBinary" class="anchor" title="Link to MarshalBinary">#</a>
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.
It returns [Addr.MarshalBinary] with an additional two bytes appended
containing the port in little-endian.</p>
               
               <pre><code class="language-go">func (p AddrPort) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalBinary" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalBinary" class="anchor" title="Link to MarshalBinary">#</a>
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.
It returns [Addr.MarshalBinary] with an additional byte appended
containing the prefix bits.</p>
               
               <pre><code class="language-go">func (p Prefix) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface,
The encoding is the same as returned by [Addr.String], with one exception:
If ip is the zero [Addr], the encoding is the empty string.</p>
               
               <pre><code class="language-go">func (ip Addr) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface,
The encoding is the same as returned by [Prefix.String], with one exception:
If p is the zero value, the encoding is the empty string.</p>
               
               <pre><code class="language-go">func (p Prefix) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface. The
encoding is the same as returned by [AddrPort.String], with one exception: if
p.Addr() is the zero [Addr], the encoding is the empty string.</p>
               
               <pre><code class="language-go">func (p AddrPort) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Masked" data-name="Masked">
               <h3>
                  Masked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Masked" class="anchor" title="Link to Masked">#</a>
               </h3>
               
               <p>Masked returns p in its canonical form, with all but the high
p.Bits() bits of p.Addr() masked off.
If p is zero or otherwise invalid, Masked returns the zero [Prefix].</p>
               
               <pre><code class="language-go">func (p Prefix) Masked() Prefix</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MustParseAddr" data-name="MustParseAddr">
               <h3>
                  MustParseAddr 
                  <span class="badge">function</span>
                  
                  <a href="#MustParseAddr" class="anchor" title="Link to MustParseAddr">#</a>
               </h3>
               
               <p>MustParseAddr calls [ParseAddr](s) and panics on error.
It is intended for use in tests with hard-coded strings.</p>
               
               <pre><code class="language-go">func MustParseAddr(s string) Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MustParseAddrPort" data-name="MustParseAddrPort">
               <h3>
                  MustParseAddrPort 
                  <span class="badge">function</span>
                  
                  <a href="#MustParseAddrPort" class="anchor" title="Link to MustParseAddrPort">#</a>
               </h3>
               
               <p>MustParseAddrPort calls [ParseAddrPort](s) and panics on error.
It is intended for use in tests with hard-coded strings.</p>
               
               <pre><code class="language-go">func MustParseAddrPort(s string) AddrPort</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MustParsePrefix" data-name="MustParsePrefix">
               <h3>
                  MustParsePrefix 
                  <span class="badge">function</span>
                  
                  <a href="#MustParsePrefix" class="anchor" title="Link to MustParsePrefix">#</a>
               </h3>
               
               <p>MustParsePrefix calls [ParsePrefix](s) and panics on error.
It is intended for use in tests with hard-coded strings.</p>
               
               <pre><code class="language-go">func MustParsePrefix(s string) Prefix</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next returns the address following ip.
If there is none, it returns the zero [Addr].</p>
               
               <pre><code class="language-go">func (ip Addr) Next() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Overlaps" data-name="Overlaps">
               <h3>
                  Overlaps 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Overlaps" class="anchor" title="Link to Overlaps">#</a>
               </h3>
               
               <p>Overlaps reports whether p and o contain any IP addresses in common.
If p and o are of different address families or either have a zero
IP, it reports false. Like the Contains method, a prefix with an
IPv4-mapped IPv6 address is still treated as an IPv6 mask.</p>
               
               <pre><code class="language-go">func (p Prefix) Overlaps(o Prefix) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseAddr" data-name="ParseAddr">
               <h3>
                  ParseAddr 
                  <span class="badge">function</span>
                  
                  <a href="#ParseAddr" class="anchor" title="Link to ParseAddr">#</a>
               </h3>
               
               <p>ParseAddr parses s as an IP address, returning the result. The string
s can be in dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"),
or IPv6 with a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18").</p>
               
               <pre><code class="language-go">func ParseAddr(s string) (Addr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseAddrPort" data-name="ParseAddrPort">
               <h3>
                  ParseAddrPort 
                  <span class="badge">function</span>
                  
                  <a href="#ParseAddrPort" class="anchor" title="Link to ParseAddrPort">#</a>
               </h3>
               
               <p>ParseAddrPort parses s as an [AddrPort].
It doesn't do any name resolution: both the address and the port
must be numeric.</p>
               
               <pre><code class="language-go">func ParseAddrPort(s string) (AddrPort, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParsePrefix" data-name="ParsePrefix">
               <h3>
                  ParsePrefix 
                  <span class="badge">function</span>
                  
                  <a href="#ParsePrefix" class="anchor" title="Link to ParsePrefix">#</a>
               </h3>
               
               <p>ParsePrefix parses s as an IP address prefix.
The string can be in the form "192.168.1.0/24" or "2001:db8::/32",
the CIDR notation defined in RFC 4632 and RFC 4291.
IPv6 zones are not permitted in prefixes, and an error will be returned if a
zone is present.
Note that masked address bits are not zeroed. Use Masked for that.</p>
               
               <pre><code class="language-go">func ParsePrefix(s string) (Prefix, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Port" data-name="Port">
               <h3>
                  Port 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Port" class="anchor" title="Link to Port">#</a>
               </h3>
               
               <p>Port returns p's port.</p>
               
               <pre><code class="language-go">func (p AddrPort) Port() uint16</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prefix" data-name="Prefix">
               <h3>
                  Prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Prefix" class="anchor" title="Link to Prefix">#</a>
               </h3>
               
               <p>Prefix keeps only the top b bits of IP, producing a Prefix
of the specified length.
If ip is a zero [Addr], Prefix always returns a zero Prefix and a nil error.
Otherwise, if bits is less than zero or greater than ip.BitLen(),
Prefix returns an error.</p>
               
               <pre><code class="language-go">func (ip Addr) Prefix(b int) (Prefix, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PrefixFrom" data-name="PrefixFrom">
               <h3>
                  PrefixFrom 
                  <span class="badge">function</span>
                  
                  <a href="#PrefixFrom" class="anchor" title="Link to PrefixFrom">#</a>
               </h3>
               
               <p>PrefixFrom returns a [Prefix] with the provided IP address and bit
prefix length.
It does not allocate. Unlike [Addr.Prefix], [PrefixFrom] does not mask
off the host bits of ip.
If bits is less than zero or greater than ip.BitLen, [Prefix.Bits]
will return an invalid value -1.</p>
               
               <pre><code class="language-go">func PrefixFrom(ip Addr, bits int) Prefix</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prev" data-name="Prev">
               <h3>
                  Prev 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Prev" class="anchor" title="Link to Prev">#</a>
               </h3>
               
               <p>Prev returns the IP before ip.
If there is none, it returns the IP zero value.</p>
               
               <pre><code class="language-go">func (ip Addr) Prev() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (p AddrPort) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the CIDR notation of p: "<ip>/<bits>".</p>
               
               <pre><code class="language-go">func (p Prefix) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the string form of the IP address ip.
It returns one of 5 forms:
- "invalid IP", if ip is the zero [Addr]
- IPv4 dotted decimal ("192.0.2.1")
- IPv6 ("2001:db8::1")
- "::ffff:1.2.3.4" (if [Addr.Is4In6])
- IPv6 with zone ("fe80:db8::1%eth0")
Note that unlike package net's IP.String method,
IPv4-mapped IPv6 addresses format with a "::ffff:"
prefix before the dotted quad.</p>
               
               <pre><code class="language-go">func (ip Addr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StringExpanded" data-name="StringExpanded">
               <h3>
                  StringExpanded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StringExpanded" class="anchor" title="Link to StringExpanded">#</a>
               </h3>
               
               <p>StringExpanded is like [Addr.String] but IPv6 addresses are expanded with leading
zeroes and no "::" compression. For example, "2001:db8::1" becomes
"2001:0db8:0000:0000:0000:0000:0000:0001".</p>
               
               <pre><code class="language-go">func (ip Addr) StringExpanded() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unmap" data-name="Unmap">
               <h3>
                  Unmap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unmap" class="anchor" title="Link to Unmap">#</a>
               </h3>
               
               <p>Unmap returns ip with any IPv4-mapped IPv6 address prefix removed.
That is, if ip is an IPv6 address wrapping an IPv4 address, it
returns the wrapped IPv4 address. Otherwise it returns ip unmodified.</p>
               
               <pre><code class="language-go">func (ip Addr) Unmap() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalBinary" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalBinary" class="anchor" title="Link to UnmarshalBinary">#</a>
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.
It expects data in the form generated by MarshalBinary.</p>
               
               <pre><code class="language-go">func (ip *Addr) UnmarshalBinary(b []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalBinary" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalBinary" class="anchor" title="Link to UnmarshalBinary">#</a>
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.
It expects data in the form generated by [AddrPort.MarshalBinary].</p>
               
               <pre><code class="language-go">func (p *AddrPort) UnmarshalBinary(b []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalBinary" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalBinary" class="anchor" title="Link to UnmarshalBinary">#</a>
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.
It expects data in the form generated by [Prefix.MarshalBinary].</p>
               
               <pre><code class="language-go">func (p *Prefix) UnmarshalBinary(b []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the encoding.TextUnmarshaler interface.
The IP address is expected in a form accepted by [ParsePrefix]
or generated by [Prefix.MarshalText].</p>
               
               <pre><code class="language-go">func (p *Prefix) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the encoding.TextUnmarshaler
interface. The [AddrPort] is expected in a form
generated by [AddrPort.MarshalText] or accepted by [ParseAddrPort].</p>
               
               <pre><code class="language-go">func (p *AddrPort) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the encoding.TextUnmarshaler interface.
The IP address is expected in a form accepted by [ParseAddr].
If text is empty, UnmarshalText sets *ip to the zero [Addr] and
returns no error.</p>
               
               <pre><code class="language-go">func (ip *Addr) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithZone" data-name="WithZone">
               <h3>
                  WithZone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithZone" class="anchor" title="Link to WithZone">#</a>
               </h3>
               
               <p>WithZone returns an IP that's the same as ip but with the provided
zone. If zone is empty, the zone is removed. If ip is an IPv4
address, WithZone is a no-op and returns ip unchanged.</p>
               
               <pre><code class="language-go">func (ip Addr) WithZone(zone string) Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zone" data-name="Zone">
               <h3>
                  Zone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zone" class="anchor" title="Link to Zone">#</a>
               </h3>
               
               <p>Zone returns ip's IPv6 scoped addressing zone, if any.</p>
               
               <pre><code class="language-go">func (ip Addr) Zone() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addOne" data-name="addOne">
               <h3>
                  addOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addOne" class="anchor" title="Link to addOne">#</a>
               </h3>
               
               <p>addOne returns u + 1.</p>
               
               <pre><code class="language-go">func (u uint128) addOne() uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="and" data-name="and">
               <h3>
                  and 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#and" class="anchor" title="Link to and">#</a>
               </h3>
               
               <p>and returns the bitwise AND of u and m (u&m).</p>
               
               <pre><code class="language-go">func (u uint128) and(m uint128) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendDecimal" data-name="appendDecimal">
               <h3>
                  appendDecimal 
                  <span class="badge">function</span>
                  
                  <a href="#appendDecimal" class="anchor" title="Link to appendDecimal">#</a>
               </h3>
               
               <p>appendDecimal appends the decimal string representation of x to b.</p>
               
               <pre><code class="language-go">func appendDecimal(b []byte, x uint8) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendHex" data-name="appendHex">
               <h3>
                  appendHex 
                  <span class="badge">function</span>
                  
                  <a href="#appendHex" class="anchor" title="Link to appendHex">#</a>
               </h3>
               
               <p>appendHex appends the hex string representation of x to b.</p>
               
               <pre><code class="language-go">func appendHex(b []byte, x uint16) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendHexPad" data-name="appendHexPad">
               <h3>
                  appendHexPad 
                  <span class="badge">function</span>
                  
                  <a href="#appendHexPad" class="anchor" title="Link to appendHexPad">#</a>
               </h3>
               
               <p>appendHexPad appends the fully padded hex string representation of x to b.</p>
               
               <pre><code class="language-go">func appendHexPad(b []byte, x uint16) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTo4" data-name="appendTo4">
               <h3>
                  appendTo4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendTo4" class="anchor" title="Link to appendTo4">#</a>
               </h3>
               
               <pre><code class="language-go">func (ip Addr) appendTo4(ret []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTo4In6" data-name="appendTo4In6">
               <h3>
                  appendTo4In6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendTo4In6" class="anchor" title="Link to appendTo4In6">#</a>
               </h3>
               
               <pre><code class="language-go">func (ip Addr) appendTo4In6(ret []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTo6" data-name="appendTo6">
               <h3>
                  appendTo6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendTo6" class="anchor" title="Link to appendTo6">#</a>
               </h3>
               
               <pre><code class="language-go">func (ip Addr) appendTo6(ret []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitsClearedFrom" data-name="bitsClearedFrom">
               <h3>
                  bitsClearedFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bitsClearedFrom" class="anchor" title="Link to bitsClearedFrom">#</a>
               </h3>
               
               <p>bitsClearedFrom returns a copy of u with the given bit
and all subsequent ones cleared.</p>
               
               <pre><code class="language-go">func (u uint128) bitsClearedFrom(bit uint8) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitsSetFrom" data-name="bitsSetFrom">
               <h3>
                  bitsSetFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bitsSetFrom" class="anchor" title="Link to bitsSetFrom">#</a>
               </h3>
               
               <p>bitsSetFrom returns a copy of u with the given bit
and all subsequent ones set.</p>
               
               <pre><code class="language-go">func (u uint128) bitsSetFrom(bit uint8) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compare" data-name="compare">
               <h3>
                  compare 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compare" class="anchor" title="Link to compare">#</a>
               </h3>
               
               <p>compare returns an integer comparing two prefixes.
The result will be 0 if p == p2, -1 if p < p2, and +1 if p > p2.
Prefixes sort first by validity (invalid before valid), then
address family (IPv4 before IPv6), then prefix length, then
address.
Unexported for Go 1.22 because we may want to compare by p.Addr first.
See post-acceptance discussion on go.dev/issue/61642.</p>
               
               <pre><code class="language-go">func (p Prefix) compare(p2 Prefix) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="halves" data-name="halves">
               <h3>
                  halves 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#halves" class="anchor" title="Link to halves">#</a>
               </h3>
               
               <p>halves returns the two uint64 halves of the uint128.
Logically, think of it as returning two uint64s.
It only returns pointers for inlining reasons on 32-bit platforms.</p>
               
               <pre><code class="language-go">func (u *uint128) halves() [2]*uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasZone" data-name="hasZone">
               <h3>
                  hasZone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasZone" class="anchor" title="Link to hasZone">#</a>
               </h3>
               
               <p>hasZone reports whether ip has an IPv6 zone.</p>
               
               <pre><code class="language-go">func (ip Addr) hasZone() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isZero" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isZero" class="anchor" title="Link to isZero">#</a>
               </h3>
               
               <p>isZero reports whether u == 0.
It's faster than u == (uint128{}) because the compiler (as of Go
1.15/1.16b1) doesn't do this trick and instead inserts a branch in
its eq alg's generated code.</p>
               
               <pre><code class="language-go">func (u uint128) isZero() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isZero" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isZero" class="anchor" title="Link to isZero">#</a>
               </h3>
               
               <p>isZero reports whether ip is the zero value of the IP type.
The zero value is not a valid IP address of any type.
Note that "0.0.0.0" and "::" are not the zero value. Use IsUnspecified to
check for these values instead.</p>
               
               <pre><code class="language-go">func (ip Addr) isZero() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isZero" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isZero" class="anchor" title="Link to isZero">#</a>
               </h3>
               
               <pre><code class="language-go">func (p Prefix) isZero() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalBinarySize" data-name="marshalBinarySize">
               <h3>
                  marshalBinarySize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalBinarySize" class="anchor" title="Link to marshalBinarySize">#</a>
               </h3>
               
               <pre><code class="language-go">func (ip Addr) marshalBinarySize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mask6" data-name="mask6">
               <h3>
                  mask6 
                  <span class="badge">function</span>
                  
                  <a href="#mask6" class="anchor" title="Link to mask6">#</a>
               </h3>
               
               <p>mask6 returns a uint128 bitmask with the topmost n bits of a
128-bit number.</p>
               
               <pre><code class="language-go">func mask6(n int) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="not" data-name="not">
               <h3>
                  not 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#not" class="anchor" title="Link to not">#</a>
               </h3>
               
               <p>not returns the bitwise NOT of u.</p>
               
               <pre><code class="language-go">func (u uint128) not() uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="or" data-name="or">
               <h3>
                  or 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#or" class="anchor" title="Link to or">#</a>
               </h3>
               
               <p>or returns the bitwise OR of u and m (u|m).</p>
               
               <pre><code class="language-go">func (u uint128) or(m uint128) uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseIPv4" data-name="parseIPv4">
               <h3>
                  parseIPv4 
                  <span class="badge">function</span>
                  
                  <a href="#parseIPv4" class="anchor" title="Link to parseIPv4">#</a>
               </h3>
               
               <p>parseIPv4 parses s as an IPv4 address (in form "192.168.0.1").</p>
               
               <pre><code class="language-go">func parseIPv4(s string) (ip Addr, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseIPv4Fields" data-name="parseIPv4Fields">
               <h3>
                  parseIPv4Fields 
                  <span class="badge">function</span>
                  
                  <a href="#parseIPv4Fields" class="anchor" title="Link to parseIPv4Fields">#</a>
               </h3>
               
               <pre><code class="language-go">func parseIPv4Fields(in string, off int, end int, fields []uint8) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseIPv6" data-name="parseIPv6">
               <h3>
                  parseIPv6 
                  <span class="badge">function</span>
                  
                  <a href="#parseIPv6" class="anchor" title="Link to parseIPv6">#</a>
               </h3>
               
               <p>parseIPv6 parses s as an IPv6 address (in form "2001:db8::68").</p>
               
               <pre><code class="language-go">func parseIPv6(in string) (Addr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitAddrPort" data-name="splitAddrPort">
               <h3>
                  splitAddrPort 
                  <span class="badge">function</span>
                  
                  <a href="#splitAddrPort" class="anchor" title="Link to splitAddrPort">#</a>
               </h3>
               
               <p>splitAddrPort splits s into an IP address string and a port
string. It splits strings shaped like "foo:bar" or "[foo]:bar",
without further validating the substrings. v6 indicates whether the
ip string should parse as an IPv6 address or an IPv4 address, in
order for s to be a valid ip:port string.</p>
               
               <pre><code class="language-go">func splitAddrPort(s string) (ip string, port string, v6 bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="string4" data-name="string4">
               <h3>
                  string4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#string4" class="anchor" title="Link to string4">#</a>
               </h3>
               
               <pre><code class="language-go">func (ip Addr) string4() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="string4In6" data-name="string4In6">
               <h3>
                  string4In6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#string4In6" class="anchor" title="Link to string4In6">#</a>
               </h3>
               
               <pre><code class="language-go">func (ip Addr) string4In6() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="string6" data-name="string6">
               <h3>
                  string6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#string6" class="anchor" title="Link to string6">#</a>
               </h3>
               
               <p>string6 formats ip in IPv6 textual representation. It follows the
guidelines in section 4 of RFC 5952
(https://tools.ietf.org/html/rfc5952#section-4): no unnecessary
zeros, use :: to elide the longest run of zeros, and don't use ::
to compact a single zero field.</p>
               
               <pre><code class="language-go">func (ip Addr) string6() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subOne" data-name="subOne">
               <h3>
                  subOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subOne" class="anchor" title="Link to subOne">#</a>
               </h3>
               
               <p>subOne returns u - 1.</p>
               
               <pre><code class="language-go">func (u uint128) subOne() uint128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="v4" data-name="v4">
               <h3>
                  v4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#v4" class="anchor" title="Link to v4">#</a>
               </h3>
               
               <p>v4 returns the i'th byte of ip. If ip is not an IPv4, v4 returns
unspecified garbage.</p>
               
               <pre><code class="language-go">func (ip Addr) v4(i uint8) uint8</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="v6" data-name="v6">
               <h3>
                  v6 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#v6" class="anchor" title="Link to v6">#</a>
               </h3>
               
               <p>v6 returns the i'th byte of ip. If ip is an IPv4 address, this
accesses the IPv4-mapped IPv6 address form of the IP.</p>
               
               <pre><code class="language-go">func (ip Addr) v6(i uint8) uint8</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="v6u16" data-name="v6u16">
               <h3>
                  v6u16 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#v6u16" class="anchor" title="Link to v6u16">#</a>
               </h3>
               
               <p>v6u16 returns the i'th 16-bit word of ip. If ip is an IPv4 address,
this accesses the IPv4-mapped IPv6 address form of the IP.</p>
               
               <pre><code class="language-go">func (ip Addr) v6u16(i uint8) uint16</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withoutZone" data-name="withoutZone">
               <h3>
                  withoutZone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withoutZone" class="anchor" title="Link to withoutZone">#</a>
               </h3>
               
               <p>withoutZone unconditionally strips the zone from ip.
It's similar to WithZone, but small enough to be inlinable.</p>
               
               <pre><code class="language-go">func (ip Addr) withoutZone() Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xor" data-name="xor">
               <h3>
                  xor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xor" class="anchor" title="Link to xor">#</a>
               </h3>
               
               <p>xor returns the bitwise XOR of u and m (u^m).</p>
               
               <pre><code class="language-go">func (u uint128) xor(m uint128) uint128</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>