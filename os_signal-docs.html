<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - signal</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>signal</code>
         </h1>
         <hr />
         
         <article class="global" data-name="prSetKeepCaps">
            <h2>prSetKeepCaps</h2>
            <hr />
            
            <pre><code>prSetKeepCaps</code></pre>
         </article>
         
         <article class="global" data-name="sigtab">
            <h2>sigtab</h2>
            <hr />
            
            <pre><code>sigtab</code></pre>
         </article>
         
         <article class="global" data-name="numSig">
            <h2>numSig</h2>
            <hr />
            
            <pre><code>numSig</code></pre>
         </article>
         
         <article class="global" data-name="settleTime">
            <h2>settleTime</h2>
            <hr />
            
            <p>settleTime is an upper bound on how long we expect signals to take to be
delivered. Lower values make the test faster, but also flakier — especially
on heavily loaded systems.

The current value is set based on flakes observed in the Go builders.</p>
            
            <pre><code>settleTime</code></pre>
         </article>
         
         <article class="global" data-name="fatalWaitingTime">
            <h2>fatalWaitingTime</h2>
            <hr />
            
            <p>fatalWaitingTime is an absurdly long time to wait for signals to be
delivered but, using it, we (hopefully) eliminate test flakes on the
build servers. See #46736 for discussion.</p>
            
            <pre><code>fatalWaitingTime</code></pre>
         </article>
         
         <article class="global" data-name="checkSighupIgnored">
            <h2>checkSighupIgnored</h2>
            <hr />
            
            <pre><code>checkSighupIgnored</code></pre>
         </article>
         
         <article class="global" data-name="sendUncaughtSighup">
            <h2>sendUncaughtSighup</h2>
            <hr />
            
            <pre><code>sendUncaughtSighup</code></pre>
         </article>
         
         <article class="global" data-name="dieFromSighup">
            <h2>dieFromSighup</h2>
            <hr />
            
            <pre><code>dieFromSighup</code></pre>
         </article>
         
         <article class="global" data-name="checkNotifyContext">
            <h2>checkNotifyContext</h2>
            <hr />
            
            <pre><code>checkNotifyContext</code></pre>
         </article>
         
         <article class="global" data-name="ctxNotifyTimes">
            <h2>ctxNotifyTimes</h2>
            <hr />
            
            <pre><code>ctxNotifyTimes</code></pre>
         </article>
         
         <article class="global" data-name="numSig">
            <h2>numSig</h2>
            <hr />
            
            <pre><code>numSig</code></pre>
         </article>
         
         <article class="global" data-name="handlers">
            <h2>handlers</h2>
            <hr />
            
            <pre><code>handlers *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="watchSignalLoopOnce">
            <h2>watchSignalLoopOnce</h2>
            <hr />
            
            <p>watchSignalLoopOnce guards calling the conditionally
initialized watchSignalLoop. If watchSignalLoop is non-nil,
it will be run in a goroutine lazily once Notify is invoked.
See Issue 21576.</p>
            
            <pre><code>watchSignalLoopOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="watchSignalLoop">
            <h2>watchSignalLoop</h2>
            <hr />
            
            <pre><code>watchSignalLoop func</code></pre>
         </article>
          
         <article class="struct" data-name="stopping">
            <h2>type stopping struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">c *ast.ChanType
h *handler</code></pre>
         </article>
         
         <article class="struct" data-name="handler">
            <h2>type handler struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mask []uint32</code></pre>
         </article>
         
         <article class="struct" data-name="signalCtx">
            <h2>type signalCtx struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">context.Context
cancel context.CancelFunc
signals []os.Signal
ch *ast.ChanType</code></pre>
         </article>
          
         <article class="function" data-name="TestAllThreadsSyscallSignals">
            <h2>TestAllThreadsSyscallSignals</h2>
            <hr />
            
            <p>This test validates that syscall.AllThreadsSyscall() can reliably
reach all 'm' (threads) of the nocgo runtime even when one thread
is blocked waiting to receive signals from the kernel. This monitors
for a regression vs. the fix for #43149.</p>
            
            <pre><code>func TestAllThreadsSyscallSignals(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="signal_disable">
            <h2>signal_disable</h2>
            <hr />
            
            <p>Defined by the runtime package.</p>
            
            <pre><code>func signal_disable(uint32)</code></pre>
         </article>
         
         <article class="function" data-name="signal_enable">
            <h2>signal_enable</h2>
            <hr />
            
            <pre><code>func signal_enable(uint32)</code></pre>
         </article>
         
         <article class="function" data-name="signal_ignore">
            <h2>signal_ignore</h2>
            <hr />
            
            <pre><code>func signal_ignore(uint32)</code></pre>
         </article>
         
         <article class="function" data-name="signal_ignored">
            <h2>signal_ignored</h2>
            <hr />
            
            <pre><code>func signal_ignored(uint32) bool</code></pre>
         </article>
         
         <article class="function" data-name="signal_recv">
            <h2>signal_recv</h2>
            <hr />
            
            <pre><code>func signal_recv() string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="loop">
            <h2>loop</h2>
            <hr />
            
            <pre><code>func loop()</code></pre>
         </article>
         
         <article class="function" data-name="signum">
            <h2>signum</h2>
            <hr />
            
            <pre><code>func signum(sig os.Signal) int</code></pre>
         </article>
         
         <article class="function" data-name="enableSignal">
            <h2>enableSignal</h2>
            <hr />
            
            <pre><code>func enableSignal(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="disableSignal">
            <h2>disableSignal</h2>
            <hr />
            
            <pre><code>func disableSignal(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="ignoreSignal">
            <h2>ignoreSignal</h2>
            <hr />
            
            <pre><code>func ignoreSignal(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="signalIgnored">
            <h2>signalIgnored</h2>
            <hr />
            
            <pre><code>func signalIgnored(sig int) bool</code></pre>
         </article>
         
         <article class="function" data-name="waitSig">
            <h2>waitSig</h2>
            <hr />
            
            <pre><code>func waitSig(t *testing.T, c *ast.ChanType, sig os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="TestSignal">
            <h2>TestSignal</h2>
            <hr />
            
            <p>Test that basic signal handling works.</p>
            
            <pre><code>func TestSignal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStress">
            <h2>TestStress</h2>
            <hr />
            
            <pre><code>func TestStress(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStop">
            <h2>TestStop</h2>
            <hr />
            
            <p>Test that Stop cancels the channel's registrations.</p>
            
            <pre><code>func TestStop(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="postNote">
            <h2>postNote</h2>
            <hr />
            
            <pre><code>func postNote(pid int, note string) error</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="waitSig">
            <h2>waitSig</h2>
            <hr />
            
            <pre><code>func waitSig(t *testing.T, c *ast.ChanType, sig os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="waitSigAll">
            <h2>waitSigAll</h2>
            <hr />
            
            <pre><code>func waitSigAll(t *testing.T, c *ast.ChanType, sig os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="waitSig1">
            <h2>waitSig1</h2>
            <hr />
            
            <pre><code>func waitSig1(t *testing.T, c *ast.ChanType, sig os.Signal, all bool)</code></pre>
         </article>
         
         <article class="function" data-name="quiesce">
            <h2>quiesce</h2>
            <hr />
            
            <p>quiesce waits until we can be reasonably confident that all pending signals
have been delivered by the OS.</p>
            
            <pre><code>func quiesce()</code></pre>
         </article>
         
         <article class="function" data-name="TestSignal">
            <h2>TestSignal</h2>
            <hr />
            
            <p>Test that basic signal handling works.</p>
            
            <pre><code>func TestSignal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStress">
            <h2>TestStress</h2>
            <hr />
            
            <pre><code>func TestStress(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testCancel">
            <h2>testCancel</h2>
            <hr />
            
            <pre><code>func testCancel(t *testing.T, ignore bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestReset">
            <h2>TestReset</h2>
            <hr />
            
            <p>Test that Reset cancels registration for listed signals on all channels.</p>
            
            <pre><code>func TestReset(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIgnore">
            <h2>TestIgnore</h2>
            <hr />
            
            <p>Test that Ignore cancels registration for listed signals on all channels.</p>
            
            <pre><code>func TestIgnore(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIgnored">
            <h2>TestIgnored</h2>
            <hr />
            
            <p>Test that Ignored correctly detects changes to the ignored status of a signal.</p>
            
            <pre><code>func TestIgnored(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDetectNohup">
            <h2>TestDetectNohup</h2>
            <hr />
            
            <p>Test that Ignored(SIGHUP) correctly detects whether it is being run under nohup.</p>
            
            <pre><code>func TestDetectNohup(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStop">
            <h2>TestStop</h2>
            <hr />
            
            <p>Test that Stop cancels the channel's registrations.</p>
            
            <pre><code>func TestStop(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNohup">
            <h2>TestNohup</h2>
            <hr />
            
            <p>Test that when run under nohup, an uncaught SIGHUP does not kill the program.</p>
            
            <pre><code>func TestNohup(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSIGCONT">
            <h2>TestSIGCONT</h2>
            <hr />
            
            <p>Test that SIGCONT works (issue 8953).</p>
            
            <pre><code>func TestSIGCONT(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAtomicStop">
            <h2>TestAtomicStop</h2>
            <hr />
            
            <p>Test race between stopping and receiving a signal (issue 14571).</p>
            
            <pre><code>func TestAtomicStop(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="atomicStopTestProgram">
            <h2>atomicStopTestProgram</h2>
            <hr />
            
            <p>atomicStopTestProgram is run in a subprocess by TestAtomicStop.
It tries to trigger a signal delivery race. This function should
either catch a signal or die from it.</p>
            
            <pre><code>func atomicStopTestProgram(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTime">
            <h2>TestTime</h2>
            <hr />
            
            <pre><code>func TestTime(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNotifyContextNotifications">
            <h2>TestNotifyContextNotifications</h2>
            <hr />
            
            <pre><code>func TestNotifyContextNotifications(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNotifyContextStop">
            <h2>TestNotifyContextStop</h2>
            <hr />
            
            <pre><code>func TestNotifyContextStop(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNotifyContextCancelParent">
            <h2>TestNotifyContextCancelParent</h2>
            <hr />
            
            <pre><code>func TestNotifyContextCancelParent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNotifyContextPrematureCancelParent">
            <h2>TestNotifyContextPrematureCancelParent</h2>
            <hr />
            
            <pre><code>func TestNotifyContextPrematureCancelParent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNotifyContextSimultaneousStop">
            <h2>TestNotifyContextSimultaneousStop</h2>
            <hr />
            
            <pre><code>func TestNotifyContextSimultaneousStop(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNotifyContextStringer">
            <h2>TestNotifyContextStringer</h2>
            <hr />
            
            <pre><code>func TestNotifyContextStringer(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSignalTrace">
            <h2>TestSignalTrace</h2>
            <hr />
            
            <p>#44193 test signal handling while stopping and starting the world.</p>
            
            <pre><code>func TestSignalTrace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="signal_disable">
            <h2>signal_disable</h2>
            <hr />
            
            <p>Defined by the runtime package.</p>
            
            <pre><code>func signal_disable(uint32)</code></pre>
         </article>
         
         <article class="function" data-name="signal_enable">
            <h2>signal_enable</h2>
            <hr />
            
            <pre><code>func signal_enable(uint32)</code></pre>
         </article>
         
         <article class="function" data-name="signal_ignore">
            <h2>signal_ignore</h2>
            <hr />
            
            <pre><code>func signal_ignore(uint32)</code></pre>
         </article>
         
         <article class="function" data-name="signal_ignored">
            <h2>signal_ignored</h2>
            <hr />
            
            <pre><code>func signal_ignored(uint32) bool</code></pre>
         </article>
         
         <article class="function" data-name="signal_recv">
            <h2>signal_recv</h2>
            <hr />
            
            <pre><code>func signal_recv() uint32</code></pre>
         </article>
         
         <article class="function" data-name="loop">
            <h2>loop</h2>
            <hr />
            
            <pre><code>func loop()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="signum">
            <h2>signum</h2>
            <hr />
            
            <pre><code>func signum(sig os.Signal) int</code></pre>
         </article>
         
         <article class="function" data-name="enableSignal">
            <h2>enableSignal</h2>
            <hr />
            
            <pre><code>func enableSignal(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="disableSignal">
            <h2>disableSignal</h2>
            <hr />
            
            <pre><code>func disableSignal(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="ignoreSignal">
            <h2>ignoreSignal</h2>
            <hr />
            
            <pre><code>func ignoreSignal(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="signalIgnored">
            <h2>signalIgnored</h2>
            <hr />
            
            <pre><code>func signalIgnored(sig int) bool</code></pre>
         </article>
         
         <article class="function" data-name="sendCtrlBreak">
            <h2>sendCtrlBreak</h2>
            <hr />
            
            <pre><code>func sendCtrlBreak(t *testing.T, pid int)</code></pre>
         </article>
         
         <article class="function" data-name="TestCtrlBreak">
            <h2>TestCtrlBreak</h2>
            <hr />
            
            <pre><code>func TestCtrlBreak(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="want">
            <h2>want</h2>
            <hr />
            
            <pre><code>func want(sig int) bool</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <pre><code>func set(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="clear">
            <h2>clear</h2>
            <hr />
            
            <pre><code>func clear(sig int)</code></pre>
         </article>
         
         <article class="function" data-name="cancel">
            <h2>cancel</h2>
            <hr />
            
            <p>Stop relaying the signals, sigs, to any channels previously registered to
receive them and either reset the signal handlers to their original values
(action=disableSignal) or ignore the signals (action=ignoreSignal).</p>
            
            <pre><code>func cancel(sigs []os.Signal, action func)</code></pre>
         </article>
         
         <article class="function" data-name="Ignore">
            <h2>Ignore</h2>
            <hr />
            
            <p>Ignore causes the provided signals to be ignored. If they are received by
the program, nothing will happen. Ignore undoes the effect of any prior
calls to [Notify] for the provided signals.
If no signals are provided, all incoming signals will be ignored.</p>
            
            <pre><code>func Ignore(sig ...os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="Ignored">
            <h2>Ignored</h2>
            <hr />
            
            <p>Ignored reports whether sig is currently ignored.</p>
            
            <pre><code>func Ignored(sig os.Signal) bool</code></pre>
         </article>
         
         <article class="function" data-name="Notify">
            <h2>Notify</h2>
            <hr />
            
            <p>Notify causes package signal to relay incoming signals to c.
If no signals are provided, all incoming signals will be relayed to c.
Otherwise, just the provided signals will.

Package signal will not block sending to c: the caller must ensure
that c has sufficient buffer space to keep up with the expected
signal rate. For a channel used for notification of just one signal value,
a buffer of size 1 is sufficient.

It is allowed to call Notify multiple times with the same channel:
each call expands the set of signals sent to that channel.
The only way to remove signals from the set is to call [Stop].

It is allowed to call Notify multiple times with different channels
and the same signals: each channel receives copies of incoming
signals independently.</p>
            
            <pre><code>func Notify(c *ast.ChanType, sig ...os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset undoes the effect of any prior calls to [Notify] for the provided
signals.
If no signals are provided, all signal handlers will be reset.</p>
            
            <pre><code>func Reset(sig ...os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="Stop">
            <h2>Stop</h2>
            <hr />
            
            <p>Stop causes package signal to stop relaying incoming signals to c.
It undoes the effect of all prior calls to [Notify] using c.
When Stop returns, it is guaranteed that c will receive no more signals.</p>
            
            <pre><code>func Stop(c *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="signalWaitUntilIdle">
            <h2>signalWaitUntilIdle</h2>
            <hr />
            
            <p>Wait until there are no more signals waiting to be delivered.
Defined by the runtime package.</p>
            
            <pre><code>func signalWaitUntilIdle()</code></pre>
         </article>
         
         <article class="function" data-name="process">
            <h2>process</h2>
            <hr />
            
            <pre><code>func process(sig os.Signal)</code></pre>
         </article>
         
         <article class="function" data-name="NotifyContext">
            <h2>NotifyContext</h2>
            <hr />
            
            <p>NotifyContext returns a copy of the parent context that is marked done
(its Done channel is closed) when one of the listed signals arrives,
when the returned stop function is called, or when the parent context's
Done channel is closed, whichever happens first.

The stop function unregisters the signal behavior, which, like [signal.Reset],
may restore the default behavior for a given signal. For example, the default
behavior of a Go program receiving [os.Interrupt] is to exit. Calling
NotifyContext(parent, os.Interrupt) will change the behavior to cancel
the returned context. Future interrupts received will not trigger the default
(exit) behavior until the returned stop function is called.

The stop function releases resources associated with it, so code should
call stop as soon as the operations running in this Context complete and
signals no longer need to be diverted to the context.</p>
            
            <pre><code>func NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)</code></pre>
         </article>
         
         <article class="function" data-name="stop">
            <h2>stop</h2>
            <hr />
            
            <pre><code>func stop()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
