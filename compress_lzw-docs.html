<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>lzw - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>lzw</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bufio"
"errors"
"fmt"
"io"
"bufio"
"errors"
"fmt"
"io"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="LSB" data-name="LSB">
               <h3>
                  LSB 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LSB" class="anchor" title="Link to LSB">#</a>
               </h3>
               
                  <p class="doc-comment">LSB means Least Significant Bits first, as used in the GIF file format.</p>
               
               <pre><code class="language-go">const LSB Order = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MSB" data-name="MSB">
               <h3>
                  MSB 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MSB" class="anchor" title="Link to MSB">#</a>
               </h3>
               
                  <p class="doc-comment">MSB means Most Significant Bits first, as used in the TIFF and PDF
file formats.</p>
               
               <pre><code class="language-go">const MSB</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="decoderInvalidCode" data-name="decoderInvalidCode">
               <h3>
                  decoderInvalidCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#decoderInvalidCode" class="anchor" title="Link to decoderInvalidCode">#</a>
               </h3>
               
               <pre><code class="language-go">const decoderInvalidCode = 0xffff</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errClosed" data-name="errClosed">
               <h3>
                  errClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errClosed" class="anchor" title="Link to errClosed">#</a>
               </h3>
               
               <pre><code class="language-go">var errClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errOutOfCodes" data-name="errOutOfCodes">
               <h3>
                  errOutOfCodes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errOutOfCodes" class="anchor" title="Link to errOutOfCodes">#</a>
               </h3>
               
                  <p class="doc-comment">errOutOfCodes is an internal error that means that the writer has run out
of unused codes and a clear code needs to be sent next.</p>
               
               <pre><code class="language-go">var errOutOfCodes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flushBuffer" data-name="flushBuffer">
               <h3>
                  flushBuffer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flushBuffer" class="anchor" title="Link to flushBuffer">#</a>
               </h3>
               
               <pre><code class="language-go">const flushBuffer = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidCode" data-name="invalidCode">
               <h3>
                  invalidCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidCode" class="anchor" title="Link to invalidCode">#</a>
               </h3>
               
               <pre><code class="language-go">const invalidCode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidEntry" data-name="invalidEntry">
               <h3>
                  invalidEntry 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidEntry" class="anchor" title="Link to invalidEntry">#</a>
               </h3>
               
                  <p class="doc-comment">A hash table entry is a uint32. Zero is an invalid entry since the
lower 12 bits of a valid entry must be a non-literal code.</p>
               
               <pre><code class="language-go">const invalidEntry = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxCode" data-name="maxCode">
               <h3>
                  maxCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxCode" class="anchor" title="Link to maxCode">#</a>
               </h3>
               
                  <p class="doc-comment">A code is a 12 bit value, stored as a uint32 when encoding to avoid
type conversions when shifting bits.</p>
               
               <pre><code class="language-go">const maxCode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxWidth" data-name="maxWidth">
               <h3>
                  maxWidth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxWidth" class="anchor" title="Link to maxWidth">#</a>
               </h3>
               
               <pre><code class="language-go">const maxWidth = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tableMask" data-name="tableMask">
               <h3>
                  tableMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#tableMask" class="anchor" title="Link to tableMask">#</a>
               </h3>
               
               <pre><code class="language-go">const tableMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tableSize" data-name="tableSize">
               <h3>
                  tableSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#tableSize" class="anchor" title="Link to tableSize">#</a>
               </h3>
               
                  <p class="doc-comment">There are 1<<12 possible codes, which is an upper bound on the number of
valid hash table entries at any given point in time. tableSize is 4x that.</p>
               
               <pre><code class="language-go">const tableSize = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Order" data-name="Order">
               <h3>
                  Order
                  <span class="badge type-badge">type</span>
                  <a href="#Order" class="anchor" title="Link to Order">#</a>
               </h3>
               
               <p>Order specifies the bit ordering in an LZW data stream.</p>
               
               <pre><code class="language-go">type Order int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="writer" data-name="writer">
               <h3>
                  writer
                  <span class="badge interface-badge">interface</span>
                  <a href="#writer" class="anchor" title="Link to writer">#</a>
               </h3>
               
               <p>A writer is a buffered, flushable writer.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type writer interface {
io.ByteWriter
Flush() error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>Reader is an io.Reader which can be used to read compressed data in the
LZW format.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Reader struct {
r io.ByteReader
bits uint32
nBits uint
width uint
read func(*Reader) (uint16, error)
litWidth int
err error
clear uint16
eof uint16
hi uint16
overflow uint16
last uint16
suffix [*ast.BinaryExpr]uint8
prefix [*ast.BinaryExpr]uint16
output [*ast.BinaryExpr]byte
o int
toRead []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>Writer is an LZW compressor. It writes the compressed form of the data
to an underlying writer (see [NewWriter]).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Writer struct {
w writer
litWidth uint
order Order
write func(*Writer, uint32) error
nBits uint
width uint
bits uint32
hi uint32
overflow uint32
savedCode uint32
err error
table [tableSize]uint32
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the [Writer], flushing any pending output. It does not close
w's underlying writer.</p>
               
               <pre><code class="language-go">func (w *Writer) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the [Reader] and returns an error for any future read operation.
It does not close the underlying [io.Reader].</p>
               
               <pre><code class="language-go">func (r *Reader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader creates a new [io.ReadCloser].
Reads from the returned [io.ReadCloser] read and decompress data from r.
If r does not also implement [io.ByteReader],
the decompressor may read more data than necessary from r.
It is the caller's responsibility to call Close on the ReadCloser when
finished reading.
The number of bits to use for literal codes, litWidth, must be in the
range [2,8] and is typically 8. It must equal the litWidth
used during compression.
It is guaranteed that the underlying type of the returned [io.ReadCloser]
is a *[Reader].</p>
               
               <pre><code class="language-go">func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter creates a new [io.WriteCloser].
Writes to the returned [io.WriteCloser] are compressed and written to w.
It is the caller's responsibility to call Close on the WriteCloser when
finished writing.
The number of bits to use for literal codes, litWidth, must be in the
range [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.
It is guaranteed that the underlying type of the returned [io.WriteCloser]
is a *[Writer].</p>
               
               <pre><code class="language-go">func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read implements io.Reader, reading uncompressed bytes from its underlying [Reader].</p>
               
               <pre><code class="language-go">func (r *Reader) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset clears the [Writer]'s state and allows it to be reused again
as a new [Writer].</p>
               
               <pre><code class="language-go">func (w *Writer) Reset(dst io.Writer, order Order, litWidth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset clears the [Reader]'s state and allows it to be reused again
as a new [Reader].</p>
               
               <pre><code class="language-go">func (r *Reader) Reset(src io.Reader, order Order, litWidth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes a compressed representation of p to w's underlying writer.</p>
               
               <pre><code class="language-go">func (w *Writer) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decode" data-name="decode">
               <h3>
                  decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decode" class="anchor" title="Link to decode">#</a>
               </h3>
               
               <p>decode decompresses bytes from r and leaves them in d.toRead.
read specifies how to decode bytes into codes.
litWidth is the width in bits of literal codes.</p>
               
               <pre><code class="language-go">func (r *Reader) decode()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="incHi" data-name="incHi">
               <h3>
                  incHi 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#incHi" class="anchor" title="Link to incHi">#</a>
               </h3>
               
               <p>incHi increments e.hi and checks for both overflow and running out of
unused codes. In the latter case, incHi sends a clear code, resets the
writer state and returns errOutOfCodes.</p>
               
               <pre><code class="language-go">func (w *Writer) incHi() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Reader) init(src io.Reader, order Order, litWidth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *Writer) init(dst io.Writer, order Order, litWidth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newReader" data-name="newReader">
               <h3>
                  newReader 
                  <span class="badge">function</span>
                  
                  <a href="#newReader" class="anchor" title="Link to newReader">#</a>
               </h3>
               
               <pre><code class="language-go">func newReader(src io.Reader, order Order, litWidth int) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWriter" data-name="newWriter">
               <h3>
                  newWriter 
                  <span class="badge">function</span>
                  
                  <a href="#newWriter" class="anchor" title="Link to newWriter">#</a>
               </h3>
               
               <pre><code class="language-go">func newWriter(dst io.Writer, order Order, litWidth int) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLSB" data-name="readLSB">
               <h3>
                  readLSB 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLSB" class="anchor" title="Link to readLSB">#</a>
               </h3>
               
               <p>readLSB returns the next code for "Least Significant Bits first" data.</p>
               
               <pre><code class="language-go">func (r *Reader) readLSB() (uint16, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readMSB" data-name="readMSB">
               <h3>
                  readMSB 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readMSB" class="anchor" title="Link to readMSB">#</a>
               </h3>
               
               <p>readMSB returns the next code for "Most Significant Bits first" data.</p>
               
               <pre><code class="language-go">func (r *Reader) readMSB() (uint16, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeLSB" data-name="writeLSB">
               <h3>
                  writeLSB 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeLSB" class="anchor" title="Link to writeLSB">#</a>
               </h3>
               
               <p>writeLSB writes the code c for "Least Significant Bits first" data.</p>
               
               <pre><code class="language-go">func (w *Writer) writeLSB(c uint32) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeMSB" data-name="writeMSB">
               <h3>
                  writeMSB 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeMSB" class="anchor" title="Link to writeMSB">#</a>
               </h3>
               
               <p>writeMSB writes the code c for "Most Significant Bits first" data.</p>
               
               <pre><code class="language-go">func (w *Writer) writeMSB(c uint32) error</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>