<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - types</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>types</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmd/compile/internal/base"
"strconv"
"fmt"
"internal/goversion"
"internal/lazyregexp"
"log"
"strconv"
"cmd/compile/internal/base"
"math"
"slices"
"cmd/compile/internal/base"
"cmd/internal/src"
"internal/types/errors"
"cmd/compile/internal/base"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"go/constant"
"internal/buildcfg"
"internal/types/errors"
"sync"
"bytes"
"encoding/binary"
"fmt"
"strconv"
"sync"
"cmd/compile/internal/base"
"cmd/internal/hash"
"strconv"
"cmd/internal/obj"
"cmd/internal/objabi"
"fmt"
"strconv"
"sync"
"cmd/compile/internal/base"
"cmd/internal/obj"
"strings"
"unicode"
"unicode/utf8"
"cmd/compile/internal/base"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ACPLX128">
               <h3>
                  ACPLX128 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ACPLX128</code></pre>
            </article>
            
            <article class="global" data-name="ACPLX64">
               <h3>
                  ACPLX64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ACPLX64</code></pre>
            </article>
            
            <article class="global" data-name="AFLOAT32">
               <h3>
                  AFLOAT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AFLOAT32</code></pre>
            </article>
            
            <article class="global" data-name="AFLOAT64">
               <h3>
                  AFLOAT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AFLOAT64</code></pre>
            </article>
            
            <article class="global" data-name="AINTER">
               <h3>
                  AINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AINTER</code></pre>
            </article>
            
            <article class="global" data-name="AMEM">
               <h3>
                  AMEM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM</code></pre>
            </article>
            
            <article class="global" data-name="AMEM0">
               <h3>
                  AMEM0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM0</code></pre>
            </article>
            
            <article class="global" data-name="AMEM128">
               <h3>
                  AMEM128 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM128</code></pre>
            </article>
            
            <article class="global" data-name="AMEM16">
               <h3>
                  AMEM16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM16</code></pre>
            </article>
            
            <article class="global" data-name="AMEM32">
               <h3>
                  AMEM32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM32</code></pre>
            </article>
            
            <article class="global" data-name="AMEM64">
               <h3>
                  AMEM64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM64</code></pre>
            </article>
            
            <article class="global" data-name="AMEM8">
               <h3>
                  AMEM8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AMEM8</code></pre>
            </article>
            
            <article class="global" data-name="ANILINTER">
               <h3>
                  ANILINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ANILINTER</code></pre>
            </article>
            
            <article class="global" data-name="ANOALG">
               <h3>
                  ANOALG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ANOALG</code></pre>
            </article>
            
            <article class="global" data-name="ANOEQ">
               <h3>
                  ANOEQ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ANOEQ</code></pre>
            </article>
            
            <article class="global" data-name="ASPECIAL">
               <h3>
                  ASPECIAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ASPECIAL</code></pre>
            </article>
            
            <article class="global" data-name="ASTRING">
               <h3>
                  ASTRING 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ASTRING</code></pre>
            </article>
            
            <article class="global" data-name="AUNK">
               <h3>
                  AUNK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AUNK AlgKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="AnyType">
               <h3>
                  AnyType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Predeclared alias types. These are actually created as distinct
defined types for better error messages, but are then specially
treated as identical to their respective underlying types.</p>
               
               <pre><code>var AnyType *Type</code></pre>
            </article>
            
            <article class="global" data-name="BADWIDTH">
               <h3>
                  BADWIDTH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BADWIDTH = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="BasicTypeNames">
               <h3>
                  BasicTypeNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var BasicTypeNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="BlankSym">
               <h3>
                  BlankSym 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>BlankSym is the blank (_) symbol.</p>
               
               <pre><code>var BlankSym *Sym</code></pre>
            </article>
            
            <article class="global" data-name="BuiltinPkg">
               <h3>
                  BuiltinPkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>BuiltinPkg is a fake package that declares the universe block.</p>
               
               <pre><code>var BuiltinPkg *Pkg</code></pre>
            </article>
            
            <article class="global" data-name="ByteType">
               <h3>
                  ByteType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ByteType *Type</code></pre>
            </article>
            
            <article class="global" data-name="CMPeq">
               <h3>
                  CMPeq 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CMPeq = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="CMPgt">
               <h3>
                  CMPgt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CMPgt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="CMPlt">
               <h3>
                  CMPlt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CMPlt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="CalcSizeDisabled">
               <h3>
                  CalcSizeDisabled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>CalcSizeDisabled indicates whether it is safe
to calculate Types' widths and alignments. See CalcSize.</p>
               
               <pre><code>var CalcSizeDisabled bool</code></pre>
            </article>
            
            <article class="global" data-name="Cboth">
               <h3>
                  Cboth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Cboth ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ComparableType">
               <h3>
                  ComparableType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Predeclared comparable interface type.</p>
               
               <pre><code>var ComparableType *Type</code></pre>
            </article>
            
            <article class="global" data-name="CountBlankFields">
               <h3>
                  CountBlankFields 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CountBlankFields componentsIncludeBlankFields = true</code></pre>
            </article>
            
            <article class="global" data-name="Crecv">
               <h3>
                  Crecv 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>types of channel
must match ../../../../reflect/type.go:/ChanDir</p>
               
               <pre><code>const Crecv ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Csend">
               <h3>
                  Csend 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Csend ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="DefaultKinds">
               <h3>
                  DefaultKinds 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DefaultKinds maps from a constant.Kind to its default Kind.</p>
               
               <pre><code>var DefaultKinds = [...]Kind{...}</code></pre>
            </article>
            
            <article class="global" data-name="ErrorType">
               <h3>
                  ErrorType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Predeclared error interface type.</p>
               
               <pre><code>var ErrorType *Type</code></pre>
            </article>
            
            <article class="global" data-name="IgnoreBlankFields">
               <h3>
                  IgnoreBlankFields 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IgnoreBlankFields componentsIncludeBlankFields = false</code></pre>
            </article>
            
            <article class="global" data-name="IsComplex">
               <h3>
                  IsComplex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var IsComplex [NTYPE]bool</code></pre>
            </article>
            
            <article class="global" data-name="IsFloat">
               <h3>
                  IsFloat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var IsFloat [NTYPE]bool</code></pre>
            </article>
            
            <article class="global" data-name="IsInt">
               <h3>
                  IsInt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var IsInt [NTYPE]bool</code></pre>
            </article>
            
            <article class="global" data-name="IsOrdered">
               <h3>
                  IsOrdered 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var IsOrdered [NTYPE]bool</code></pre>
            </article>
            
            <article class="global" data-name="IsSimple">
               <h3>
                  IsSimple 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var IsSimple [NTYPE]bool</code></pre>
            </article>
            
            <article class="global" data-name="LocalPkg">
               <h3>
                  LocalPkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>LocalPkg is the package being compiled.</p>
               
               <pre><code>var LocalPkg *Pkg</code></pre>
            </article>
            
            <article class="global" data-name="MaxWidth">
               <h3>
                  MaxWidth 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>MaxWidth is the maximum size of a value on the target architecture.</p>
               
               <pre><code>var MaxWidth int64</code></pre>
            </article>
            
            <article class="global" data-name="NTYPE">
               <h3>
                  NTYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NTYPE</code></pre>
            </article>
            
            <article class="global" data-name="NewPtrCacheEnabled">
               <h3>
                  NewPtrCacheEnabled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>NewPtrCacheEnabled controls whether *T Types are cached in T.
Caching is disabled just before starting the backend.
This allows the backend to run concurrently.</p>
               
               <pre><code>var NewPtrCacheEnabled = true</code></pre>
            </article>
            
            <article class="global" data-name="NumImport">
               <h3>
                  NumImport 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>numImport tracks how often a package with a given name is imported.
It is used to provide a better error message (by using the package
path to disambiguate) if a package that appears multiple times with
the same name appears in an error message.</p>
               
               <pre><code>var NumImport = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="PtrSize">
               <h3>
                  PtrSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var PtrSize int</code></pre>
            </article>
            
            <article class="global" data-name="RegSize">
               <h3>
                  RegSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var RegSize int</code></pre>
            </article>
            
            <article class="global" data-name="RuneType">
               <h3>
                  RuneType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var RuneType *Type</code></pre>
            </article>
            
            <article class="global" data-name="ShapePkg">
               <h3>
                  ShapePkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Fake package for shape types (see typecheck.Shapify()).</p>
               
               <pre><code>var ShapePkg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="SimType">
               <h3>
                  SimType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var SimType [NTYPE]Kind</code></pre>
            </article>
            
            <article class="global" data-name="SkipSizeForTracing">
               <h3>
                  SkipSizeForTracing 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var SkipSizeForTracing bool</code></pre>
            </article>
            
            <article class="global" data-name="SliceCapOffset">
               <h3>
                  SliceCapOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Slices in the runtime are represented by three components:
type slice struct {
ptr unsafe.Pointer
len int
cap int
}
Strings in the runtime are represented by two components:
type string struct {
ptr unsafe.Pointer
len int
}
These variables are the offsets of fields and sizes of these structs.</p>
               
               <pre><code>var SliceCapOffset int64</code></pre>
            </article>
            
            <article class="global" data-name="SliceLenOffset">
               <h3>
                  SliceLenOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Slices in the runtime are represented by three components:
type slice struct {
ptr unsafe.Pointer
len int
cap int
}
Strings in the runtime are represented by two components:
type string struct {
ptr unsafe.Pointer
len int
}
These variables are the offsets of fields and sizes of these structs.</p>
               
               <pre><code>var SliceLenOffset int64</code></pre>
            </article>
            
            <article class="global" data-name="SlicePtrOffset">
               <h3>
                  SlicePtrOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Slices in the runtime are represented by three components:
type slice struct {
ptr unsafe.Pointer
len int
cap int
}
Strings in the runtime are represented by two components:
type string struct {
ptr unsafe.Pointer
len int
}
These variables are the offsets of fields and sizes of these structs.</p>
               
               <pre><code>var SlicePtrOffset int64</code></pre>
            </article>
            
            <article class="global" data-name="SliceSize">
               <h3>
                  SliceSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Slices in the runtime are represented by three components:
type slice struct {
ptr unsafe.Pointer
len int
cap int
}
Strings in the runtime are represented by two components:
type string struct {
ptr unsafe.Pointer
len int
}
These variables are the offsets of fields and sizes of these structs.</p>
               
               <pre><code>var SliceSize int64</code></pre>
            </article>
            
            <article class="global" data-name="StringSize">
               <h3>
                  StringSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Slices in the runtime are represented by three components:
type slice struct {
ptr unsafe.Pointer
len int
cap int
}
Strings in the runtime are represented by two components:
type string struct {
ptr unsafe.Pointer
len int
}
These variables are the offsets of fields and sizes of these structs.</p>
               
               <pre><code>var StringSize int64</code></pre>
            </article>
            
            <article class="global" data-name="TANY">
               <h3>
                  TANY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TANY</code></pre>
            </article>
            
            <article class="global" data-name="TARRAY">
               <h3>
                  TARRAY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TARRAY</code></pre>
            </article>
            
            <article class="global" data-name="TBLANK">
               <h3>
                  TBLANK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TBLANK</code></pre>
            </article>
            
            <article class="global" data-name="TBOOL">
               <h3>
                  TBOOL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TBOOL</code></pre>
            </article>
            
            <article class="global" data-name="TCHAN">
               <h3>
                  TCHAN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TCHAN</code></pre>
            </article>
            
            <article class="global" data-name="TCHANARGS">
               <h3>
                  TCHANARGS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TCHANARGS</code></pre>
            </article>
            
            <article class="global" data-name="TCOMPLEX128">
               <h3>
                  TCOMPLEX128 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TCOMPLEX128</code></pre>
            </article>
            
            <article class="global" data-name="TCOMPLEX64">
               <h3>
                  TCOMPLEX64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TCOMPLEX64</code></pre>
            </article>
            
            <article class="global" data-name="TFLOAT32">
               <h3>
                  TFLOAT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TFLOAT32</code></pre>
            </article>
            
            <article class="global" data-name="TFLOAT64">
               <h3>
                  TFLOAT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TFLOAT64</code></pre>
            </article>
            
            <article class="global" data-name="TFORW">
               <h3>
                  TFORW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TFORW</code></pre>
            </article>
            
            <article class="global" data-name="TFUNC">
               <h3>
                  TFUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TFUNC</code></pre>
            </article>
            
            <article class="global" data-name="TFUNCARGS">
               <h3>
                  TFUNCARGS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>pseudo-types used temporarily only during frame layout (CalcSize())</p>
               
               <pre><code>const TFUNCARGS</code></pre>
            </article>
            
            <article class="global" data-name="TIDEAL">
               <h3>
                  TIDEAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>pseudo-types for literals</p>
               
               <pre><code>const TIDEAL</code></pre>
            </article>
            
            <article class="global" data-name="TINT">
               <h3>
                  TINT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TINT</code></pre>
            </article>
            
            <article class="global" data-name="TINT16">
               <h3>
                  TINT16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TINT16</code></pre>
            </article>
            
            <article class="global" data-name="TINT32">
               <h3>
                  TINT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TINT32</code></pre>
            </article>
            
            <article class="global" data-name="TINT64">
               <h3>
                  TINT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TINT64</code></pre>
            </article>
            
            <article class="global" data-name="TINT8">
               <h3>
                  TINT8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TINT8</code></pre>
            </article>
            
            <article class="global" data-name="TINTER">
               <h3>
                  TINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TINTER</code></pre>
            </article>
            
            <article class="global" data-name="TMAP">
               <h3>
                  TMAP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TMAP</code></pre>
            </article>
            
            <article class="global" data-name="TNIL">
               <h3>
                  TNIL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TNIL</code></pre>
            </article>
            
            <article class="global" data-name="TPTR">
               <h3>
                  TPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TPTR</code></pre>
            </article>
            
            <article class="global" data-name="TRESULTS">
               <h3>
                  TRESULTS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TRESULTS</code></pre>
            </article>
            
            <article class="global" data-name="TSLICE">
               <h3>
                  TSLICE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TSLICE</code></pre>
            </article>
            
            <article class="global" data-name="TSSA">
               <h3>
                  TSSA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>SSA backend types</p>
               
               <pre><code>const TSSA</code></pre>
            </article>
            
            <article class="global" data-name="TSTRING">
               <h3>
                  TSTRING 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TSTRING</code></pre>
            </article>
            
            <article class="global" data-name="TSTRUCT">
               <h3>
                  TSTRUCT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TSTRUCT</code></pre>
            </article>
            
            <article class="global" data-name="TTUPLE">
               <h3>
                  TTUPLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TTUPLE</code></pre>
            </article>
            
            <article class="global" data-name="TUINT">
               <h3>
                  TUINT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUINT</code></pre>
            </article>
            
            <article class="global" data-name="TUINT16">
               <h3>
                  TUINT16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUINT16</code></pre>
            </article>
            
            <article class="global" data-name="TUINT32">
               <h3>
                  TUINT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUINT32</code></pre>
            </article>
            
            <article class="global" data-name="TUINT64">
               <h3>
                  TUINT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUINT64</code></pre>
            </article>
            
            <article class="global" data-name="TUINT8">
               <h3>
                  TUINT8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUINT8</code></pre>
            </article>
            
            <article class="global" data-name="TUINTPTR">
               <h3>
                  TUINTPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUINTPTR</code></pre>
            </article>
            
            <article class="global" data-name="TUNSAFEPTR">
               <h3>
                  TUNSAFEPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TUNSAFEPTR</code></pre>
            </article>
            
            <article class="global" data-name="Txxx">
               <h3>
                  Txxx 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Txxx Kind = iota</code></pre>
            </article>
            
            <article class="global" data-name="TypeFlags">
               <h3>
                  TypeFlags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TypeFlags = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="TypeInt128">
               <h3>
                  TypeInt128 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TypeInt128 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="TypeInvalid">
               <h3>
                  TypeInvalid 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>TSSA types. HasPointers assumes these are pointer-free.</p>
               
               <pre><code>var TypeInvalid = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="TypeMem">
               <h3>
                  TypeMem 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TypeMem = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="TypeResultMem">
               <h3>
                  TypeResultMem 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TypeResultMem = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="TypeVoid">
               <h3>
                  TypeVoid 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TypeVoid = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="Types">
               <h3>
                  Types 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Types stores pointers to predeclared named types.
It also stores pointers to several special types:
- Types[TANY] is the placeholder "any" type recognized by SubstArgTypes.
- Types[TBLANK] represents the blank variable's type.
- Types[TINTER] is the canonical "interface{}" type.
- Types[TNIL] represents the predeclared "nil" value's type.
- Types[TUNSAFEPTR] is package unsafe's Pointer type.</p>
               
               <pre><code>var Types [NTYPE]*Type</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePkg">
               <h3>
                  UnsafePkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>UnsafePkg is package unsafe.</p>
               
               <pre><code>var UnsafePkg *Pkg</code></pre>
            </article>
            
            <article class="global" data-name="UntypedBool">
               <h3>
                  UntypedBool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var UntypedBool = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="UntypedComplex">
               <h3>
                  UntypedComplex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var UntypedComplex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="UntypedFloat">
               <h3>
                  UntypedFloat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var UntypedFloat = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="UntypedInt">
               <h3>
                  UntypedInt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Types to represent untyped numeric constants.</p>
               
               <pre><code>var UntypedInt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="UntypedRune">
               <h3>
                  UntypedRune 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var UntypedRune = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="UntypedString">
               <h3>
                  UntypedString 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Types to represent untyped string and boolean constants.</p>
               
               <pre><code>var UntypedString = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="UntypedTypes">
               <h3>
                  UntypedTypes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>UntypedTypes maps from a constant.Kind to its untyped Type
representation.</p>
               
               <pre><code>var UntypedTypes = [...]*Type{...}</code></pre>
            </article>
            
            <article class="global" data-name="_AlgKind_index">
               <h3>
                  _AlgKind_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _AlgKind_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_AlgKind_name">
               <h3>
                  _AlgKind_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _AlgKind_name = "UNKNOEQNOALGMEMMEM0MEM8MEM16MEM32MEM64MEM128STRINGINTERNILINTERFLOAT32FLOAT64CPLX64CPLX128SPECIAL"</code></pre>
            </article>
            
            <article class="global" data-name="_Kind_index">
               <h3>
                  _Kind_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _Kind_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_Kind_name">
               <h3>
                  _Kind_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Kind_name = "xxxINT8UINT8INT16UINT16INT32UINT32INT64UINT64INTUINTUINTPTRCOMPLEX64COMPLEX128FLOAT32FLOAT64BOOLPTRFUNCSLICEARRAYSTRUCTCHANMAPINTERFORWANYSTRINGUNSAFEPTRIDEALNILBLANKFUNCARGSCHANARGSSSATUPLERESULTSNTYPE"</code></pre>
            </article>
            
            <article class="global" data-name="algPriority">
               <h3>
                  algPriority 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Most kinds are priority 0. Higher numbers are higher priority, in that
the higher priority kinds override lower priority kinds.</p>
               
               <pre><code>var algPriority = [*ast.BinaryExpr]int8{...}</code></pre>
            </article>
            
            <article class="global" data-name="basicTypes">
               <h3>
                  basicTypes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var basicTypes = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="defercalc">
               <h3>
                  defercalc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>machine size and rounding alignment is dictated around
the size of a pointer, set in gc.Main (see ../gc/main.go).</p>
               
               <pre><code>var defercalc int</code></pre>
            </article>
            
            <article class="global" data-name="deferredTypeStack">
               <h3>
                  deferredTypeStack 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var deferredTypeStack []*Type</code></pre>
            </article>
            
            <article class="global" data-name="fieldIsDDD">
               <h3>
                  fieldIsDDD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fieldIsDDD = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="fieldNointerface">
               <h3>
                  fieldNointerface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fieldNointerface</code></pre>
            </article>
            
            <article class="global" data-name="fmtBufferPool">
               <h3>
                  fmtBufferPool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fmtBufferPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="fmtDebug">
               <h3>
                  fmtDebug 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fmtDebug</code></pre>
            </article>
            
            <article class="global" data-name="fmtGo">
               <h3>
                  fmtGo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fmtGo fmtMode = iota</code></pre>
            </article>
            
            <article class="global" data-name="fmtTypeID">
               <h3>
                  fmtTypeID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fmtTypeID</code></pre>
            </article>
            
            <article class="global" data-name="fmtTypeIDName">
               <h3>
                  fmtTypeIDName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fmtTypeIDName</code></pre>
            </article>
            
            <article class="global" data-name="goVersionRE">
               <h3>
                  goVersionRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>goVersionRE is a regular expression that matches the valid
arguments to the -lang flag.</p>
               
               <pre><code>var goVersionRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="identIgnoreTags">
               <h3>
                  identIgnoreTags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const identIgnoreTags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="identStrict">
               <h3>
                  identStrict 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const identStrict</code></pre>
            </article>
            
            <article class="global" data-name="internedStrings">
               <h3>
                  internedStrings 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var internedStrings = map[string]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="internedStringsmu">
               <h3>
                  internedStringsmu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var internedStringsmu sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="langWant">
               <h3>
                  langWant 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>langWant is the desired language version set by the -lang flag.
If the -lang flag is not set, this is the zero value, meaning that
any language version is supported.</p>
               
               <pre><code>var langWant lang</code></pre>
            </article>
            
            <article class="global" data-name="nopkg">
               <h3>
                  nopkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nopkg = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="pkgMap">
               <h3>
                  pkgMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>pkgMap maps a package path to a package.</p>
               
               <pre><code>var pkgMap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="recvType">
               <h3>
                  recvType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var recvType *Type</code></pre>
            </article>
            
            <article class="global" data-name="symAsm">
               <h3>
                  symAsm 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const symAsm</code></pre>
            </article>
            
            <article class="global" data-name="symFunc">
               <h3>
                  symFunc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const symFunc</code></pre>
            </article>
            
            <article class="global" data-name="symOnExportList">
               <h3>
                  symOnExportList 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const symOnExportList = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="symSiggen">
               <h3>
                  symSiggen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const symSiggen</code></pre>
            </article>
            
            <article class="global" data-name="symUniq">
               <h3>
                  symUniq 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const symUniq</code></pre>
            </article>
            
            <article class="global" data-name="typeDeferwidth">
               <h3>
                  typeDeferwidth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeDeferwidth</code></pre>
            </article>
            
            <article class="global" data-name="typeHasShape">
               <h3>
                  typeHasShape 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeHasShape</code></pre>
            </article>
            
            <article class="global" data-name="typeIsFullyInstantiated">
               <h3>
                  typeIsFullyInstantiated 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>typeIsFullyInstantiated reports whether a type is fully instantiated generic type; i.e.
an instantiated generic type where all type arguments are non-generic or fully instantiated generic types.</p>
               
               <pre><code>const typeIsFullyInstantiated</code></pre>
            </article>
            
            <article class="global" data-name="typeIsShape">
               <h3>
                  typeIsShape 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeIsShape</code></pre>
            </article>
            
            <article class="global" data-name="typeNoalg">
               <h3>
                  typeNoalg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeNoalg</code></pre>
            </article>
            
            <article class="global" data-name="typeNotInHeap">
               <h3>
                  typeNotInHeap 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeNotInHeap = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="typeRecur">
               <h3>
                  typeRecur 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeRecur</code></pre>
            </article>
            
            <article class="global" data-name="typedefs">
               <h3>
                  typedefs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var typedefs = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="typepkg">
               <h3>
                  typepkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Fake package for runtime type info (headers)
Don't access directly, use typeLookup below.</p>
               
               <pre><code>var typepkg = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="typepkgmu">
               <h3>
                  typepkgmu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Fake package for runtime type info (headers)
Don't access directly, use typeLookup below.</p>
               
               <pre><code>var typepkgmu sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="unsignedEType">
               <h3>
                  unsignedEType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unsignedEType = [...]Kind{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="AlgKind">
               <h3>
                  AlgKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>AlgKind describes the kind of algorithms used for comparing and
hashing a Type.</p>
               
               <pre><code>type AlgKind int8</code></pre>
            </article>
            
            <article class="type" data-name="ChanDir">
               <h3>
                  ChanDir
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ChanDir is whether a channel can send, receive, or both.</p>
               
               <pre><code>type ChanDir uint8</code></pre>
            </article>
            
            <article class="type" data-name="Cmp">
               <h3>
                  Cmp
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Cmp is a comparison between values a and b.
-1 if a < b
0 if a == b
1 if a > b</p>
               
               <pre><code>type Cmp int8</code></pre>
            </article>
            
            <article class="type" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Kind describes a kind of type.</p>
               
               <pre><code>type Kind uint8</code></pre>
            </article>
            
            <article class="type" data-name="bitset8">
               <h3>
                  bitset8
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bitset8 uint8</code></pre>
            </article>
            
            <article class="type" data-name="componentsIncludeBlankFields">
               <h3>
                  componentsIncludeBlankFields
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type componentsIncludeBlankFields bool</code></pre>
            </article>
            
            <article class="type" data-name="fmtMode">
               <h3>
                  fmtMode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>fmtMode represents the kind of printing being done.
The default is regular Go syntax (fmtGo).
fmtDebug is like fmtGo but for debugging dumps and prints the type kind too.
fmtTypeID and fmtTypeIDName are for generating various unique representations
of types used in hashes, the linker, and function/method instantiations.</p>
               
               <pre><code>type fmtMode int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Object">
               <h3>
                  Object
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Object represents an ir.Node, but without needing to import cmd/compile/internal/ir,
which would cause an import cycle. The uses in other packages must type assert
values of type Object to ir.Node or a more specific type.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Object interface {
Pos() src.XPos
Sym() *Sym
Type() *Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Array">
               <h3>
                  Array
                  <span class="badge">struct</span>
               </h3>
               
               <p>Array contains Type fields specific to array types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Array struct {
Elem *Type
Bound int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Chan">
               <h3>
                  Chan
                  <span class="badge">struct</span>
               </h3>
               
               <p>Chan contains Type fields specific to channel types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Chan struct {
Elem *Type
Dir ChanDir
}</code></pre>
            </article>
            
            <article class="struct" data-name="ChanArgs">
               <h3>
                  ChanArgs
                  <span class="badge">struct</span>
               </h3>
               
               <p>ChanArgs contains Type fields specific to TCHANARGS types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ChanArgs struct {
T *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Field">
               <h3>
                  Field
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Field is a (Sym, Type) pairing along with some other information, and,
depending on the context, is used to represent:
- a field in a struct
- a method in an interface or associated with a named type
- a function parameter</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Field struct {
flags bitset8
Embedded uint8
Pos src.XPos
Sym *Sym
Type *Type
Note string
Nname Object
Offset int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Forward">
               <h3>
                  Forward
                  <span class="badge">struct</span>
               </h3>
               
               <p>Forward contains Type fields specific to forward types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Forward struct {
Copyto []*Type
Embedlineno src.XPos
}</code></pre>
            </article>
            
            <article class="struct" data-name="Func">
               <h3>
                  Func
                  <span class="badge">struct</span>
               </h3>
               
               <p>Func contains Type fields specific to func types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Func struct {
allParams []*Field
startParams int
startResults int
resultsTuple *Type
Argwid int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="FuncArgs">
               <h3>
                  FuncArgs
                  <span class="badge">struct</span>
               </h3>
               
               <p>FuncArgs contains Type fields specific to TFUNCARGS types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FuncArgs struct {
T *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Interface">
               <h3>
                  Interface
                  <span class="badge">struct</span>
               </h3>
               
               <p>Interface contains Type fields specific to interface types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Interface struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
               </h3>
               
               <p>Map contains Type fields specific to maps.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Map struct {
Key *Type
Elem *Type
OldBucket *Type
SwissGroup *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Pkg">
               <h3>
                  Pkg
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Pkg struct {
Path string
Name string
Prefix string
Syms map[string]*Sym
Pathsym *obj.LSym
Direct bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Ptr">
               <h3>
                  Ptr
                  <span class="badge">struct</span>
               </h3>
               
               <p>Ptr contains Type fields specific to pointer types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Ptr struct {
Elem *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Results">
               <h3>
                  Results
                  <span class="badge">struct</span>
               </h3>
               
               <p>Results are the output from calls that will be late-expanded.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Results struct {
Types []*Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Slice">
               <h3>
                  Slice
                  <span class="badge">struct</span>
               </h3>
               
               <p>Slice contains Type fields specific to slice types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Slice struct {
Elem *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Struct">
               <h3>
                  Struct
                  <span class="badge">struct</span>
               </h3>
               
               <p>StructType contains Type fields specific to struct types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Struct struct {
fields fields
Map *Type
ParamTuple bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Sym">
               <h3>
                  Sym
                  <span class="badge">struct</span>
               </h3>
               
               <p>Sym represents an object name in a segmented (pkg, name) namespace.
Most commonly, this is a Go identifier naming an object declared within a package,
but Syms are also used to name internal synthesized objects.
As an exception, field and method names that are exported use the Sym
associated with localpkg instead of the package that declared them. This
allows using Sym pointer equality to test for Go identifier uniqueness when
handling selector expressions.
Ideally, Sym should be used for representing Go language constructs,
while cmd/internal/obj.LSym is used for representing emitted artifacts.
NOTE: In practice, things can be messier than the description above
for various reasons (historical, convenience).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Sym struct {
Linkname string
Pkg *Pkg
Name string
Def Object
flags bitset8
}</code></pre>
            </article>
            
            <article class="struct" data-name="Tuple">
               <h3>
                  Tuple
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Tuple struct {
first *Type
second *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Type">
               <h3>
                  Type
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Type represents a Go type.
There may be multiple unnamed types with identical structure. However, there must
be a unique Type object for each unique named (defined) type. After noding, a
package-level type can be looked up by building its unique symbol sym (sym =
package.Lookup(name)) and checking sym.Def. If sym.Def is non-nil, the type
already exists at package scope and is available at sym.Def.(*ir.Name).Type().
Local types (which may have the same name as a package-level type) are
distinguished by their vargen, which is embedded in their symbol name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Type struct {
extra interface{}
width int64
methods fields
allMethods fields
obj Object
underlying *Type
cache struct{...}
kind Kind
align uint8
intRegs uint8
floatRegs uint8
flags bitset8
alg AlgKind
ptrBytes int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="fields">
               <h3>
                  fields
                  <span class="badge">struct</span>
               </h3>
               
               <p>fields is a pointer to a slice of *Field.
This saves space in Types that do not have fields or methods
compared to a simple slice of *Field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fields struct {
s *[]*Field
}</code></pre>
            </article>
            
            <article class="struct" data-name="lang">
               <h3>
                  lang
                  <span class="badge">struct</span>
               </h3>
               
               <p>A lang is a language version broken into major and minor numbers.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lang struct {
major int
minor int
}</code></pre>
            </article>
            
            <article class="struct" data-name="typePair">
               <h3>
                  typePair
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typePair struct {
t1 *Type
t2 *Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AlgType">
               <h3>
                  AlgType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AlgType returns the AlgKind used for comparing and hashing Type t.</p>
               
               <pre><code>func AlgType(t *Type) AlgKind</code></pre>
            </article>
            
            <article class="function" data-name="Alignment">
               <h3>
                  Alignment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Alignment() int64</code></pre>
            </article>
            
            <article class="function" data-name="AllMethods">
               <h3>
                  AllMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AllMethods returns a pointer to all the methods (including embedding) for type t.
For an interface type, this is the set of methods that are typically iterated
over. For non-interface types, AllMethods() only returns a valid result after
CalcMethods() has been called at least once.</p>
               
               <pre><code>func (t *Type) AllMethods() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="AllowsGoVersion">
               <h3>
                  AllowsGoVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AllowsGoVersion reports whether local package is allowed
to use Go version major.minor.</p>
               
               <pre><code>func AllowsGoVersion(major int, minor int) bool</code></pre>
            </article>
            
            <article class="function" data-name="ArgWidth">
               <h3>
                  ArgWidth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ArgWidth returns the total aligned argument size for a function.
It includes the receiver, parameters, and results.</p>
               
               <pre><code>func (t *Type) ArgWidth() int64</code></pre>
            </article>
            
            <article class="function" data-name="Asm">
               <h3>
                  Asm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) Asm() bool</code></pre>
            </article>
            
            <article class="function" data-name="CalcSize">
               <h3>
                  CalcSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CalcSize calculates and stores the size, alignment, eq/hash algorithm,
and ptrBytes for t.
If CalcSizeDisabled is set, and the size/alignment
have not already been calculated, it calls Fatal.
This is used to prevent data races in the back end.</p>
               
               <pre><code>func CalcSize(t *Type)</code></pre>
            </article>
            
            <article class="function" data-name="CalcStructSize">
               <h3>
                  CalcStructSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CalcStructSize calculates the size of t,
filling in t.width, t.align, t.intRegs, and t.floatRegs,
even if size calculation is otherwise disabled.</p>
               
               <pre><code>func CalcStructSize(t *Type)</code></pre>
            </article>
            
            <article class="function" data-name="CanBeAnSSAAux">
               <h3>
                  CanBeAnSSAAux 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Type) CanBeAnSSAAux()</code></pre>
            </article>
            
            <article class="function" data-name="CanRecv">
               <h3>
                  CanRecv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c ChanDir) CanRecv() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanSend">
               <h3>
                  CanSend 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c ChanDir) CanSend() bool</code></pre>
            </article>
            
            <article class="function" data-name="ChanArgs">
               <h3>
                  ChanArgs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ChanArgs returns the channel type for TCHANARGS type t.</p>
               
               <pre><code>func (t *Type) ChanArgs() *Type</code></pre>
            </article>
            
            <article class="function" data-name="ChanDir">
               <h3>
                  ChanDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ChanDir returns the direction of a channel type t.
The direction will be one of Crecv, Csend, or Cboth.</p>
               
               <pre><code>func (t *Type) ChanDir() ChanDir</code></pre>
            </article>
            
            <article class="function" data-name="CheckSize">
               <h3>
                  CheckSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func CheckSize(t *Type)</code></pre>
            </article>
            
            <article class="function" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compare compares types for purposes of the SSA back
end, returning a Cmp (one of CMPlt, CMPeq, CMPgt).
The answers are correct for an optimizer
or code generator, but not necessarily typechecking.
The order chosen is arbitrary, only consistency and division
into equivalence classes (Types that compare CMPeq) matters.</p>
               
               <pre><code>func (t *Type) Compare(x *Type) Cmp</code></pre>
            </article>
            
            <article class="function" data-name="CompareFields">
               <h3>
                  CompareFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CompareFields compares two Field values by name.</p>
               
               <pre><code>func CompareFields(a *Field, b *Field) int</code></pre>
            </article>
            
            <article class="function" data-name="CompareSyms">
               <h3>
                  CompareSyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CompareSyms return the ordering of a and b, as for [cmp.Compare].
Symbols are ordered exported before non-exported, then by name, and
finally (for non-exported symbols) by package path.</p>
               
               <pre><code>func CompareSyms(a *Sym, b *Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="ComplexForFloat">
               <h3>
                  ComplexForFloat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ComplexForFloat(t *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Field) Copy() *Field</code></pre>
            </article>
            
            <article class="function" data-name="DeferCheckSize">
               <h3>
                  DeferCheckSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func DeferCheckSize()</code></pre>
            </article>
            
            <article class="function" data-name="Deferwidth">
               <h3>
                  Deferwidth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Deferwidth() bool</code></pre>
            </article>
            
            <article class="function" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Elem returns the type of elements of t.
Usable with pointers, channels, arrays, slices, and maps.</p>
               
               <pre><code>func (t *Type) Elem() *Type</code></pre>
            </article>
            
            <article class="function" data-name="End">
               <h3>
                  End 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>End returns the offset of the first byte immediately after this field.</p>
               
               <pre><code>func (f *Field) End() int64</code></pre>
            </article>
            
            <article class="function" data-name="FakeRecv">
               <h3>
                  FakeRecv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func FakeRecv() *Field</code></pre>
            </article>
            
            <article class="function" data-name="FakeRecvType">
               <h3>
                  FakeRecvType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FakeRecvType returns the singleton type used for interface method receivers.</p>
               
               <pre><code>func FakeRecvType() *Type</code></pre>
            </article>
            
            <article class="function" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Field returns the i'th field of struct type t.</p>
               
               <pre><code>func (t *Type) Field(i int) *Field</code></pre>
            </article>
            
            <article class="function" data-name="FieldName">
               <h3>
                  FieldName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) FieldName(i int) string</code></pre>
            </article>
            
            <article class="function" data-name="FieldOff">
               <h3>
                  FieldOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) FieldOff(i int) int64</code></pre>
            </article>
            
            <article class="function" data-name="FieldType">
               <h3>
                  FieldType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) FieldType(i int) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Fields">
               <h3>
                  Fields 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fields returns a slice of containing all fields of
a struct type t.</p>
               
               <pre><code>func (t *Type) Fields() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="FloatForComplex">
               <h3>
                  FloatForComplex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func FloatForComplex(t *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Format implements formatting for a Sym.
The valid formats are:
%v	Go syntax: Name for symbols in the local package, PkgName.Name for imported symbols.
%+v	Debug syntax: always include PkgName. prefix even for local names.
%S	Short syntax: Name only, no matter what.</p>
               
               <pre><code>func (s *Sym) Format(f fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Format implements formatting for a Type.
The valid formats are:
%v	Go syntax
%+v	Debug syntax: Go syntax with a KIND- prefix for all but builtins.
%L	Go syntax for underlying type if t is named
%S	short Go syntax: drop leading "func" in function type
%-S	special case for method receiver symbol</p>
               
               <pre><code>func (t *Type) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Func">
               <h3>
                  Func 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) Func() bool</code></pre>
            </article>
            
            <article class="function" data-name="FuncArgs">
               <h3>
                  FuncArgs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FuncArgs returns the func type for TFUNCARGS type t.</p>
               
               <pre><code>func (t *Type) FuncArgs() *Type</code></pre>
            </article>
            
            <article class="function" data-name="HasNil">
               <h3>
                  HasNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>HasNil reports whether the set of values determined by t includes nil.</p>
               
               <pre><code>func (t *Type) HasNil() bool</code></pre>
            </article>
            
            <article class="function" data-name="HasPointers">
               <h3>
                  HasPointers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>HasPointers reports whether t contains a heap pointer.
Note that this function ignores pointers to not-in-heap types.</p>
               
               <pre><code>func (t *Type) HasPointers() bool</code></pre>
            </article>
            
            <article class="function" data-name="HasShape">
               <h3>
                  HasShape 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) HasShape() bool</code></pre>
            </article>
            
            <article class="function" data-name="Identical">
               <h3>
                  Identical 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Identical reports whether t1 and t2 are identical types, following the spec rules.
Receiver parameter types are ignored. Named (defined) types are only equal if they
are pointer-equal - i.e. there must be a unique types.Type for each specific named
type. Also, a type containing a shape type is considered identical to another type
(shape or not) if their underlying types are the same, or they are both pointers.</p>
               
               <pre><code>func Identical(t1 *Type, t2 *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IdenticalIgnoreTags">
               <h3>
                  IdenticalIgnoreTags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IdenticalIgnoreTags is like Identical, but it ignores struct tags
for struct identity.</p>
               
               <pre><code>func IdenticalIgnoreTags(t1 *Type, t2 *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IdenticalStrict">
               <h3>
                  IdenticalStrict 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IdenticalStrict is like Identical, but matches types exactly, without the
exception for shapes.</p>
               
               <pre><code>func IdenticalStrict(t1 *Type, t2 *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IncomparableField">
               <h3>
                  IncomparableField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IncomparableField returns an incomparable Field of struct Type t, if any.</p>
               
               <pre><code>func IncomparableField(t *Type) *Field</code></pre>
            </article>
            
            <article class="function" data-name="InitTypes">
               <h3>
                  InitTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func InitTypes(defTypeName func(sym *Sym, typ *Type) Object)</code></pre>
            </article>
            
            <article class="function" data-name="InternString">
               <h3>
                  InternString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func InternString(b []byte) string</code></pre>
            </article>
            
            <article class="function" data-name="IsArray">
               <h3>
                  IsArray 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsArray() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsBlank">
               <h3>
                  IsBlank 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) IsBlank() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsBoolean">
               <h3>
                  IsBoolean 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsBoolean() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsChan">
               <h3>
                  IsChan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsChan() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsComparable">
               <h3>
                  IsComparable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsComparable reports whether t is a comparable type.</p>
               
               <pre><code>func IsComparable(t *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsComplex">
               <h3>
                  IsComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsComplex() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDDD">
               <h3>
                  IsDDD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Field) IsDDD() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDirectIface">
               <h3>
                  IsDirectIface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Can this type be stored directly in an interface word?
Yes, if the representation is a single pointer.</p>
               
               <pre><code>func IsDirectIface(t *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsEmptyInterface">
               <h3>
                  IsEmptyInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsEmptyInterface reports whether t is an empty interface type.</p>
               
               <pre><code>func (t *Type) IsEmptyInterface() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsExported reports whether name is an exported Go symbol (that is,
whether it begins with an upper-case letter).</p>
               
               <pre><code>func IsExported(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFlags">
               <h3>
                  IsFlags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsFlags() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFloat">
               <h3>
                  IsFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsFloat() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFullyInstantiated">
               <h3>
                  IsFullyInstantiated 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsFullyInstantiated() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFuncArgStruct">
               <h3>
                  IsFuncArgStruct 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsFuncArgStruct reports whether t is a struct representing function parameters or results.</p>
               
               <pre><code>func (t *Type) IsFuncArgStruct() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsInteger">
               <h3>
                  IsInteger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsInteger() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsInterface">
               <h3>
                  IsInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsInterface() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsInterfaceMethod">
               <h3>
                  IsInterfaceMethod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsInterfaceMethod reports whether (field) m is
an interface method. Such methods have the
special receiver type types.FakeRecvType().</p>
               
               <pre><code>func IsInterfaceMethod(f *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsKind">
               <h3>
                  IsKind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsKind reports whether t is a Type of the specified kind.</p>
               
               <pre><code>func (t *Type) IsKind(et Kind) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMap">
               <h3>
                  IsMap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsMap() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMemory">
               <h3>
                  IsMemory 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsMemory() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMethod">
               <h3>
                  IsMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsMethod reports whether f represents a method rather than a struct field.</p>
               
               <pre><code>func (f *Field) IsMethod() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMethodApplicable">
               <h3>
                  IsMethodApplicable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsMethodApplicable reports whether method m can be called on a
value of type t. This is necessary because we compute a single
method set for both T and *T, but some *T methods are not
applicable to T receivers.</p>
               
               <pre><code>func IsMethodApplicable(t *Type, m *Field) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNoInstrumentPkg">
               <h3>
                  IsNoInstrumentPkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsNoInstrumentPkg reports whether p is a package that
should not be instrumented.</p>
               
               <pre><code>func IsNoInstrumentPkg(p *Pkg) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNoRacePkg">
               <h3>
                  IsNoRacePkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsNoRacePkg reports whether p is a package that
should not be race instrumented.</p>
               
               <pre><code>func IsNoRacePkg(p *Pkg) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPaddedField">
               <h3>
                  IsPaddedField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsPaddedField reports whether the i'th field of struct type t is followed
by padding.</p>
               
               <pre><code>func IsPaddedField(t *Type, i int) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPtr">
               <h3>
                  IsPtr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPtr reports whether t is a regular Go pointer type.
This does not include unsafe.Pointer.</p>
               
               <pre><code>func (t *Type) IsPtr() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPtrElem">
               <h3>
                  IsPtrElem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPtrElem reports whether t is the element of a pointer (to t).</p>
               
               <pre><code>func (t *Type) IsPtrElem() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPtrShaped">
               <h3>
                  IsPtrShaped 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPtrShaped reports whether t is represented by a single machine pointer.
In addition to regular Go pointer types, this includes map, channel, and
function types and unsafe.Pointer. It does not include array or struct types
that consist of a single pointer shaped type.
TODO(mdempsky): Should it? See golang.org/issue/15028.</p>
               
               <pre><code>func (t *Type) IsPtrShaped() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsReflexive">
               <h3>
                  IsReflexive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsReflexive reports whether t has a reflexive equality operator.
That is, if x==x for all x of type t.</p>
               
               <pre><code>func IsReflexive(t *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsResults">
               <h3>
                  IsResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsResults() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsRuntimePkg">
               <h3>
                  IsRuntimePkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsRuntimePkg reports whether p is a runtime package.</p>
               
               <pre><code>func IsRuntimePkg(p *Pkg) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsScalar">
               <h3>
                  IsScalar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsScalar reports whether 't' is a scalar Go type, e.g.
bool/int/float/complex. Note that struct and array types consisting
of a single scalar element are not considered scalar, likewise
pointer types are also not considered scalar.</p>
               
               <pre><code>func (t *Type) IsScalar() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsShape">
               <h3>
                  IsShape 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsShape() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSigned">
               <h3>
                  IsSigned 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsSigned() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSlice">
               <h3>
                  IsSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsSlice() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsString">
               <h3>
                  IsString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsString() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsStruct">
               <h3>
                  IsStruct 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsStruct() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsTuple">
               <h3>
                  IsTuple 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsTuple() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsUintptr">
               <h3>
                  IsUintptr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsUintptr reports whether t is a uintptr.</p>
               
               <pre><code>func (t *Type) IsUintptr() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsUnsafePtr">
               <h3>
                  IsUnsafePtr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsUnsafePtr reports whether t is an unsafe pointer.</p>
               
               <pre><code>func (t *Type) IsUnsafePtr() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsUnsigned">
               <h3>
                  IsUnsigned 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsUnsigned() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsUntyped">
               <h3>
                  IsUntyped 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsUntyped reports whether t is an untyped type.</p>
               
               <pre><code>func (t *Type) IsUntyped() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsVariadic">
               <h3>
                  IsVariadic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsVariadic reports whether function type t is variadic.</p>
               
               <pre><code>func (t *Type) IsVariadic() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsVoid">
               <h3>
                  IsVoid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) IsVoid() bool</code></pre>
            </article>
            
            <article class="function" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Key returns the key type of map type t.</p>
               
               <pre><code>func (t *Type) Key() *Type</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Kind returns the kind of type t.</p>
               
               <pre><code>func (t *Type) Kind() Kind</code></pre>
            </article>
            
            <article class="function" data-name="LinkString">
               <h3>
                  LinkString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LinkString returns a string description of t, suitable for use in
link symbols.
The description corresponds to type identity. That is, for any pair
of types t1 and t2, Identical(t1, t2) == (t1.LinkString() ==
t2.LinkString()) is true. Thus it's safe to use as a map key to
implement a type-identity-keyed map.</p>
               
               <pre><code>func (t *Type) LinkString() string</code></pre>
            </article>
            
            <article class="function" data-name="Linksym">
               <h3>
                  Linksym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Deprecated: This method should not be used directly. Instead, use a
higher-level abstraction that directly returns the linker symbol
for a named object. For example, reflectdata.TypeLinksym(t) instead
of reflectdata.TypeSym(t).Linksym().</p>
               
               <pre><code>func (sym *Sym) Linksym() *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="LinksymABI">
               <h3>
                  LinksymABI 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Deprecated: This method should not be used directly. Instead, use a
higher-level abstraction that directly returns the linker symbol
for a named object. For example, (*ir.Name).LinksymABI(abi) instead
of (*ir.Name).Sym().LinksymABI(abi).</p>
               
               <pre><code>func (sym *Sym) LinksymABI(abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pkg *Pkg) Lookup(name string) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="LookupBytes">
               <h3>
                  LookupBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pkg *Pkg) LookupBytes(name []byte) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="LookupNum">
               <h3>
                  LookupNum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupNum looks up the symbol starting with prefix and ending with
the decimal n. If prefix is too long, LookupNum panics.</p>
               
               <pre><code>func (pkg *Pkg) LookupNum(prefix string, n int) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="LookupOK">
               <h3>
                  LookupOK 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupOK looks up name in pkg and reports whether it previously existed.</p>
               
               <pre><code>func (pkg *Pkg) LookupOK(name string) (s *Sym, existed bool)</code></pre>
            </article>
            
            <article class="function" data-name="MapType">
               <h3>
                  MapType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapType returns t's extra map-specific fields.</p>
               
               <pre><code>func (t *Type) MapType() *Map</code></pre>
            </article>
            
            <article class="function" data-name="Methods">
               <h3>
                  Methods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Methods returns a pointer to the base methods (excluding embedding) for type t.
These can either be concrete methods (for non-interface types) or interface
methods (for interface types).</p>
               
               <pre><code>func (t *Type) Methods() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="NameString">
               <h3>
                  NameString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NameString generates a user-readable, mostly unique string
description of t. NameString always returns the same description
for identical types, even across compilation units.
NameString qualifies identifiers by package name, so it has
collisions when different packages share the same names and
identifiers. It also does not distinguish function-scope defined
types from package-scoped defined types or from each other.</p>
               
               <pre><code>func (t *Type) NameString() string</code></pre>
            </article>
            
            <article class="function" data-name="NewArray">
               <h3>
                  NewArray 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewArray returns a new fixed-length array Type.</p>
               
               <pre><code>func NewArray(elem *Type, bound int64) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewChan">
               <h3>
                  NewChan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewChan returns a new chan Type with direction dir.</p>
               
               <pre><code>func NewChan(elem *Type, dir ChanDir) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewChanArgs">
               <h3>
                  NewChanArgs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewChanArgs returns a new TCHANARGS type for channel type c.</p>
               
               <pre><code>func NewChanArgs(c *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewField">
               <h3>
                  NewField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewField(pos src.XPos, sym *Sym, typ *Type) *Field</code></pre>
            </article>
            
            <article class="function" data-name="NewFuncArgs">
               <h3>
                  NewFuncArgs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewFuncArgs returns a new TFUNCARGS type for func type f.</p>
               
               <pre><code>func NewFuncArgs(f *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewInterface">
               <h3>
                  NewInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewInterface returns a new interface for the given methods and
embedded types. Embedded types are specified as fields with no Sym.</p>
               
               <pre><code>func NewInterface(methods []*Field) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewMap">
               <h3>
                  NewMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewMap returns a new map Type with key type k and element (aka value) type v.</p>
               
               <pre><code>func NewMap(k *Type, v *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewNamed">
               <h3>
                  NewNamed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewNamed returns a new named type for the given type name. obj should be an
ir.Name. The new type is incomplete (marked as TFORW kind), and the underlying
type should be set later via SetUnderlying(). References to the type are
maintained until the type is filled in, so those references can be updated when
the type is complete.</p>
               
               <pre><code>func NewNamed(obj Object) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewPkg">
               <h3>
                  NewPkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewPkg returns a new Pkg for the given package path and name.
Unless name is the empty string, if the package exists already,
the existing package name and the provided name must match.</p>
               
               <pre><code>func NewPkg(path string, name string) *Pkg</code></pre>
            </article>
            
            <article class="function" data-name="NewPtr">
               <h3>
                  NewPtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewPtr returns the pointer type pointing to t.</p>
               
               <pre><code>func NewPtr(elem *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewResults">
               <h3>
                  NewResults 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewResults(types []*Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewSignature">
               <h3>
                  NewSignature 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewSignature returns a new function type for the given receiver,
parameters, and results, any of which may be nil.</p>
               
               <pre><code>func NewSignature(recv *Field, params []*Field, results []*Field) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewSlice">
               <h3>
                  NewSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewSlice returns the slice Type with element type elem.</p>
               
               <pre><code>func NewSlice(elem *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewStruct">
               <h3>
                  NewStruct 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewStruct returns a new struct with the given fields.</p>
               
               <pre><code>func NewStruct(fields []*Field) *Type</code></pre>
            </article>
            
            <article class="function" data-name="NewTuple">
               <h3>
                  NewTuple 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewTuple(t1 *Type, t2 *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Noalg">
               <h3>
                  Noalg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Noalg() bool</code></pre>
            </article>
            
            <article class="function" data-name="Nointerface">
               <h3>
                  Nointerface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Field) Nointerface() bool</code></pre>
            </article>
            
            <article class="function" data-name="NotInHeap">
               <h3>
                  NotInHeap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NotInHeap() bool</code></pre>
            </article>
            
            <article class="function" data-name="NumComponents">
               <h3>
                  NumComponents 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumComponents returns the number of primitive elements that compose t.
Struct and array types are flattened for the purpose of counting.
All other types (including string, slice, and interface types) count as one element.
If countBlank is IgnoreBlankFields, then blank struct fields
(and their comprised elements) are excluded from the count.
struct { x, y [3]int } has six components; [10]struct{ x, y string } has twenty.</p>
               
               <pre><code>func (t *Type) NumComponents(countBlank componentsIncludeBlankFields) int64</code></pre>
            </article>
            
            <article class="function" data-name="NumElem">
               <h3>
                  NumElem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NumElem() int64</code></pre>
            </article>
            
            <article class="function" data-name="NumFields">
               <h3>
                  NumFields 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NumFields() int</code></pre>
            </article>
            
            <article class="function" data-name="NumParams">
               <h3>
                  NumParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NumParams() int</code></pre>
            </article>
            
            <article class="function" data-name="NumRecvs">
               <h3>
                  NumRecvs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NumRecvs() int</code></pre>
            </article>
            
            <article class="function" data-name="NumResults">
               <h3>
                  NumResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NumResults() int</code></pre>
            </article>
            
            <article class="function" data-name="Obj">
               <h3>
                  Obj 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Obj returns the canonical type name node for a named type t, nil for an unnamed type.</p>
               
               <pre><code>func (t *Type) Obj() Object</code></pre>
            </article>
            
            <article class="function" data-name="OffsetOf">
               <h3>
                  OffsetOf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OffsetOf reports the offset of the field of a struct.
The field is looked up by name.</p>
               
               <pre><code>func (t *Type) OffsetOf(name string) int64</code></pre>
            </article>
            
            <article class="function" data-name="OnExportList">
               <h3>
                  OnExportList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) OnExportList() bool</code></pre>
            </article>
            
            <article class="function" data-name="Param">
               <h3>
                  Param 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Param returns the i'th parameter of signature type t.</p>
               
               <pre><code>func (t *Type) Param(i int) *Field</code></pre>
            </article>
            
            <article class="function" data-name="Params">
               <h3>
                  Params 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Params returns a slice of regular parameters of signature type t.</p>
               
               <pre><code>func (t *Type) Params() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="ParamsResults">
               <h3>
                  ParamsResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ParamsResults returns a slice containing the signature's (normal)
parameters followed by its results.</p>
               
               <pre><code>func (t *Type) ParamsResults() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="ParseLangFlag">
               <h3>
                  ParseLangFlag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseLangFlag verifies that the -lang flag holds a valid value, and
exits if not. It initializes data used by AllowsGoVersion.</p>
               
               <pre><code>func ParseLangFlag()</code></pre>
            </article>
            
            <article class="function" data-name="PkgMap">
               <h3>
                  PkgMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func PkgMap() map[string]*Pkg</code></pre>
            </article>
            
            <article class="function" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pos returns a position associated with t, if any.
This should only be used for diagnostics.</p>
               
               <pre><code>func (t *Type) Pos() src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="PtrDataSize">
               <h3>
                  PtrDataSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PtrDataSize returns the length in bytes of the prefix of t
containing pointer data. Anything after this offset is scalar data.
PtrDataSize is only defined for actual Go types. It's an error to
use it on compiler-internal types (e.g., TSSA, TRESULTS).</p>
               
               <pre><code>func PtrDataSize(t *Type) int64</code></pre>
            </article>
            
            <article class="function" data-name="PtrTo">
               <h3>
                  PtrTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) PtrTo() *Type</code></pre>
            </article>
            
            <article class="function" data-name="ReceiverBaseType">
               <h3>
                  ReceiverBaseType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReceiverBaseType returns the underlying type, if any,
that owns methods with receiver parameter t.
The result is either a named type or an anonymous struct.</p>
               
               <pre><code>func ReceiverBaseType(t *Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Recur">
               <h3>
                  Recur 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Recur() bool</code></pre>
            </article>
            
            <article class="function" data-name="Recv">
               <h3>
                  Recv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Recv returns the receiver of function type t, if any.</p>
               
               <pre><code>func (t *Type) Recv() *Field</code></pre>
            </article>
            
            <article class="function" data-name="RecvParams">
               <h3>
                  RecvParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RecvParams returns a slice containing the signature's receiver (if
any) followed by its (normal) parameters.</p>
               
               <pre><code>func (t *Type) RecvParams() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="RecvParamsResults">
               <h3>
                  RecvParamsResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RecvParamsResults returns a slice containing all of the
signature's parameters in receiver (if any), (normal) parameters,
and then results.</p>
               
               <pre><code>func (t *Type) RecvParamsResults() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="Recvs">
               <h3>
                  Recvs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Recvs returns a slice of receiver parameters of signature type t.
The returned slice always has length 0 or 1.</p>
               
               <pre><code>func (t *Type) Recvs() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="ReflectSymName">
               <h3>
                  ReflectSymName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReflectSymName returns the name of s if it's in package "reflect"; otherwise
it returns "".</p>
               
               <pre><code>func ReflectSymName(s *Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="Registers">
               <h3>
                  Registers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Registers returns the number of integer and floating-point
registers required to represent a parameter of this type under the
ABIInternal calling conventions.
If t must be passed by memory, Registers returns (math.MaxUint8,
math.MaxUint8).</p>
               
               <pre><code>func (t *Type) Registers() (uint8, uint8)</code></pre>
            </article>
            
            <article class="function" data-name="Result">
               <h3>
                  Result 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Result returns the i'th result of signature type t.</p>
               
               <pre><code>func (t *Type) Result(i int) *Field</code></pre>
            </article>
            
            <article class="function" data-name="Results">
               <h3>
                  Results 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Results returns a slice of result parameters of signature type t.</p>
               
               <pre><code>func (t *Type) Results() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="ResultsTuple">
               <h3>
                  ResultsTuple 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ResultsTuple returns the result type of signature type t as a tuple.
This can be used as the type of multi-valued call expressions.</p>
               
               <pre><code>func (t *Type) ResultsTuple() *Type</code></pre>
            </article>
            
            <article class="function" data-name="ResumeCheckSize">
               <h3>
                  ResumeCheckSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ResumeCheckSize()</code></pre>
            </article>
            
            <article class="function" data-name="RoundUp">
               <h3>
                  RoundUp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RoundUp rounds o to a multiple of r, r is a power of 2.</p>
               
               <pre><code>func RoundUp(o int64, r int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="RuntimeSymName">
               <h3>
                  RuntimeSymName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RuntimeSymName returns the name of s if it's in package "runtime"; otherwise
it returns "".</p>
               
               <pre><code>func RuntimeSymName(s *Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="Selector">
               <h3>
                  Selector 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Selector looks up a selector identifier.</p>
               
               <pre><code>func (pkg *Pkg) Selector(name string) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets f to a slice.
This takes ownership of the slice.</p>
               
               <pre><code>func (f *fields) Set(s []*Field)</code></pre>
            </article>
            
            <article class="function" data-name="SetAllMethods">
               <h3>
                  SetAllMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAllMethods sets the set of all methods for type t (i.e.,
including promoted methods from embedded types).</p>
               
               <pre><code>func (t *Type) SetAllMethods(fs []*Field)</code></pre>
            </article>
            
            <article class="function" data-name="SetAsm">
               <h3>
                  SetAsm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) SetAsm(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetDeferwidth">
               <h3>
                  SetDeferwidth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SetDeferwidth(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetFunc">
               <h3>
                  SetFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) SetFunc(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetHasShape">
               <h3>
                  SetHasShape 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SetHasShape(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetInterface">
               <h3>
                  SetInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetInterface sets the base methods of an interface type t.</p>
               
               <pre><code>func (t *Type) SetInterface(methods []*Field)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsDDD">
               <h3>
                  SetIsDDD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Field) SetIsDDD(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsFullyInstantiated">
               <h3>
                  SetIsFullyInstantiated 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SetIsFullyInstantiated(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsShape">
               <h3>
                  SetIsShape 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Should always do SetHasShape(true) when doing SetIsShape(true).</p>
               
               <pre><code>func (t *Type) SetIsShape(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetMethods">
               <h3>
                  SetMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMethods sets the direct method set for type t (i.e., *not*
including promoted methods from embedded types).</p>
               
               <pre><code>func (t *Type) SetMethods(fs []*Field)</code></pre>
            </article>
            
            <article class="function" data-name="SetNoalg">
               <h3>
                  SetNoalg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SetNoalg(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNointerface">
               <h3>
                  SetNointerface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Field) SetNointerface(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNotInHeap">
               <h3>
                  SetNotInHeap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SetNotInHeap(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetOnExportList">
               <h3>
                  SetOnExportList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) SetOnExportList(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetRecur">
               <h3>
                  SetRecur 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SetRecur(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetSiggen">
               <h3>
                  SetSiggen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) SetSiggen(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetUnderlying">
               <h3>
                  SetUnderlying 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetUnderlying sets the underlying type of an incomplete type (i.e. type whose kind
is currently TFORW). SetUnderlying automatically updates any types that were waiting
for this type to be completed.</p>
               
               <pre><code>func (t *Type) SetUnderlying(underlying *Type)</code></pre>
            </article>
            
            <article class="function" data-name="SetUniq">
               <h3>
                  SetUniq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) SetUniq(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="Siggen">
               <h3>
                  Siggen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) Siggen() bool</code></pre>
            </article>
            
            <article class="function" data-name="SimpleString">
               <h3>
                  SimpleString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) SimpleString() string</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Slice returns the entries in f as a slice.
Changes to the slice entries will be reflected in f.</p>
               
               <pre><code>func (f *fields) Slice() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="SoleComponent">
               <h3>
                  SoleComponent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SoleComponent returns the only primitive component in t,
if there is exactly one. Otherwise, it returns nil.
Components are counted as in NumComponents, including blank fields.
Keep in sync with cmd/compile/internal/walk/convert.go:soleComponent.</p>
               
               <pre><code>func (t *Type) SoleComponent() *Type</code></pre>
            </article>
            
            <article class="function" data-name="SplitVargenSuffix">
               <h3>
                  SplitVargenSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitVargenSuffix returns name split into a base string and a ·N
suffix, if any.</p>
               
               <pre><code>func SplitVargenSuffix(name string) (base string, suffix string)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i Kind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i AlgKind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Sym) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the Go syntax for the type t.</p>
               
               <pre><code>func (t *Type) String() string</code></pre>
            </article>
            
            <article class="function" data-name="StructType">
               <h3>
                  StructType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StructType returns t's extra struct-specific fields.</p>
               
               <pre><code>func (t *Type) StructType() *Struct</code></pre>
            </article>
            
            <article class="function" data-name="SubstAny">
               <h3>
                  SubstAny 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SubstAny walks t, replacing instances of "any" with successive
elements removed from types.  It returns the substituted type.</p>
               
               <pre><code>func SubstAny(t *Type, types *[]*Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sym returns the name of type t.</p>
               
               <pre><code>func (t *Type) Sym() *Sym</code></pre>
            </article>
            
            <article class="function" data-name="ToUnsigned">
               <h3>
                  ToUnsigned 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ToUnsigned returns the unsigned equivalent of integer type t.</p>
               
               <pre><code>func (t *Type) ToUnsigned() *Type</code></pre>
            </article>
            
            <article class="function" data-name="TypeHasNoAlg">
               <h3>
                  TypeHasNoAlg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeHasNoAlg reports whether t does not have any associated hash/eq
algorithms because t, or some component of t, is marked Noalg.</p>
               
               <pre><code>func TypeHasNoAlg(t *Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="TypeHash">
               <h3>
                  TypeHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeHash computes a hash value for type t to use in type switch statements.</p>
               
               <pre><code>func TypeHash(t *Type) uint32</code></pre>
            </article>
            
            <article class="function" data-name="TypeSym">
               <h3>
                  TypeSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeSym(t *Type) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="TypeSymLookup">
               <h3>
                  TypeSymLookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeSymLookup(name string) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="TypeSymName">
               <h3>
                  TypeSymName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeSymName(t *Type) string</code></pre>
            </article>
            
            <article class="function" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Underlying returns the underlying type of type t.</p>
               
               <pre><code>func (t *Type) Underlying() *Type</code></pre>
            </article>
            
            <article class="function" data-name="Uniq">
               <h3>
                  Uniq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sym *Sym) Uniq() bool</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="calcStructOffset">
               <h3>
                  calcStructOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>calcStructOffset computes the offsets of a sequence of fields,
starting at the given offset. It returns the resulting offset and
maximum field alignment.</p>
               
               <pre><code>func calcStructOffset(t *Type, fields []*Field, offset int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="chanType">
               <h3>
                  chanType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>chanType returns t's extra channel-specific fields.</p>
               
               <pre><code>func (t *Type) chanType() *Chan</code></pre>
            </article>
            
            <article class="function" data-name="cmp">
               <h3>
                  cmp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cmp compares two *Types t and x, returning CMPlt,
CMPeq, CMPgt as t<x, t==x, t>x, for an arbitrary
and optimizer-centric notion of comparison.
TODO(josharian): make this safe for recursive interface types
and use in signatlist sorting. See issue 19869.</p>
               
               <pre><code>func (t *Type) cmp(x *Type) Cmp</code></pre>
            </article>
            
            <article class="function" data-name="cmpForNe">
               <h3>
                  cmpForNe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cmpForNe(x bool) Cmp</code></pre>
            </article>
            
            <article class="function" data-name="cmpsym">
               <h3>
                  cmpsym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Sym) cmpsym(s *Sym) Cmp</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copy returns a shallow copy of the Type.</p>
               
               <pre><code>func (t *Type) copy() *Type</code></pre>
            </article>
            
            <article class="function" data-name="currentLang">
               <h3>
                  currentLang 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>currentLang returns the current language version.</p>
               
               <pre><code>func currentLang() string</code></pre>
            </article>
            
            <article class="function" data-name="expandiface">
               <h3>
                  expandiface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>expandiface computes the method set for interface type t by
expanding embedded interfaces.</p>
               
               <pre><code>func expandiface(t *Type)</code></pre>
            </article>
            
            <article class="function" data-name="fields">
               <h3>
                  fields 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fields returns the fields of struct type t.</p>
               
               <pre><code>func (t *Type) fields() *fields</code></pre>
            </article>
            
            <article class="function" data-name="fieldsHasShape">
               <h3>
                  fieldsHasShape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fieldsHasShape(fields []*Field) bool</code></pre>
            </article>
            
            <article class="function" data-name="fldconv">
               <h3>
                  fldconv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fldconv(b *bytes.Buffer, f *Field, verb rune, mode fmtMode, visited map[*Type]int, isParam bool)</code></pre>
            </article>
            
            <article class="function" data-name="formatParams">
               <h3>
                  formatParams 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func formatParams(b *bytes.Buffer, params []*Field, mode fmtMode, visited map[*Type]int)</code></pre>
            </article>
            
            <article class="function" data-name="forwardType">
               <h3>
                  forwardType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>forwardType returns t's extra forward-type-specific fields.</p>
               
               <pre><code>func (t *Type) forwardType() *Forward</code></pre>
            </article>
            
            <article class="function" data-name="funcType">
               <h3>
                  funcType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcType returns t's extra func-specific fields.</p>
               
               <pre><code>func (t *Type) funcType() *Func</code></pre>
            </article>
            
            <article class="function" data-name="identical">
               <h3>
                  identical 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func identical(t1 *Type, t2 *Type, flags int, assumedEqual map[typePair]struct{...}) bool</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="isAtomicStdPkg">
               <h3>
                  isAtomicStdPkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isAtomicStdPkg(p *Pkg) bool</code></pre>
            </article>
            
            <article class="function" data-name="makeComparableInterface">
               <h3>
                  makeComparableInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeComparableInterface makes the predefined "comparable" interface in the
built-in package. It has a unique name, but no methods.</p>
               
               <pre><code>func makeComparableInterface() *Type</code></pre>
            </article>
            
            <article class="function" data-name="makeErrorInterface">
               <h3>
                  makeErrorInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeErrorInterface() *Type</code></pre>
            </article>
            
            <article class="function" data-name="newBasic">
               <h3>
                  newBasic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newBasic returns a new basic type of the given kind.</p>
               
               <pre><code>func newBasic(kind Kind, obj Object) *Type</code></pre>
            </article>
            
            <article class="function" data-name="newResults">
               <h3>
                  newResults 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newResults(types []*Type) *Type</code></pre>
            </article>
            
            <article class="function" data-name="newSSA">
               <h3>
                  newSSA 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newSSA(name string) *Type</code></pre>
            </article>
            
            <article class="function" data-name="newType">
               <h3>
                  newType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newType returns a new Type of the specified kind.</p>
               
               <pre><code>func newType(et Kind) *Type</code></pre>
            </article>
            
            <article class="function" data-name="params">
               <h3>
                  params 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ft *Func) params() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="paramsResults">
               <h3>
                  paramsResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ft *Func) paramsResults() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="parseLang">
               <h3>
                  parseLang 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseLang parses a -lang option into a langVer.</p>
               
               <pre><code>func parseLang(s string) (lang, error)</code></pre>
            </article>
            
            <article class="function" data-name="pkgqual">
               <h3>
                  pkgqual 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pkgqual returns the qualifier that should be used for printing
symbols from the given package in the given mode.
If it returns the empty string, no qualification is needed.</p>
               
               <pre><code>func pkgqual(pkg *Pkg, verb rune, mode fmtMode) string</code></pre>
            </article>
            
            <article class="function" data-name="recvParams">
               <h3>
                  recvParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ft *Func) recvParams() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="recvs">
               <h3>
                  recvs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ft *Func) recvs() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="results">
               <h3>
                  results 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ft *Func) results() []*Field</code></pre>
            </article>
            
            <article class="function" data-name="sconv">
               <h3>
                  sconv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>See #16897 for details about performance implications
before changing the implementation of sconv.</p>
               
               <pre><code>func sconv(s *Sym, verb rune, mode fmtMode) string</code></pre>
            </article>
            
            <article class="function" data-name="sconv2">
               <h3>
                  sconv2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sconv2(b *bytes.Buffer, s *Sym, verb rune, mode fmtMode)</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *bitset8) set(mask uint8, b bool)</code></pre>
            </article>
            
            <article class="function" data-name="setAlg">
               <h3>
                  setAlg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setAlg sets the algorithm type of t to a, if it is of higher
priority to the current algorithm type.</p>
               
               <pre><code>func (t *Type) setAlg(a AlgKind)</code></pre>
            </article>
            
            <article class="function" data-name="setFields">
               <h3>
                  setFields 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setFields sets struct type t's fields to fields.</p>
               
               <pre><code>func (t *Type) setFields(fields []*Field)</code></pre>
            </article>
            
            <article class="function" data-name="substFields">
               <h3>
                  substFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func substFields(fields []*Field, types *[]*Type) []*Field</code></pre>
            </article>
            
            <article class="function" data-name="symfmt">
               <h3>
                  symfmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func symfmt(b *bytes.Buffer, s *Sym, verb rune, mode fmtMode)</code></pre>
            </article>
            
            <article class="function" data-name="tconv">
               <h3>
                  tconv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func tconv(t *Type, verb rune, mode fmtMode) string</code></pre>
            </article>
            
            <article class="function" data-name="tconv2">
               <h3>
                  tconv2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tconv2 writes a string representation of t to b.
flag and mode control exactly what is printed.
Any types x that are already in the visited map get printed as @%d where %d=visited[x].
See #16897 before changing the implementation of tconv.</p>
               
               <pre><code>func tconv2(b *bytes.Buffer, t *Type, verb rune, mode fmtMode, visited map[*Type]int)</code></pre>
            </article>
            
            <article class="function" data-name="typePos">
               <h3>
                  typePos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typePos returns the position associated with t.
This is where t was declared or where it appeared as a type expression.</p>
               
               <pre><code>func typePos(t *Type) src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="wantEtype">
               <h3>
                  wantEtype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) wantEtype(et Kind)</code></pre>
            </article>
            
            <article class="function" data-name="widthCalculated">
               <h3>
                  widthCalculated 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) widthCalculated() bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
